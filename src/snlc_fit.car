c *********************************************************
c Created June 2006   by R.Kessler
c   
c Generic SNIa lightcurve fitter.
c "Generic" means that any SNIa model can be fit to the data.
c This code applies a known model, but does NOT train SN models.
c    
c -------------------------------------------------------
c This file patches in public analysis utilities 
c (HBOOK, READING DATA, etc ...)
c
c Contents:
c   FITPAR_INI   : one-time init 
c   FITPAR_INI2  : one-time init after 1st event is read
c   FITPAR_PREP  : prepare each SN prior to fit (was FITPAR_INI)
c   FITPAR_ANA   : analyze fit results after each lightcurve fit
c   FITPAR_END   : called once after all fits
c
c   FCNSNLC      : function to minimize for MINUIT
c
c
c        HISTORY (2011-)
c  ~~~~~~~~~~~~~~~~~~~~~~~~~~
c
c Jun 2, 2011: OPT_COVAR_FLUX > 0 now works with SALT2 model.
c              See call to new function  GENCOVAR_SALT2().
c
c Jul 25, 2011: replace code for SIMEFF. 
c               Use utility INIT_SIMEFF and GET_SIMEFFMAP
c               New shell function SNLC_FIT_SIMEFF()
c
c July 26, 2011: FUDGE_FITERR_PASSBANDS*8 -> FUDGE_FITERR_PASSBANDS*80
c
c Sep 29, 2011: remove obsolete MAGERR_FILT
c
c Oct 19, 2011: define new FITNML variables FITWIN_TREST and FITWIN_MJD
c               to eventually replace TREST_REJECT and MJD_REJECT.
c               Note these variables are just defined ...not implemented.
c
c Oct 28, 2011: new &FITNML variable OPT_NTUP_FITRES for ntuple options.
c
c Jan 05, 2012: 
c    Replace MJD_REJECT -> FITWIN_MJD and TREST_REJECT -> FITWIN_TREST.
c    Allow legacy nnl variables using EQUIVLANCE to new variables.
c
c    New &FITINP namelist variable string FITWIN_TREST_FILTER
c    to set filter-dependent TREST selection.
c    See new subroutine SETCUTS_FITWIN_TREST.
c
c    EP_SNRMAX -> EP_SNRMAX_FIT and EP_SNRMAX_RAW ;
c    the former includes the error fudge, the latter does not.
c    The former (with error fudge) is used for sorted SNRMAX
c    while the latter goes into the ntuple for SNRMAX_[filt]
c
c Feb 03, 2012: OPT_NEARFILT is now obsolete, but leave it in
c               &FITINP to avoid aborts. 
c
c Feb 12, 2012: new option FILTLIST_FITRESTMAG = 'X' to fit for
c               rest-frame mag in filter X. See manual.
c
c May 17, 2012: remove obsolete DMP_FITSORT
c
c Sep 28,2012:  new suborutine CWNTUP_FITRES(isn) to give column-wise
c               ntuple instead of row-wise. Can get legacy RWN using
c                 OPT_LEGACY_RWNT = 1 (RWNT id=7788, no CWNT)
c                 OPT_LEGACY_RWNT = 3 (RWNT id=7788, and CWNT id=6666)
c
c Nov 26, 2012: 
c    fix bug applying optional user-defined  RESTLAMBDA_FITRANGE.
c    See new variable RESTLAMBDA_USEFIT ... the range actually used.
c
c Feb 01, 2013: remove OPT_LEGACY_RWNT
c
c Mar 22, 2013: new option FILTER_FITMAGDIF; fit this filter only,
c               then fit all other filters; plot difference in peakmag.
c
c Apr 7, 2013:
c   New namelist variables with LUMI -> SHAPE :
c    LUMIFIX_FITRESTMAG    -> SHAPEFIX_FITRESMAG
c    USESIM_LUMIPAR        -> USESIM_SHAPE
c    FITWIN_LUMIPAR        -> FITWIN_SHAPE
c    INISTP_LUMIPAR        -> INISTP_SHAPE
c    INIVAL_LUMIPAR        -> INIVAL_SHAPE
c    PRIOR_LUMIPAR_RANGE   -> PRIOR_SHAPE_RANGE
c    PRIOR_LUMIPAR_SIGMA   -> PRIOR_SHAPE_SIGMA 
c  Keep old LUMIPAR nml variables for back-compatibility
c
c Sep 8 2104: changes for new SNTABLE_LIST system of outputs.
c   remove obsolete &FITINP variable OPT_NTUP_FITRES
c   remove obsolete subroutine TABLE_PARNAMES 
c
c Apr 2 2018:
c  + new &FITINP inputs PRIOR_COLOR_RANGE(2) and PRIOR_COLOR_SIGMA
c
c Jul 31 2018: rename SIM_NONIa -> SIM_TEMPLATE_INDEX
c --------------------------------------------------------



C =======================================
+PATCH,*FITCOM.

+KEEP,SNFITCOM.

+CDE,SNFITPAR.
+CDE,SNFITVAR.
+CDE,SNFITINP.


+KEEP,SNFITPAR.

      INTEGER 
     &   IPAR_ITER
     &  ,IPAR_ISN
     &  ,IPAR_PEAKMJD
     &  ,IPAR_SHAPE
     &  ,IPAR_SHAPE2
     &  ,IPAR_AV
     &  ,IPAR_RV, IPAR_AVRV
     &  ,IPAR_DLMAG, IPAR_ZPHOT
     &  ,IPAR_X0, IPAR_COLOR  ! for SALT2
     &  ,IPAR_MB              ! for SALT2
     &  ,IPAR_MAX
     &  ,IPAR_SPARE
c  Define Error flags 
c  _FIT -> fixed redshift; _ZFIT -> photoz fit
     &  ,ERRFLAG_FITPREP_NOFILTERS    
     &  ,ERRFLAG_FITPREP_NOEPOCHS
     &  ,ERRFLAG_FITPREP_NEPOCH
     &  ,ERRFLAG_FIT_BADCOV
     &  ,ERRFLAG_FIT_CRAZYERR
     &  ,ERRFLAG_FIT_MARGINALIZE
     &  ,ERRFLAG_FIT_CUTS
     &  ,ERRFLAG_ZFIT_DROPFILTCUTS
     &  ,ERRFLAG_ZFIT_RANGE
     &  ,ERRFLAG_REPEAT_ITER
     &  ,ERRFLAG_REPEAT_MINOS
c
     &  ,OPT_FITANA_STORE_VAL
     &  ,OPT_FITANA_STORE_ERR

      PARAMETER ( 
     &   IPAR_ITER            =  1  ! iteration: 1,2 ... NFIT_ITERATION
     &  ,IPAR_ISN             =  2
     &  ,IPAR_PEAKMJD         =  3  ! MJD at peak
     &  ,IPAR_SHAPE           =  4  ! stretch or delta, or dm15 ... 
     &  ,IPAR_SHAPE2          =  5  ! 2nd shape-param
     &  ,IPAR_AV              =  6
     &  ,IPAR_COLOR           =  IPAR_AV     ! for SALT2
     &  ,IPAR_RV              =  7           ! MLCS-RV
     &  ,IPAR_MB              =  IPAR_RV     ! for SALT2
     &  ,IPAR_AVRV            =  IPAR_RV     ! AV/RV
     &  ,IPAR_DLMAG           =  8           ! distance modulus
     &  ,IPAR_X0              =  IPAR_DLMAG  ! for SALT2
     &  ,IPAR_ZPHOT           =  9           ! photoZ
     &  ,IPAR_MAX             =  9  ! max number of fit params  
     &  ,IPAR_SPARE           =  IPAR_MAX + 1
c
     &  ,ERRFLAG_FITPREP_NOFILTERS  =  1  ! no valid filters
     &  ,ERRFLAG_FITPREP_NOEPOCHS   =  2  ! no epochs in FITINI_COV
     &  ,ERRFLAG_FITPREP_NEPOCH     =  3  ! too few epochs
     &  ,ERRFLAG_FIT_BADCOV         =  9  ! MNSTAT returns ISTAT<3
     &  ,ERRFLAG_FIT_CRAZYERR       = 10  ! insane error detected
     &  ,ERRFLAG_FIT_MARGINALIZE    = 11  ! could not marginalize
     &  ,ERRFLAG_FIT_CUTS           = 12  ! failed 1 or more cuts
     &  ,ERRFLAG_ZFIT_DROPFILTCUTS  = 13  ! fail Zphot-cuts after drop filter
     &  ,ERRFLAG_ZFIT_RANGE         = 14  ! Zphot outside valid range
     &  ,ERRFLAG_REPEAT_ITER        = -1  ! repeat fit iteration
     &  ,ERRFLAG_REPEAT_MINOS       = -2  ! repeat entire it with MINOS
c
     &  ,OPT_FITANA_STORE_VAL = 1
     &  ,OPT_FITANA_STORE_ERR = 2
     &    )


c  OPT_PHOTOZ mask options for redshift prior (Jun 3 2022)
      INTEGER
     &   BIT_PHOTOZ_GAUSS  ! use <zPhot> and RMS in Gauss approx
     &  ,BIT_BESTZ_GAUSS   ! idem, but with best redshift (e.g., zSpec)
     &  ,BIT_PHOTOZ_QUANTILES ! use photo-z quantiles for prior
     &  ,BIT_PHOTOZ_CHEAT  ! use correct redshift and filters

      PARAMETER (
     &   BIT_PHOTOZ_GAUSS      = 0  ! OPT_PHOTOZ += 1
     &  ,BIT_BESTZ_GAUSS       = 1  ! OPT_PHOTOZ += 2
     &  ,BIT_PHOTOZ_QUANTILES  = 2  ! OPT_PHOTOZ += 4
     &  ,BIT_PHOTOZ_CHEAT      = 4  ! OPT_PHOTOZ += 16
     &    )

+KEEP,SIMEFFCM.

      INTEGER
     &   MXPAR_SIMEFF
     &  ,IPAR_SIMEFF_REDSHIFT
     &  ,IPAR_SIMEFF_MWEBV

      PARAMETER (
     &   MXPAR_SIMEFF         = 10
     &  ,IPAR_SIMEFF_REDSHIFT = 51  ! much larger than IPAR_MAX
     &  ,IPAR_SIMEFF_MWEBV    = 52
     &     )

      
      INTEGER 
     &   NPAR_SIMEFF
     &  ,IPAR_SIMEFF(MXPAR_SIMEFF)

      REAL*8  PARVAL8_SIMEFF(MXPAR_SIMEFF) ! Z, AV, DELTA, etc ...
      COMMON / SIMEFFCM4 / NPAR_SIMEFF, IPAR_SIMEFF
      COMMON / SIMEFFCM8 / PARVAL8_SIMEFF

+KEEP,SNFITVAR.

c Jul 22 2017: reduce MXFIT_DATA<1000 so that char BAND can
c              be added to RESIDUAL part of FITRES table.

      INTEGER MXFIT_DATA
      PARAMETER ( MXFIT_DATA = 1500 )

c variables used in fit.

      LOGICAL   
     &   LBKSNINFO
     &  ,USESIM_FITPAR(IPAR_MAX)
     &  ,LOBS_FITMODEL, LREST_FITMODEL
     &  ,LSED_FITMODEL
     &  ,DOFIT_PHOTOZ_MCMC_ADJUST   ! True if using MCMC init for photo-z

      INTEGER 
     &   FITMODEL_INDEX              ! integer index for model to fit
     &  ,NSHAPEPAR                    ! 1 or 2 
     &  ,NFITDOF(0:MXFILT_OBS)       ! # deg of freedom per filter (0=all)
     &  ,NFILT_FIT                   ! number of filters fitted
     &  ,ISTORE_ZPULL                ! storage index for Photoz Pull
     &  ,NFILT_MODEL                 ! # rest-filters in SN model
     &  ,IFILTMAP_MODEL(MXFILT_ALL)  ! spare map: ifilt_rest = (ifilt)
     &  ,IFILTINVMAP_MODEL(MXFILT_ALL) ! inverse map

c ------------
c NEW Jan 25 2014
c Define two sets of arrays: 
c  1: _ALL stores all epochs using the fixed 'ep' index
c  2: _FIT stores only the epochs used in the fit; so each index
c     can change its location on the next iteration. This sparse
c     array is needed for SNLCPAK.
c
c Note that EPLIST_FIT is used in FCN to loop over only
c the epochs to be fit.
c
c Oct 15 2021: add IEP_CCDNUN, IEP_IMGNUM

      INTEGER MXVAR_R4, MXVAR_I4
      PARAMETER ( MXVAR_R4=60, MXVAR_I4=12 )
      
      REAL*4 
     &   R4EP_ALL(MXFIT_DATA,MXVAR_R4) !vs. absolute epoch; fixed each iter
     &  ,R4EP_FIT(MXFIT_DATA,MXVAR_R4) !sparse subset in fit; changes each iter
     &  ,R4EP_LAST(MXFIT_DATA,MXVAR_R4) ! store R4EP_ALL for previous fit-iter

      INTEGER
     &   I4EP_ALL(MXFIT_DATA,MXVAR_I4)
     &  ,I4EP_FIT(MXFIT_DATA,MXVAR_I4)
     &  ,EPLIST_FIT(MXFIT_DATA)          ! ep-list for _FIT arrays

      CHARACTER 
     &   BANDEP_ALL(MXFIT_DATA)*4  ! added July 2017
     &  ,BANDEP_FIT(MXFIT_DATA)*4

      COMMON / EPFITCOM4 / EPLIST_FIT
     &    ,R4EP_ALL, R4EP_FIT, I4EP_ALL, I4EP_FIT, R4EP_LAST
     &    ,BANDEP_ALL, BANDEP_FIT

c define index for each variable.

c variable indices for I4EP_
      INTEGER
     &   IEP_IMJD, IEP_EPOCH, IEP_IDTEL
     &  ,IEP_IFILT, IEP_IFILT_OBS, IEP_IFILT_REST1, IEP_IFILT_REST2
     &  ,IEP_REJECT, IEP_REJECT2
     &  ,IEP_CCDNUM, IEP_IMGNUM

c variable indices for R4EP_
      INTEGER   
     &   JEP_MJD, JEP_TOBS, JEP_TREST
     &  ,JEP_DATAFLUX,  JEP_DATAFLUX_ERR
     &  ,JEP_DATAMAG,   JEP_DATAMAG_ERR
     &  ,JEP_MODELFLUX, JEP_MODELFLUX_ERR
     &  ,JEP_MODELMAG,  JEP_MODELMAG_ERR
     &  ,JEP_FLUX_ERRTOT, JEP_RATIO, JEP_RATIO_ERR
     &  ,JEP_LAMREST, JEP_AVWARP, JEP_KCOR, JEP_KCOR_ERR
     &  ,JEP_DATAFLUX_REST, JEP_MODELMAG_REST
     &  ,JEP_FUDGEFLUX_ERR, JEP_FUDGE_MAXFRAC
     &  ,JEP_RESID, JEP_RESID_ERR, JEP_MAGDIF, JEP_DELCHI2
     &  ,JEP_XTHOST, JEP_MWXT, JEP_MWXT_MAGERR, JEP_MWXT_FLUXERR
     &  ,JEP_FPKRAT, JEP_FPKRATERR
     &  ,JEP_PSF, JEP_NEA, JEP_SKYSIG, JEP_SKYSIG_T
     &  ,JEP_ZP, JEP_ZPERR, JEP_GAIN, JEP_XPIX, JEP_YPIX, JEP_AREAFRAC
     &  ,JEP_SKYFLUXCAL, JEP_SBFLUXCAL, JEP_ERRTEST, JEP_ERRCALC
     &  ,JEP_PHOTPROB
     &  ,JEP_SIM_MAGREST, JEP_SIM_FLUXREST
     &  ,JEP_SIM_FLUXCAL, JEP_SIM_DELCHI2

      PARAMETER (
c for I4EP_XXX
     &   IEP_IMJD            = 1  ! for absolute IMJD index
     &  ,IEP_EPOCH           = 2  ! for absolute ep index
     &  ,IEP_IDTEL           = 3  ! telescope index
     &  ,IEP_IFILT           = 4  ! sparse survey filter index
     &  ,IEP_IFILT_OBS       = 5  ! absolute filter index
     &  ,IEP_IFILT_REST1     = 6  ! absolute filter index, nearest rest-filter
     &  ,IEP_IFILT_REST2     = 7  ! idem, 2nd nearest rest-frame filter
     &  ,IEP_REJECT          = 8  ! flag to reject epoch from fit
     &  ,IEP_REJECT2         = 9  ! rejected inside Trest window (Mar 2020)
     &  ,IEP_CCDNUM          = 10 ! CCD number
     &  ,IEP_IMGNUM          = 11 ! image number (e..g, EXPNUM, VISIT_ID)
c
c for R4EP_XXX
     &  ,JEP_MJD              = 1
     &  ,JEP_TOBS             = 2
     &  ,JEP_TREST            = 3
     &  ,JEP_DATAFLUX         = 4
     &  ,JEP_DATAFLUX_ERR     = 5
     &  ,JEP_DATAMAG          = 6
     &  ,JEP_DATAMAG_ERR      = 7
     &  ,JEP_MODELFLUX        = 8 
     &  ,JEP_MODELFLUX_ERR    = 9
     &  ,JEP_MODELMAG         = 10
     &  ,JEP_MODELMAG_ERR     = 11
     &  ,JEP_FLUX_ERRTOT      = 12
     &  ,JEP_RATIO            = 13
     &  ,JEP_RATIO_ERR        = 14
     &  ,JEP_LAMREST          = 15  
     &  ,JEP_AVWARP           = 16
     &  ,JEP_KCOR             = 17
     &  ,JEP_KCOR_ERR         = 18
     &  ,JEP_DATAFLUX_REST    = 19
     &  ,JEP_MODELMAG_REST    = 20
     &  ,JEP_FUDGEFLUX_ERR    = 21
     &  ,JEP_RESID            = 22
     &  ,JEP_RESID_ERR        = 23
     &  ,JEP_MAGDIF           = 24  ! mag(data) - mag(fitModel)
     &  ,JEP_DELCHI2          = 25
     &  ,JEP_XTHOST           = 26
     &  ,JEP_MWXT             = 27
     &  ,JEP_MWXT_MAGERR      = 28
     &  ,JEP_MWXT_FLUXERR     = 29
     &  ,JEP_FPKRAT           = 30
     &  ,JEP_FPKRATERR        = 31
     &  ,JEP_PSF           = 32
     &  ,JEP_NEA           = 33
     &  ,JEP_SKYSIG        = 34 
     &  ,JEP_SKYSIG_T      = 35
     &  ,JEP_ZP            = 36
     &  ,JEP_ZPERR         = 37
     &  ,JEP_GAIN          = 38
     &  ,JEP_XPIX          = 39
     &  ,JEP_YPIX          = 40
     &  ,JEP_AREAFRAC      = 41
     &  ,JEP_SKYFLUXCAL    = 42
     &  ,JEP_SBFLUXCAL     = 43
     &  ,JEP_ERRTEST       = 44  ! ERRCALC/FLUXCAL_ERR
     &  ,JEP_ERRCALC       = 45  ! calculated error
     &  ,JEP_PHOTPROB      = 46
     &  ,JEP_SIM_MAGREST   = 47
     &  ,JEP_SIM_FLUXREST  = 48
     &  ,JEP_SIM_FLUXCAL   = 49  ! for LSIM_MAGOBS = T
     &  ,JEP_SIM_DELCHI2   = 50  ! chi2 from data-sim flux diff
     &  ,JEP_FUDGE_MAXFRAC = 51
     &     )

c EP_XXX refers to "IMJD" variables stored at end of fit.
c These arrays are defined to be passed for plotting.

      REAL
     &   FCN_FITCHI2(0:MXFILT_OBS)         ! FCN fit chi2 per filter (0=>sum)
     &  ,XNFITDOF(0:MXFILT_OBS)
     &  ,PEAKMAG_OBS_MODEL(MXFILT_ALL)         ! model peak mag (observer)
     &  ,PEAKMAG_OBS_MODEL_ERR(MXFILT_ALL)     ! error on above
     &  ,PEAKFLUX_OBS_MODEL(MXFILT_ALL)        ! model peak flux (observer)
     &  ,PEAKFLUX_OBS_MODEL_ERR(MXFILT_ALL)    ! model peak flux (observer)
     &  ,PEAKFLUX_OBS_MODEL_COR(MXFILT_ALL)    ! data/model correction
     &  ,PEAKMAG_REST_MODEL(MXFILT_ALL)        ! model peak mag (rest-frame)
     &  ,PEAKMAG_REST_MODEL_ERR(MXFILT_ALL)    ! error on above
     &  ,PEAK_KCOR_MODEL(MXFILT_ALL)           ! model Kcor at peak
c
     &  ,REDSHIFT_FIT   ! z used in fit: SNLC_REDSHIFT or SIM_REDSHIFT
     &  ,CUTWIN_FITPAR(2,IPAR_MAX)             ! used in fitter cuts
     &  ,CUTWIN_FITCOV(2,IPAR_MAX,IPAR_MAX)    ! idem, 9/2016
     &  ,CUTWIN_FITERRz1(2,IPAR_MAX)           ! cuts on sigma(fitPar)/(1+z)
c
     &  ,LC_FITCHI2(0:MXFILT_OBS)   ! min chi2 from fit
     &  ,LC_FITPROB(0:MXFILT_OBS)   ! prob from above
     &  ,LC_MARGCHI2(0:MXFILT_OBS)  ! chi2 from marginalized params
     &  ,LC_MARGPROB(0:MXFILT_OBS)  ! prob from above
c
     &  ,RESTLAMBDA_MODEL(2)   ! range defined by SN model
     &  ,RESTLAMBDA_USEFIT(2)  ! range actually used in fit (Nov 2012)


      LOGICAL 
     &   USE_FITCOV  ! T=> use full covariance matrix in fit
     &  ,USE_FILT(0:MXFILT_ALL)  ! user-filter and it exists
     &  ,USE_LANDOLT_REST
     &  ,USE_LANDOLT_OBS

      INTEGER 
     &   NFITDATA             ! number of fitted data points
     &  ,NFITDATA_REJECT      !  number rejected
     &  ,NFITDATA_TOTAL                 ! sum of above
     &  ,IFITDATA_USRFUN
     &  ,I4BAND_EP_NEARPEAK(MXFIT_DATA) ! ep index nearest peak

c R4BNAND_  for filter-dependent quantities
c R4SN_     for SN-dependent quantities (scalars)

      REAL*8  R8EP_MJD(MXFIT_DATA)

      REAL*4
     &    R4BAND_TREST_NEARPEAK(MXFILT_ALL)
     &   ,R4BAND_XTMW_NEARPEAK(MXFILT_ALL) 
     &   ,R4BAND_SNRMAX_FIT(MXFILT_ALL)    
     &   ,R4BAND_SNRMAX_RAW(MXFILT_ALL) 
c
     &   ,R4SN_TEARLY, R4SN_TLATE  
     &   ,R4SN_MJDmin, R4SN_MJDmax 
     &   ,R4SN_FFSUM_DATA     !  sum F_data**2/sigma^2
     &   ,R4SN_FFSUM_MODEL    !  sum F_model**2/sigma^2
     &   ,R4SN_FFSUM_CROSS    !  sum F_data*F_model/sigma^2
     &   ,R4SN_FFSUM_WGT
     &   ,R4SN_FFSUM_RATIO

c define covariance matrices for SN model correlations (NOT for fit)

      REAL*8
     &   COVMAT1(MXFIT_DATA*MXFIT_DATA)  ! 1-dim matrix from get_covar
     &  ,COVMAT2(MXFIT_DATA,MXFIT_DATA)  ! 2-dim matrix to invert
     &  ,COVMAT_MIN    ! min value among all elements
     &  ,COVMAT_MAX    ! max value ...
     &  ,DETERM_COVMAT2 ! determinant

      CHARACTER 
     &   FITMODEL_PATH*(MXCHAR_PATH)          ! path for model params 
     &  ,FITMODEL_LIST(MXMODEL_INDEX)*40         ! generic name(s) for each model
     &  ,FITMODEL_VERSION*(MXCHAR_MODELNAME)  ! = FITMODEL_NAME 
     &  ,FILTLIST_MODEL*(MXFILT_REST*2)  ! filter string for rest-frame model

c common block

      COMMON / SNFITVAR / FITMODEL_INDEX, NSHAPEPAR
     &  ,FITMODEL_PATH, FITMODEL_LIST, FITMODEL_VERSION
     &  ,LOBS_FITMODEL, LREST_FITMODEL, LSED_FITMODEL
     &  ,DOFIT_PHOTOZ_MCMC_ADJUST
     &  ,NFITDOF, XNFITDOF, NFILT_FIT, ISTORE_ZPULL
     &  ,RESTLAMBDA_MODEL, RESTLAMBDA_USEFIT
     &  ,NFILT_MODEL, FILTLIST_MODEL
     &  ,IFILTMAP_MODEL, IFILTINVMAP_MODEL
     &  ,FCN_FITCHI2
     &  ,LC_FITCHI2,  LC_FITPROB
     &  ,LC_MARGCHI2, LC_MARGPROB
c
     &  ,NFITDATA_TOTAL, NFITDATA_REJECT, NFITDATA
     &  ,I4BAND_EP_NEARPEAK
     &  ,USE_FITCOV, USE_FILT, IFITDATA_USRFUN
     &  ,R4BAND_TREST_NEARPEAK, R4BAND_XTMW_NEARPEAK
     &  ,R4BAND_SNRMAX_FIT, R4BAND_SNRMAX_RAW
     &  ,R4SN_TEARLY, R4SN_TLATE, R4SN_MJDmin, R4SN_MJDmax
     &  ,R4SN_FFSUM_DATA, R4SN_FFSUM_MODEL, R4SN_FFSUM_CROSS
     &  ,R4SN_FFSUM_WGT, R4SN_FFSUM_RATIO
c
     &  ,PEAKMAG_OBS_MODEL,   PEAKMAG_OBS_MODEL_ERR
     &  ,PEAKMAG_REST_MODEL,  PEAKMAG_REST_MODEL_ERR
     &  ,PEAKFLUX_OBS_MODEL,  PEAKFLUX_OBS_MODEL_ERR
     &  ,PEAKFLUX_OBS_MODEL_COR
     &  ,PEAK_KCOR_MODEL
     &  ,LBKSNINFO, USESIM_FITPAR, REDSHIFT_FIT
     &  ,CUTWIN_FITPAR, CUTWIN_FITCOV, CUTWIN_FITERRz1
     &  ,USE_LANDOLT_REST, USE_LANDOLT_OBS

      COMMON / COVMAT8 / 
     &   COVMAT1, COVMAT2, COVMAT_MIN, COVMAT_MAX

      COMMON / SNFITVAR8 / R8EP_MJD

c define photoZ variables for photoZ fit.
     
      REAL
     &   PHOTOZ_ERR_SNFIT    ! photoZ error from SN photoz fit     
     &  ,PHOTOZ_ERR_SNHOST   ! photoZ error from host gal
     &  ,PHOTOZ_ERR_SNMAG    ! photoZ error from intrinsic SN mag error
     &  ,PHOTOZ_ERR_ZPULL    ! photoZdif(SN-host) / error
     &  ,PRIOR_PHOTOZ, PRIOR_PHOTOZ_ERR ! actual z prior used in fit
c
     &  ,PHOTOZ_DROPFILTER_MIN(MXFILT_ALL)  ! min valid Z
     &  ,PHOTOZ_DROPFILTER_MAX(MXFILT_ALL)  ! max valid Z
     &  ,PHOTODZ_MIN(MXITER)    ! min | PHOTOZ-Zvalid(model) |
     &  ,PHOTODZ1Z_MIN(MXITER)  ! idem ind dZ/(1+z) space
c 
c ? DOFIT_PHOTOZ_HOST=> DOFIT_PHOTOZ_GAUSS

      LOGICAL  
     &   DOFIT_PHOTOZ_HOST      ! T=> include host-photoz 
     &  ,DOFIT_PHOTOZ_noHOST    ! T=> no host-photoz 
     &  ,DOFIT_PHOTOZ_CHEAT     ! T=> cheater option 
     &  ,PHOTOZ_DROPFILTER(MXFILT_ALL)  ! T=> filter was dropped
     &  ,PHOTOZ_ADDFILTER(MXFILT_ALL)   ! T=> filter added

      INTEGER IFILT_NEARDROP  ! used filt-index nearest to gettinng dropped
 
      COMMON / PHOTOZCOM / 
     &   DOFIT_PHOTOZ_HOST, DOFIT_PHOTOZ_noHOST, DOFIT_PHOTOZ_CHEAT
     &  ,PHOTOZ_ERR_SNFIT, PHOTOZ_ERR_SNHOST, PHOTOZ_ERR_SNMAG 
     &  ,PHOTOZ_ERR_ZPULL
     &  ,PRIOR_PHOTOZ, PRIOR_PHOTOZ_ERR  ! Feb 2022
     &  ,PHOTOZ_DROPFILTER_MIN, PHOTOZ_DROPFILTER_MAX
     &  ,PHOTOZ_DROPFILTER, PHOTOZ_ADDFILTER
     &  ,PHOTODZ_MIN, PHOTODZ1Z_MIN, IFILT_NEARDROP

c define variables for prior on each fit variable.
c CHI2GRID_PRIOR is a grid storing chi2-values to add.

      INTEGER NBIN_PRIOR
      PARAMETER ( NBIN_PRIOR = 1000 )

      REAL*8  
     &   PRIOR_CHI2GRID(NBIN_PRIOR,IPAR_MAX)
     &  ,PRIOR_PROBGRID(NBIN_PRIOR,IPAR_MAX)
     &  ,PRIOR_GRID(NBIN_PRIOR,IPAR_MAX)
     &  ,PRIOR_RANGE(2,IPAR_MAX)
     &  ,PRIOR_BINSIZE(IPAR_MAX)
     &  ,FLATPRIOR_RANGE(2,IPAR_MAX)  ! used to interp near discontinuity

      LOGICAL USE_PRIOR(IPAR_MAX), USE_PRIOR_AV

      INTEGER FLATPRIOR_BINRANGE(2,IPAR_MAX)

      COMMON / PRIORCOM8 / 
     &    PRIOR_CHI2GRID, PRIOR_PROBGRID, PRIOR_GRID
     &  , PRIOR_RANGE, PRIOR_BINSIZE
     &  , FLATPRIOR_RANGE, FLATPRIOR_BINRANGE

      COMMON / PRIORCOM4 / USE_PRIOR, USE_PRIOR_AV


+KEEP,SNFITINP.

c namelist input variables.

      CHARACTER 
     &    FITMODEL_NAME*(MXCHAR_FILENAME)    ! path/model
     &   ,FITCOVAR_FILE*(MXCHAR_FILENAME)    ! '' => default, 'SIM' => from sim
     &   ,SIMEFF_FILE*(MXCHAR_FILENAME)     ! sim-eff file for PRIOR
     &   ,STRETCH_TEMPLATE_FILE*(MXCHAR_FILENAME)  ! template for stretch model
     &   ,SALT2_DICTFILE*(MXCHAR_FILENAME)    ! output for SALT2's HUBBLEFIT
     &   ,FILTLIST_FIT*(MXFILT_ALL)    ! char list of filters to fit: 
     &                            ! examples: 'gri' or 'g r i', etc ...
     &   ,FILTLIST_DMPFCN*20      ! idem for CHI2FUN [FCN] dump
     &   ,FILTLIST_DMPFUN*20      ! idem for USRFUN [flux-fun] dump
     &   ,NEARFILT_IGNORE_REST*20 ! ignore these nearest rest-filters
     &   ,FILTLAM_SHIFT*100       ! 'U 42.  B 22. etc ...'
     &   ,FILTER_FITMAGDIF*4      ! fit magObs in this filter 2 ways for test

      CHARACTER
     &   FILTLIST_FITRESTMAG*12     ! fit for these restMag filters
      REAL 
     &   LUMIFIX_FITRESTMAG       ! fix shape par to this value (legacy name)
     &  ,SHAPEFIX_FITRESTMAG      ! same as above
     &  ,COLORFIX_FITRESTMAG      ! fix color par to this value
     &  ,LAMEXTRAP_FITRESTMAG     ! allow this much rest-frame extrapolation
     &  ,DLAMTOL_FITRESTMAG       ! allow this lam-tolerance for closest bands

      LOGICAL
     &    DOFIT_FILT(0:MXFILT_ALL)
     &   ,LDMPFCN(0:MXFILT_ALL)
     &   ,LDMPFUN(MXFILT_ALL)
     &   ,LDMPFCN_PLOTCHI2(MXFILT_ALL)
     &   ,LDMPFUN_PLOTCHI2(MXFILT_ALL)
     &   ,LFIXPAR_ALL       ! T=> fix all paramters; FITVAL = INIVAL
     &   ,LFIXPAR_ADJUST    ! T=> leave params based on FITINI_ADJUST
     &   ,LKCOR_STRETCH     ! T=> get Kcor from stretched template
     &   ,LKCOR_AVWARP      ! T=> get Kcor from color-warped template
     &   ,USE_MODEL_MAGERR  ! T=> use mag error from model
     &   ,ENABLE_MAGSHIFT_SALT2  ! T=> enable magshifts from training
     &   ,ENABLE_WAVESHIFT_SALT2 ! T=> enable magshifts from training
     &   ,ALLOW_NEGFLUX_SALT2    ! T=> alow Flam < 0; otherwise force Flam=0
     &   ,ADD_SALT2ERR_FROMz ! T=> add SALT2 param errors from zerr
     &   ,USESIM_COLOR      ! T=> use simulated color (AV,c ...)
     &   ,USESIM_AV         ! T => use sim. AV in fit (only if LSIM=T)
     &   ,USESIM_RV
     &   ,USESIM_LUMIPAR    ! T => use sim lumipar in fit (legacy name)
     &   ,USESIM_SHAPE      ! T => use sim shape value in fit
     &   ,USESIM_PEAKMJD    ! T => use sim peakMJD 
     &   ,USESIM_DLMAG      ! T => use sim DLMAG
     &   ,USESIM_REDSHIFT   ! T => use sim redshift in fit
     &   ,USESIM_INIVAL     ! T => use sim params as initial values
     &   ,MINOS_ERR_DLMAG   ! T=> require valid MINOS error for DLMAG
     &   ,MINOS_ERR_REQALL0 ! T=> require all MINOS errors to be valid   
     &   ,MINOS_ERR_REQALL1 ! T=> require all but 1 MINOS errors to be valid
     &   ,MINOS_ERRMAX_BAD  ! T=> flag too-small errors (def=T)
     &   ,UCOR_BXB          ! T=> correct U-band with BX-B
     &   ,LTRACE            ! T=> debug tool to identify crashes
     &   ,LPLOTCHI2         ! T=> plot chi2 vs. each fitpar & filter
     &   ,DOCHI2_SIGMA      ! T=> add chi2 from model-error
     &   ,CHECK_CRAZYFITERR ! T=> check for crazy fit errors (default)

c option to compute Zmax/Vmax for 1/Vmax method (Jun 2013)
      CHARACTER MAGLIM_VMAX*60   ! e.g., 'r 21.5  i 22.0'
      INTEGER   OPT_VMAX         ! integer mask of options

c Note that _REJECT refer to epochs after 1st fit iteration ;
c these epochs are rejected before 2nd fit.
c FITWIN_XXX refer to cuts on final fit parameters, and are apply to SN.
c Jun 2015: FITWIN_AV -> FITWIN_COLOR

      REAL 
     &   RESTLAMBDA_FITRANGE(2)  ! rest-frame central lambda range (Angstroms)
     &  ,UVLAM_EXTRAPFLUX      ! extrapolate SED model back to this lambda
     &  ,DELCHI2_REJECT        ! reject epoch at 2nd iter if chi2 >
     &  ,SIGNOISE_REJECT       ! reject epoch below this signal/noise
     &  ,TREST_REJECT(2)       ! reject epoch at 2nd iter if fails Trest
     &  ,MJD_REJECT(2)         ! reject epoch at 2nd iter that fail MJD cut
     &  ,PEAKMJD_SANITY(2)     ! sanity check window on fit PEAKMJD
     &  ,FITWIN_ZPULL(2)       ! cut-window for ZPULL
     &  ,FITWIN_ZPHOT(2)       ! cut-windo on photoz (Dec 2014)
     &  ,FITWIN_COLOR(2)       ! cut-window for COLOR/AV
     &  ,FITWIN_SHAPE(2)       !  "         for SHAPE
     &  ,FITWIN_PROB(2)        ! cut-window for chi2 prob
     &  ,FITWIN_NOMARG_PROB(2) ! cut-window before marginalization
     &  ,FITWIN_CHI2SIGMA(2)   ! cut on chi2-contribution from sigma-term
     &  ,FITWIN_TREST(2)       ! cut on T - T0 (to replace TREST_REJECT)
     &  ,FITWIN_MJD(2)         ! cut on absolute MJD range.
c
     &  ,FITWIN_COV_OFFDIAG(2) ! global cut on offDiag fitted cov (9/2016)
     &  ,FITWIN_PEAKMJD_ERR(2) ! cut on PEAKMJDerr (9/2016)
     &  ,FITWIN_MB_ERR(2)      ! cut on mBerr  (9/2016)
     &  ,FITWIN_SHAPE_ERR(2)   ! cut on x1err or delta_err (9/2016)
     &  ,FITWIN_COLOR_ERR(2)   ! cut on cerr or AVerr (9/2016)
c
     &  ,FITWIN_PEAKMJD_ERRz1(2)! cut on PEAKMJDerr/(1+z), added Mar 2017
     &  ,FITWIN_MB_ERRz1(2)     ! cut on NBerr/(1+z)
     &  ,FITWIN_SHAPE_ERRz1(2)  ! cut on x1err/(1+z)
     &  ,FITWIN_COLOR_ERRz1(2)  ! cut on cerr/(1+z)
c
     &  ,INISTP_PEAKMJD        ! initial step size for MJD  (days)   
     &  ,INISTP_AV            ! initial step size for AV
     &  ,INISTP_RV
     &  ,INISTP_AVRV          ! non-zero => fit for AV/RV instead of RV
     &  ,INISTP_COLOR         ! initiaql step for color param
     &  ,INISTP_DLMAG         ! initial step for lumi-distance mu
     &  ,INISTP_X0            ! initial step for SALT2 x0
     &  ,INISTP_PHOTOZ        ! initial step for photo-redshift
     &  ,INISTP_SHAPE       ! initial step for shape-par
     &  ,INISTP_SHAPE2      ! initial step for 2nd shape-par
c
     &  ,INIVAL_PEAKMJD       ! initial value for MJD  (days)   
     &  ,INIVAL_PEAKMJD_SHIFT   ! shift INIVAL_PEAKMJD by this much
     &  ,INIVAL_RV            ! initial value for RV
     &  ,INIVAL_AV            ! initial value for AV
     &  ,INIVAL_AVRV          ! 
     &  ,INIVAL_COLOR
     &  ,INIVAL_DLMAG         ! initial value lumi-distance m
     &  ,INIVAL_X0            ! SALT2 parameter
     &  ,INIVAL_PHOTOZ        ! initial value photo-redshift
     &  ,INIVAL_SHAPE         ! initial value shape-par
     &  ,INIVAL_SHAPE2        ! idem for 2nd shape-par
     &  ,INIVAL_SHIFT_ERRFRAC ! after 1st iter, INIVAL += FITERR*ERRFRAC
     &  ,FRACERRDIF_REPEATFIT ! repeat fit with MINOS if FRACERRDIF > thius
c
     &  ,INIVAL_GRIDSEARCH_DPEAKMJD(3)  ! min,max w.r.t. t0_approx, binsize
     &  ,INIVAL_GRIDSEARCH_COLOR(3)  ! min,max,binsize
c
     &  ,PRIOR_AVEXP(2)   ! 2 exp slopes for AV prior
     &  ,PRIOR_AVWGT(2)   ! 2 exp wgts for AV prior
     &  ,PRIOR_AVRES      ! gaussian resolution-smearing on exponential prior
     &  ,PRIOR_MJDSIG     ! add chi2 = [(MJD - MJDINI)/MJDSIG]^2
     &  ,PRIOR_SHAPE_RANGE(2)  ! min,max for FLAT SHAPE prior
     &  ,PRIOR_SHAPE_SIGMA     ! sigma for guassian roll-off on FLAT prior
     &  ,PRIOR_COLOR_RANGE(2)  ! min,max for FLAT SHAPE prior
     &  ,PRIOR_COLOR_SIGMA     ! sigma for guassian roll-off on FLAT prior
     &  ,PRIOR_LUMIPAR_RANGE(2)  ! idem, legacy variable
     &  ,PRIOR_LUMIPAR_SIGMA     ! idem, legacy variable
     &  ,PRIOR_DELTA_PROFILE(4)  ! DELTA-prior pars: sig(low,up) & min
c
     &  ,FUDGE_COVAR      ! fudge normalized covariances (0=> no fudge)
     &  ,SCALE_COVAR      ! scale entire covariance matrix by this factor
     &  ,LANDOLT_COLOR_SHIFT(10)  ! shifts in color terms (if OPT_LANDOLT>0)
     &  ,ZSCALE_SIMEFF     ! scale redshift for SIMEFF call.
     &  ,TREST_PEAKRENORM(2)   ! Trest-range to renorm peakFlux for FPKRAT
     &  ,TREST_DMPFUN(2)       ! Trest-range for FILTLIST_DMPFUN
     &  ,SCALE_PLOTCHI2        ! for HFUNMIN
     &  ,SALT2alpha            ! needed for constrained photoZ fit
     &  ,SALT2beta         
     &  ,LAMREST_MODEL_SMOOTH  ! smooth rest-model at filter-jump

      INTEGER 
     &   OPT_NEARFILT  ! 4=> 2nd closest filter from MLCS2k2
     &  ,OPT_COVAR        ! legacy name for OPT_COVAR_FLUX
     &  ,OPT_COVAR_FLUX   ! options for using flux-covariance matrix
     &  ,OPT_COVAR_MWXTERR ! 1 => use MW error in cov matrix
     &  ,OPT_XTMW_ERR      ! legacy variable: set to OPT_COVAR_MWXTERR
     &  ,OPT_COVAR_LCFIT   ! option to fix non-invertible COV(mB,x1,c)
     &  ,OPT_SNXT      ! SN extinction options (depends on model)
     &  ,OPT_KCORERR   ! Kcor error option (2=>SJ)
     &  ,OPT_LANDOLT   ! bit1 => convert Bessell -> Landolt
     &  ,OPT_PRIOR     ! 1=use prior; 0=turn off all priors
     &  ,OPT_PRIOR_AV  ! 1=> nominal (default), 0=> flat
     &  ,OPT_PRIOR_SIMEFF ! internally set based on SIMEFF_FILE
     &  ,OPT_SIMEFF    ! obsolete => ABORT if non-zero !!!
     &  ,OPT_MNSTAT_COV ! 1-> repeat on bad value
     &  ,SIMFIT_IDEAL_PRESCALE  ! pre-scale sample for including IDEAL fit
     &  ,NGRID_PDF     ! number of grid-bins for each dimens of pdf
     &  ,NSIGMA_PDF    ! compute PDF for +- NSIGMA_PDF
     &  ,MAX_INTEGPDF  ! max # times to integrate PDFs
     &  ,CONTOUR_LIST(4,20)  ! define contour plots: CID,IPAR1,IPAR2,NPT
     &  ,OPT_SALT2FIT  ! fit 0=> fit x0;  1=> fit log10(x0); 2=> fit delta-mu
     &  ,IPAR_PLOTCHI2 ! HFUNMIN only for this parameter

C ----------------------
c define all of the PHOTOZ options here in one place
c (except for INISTP_PHOTOZ ande INIVAL_PHOTOZ)

      LOGICAL
     &   DOFIT_PHOTOZ       ! T=> fit SN photo-redshift
     &  ,SKIP_PHOTOZ_INIT   ! T=> skip initial parameter estimate
     &  ,LDMP_PHOTOZ_DROPFILTER   ! T=> dump reason for dropped filter

      INTEGER 
     &   OPT_PHOTOZ  ! bit 0 (1 ) => use host-galaxy ZPRIOR; 
                     ! bit 1 (2 ) => use spectro Z-prior
                     ! bit 2 (4 ) => use zPhot quantiles
                     ! bit 4 (16) => cheat: start with Zspec and correct filt
     &  ,ISCALE_COURSEBIN_PHOTOZ  ! scale number of course-grid bins for init
     &  ,NEVAL_MCMC_PHOTOZ

      REAL
     &   PHOTOZ_ITER1_LAMRANGE(2)  ! cut on obs-filter, ITER=1 only
     &  ,PHOTOZ_BOUND(2)       ! MINUIT bound for photoz fit
     &  ,PHOTODZ_REJECT        ! reject filters in photoZ fit (see code)
     &  ,PHOTODZ1Z_REJECT      ! idem for dz/(1+z)     
     &  ,PRIOR_ZERRSCALE       ! scale hostZ-error for prior in photoZ fits
     &  ,PRIOR_MUERRSCALE      ! scale MU-error for prior in photoZ fits
     &  ,SNMAGRMS_for_PHOTOZ   ! compute PHOTOZ error from SNMAGRMS
     &  ,PARLIST_MCMC_PHOTOZ(5) ! params for MCMC burn-in

c define varibales to fudge the data errors for particular
c TREST-range and passbands. Note that FUDGE_MAGERR_MODEL
c globally replaces the model error, while FUDGE_FITERR_MAXFRAC
c is added to chi2-error in the specified passbands and Trest range.

      INTEGER 
     &   FUDGE_FITERR_MAXITER

      REAL
     &   FUDGE_FITERR_MAXFRAC      ! add fit-error = this fraction of maxflux
     &  ,FUDGE_FITERR_TREST(4)     ! apply err-fudge to two TREST-ranges
     &  ,FUDGE_FITERR_RESTLAM(4)   ! "      "        to RESTLAM range     
     &  ,FUDGE_MAGERR_MODEL        ! fix model mag-error
     &  ,FUDGEALL_MAXFRAC          ! MAXFRAC fudge for all epochs
     &  ,FUDGEALL_ITER1_MAXFRAC    ! idem, but 1st iteration only
     &  ,FUDGE_DATAERR_SCALE       ! re-scale all data  errors.
     &  ,FUDGE_MODELERR_SCALE      ! re-scale all model errors.

      CHARACTER 
     &   FUDGE_FITERR_PASSBANDS*(MXFILT_ALL) ! apply err-fudge to these bands

c allow TREST-cut to depend on filter (to override global FITWIN_TREST cut)
      CHARACTER 
     &  FITWIN_TREST_FILTER*120    ! e.g., 'gr -10.0 50.0  iz 0 50' 
      REAL 
     &  FITWIN_TREST_FILT(2,MXFILT_ALL)  ! Trest window for each filter

      LOGICAL
     &   DOFUDGE_FITERR(MXFILT_ALL) ! internal logical computed from above
     &  ,USE_FUDGE_FITERR           ! internal logical
     &  ,DOPRIOR_DLMAG              ! internal logical 


      COMMON / FITINP / 
     &    FITMODEL_NAME, RESTLAMBDA_FITRANGE, UVLAM_EXTRAPFLUX
     &   ,FILTLIST_FIT
     &   ,FILTLIST_DMPFCN, FILTER_FITMAGDIF
     &   ,FILTLIST_FITRESTMAG, LUMIFIX_FITRESTMAG, SHAPEFIX_FITRESTMAG
     &   ,COLORFIX_FITRESTMAG, LAMEXTRAP_FITRESTMAG, DLAMTOL_FITRESTMAG
     &   ,FILTLIST_DMPFUN, TREST_DMPFUN, SCALE_PLOTCHI2
     &   ,NEARFILT_IGNORE_REST, FILTLAM_SHIFT
     &   ,DOFIT_FILT, DOFIT_PHOTOZ, SKIP_PHOTOZ_INIT
     &   ,LDMP_PHOTOZ_DROPFILTER
     &   ,LDMPFCN, LDMPFUN, LDMPFCN_PLOTCHI2, LDMPFUN_PLOTCHI2
     &   ,LFIXPAR_ALL, LFIXPAR_ADJUST, LKCOR_AVWARP, LKCOR_STRETCH
     &   ,USE_MODEL_MAGERR, DOCHI2_SIGMA, LAMREST_MODEL_SMOOTH
     &   ,CHECK_CRAZYFITERR, SIMEFF_FILE, ADD_SALT2ERR_FROMz
     &   ,ENABLE_MAGSHIFT_SALT2, ENABLE_WAVESHIFT_SALT2
     &   ,ALLOW_NEGFLUX_SALT2
     &   ,STRETCH_TEMPLATE_FILE, SALT2_DICTFILE
     &   ,DELCHI2_REJECT, SIGNOISE_REJECT, PEAKMJD_SANITY
     &   ,FITWIN_ZPULL, FITWIN_ZPHOT
     &   ,FITWIN_COLOR, FITWIN_SHAPE, FITWIN_MJD
     &   ,FITWIN_PROB, FITWIN_NOMARG_PROB, FITWIN_CHI2SIGMA
     &   ,FITWIN_TREST, FITWIN_TREST_FILTER, FITWIN_TREST_FILT
     &   ,FITWIN_COV_OFFDIAG, FITWIN_PEAKMJD_ERR
     &   ,FITWIN_MB_ERR, FITWIN_SHAPE_ERR, FITWIN_COLOR_ERR
     &   ,FITWIN_PEAKMJD_ERRz1
     &   ,FITWIN_MB_ERRz1, FITWIN_SHAPE_ERRz1, FITWIN_COLOR_ERRz1
     &   ,SNMAGRMS_for_PHOTOZ
     &   ,USESIM_AV, USESIM_RV, USESIM_COLOR
     &   ,USESIM_LUMIPAR, USESIM_SHAPE
     &   ,USESIM_PEAKMJD, USESIM_DLMAG, USESIM_REDSHIFT, USESIM_INIVAL
     &   ,INISTP_PEAKMJD, INISTP_AV, INISTP_RV, INISTP_AVRV
     &   ,INISTP_DLMAG, INISTP_X0, INISTP_PHOTOZ, INISTP_COLOR
     &   ,INISTP_SHAPE, INISTP_SHAPE2
     &   ,INIVAL_PEAKMJD, INIVAL_PEAKMJD_SHIFT
     &   ,INIVAL_AV, INIVAL_RV, INIVAL_AVRV
     &   ,INIVAL_DLMAG, INIVAL_PHOTOZ, INIVAL_COLOR, INIVAL_X0
     &   ,INIVAL_SHAPE, INIVAL_SHAPE2, INIVAL_SHIFT_ERRFRAC
     &   ,INIVAL_GRIDSEARCH_DPEAKMJD, INIVAL_GRIDSEARCH_COLOR
     &   ,FRACERRDIF_REPEATFIT
     &   ,OPT_COVAR, OPT_COVAR_FLUX, OPT_COVAR_MWXTERR, OPT_XTMW_ERR
     &   ,OPT_COVAR_LCFIT, OPT_SNXT, OPT_KCORERR, OPT_NEARFILT
     &   ,OPT_LANDOLT, ZSCALE_SIMEFF, UCOR_BXB
     &   ,OPT_PHOTOZ, ISCALE_COURSEBIN_PHOTOZ
     &   ,NEVAL_MCMC_PHOTOZ, PARLIST_MCMC_PHOTOZ
     &   ,FUDGE_COVAR, SCALE_COVAR, LANDOLT_COLOR_SHIFT
     &   ,NGRID_PDF, NSIGMA_PDF, MAX_INTEGPDF
     &   ,PRIOR_AVEXP, PRIOR_AVWGT, PRIOR_AVRES, PRIOR_MJDSIG
     &   ,PRIOR_ZERRSCALE, PRIOR_MUERRSCALE, DOPRIOR_DLMAG
     &   ,PRIOR_COLOR_RANGE,   PRIOR_COLOR_SIGMA
     &   ,PRIOR_SHAPE_RANGE,   PRIOR_SHAPE_SIGMA
     &   ,PRIOR_LUMIPAR_RANGE, PRIOR_LUMIPAR_SIGMA  ! legacy 
     &   ,PRIOR_DELTA_PROFILE
     &   ,OPT_PRIOR, OPT_PRIOR_AV, OPT_PRIOR_SIMEFF, OPT_SIMEFF
     &   ,OPT_MNSTAT_COV, SIMFIT_IDEAL_PRESCALE
     &   ,MINOS_ERR_DLMAG, MINOS_ERR_REQALL0, MINOS_ERR_REQALL1
     &   ,MINOS_ERRMAX_BAD
     &   ,CONTOUR_LIST, LTRACE, LPLOTCHI2, IPAR_PLOTCHI2
     &   ,FUDGE_FITERR_MAXFRAC, FUDGE_FITERR_TREST
     &   ,FUDGE_FITERR_PASSBANDS, DOFUDGE_FITERR, USE_FUDGE_FITERR
     &   ,FUDGE_FITERR_RESTLAM, FUDGE_MAGERR_MODEL, FUDGE_FITERR_MAXITER
     &   ,FUDGEALL_MAXFRAC, FUDGEALL_ITER1_MAXFRAC
     &   ,FUDGE_DATAERR_SCALE, FUDGE_MODELERR_SCALE
     &   ,FITCOVAR_FILE
     &   ,TREST_PEAKRENORM
     &   ,SALT2alpha, SALT2beta, OPT_SALT2FIT
     &   ,PHOTODZ_REJECT, PHOTODZ1Z_REJECT
     &   ,PHOTOZ_ITER1_LAMRANGE, PHOTOZ_BOUND
     &   ,MAGLIM_VMAX, OPT_VMAX

c ------

      NAMELIST / FITINP / 
     &    FITMODEL_NAME, RESTLAMBDA_FITRANGE, UVLAM_EXTRAPFLUX
     &   ,FILTLIST_FIT
     &   ,FILTLIST_DMPFCN, FILTER_FITMAGDIF
     &   ,FILTLIST_FITRESTMAG, LUMIFIX_FITRESTMAG, SHAPEFIX_FITRESTMAG
     &   ,COLORFIX_FITRESTMAG, LAMEXTRAP_FITRESTMAG, DLAMTOL_FITRESTMAG
     &   ,FILTLIST_DMPFUN, TREST_DMPFUN, SCALE_PLOTCHI2
     &   ,NEARFILT_IGNORE_REST, FILTLAM_SHIFT
     &   ,DOFIT_PHOTOZ, SKIP_PHOTOZ_INIT
     &   ,LDMP_PHOTOZ_DROPFILTER
     &   ,LFIXPAR_ALL, LFIXPAR_ADJUST, LKCOR_AVWARP, LKCOR_STRETCH
     &   ,USE_MODEL_MAGERR, DOCHI2_SIGMA, LAMREST_MODEL_SMOOTH
     &   ,CHECK_CRAZYFITERR, SIMEFF_FILE, ADD_SALT2ERR_FROMz
     &   ,ENABLE_MAGSHIFT_SALT2, ENABLE_WAVESHIFT_SALT2
     &   ,ALLOW_NEGFLUX_SALT2
     &   ,STRETCH_TEMPLATE_FILE, SALT2_DICTFILE
     &   ,DELCHI2_REJECT, SIGNOISE_REJECT, PEAKMJD_SANITY
     &   ,FITWIN_ZPULL, FITWIN_ZPHOT
     &   ,FITWIN_COLOR, FITWIN_SHAPE, FITWIN_MJD
     &   ,FITWIN_PROB, FITWIN_NOMARG_PROB, FITWIN_CHI2SIGMA
     &   ,FITWIN_TREST, FITWIN_TREST_FILTER, FITWIN_TREST_FILT
     &   ,FITWIN_COV_OFFDIAG, FITWIN_PEAKMJD_ERR
     &   ,FITWIN_MB_ERR, FITWIN_SHAPE_ERR, FITWIN_COLOR_ERR
     &   ,FITWIN_PEAKMJD_ERRz1
     &   ,FITWIN_MB_ERRz1, FITWIN_SHAPE_ERRz1, FITWIN_COLOR_ERRz1
     &   ,SNMAGRMS_for_PHOTOZ
     &   ,TREST_REJECT, MJD_REJECT
     &   ,USESIM_AV, USESIM_RV, USESIM_COLOR
     &   ,USESIM_LUMIPAR, USESIM_SHAPE
     &   ,USESIM_PEAKMJD, USESIM_DLMAG, USESIM_REDSHIFT, USESIM_INIVAL
     &   ,INISTP_PEAKMJD, INISTP_AV, INISTP_RV, INISTP_AVRV
     &   ,INISTP_DLMAG, INISTP_X0, INISTP_PHOTOZ, INISTP_COLOR
     &   ,INISTP_SHAPE, INISTP_SHAPE2
     &   ,INIVAL_PEAKMJD, INIVAL_PEAKMJD_SHIFT
     &   ,INIVAL_AV, INIVAL_RV, INIVAL_AVRV
     &   ,INIVAL_DLMAG, INIVAL_PHOTOZ, INIVAL_COLOR, INIVAL_X0
     &   ,INIVAL_SHAPE, INIVAL_SHAPE2, INIVAL_SHIFT_ERRFRAC
     &   ,INIVAL_GRIDSEARCH_DPEAKMJD, INIVAL_GRIDSEARCH_COLOR
     &   ,FRACERRDIF_REPEATFIT
     &   ,OPT_COVAR, OPT_COVAR_FLUX, OPT_COVAR_MWXTERR, OPT_XTMW_ERR
     &   ,OPT_COVAR_LCFIT, OPT_SNXT, OPT_KCORERR, OPT_NEARFILT
     &   ,OPT_LANDOLT, ZSCALE_SIMEFF, UCOR_BXB
     &   ,OPT_PHOTOZ, ISCALE_COURSEBIN_PHOTOZ
     &   ,NEVAL_MCMC_PHOTOZ, PARLIST_MCMC_PHOTOZ
     &   ,FUDGE_COVAR, SCALE_COVAR, LANDOLT_COLOR_SHIFT
     &   ,NGRID_PDF, NSIGMA_PDF, MAX_INTEGPDF
     &   ,PRIOR_AVEXP, PRIOR_AVWGT, PRIOR_AVRES, PRIOR_MJDSIG
     &   ,PRIOR_ZERRSCALE, PRIOR_MUERRSCALE, DOPRIOR_DLMAG
     &   ,PRIOR_COLOR_RANGE, PRIOR_COLOR_SIGMA
     &   ,PRIOR_SHAPE_RANGE, PRIOR_SHAPE_SIGMA
     &   ,PRIOR_LUMIPAR_RANGE, PRIOR_LUMIPAR_SIGMA  ! legacy 
     &   ,PRIOR_DELTA_PROFILE
     &   ,OPT_PRIOR, OPT_PRIOR_AV, OPT_SIMEFF
     &   ,OPT_MNSTAT_COV, SIMFIT_IDEAL_PRESCALE
     &   ,MINOS_ERR_DLMAG, MINOS_ERR_REQALL0, MINOS_ERR_REQALL1
     &   ,MINOS_ERRMAX_BAD
     &   ,CONTOUR_LIST, LTRACE, LPLOTCHI2, IPAR_PLOTCHI2
     &   ,FUDGE_FITERR_MAXFRAC, FUDGE_FITERR_TREST
     &   ,FUDGE_FITERR_PASSBANDS
     &   ,FUDGE_FITERR_RESTLAM, FUDGE_MAGERR_MODEL,FUDGE_FITERR_MAXITER
     &   ,FUDGEALL_MAXFRAC, FUDGEALL_ITER1_MAXFRAC
     &   ,FUDGE_DATAERR_SCALE, FUDGE_MODELERR_SCALE
     &   ,FITCOVAR_FILE
     &   ,TREST_PEAKRENORM
     &   ,SALT2alpha, SALT2beta , OPT_SALT2FIT
     &   ,PHOTODZ_REJECT, PHOTODZ1Z_REJECT
     &   ,PHOTOZ_ITER1_LAMRANGE, PHOTOZ_BOUND
     &   ,MAGLIM_VMAX, OPT_VMAX

      EQUIVALENCE ( FITWIN_MJD(1),   MJD_REJECT(1)   ) 
      EQUIVALENCE ( FITWIN_TREST(1), TREST_REJECT(1) ) 


+KEEP,TABLEVARCOM.

c Created May 2014
c Misc arrays used to initialize and fill FITRES table(s).
c These arrays either don't exist elsewhere (e..g, REDUCED
c covariance), or they replace existing arrays with BIDON 
c elements removed; e.g., SNRMAX-list with unused filters 
c excluded.  

      INTEGER MXCOV_TBL
      PARAMETER (MXCOV_TBL = IPAR_MAX*(IPAR_MAX-1)/2 ) ! off-diags only

      REAL
     &   TBL_REDCOV(MXCOV_TBL)         ! only fited params
     &  ,TBL_COV(MXCOV_TBL)            ! idem
     &  ,TBL_XTMW(MXFILT_ALL)          ! only fitted filters
     &  ,TBL_SNRMAX(MXFILT_ALL)        ! idem

      INTEGER 
     &   NCOV_TBL         ! size of REDCOV,COV arrays
     &  ,NCOV_TBL_PKMJD   ! first NCOV_PKMD elements have PKMJD element
     &  ,IPAR_TBL_COV(2,MXCOV_TBL)   ! list if IPARs for COV
     
c variables to define subset of fitted bands;

      INTEGER 
     &   NFILTOBS_TABLE                  ! for ntuple
     &  ,IFILTOBS_MAP_TABLE(MXFILT_OBS)  ! ifilt_obs vs. sparse index
     &  ,IFILT_MAP_TABLE(MXFILT_OBS)     ! ifilt vs. sparse index

      CHARACTER SURVEY_FILTERS_TABLE*100  ! list of surveys filters to plot

c variables for SPECTRA table (Nov 2016)
      INTEGER    MXLAM_TBLSPEC, NBLAM_TBLSPEC, TBLSPEC_IFILTOBS
      INTEGER    TBLSPEC_CCDNUM, TBLSPEC_IMGNUM  ! Oct 2021
      PARAMETER ( MXLAM_TBLSPEC = 1000 )
      CHARACTER  TBLSPEC_CFILT*4, TBLSPEC_FIELD*(MXCHAR_FIELDNAME)
      REAL  
     &   TBLSPEC_MJD, TBLSPEC_TREST, TBLSPEC_TOBS, TBLSPEC_LAMREST
     &  ,TBLSPEC_FLUXCAL_DATA,  TBLSPEC_FLUXCAL_DATA_ERR
     &  ,TBLSPEC_FLUXCAL_MODEL, TBLSPEC_FLUXCAL_MODEL_ERR
     &  ,TBLSPEC_MAG_MODEL(MXFILT_OBS)
     &  ,TBLSPEC_MAG_MODEL_ERR(MXFILT_OBS)
     &  ,TBLSPEC_LAMLIST(MXLAM_TBLSPEC)
     &  ,TBLSPEC_FLUXLIST(MXLAM_TBLSPEC)
      REAL*8 TBLSPEC8_MJD

c - - - - - -

      COMMON / TABLEVARCOM4 /
     &   TBL_REDCOV, TBL_COV, TBL_XTMW, TBL_SNRMAX
     &  ,NCOV_TBL, NCOV_TBL_PKMJD, IPAR_TBL_COV
c
     &  ,NFILTOBS_TABLE, IFILTOBS_MAP_TABLE, IFILT_MAP_TABLE
     &  ,SURVEY_FILTERS_TABLE
c
     &  ,NBLAM_TBLSPEC, TBLSPEC_IFILTOBS, TBLSPEC_FIELD
     &  ,TBLSPEC_CCDNUM, TBLSPEC_IMGNUM
     &  ,TBLSPEC_CFILT, TBLSPEC_MJD, TBLSPEC_TREST, TBLSPEC_TOBS
     &  ,TBLSPEC_LAMREST
     &  ,TBLSPEC_FLUXCAL_DATA,  TBLSPEC_FLUXCAL_DATA_ERR
     &  ,TBLSPEC_FLUXCAL_MODEL, TBLSPEC_FLUXCAL_MODEL_ERR
     &  ,TBLSPEC_MAG_MODEL, TBLSPEC_MAG_MODEL_ERR
     &  ,TBLSPEC_LAMLIST, TBLSPEC_FLUXLIST

      COMMON / TABLEVARCOM8 / TBLSPEC8_MJD

+KEEP,ALLFILTCOM.
c
c Mar 2013: generic variables to store ALL-FILTER results
c           before doing more specialize fits such as rest-frame mags.

      INTEGER
     &   NFIT_ITERATION_ALLFILT
     &  ,NOBS_ALLFILT           ! store NFILT_OBS using all filters

      CHARACTER 
     &   ALLFILTLIST_FIT*(MXFILT_ALL)    ! original filter list
      LOGICAL 
     &   USE_ALLFILT(MXFILT_ALL)  

      REAL
     &   FITVAL_ALLFILT(MXFITPAR)
     &  ,FITERR_ALLFILT(MXFITPAR)

      COMMON / ALLFILTCOM / NFIT_ITERATION_ALLFILT
     &  ,USE_ALLFILT, NOBS_ALLFILT,  ALLFILTLIST_FIT
     &  ,FITVAL_ALLFILT, FITERR_ALLFILT


+KEEP,MAGDIFCOM.

+CDE,ALLFILTCOM.

c Mar 2013: for FILTER_FITMAGDIF option

      INTEGER 
     &   NFIT_ITER_FITMAGDIF
     &  ,IFLAG_FITMAGDIF_NOMINAL
     &  ,IFLAG_FITMAGDIF_1FILT  ! fit only test filter
     &  ,IFLAG_FITMAGDIF_XFILT  ! exclude test filter
     &  ,IFILTOBS_FITMAGDIF     ! absolute index
     &  ,IFILT_FITMAGDIF        ! sparse survey-filter index

      PARAMETER (
     &   NFIT_ITER_FITMAGDIF     = 1    ! Number of fit-iters per test
     &  ,IFLAG_FITMAGDIF_NOMINAL = 0
     &  ,IFLAG_FITMAGDIF_1FILT   = 1
     &  ,IFLAG_FITMAGDIF_XFILT   = 2
     &      )

      INTEGER    
     &   IFLAG_FITMAGDIF(MXITER)  ! 1-> one filter fit, 2-> complement
     &  ,NFILT_FITMAGDIF(MXITER)  ! NFILT to fit per iteration

      CHARACTER  
     &   FILTLIST_FITMAGDIF(MXITER)*(MXFILT_ALL) ! filter-list per iteration

      REAL  
     &   FITMAG_1FILT, FITMAGERR_1FILT
     &  ,FITMAG_XFILT, FITMAGERR_XFILT
     &  ,FITMAGDIF, FITERRDIF
     &  ,FITPROB_1FILT, FITPROB_XFILT

      COMMON / MAGDIFCOM / IFLAG_FITMAGDIF, NFILT_FITMAGDIF
     &    ,IFILTOBS_FITMAGDIF, IFILT_FITMAGDIF   
     &    ,FILTLIST_FITMAGDIF
     &    ,FITMAG_1FILT, FITMAGERR_1FILT
     &    ,FITMAG_XFILT, FITMAGERR_XFILT
     &    ,FITMAGDIF, FITERRDIF
     &    ,FITPROB_1FILT, FITPROB_XFILT
    
+KEEP,FITRESTCOM.

+CDE,ALLFILTCOM.

c for option to fit peakMag in rest-frame filter

      INTEGER MXFILT_FITRESTMAG, NFIT_ITER_FITRESTMAG
      PARAMETER ( 
     &   MXFILT_FITRESTMAG    = 10
     &  ,NFIT_ITER_FITRESTMAG =  1  ! Number of fit-iters per rest-filter
     &     ) 

      INTEGER  
     &   NFILTDEF_FITRESTMAG
     &  ,IFILTDEF_FITRESTMAG(MXFILT_FITRESTMAG)
     &  ,IFILTDEF_ITER_FITRESTMAG(MXITER)    ! IFILTDEF vs. ITER
     &  ,IFILTSP_ITER_FITRESTMAG(MXITER)     ! sparse IFILT vs. ITER
     &  ,ITERLAST_FITRESTMAG(MXFILT_FITRESTMAG) ! last iteration vs. IFILTSP
     &  ,NFILTDEF_SURVEY_ORIG
     &  ,NLCPLOT_FITRESTMAG
     &  ,IFILTOBS_BRACKET(MXFILT_FITRESTMAG)
     &  ,IPAROFF_FITRESTMAG  ! IPAR offset for LCVAL_STORE

      REAL   
     &   FITRESTMAG(MXFILT_FITRESTMAG)         ! calculated restmag value
     &  ,FITRESTMAG_ERR(MXFILT_FITRESTMAG)     ! error on above

      COMMON / FITRESTMAGCOM / NFILTDEF_SURVEY_ORIG
     &  ,NFILTDEF_FITRESTMAG, IFILTDEF_FITRESTMAG
     &  ,IFILTDEF_ITER_FITRESTMAG, IFILTSP_ITER_FITRESTMAG
     &  ,ITERLAST_FITRESTMAG, FITRESTMAG, FITRESTMAG_ERR
     &  ,NLCPLOT_FITRESTMAG, IFILTOBS_BRACKET, IPAROFF_FITRESTMAG

+KEEP,FITIDEALCOM.

      INTEGER SIMFIT_IDEAL_DEBUG
      PARAMETER (SIMFIT_IDEAL_DEBUG=777)   ! do nominal fit twice

      LOGICAL DOFIT_IDEAL
      INTEGER NFIT_ITERATION_ORIG 
      REAL*4  
     &    SAVE_FLUXCAL(MXEPOCH), SAVE_MWEBV, SAVE_MWEBV_ERR
     &   ,FITPAR_IDEAL(20) 
      COMMON / FITIDEALCOM / 
     &   DOFIT_IDEAL, NFIT_ITERATION_ORIG, SAVE_FLUXCAL
     &  ,SAVE_MWEBV, SAVE_MWEBV_ERR, FITPAR_IDEAL

+KEEP,VMAXCOM. 

c Created Jun 2013 by R.K.

c Examples for OPT_VMAX
c  OPT_VMAX = 2 -> use obs for mag, peak for Zmax
c  OPT_VMAX = 3 -> use peak for both mag and Zmax


      INTEGER 
     &  MXFILT_VMAX 
     & ,OPTBIT_MAG    ! Zmax at epoch of max obs brightness
     & ,OPTBIT_ZMAX
     & ,OPTBIT_VERBOSE
    
      REAL*8  MAGDIF_CONVERGE

      PARAMETER ( 
     &   MXFILT_VMAX   = 5
     &  ,OPTBIT_MAG    = 0  ! bit0 off/on -> mag at best-fit obs/peak
     &  ,OPTBIT_ZMAX   = 1  ! bit1 off/on -> zmax from best-fot obs/peak
     &  ,OPTBIT_VERBOSE = 7 ! bit7(128) -> verbose printout
     &  ,MAGDIF_CONVERGE = 0.001 ! stop when |mag(zmax)-MAGLIM| < CONVERGE
     &     )

      INTEGER 
     &   NFILT_VMAX   !Number of obs filters to compute Zmax/Vmax
     &  ,IFILTOBS_LIST_VMAX(MXFILT_VMAX) ! sparse list

      REAL 
     &   MAGLIM_LIST_VMAX(MXFILT_VMAX)
     &  ,TREST_LIST_VMAX(MXFILT_VMAX)
     &  ,MAG_LIST_VMAX(MXFILT_VMAX)
     &  ,Z_LIST_VMAX(MXFILT_VMAX)
     &  ,VOL_LIST_VMAX(MXFILT_VMAX)

      INTEGER NEP_LIST_VMAX(MXFILT_VMAX)

      CHARACTER FILTLIST_VMAX*20

      COMMON/ VMAXCOM / 
     &    NFILT_VMAX, IFILTOBS_LIST_VMAX
     &   ,FILTLIST_VMAX, MAGLIM_LIST_VMAX
     &   ,TREST_LIST_VMAX, MAG_LIST_VMAX, Z_LIST_VMAX, VOL_LIST_VMAX
     &   ,NEP_LIST_VMAX

C ===================================
+PATCH,*FITCODE.
+USE,P=*SNTABFIT,T=EXE.
+USE,P=*HFUNS,T=EXE.

C ===========================================
+DECK,FITPAR_INI.
      SUBROUTINE FITPAR_INI(IERR)
c
c User init: (read input, open files, etc ...)
c
c One time initialize BEFORE fitting and USRANA begins.
c
c
c Jul 19 2019: overhaul arguments to INIT_GENMAG_SNOOPY
c 
c Aug 2 2019: pass full model name (including path) to INIT_GENMAG_SNOOPY,
c             instead of passing only the model name without path
c
c Jun 17 2020: if OPT_PHOTOZ==2, set ERRMAX_BAD(zPHOT) = 1.0E-8
c
c -------------------------------------
      IMPLICIT NONE

      INTEGER 
     &   IERR    ! (O) 0 => OK

c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT. 
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.
+CDE,INTERPCM.

      LOGICAL  LTMP

      INTEGER 
     &   ipar, ipar2, istat, len1, len2, len3, len4, len5, LL,j
     &  ,LEN_VERS, LEN_NAME

c variables for PARSE_FILTSTRING:
      INTEGER IAFILT(MXFILT_OBS), ifiltdef, ifiltr, NF
      REAL    XAFILT(MXFILT_OBS)
      REAL    ERRMAX

      CHARACTER 
     &   snsed_file*(MXCHAR_FILENAME)
     &  ,cfilt*2
     &  ,cfilt_rest*(MXFILT_REST)
     &  ,cfilt_undefined*(MXFILT_ALL)
     &  ,covFile*(MXCHAR_FILENAME)
     &  ,tmpName*(MXCHAR_FILENAME)
     &  ,ctmp*4
     &  ,chis*80

c args for GET_FLUX_FITFUN
      INTEGER isn, ifilt, ifilt_obs, opt, i, NFILT
      INTEGER ilam, NLAM, hid, OPTMASK
      REAL*4  Z4

c misc.
      REAL*8   DUM8, LAMRANGE8(2)

c define functions

      INTEGER  
     &   INIT_GENMAG_STRETCH2  ! 1 or 2-par stretch
     &  ,INIT_GENMAG_MLCS2k2
     &  ,INIT_GENMAG_SNOOPY
     &  ,SNANA_NEARNBR_RDINPUT

      EXTERNAL 
     &   INIT_GENMAG_STRETCH2
     &  ,INIT_GENMAG_MLCS2k2
     &  ,INIT_GENMAG_SNOOPY

      REAL*8  GET_FLUX_FITFUN
      INTEGER FILTINDX

C ------------------- BEGIN ---------------------

      IERR = 0

      CALL RDFITNML(IERR)
      if ( IERR .NE. 0 ) RETURN

      CALL RDMCMCNML(IERR)
      if ( IERR .NE. 0 ) RETURN

c check for NN option (read &NNINP namelist)
      NVAR_NEARNBR = SNANA_NEARNBR_RDINPUT()

c set FITANA_CUTWIN_XXX for cuts that might change for photoZ fits.
c This allows using the same FITANA_CUTWIN_XXX array in FITANA

      DO i = 1, 2
       FITANA_CUTWIN_TREST(i)    = CUTWIN_TREST(i)
       FITANA_CUTWIN_TREST2(i)   = CUTWIN_TREST2(i)
       FITANA_CUTWIN_TRESTMIN(i) = CUTWIN_TRESTMIN(i)
       FITANA_CUTWIN_TRESTMAX(i) = CUTWIN_TRESTMAX(i)
       FITANA_CUTWIN_TGAPMAX(i)  = CUTWIN_TGAPMAX(i)
       FITANA_CUTWIN_T0GAPMAX(i) = CUTWIN_T0GAPMAX(i)
      ENDDO
c -------
c Default is rest-frame model; override below for obs-frame
      LOBS_FITMODEL  = .FALSE.
      LREST_FITMODEL = .TRUE.
      LSED_FITMODEL  = .FALSE.

c ---------------------------------
c set fitpar names.

      DO ipar = 1, MXFITSTORE
         write(PARNAME_STORE(ipar),20) ipar
20       format('BIDON', I3.3)
      ENDDO

      PARNAME_STORE(IPAR_ITER)    = 'ITER'

      PARNAME_STORE(IPAR_ISN)    = 'ISN'  

c init to model that fits for extinction and MU;
c might be changed below, for example, for SALT2 model

      PARNAME_STORE(IPAR_AV)      = 'AV'
      ERRMAX_BAD(IPAR_AV)         = 0.005  ! 0.01->0.005  6/17/2020

      PARNAME_STORE(IPAR_DLMAG)   = 'DLMAG'
      ERRMAX_BAD(IPAR_DLMAG)      = 0.0

c check for floating RV in fit
      if ( INISTP_AVRV .GT. 0.0 ) then
        PARNAME_STORE(IPAR_AVRV)    = 'AVRV'
      else
        PARNAME_STORE(IPAR_RV)      = 'RV'
      endif

      PARNAME_STORE(IPAR_PEAKMJD) = 'PKMJD'

      IF ( INISTP_PHOTOZ .GT. 0.0 ) THEN
        IF ( INISTP_PHOTOZ == 1 ) THEN
           CALL ABORT_ON_CUTWIN_TREST()  ! Feb 2014
        ENDIF
        PARNAME_STORE(IPAR_ZPHOT)  = 'zPHOT'
      ELSE
        PARNAME_STORE(IPAR_ZPHOT)  = 'REDSHIFT'
      ENDIF

      IF ( OPT_PHOTOZ == 2 ) THEN
          ERRMAX_BAD(IPAR_ZPHOT) =  1.0E-8 ! likely has specz prior, 6/2020
      ELSE
          ERRMAX_BAD(IPAR_ZPHOT) =  0.0005 
      ENDIF
      ABORT_ON_BADZ           = .FALSE.

      IF ( LSIM_SNANA ) THEN
        do ipar = 1, IPAR_MAX
          USESIM_FITPAR(ipar) = .FALSE.
        enddo
        USESIM_FITPAR(IPAR_AV)      = USESIM_AV .or. USESIM_COLOR
        USESIM_FITPAR(IPAR_RV)      = USESIM_RV
        USESIM_FITPAR(IPAR_PEAKMJD) = USESIM_PEAKMJD
        USESIM_FITPAR(IPAR_SHAPE)   = USESIM_SHAPE.or.USESIM_LUMIPAR
        USESIM_FITPAR(IPAR_DLMAG)   = USESIM_DLMAG
        USESIM_FITPAR(IPAR_ZPHOT)   = USESIM_REDSHIFT

      ENDIF

c set default cut-windows to be wide open

      DO ipar = 1, IPAR_MAX
        CUTWIN_FITPAR(1,ipar) = -1.0E8
        CUTWIN_FITPAR(2,ipar) =  1.0E8

        CUTWIN_FITERRz1(1,ipar) = -0.001
        CUTWIN_FITERRz1(2,ipar) = +1.0E8

        DO ipar2 = 1, IPAR_MAX
           if ( ipar .eq. ipar2 ) then
             CUTWIN_FITCOV(1,ipar,ipar2) = -1.0E8
             CUTWIN_FITCOV(2,ipar,ipar2) = +1.0E8
           else
             CUTWIN_FITCOV(1,ipar,ipar2) = FITWIN_COV_OFFDIAG(1)
             CUTWIN_FITCOV(2,ipar,ipar2) = FITWIN_COV_OFFDIAG(2)
           endif
        ENDDO  ! end ipar2 loop

      ENDDO  ! end ipar loop
c ------------

      CALL LANDOLT_PREP

c Parse filter lambda-shifts; 
c OPT=0 to NOT error-check filter because Bessell-B 
c is usually not an observer-frame filter.

      CALL PARSE_FILTSTRING(0, FILTLAM_SHIFT, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef            = IAFILT(i)
         FILTOBS_LAMSHIFT(ifiltdef) = xafilt(i)  ! global R*4 storage
      ENDDO

c ---------------------
c print WARNING if fitting subset of filters.
      Len1 = INDEX(SURVEY_FILTERS,' ') - 1
      Len2 = INDEX(FILTLIST_FIT,  ' ') - 1
      IF ( Len2 .LT. Len1 ) THEN
           print*,'  WARNING: fitting filter subset  ', 
     &     FILTLIST_FIT(1:Len2),'  from  ', SURVEY_FILTERS(1:Len1)
      ENDIF

    
c -------------------------------------------------------
c Covariance matrix:
c construct name of covar_File for this version;
c if it does not exist, then set covFile = '' so that
c the default is used.

      if (   fitcovar_file .EQ. 'SIM'  
     &  .or. fitcovar_file .EQ. 'sim' ) then

        len1    = INDEX(SNDATA_PREFIX, ' ' ) - 1
        fitcovar_file = SNDATA_PREFIX(1:len1) // '_COVAR.DAT' 
      endif

c check option to fit restmags.
      CALL FITRESTMAG_INI()

c check option to fit obsMag 2 different ways
      CALL FITMAGDIF_INI()

c check option to include IDEAL fit with FLUX=TRUEFLUX (no Poisson fluctuations)
      CALL SIMFIT_IDEAL_INI()

c ------------------------------------------------------
c set FITMODEL_INDEX, FITMODEL_PATH and FITMODEL_VERSION

      CALL FITMODEL_INI()

      LEN_VERS = INDEX(FITMODEL_VERSION, ' ' ) - 1
      LEN_NAME = INDEX(FITMODEL_NAME,' ') - 1

      tmpName  = FITMODEL_NAME(1:LEN_NAME) // char(0)
      
c set rest-frame filter ranges.
      FILTLIST_MODEL = ''
      NFILT_MODEL    = 0

      NSHAPEPAR = 1  ! default is 1 shape-par unless changed below

      LL = INDEX(SNDATA_ROOT,' ') - 1
      
      IF (   FITMODEL_INDEX .EQ. MODEL_STRETCH
     &  .or. FITMODEL_INDEX .EQ. MODEL_STRETCH2 ) THEN

         CALL FILL_AVWARPTABLE

         RESTLAMBDA_MODEL(1) = 3000.0
         RESTLAMBDA_MODEL(2) = 9500.0        

         ISTAT = INIT_GENMAG_STRETCH2(tmpName,CFILT_REST,LEN_NAME,LEN2)

         if ( FITMODEL_INDEX .EQ. MODEL_STRETCH ) then
           PARNAME_STORE(IPAR_SHAPE) = 'STRETCH'
         else 
           PARNAME_STORE(IPAR_SHAPE)  = 'SRISE'    
           PARNAME_STORE(IPAR_SHAPE2) = 'SFALL'
           NSHAPEPAR = 2
         endif

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN

         LOBS_FITMODEL  = .TRUE.
         LREST_FITMODEL = .FALSE.
         LSED_FITMODEL  = .TRUE.

         PARNAME_STORE(IPAR_COLOR)  = 'c'
         ERRMAX_BAD(IPAR_COLOR)     = 0.001

         PARNAME_STORE(IPAR_SHAPE)  = 'x1'
         ERRMAX_BAD(IPAR_SHAPE)     =  0.001

         if ( OPT_SALT2FIT .EQ. 0 .or. OPT_SALT2FIT .EQ. 4) then   !default
           PARNAME_STORE(IPAR_X0)         = 'x0'
         else if ( OPT_SALT2FIT .EQ. 1 ) then
           PARNAME_STORE(IPAR_X0)         = 'logx0'
         else if ( OPT_SALT2FIT .EQ. 2 ) then
           PARNAME_STORE(IPAR_X0)         = 'MUDIF'
         else
           write(c1err,669) OPT_SALT2FIT
669        format('Invalid OPT_SALT2FIT = ',I5 )
           c2err = 'Check &FITINP namelist'
           CALL MADABORT("FITPAR_INI", c1err, c2err )  
         endif
         ERRMAX_BAD(IPAR_X0)        = 0.0

c note that mB is computed from fitpars, and does not float in fit
         PARNAME_STORE(IPAR_MB)         = 'mB'

         CALL SEDMODEL_INI(0,IERR)

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SIMSED ) THEN

         LOBS_FITMODEL  = .TRUE.
         LREST_FITMODEL = .FALSE.
         LSED_FITMODEL  = .TRUE.

         PARNAME_STORE(IPAR_X0)         = 'MUDIF'
         ERRMAX_BAD(IPAR_X0)        = 0.0

         CALL  SEDMODEL_INI(0,IERR)

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_MLCS2k2 ) THEN

         CALL FILL_AVWARPTABLE

         PARNAME_STORE(IPAR_SHAPE)  = 'DELTA'
         ERRMAX_BAD(IPAR_SHAPE) = 0.02

         len2 = INDEX(fitcovar_file, ' ' ) - 1
         len3 = 0

         COVFILE = FITCOVAR_FILE(1:len2) // CHAR(0)

         ISTAT = INIT_GENMAG_MLCS2k2( 
     &               tmpName, covFile, scale_covar, 
     &               FILTLIST_MODEL, LEN_VERS,len2,len3 
     &                      )

c fetch valid lambda-range from mlcs-function; note that the range
c depends on which IR filters are used.

         CALL GET_LAMRANGE_MLCS2k2(LAMRANGE8(1),LAMRANGE8(2))
         RESTLAMBDA_MODEL(1) = LAMRANGE8(1)
         RESTLAMBDA_MODEL(2) = LAMRANGE8(2)         

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SNOOPY ) THEN

         CALL FILL_AVWARPTABLE

         CALL GET_LAMRANGE_snoopy(LAMRANGE8(1),LAMRANGE8(2))
         RESTLAMBDA_MODEL(1) = LAMRANGE8(1)
         RESTLAMBDA_MODEL(2) = LAMRANGE8(2)         
         PARNAME_STORE(IPAR_SHAPE) = 'STRETCH'
         OPTMASK = 0
         ISTAT = INIT_GENMAG_SNOOPY(tmpName, OPTMASK,
     &       FILTLIST_MODEL, LEN_NAME, len2 )  ! return args

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_FIXMAG ) THEN

         PARNAME_STORE(IPAR_SHAPE) = 'NULL'
         FILTLIST_MODEL = "UBVRI"

         print*,' '
         print*,' Invalid FIXMAG model.'
         print*,' Program Stopping Gracefully. '
         print*,' '
         STOP

      ELSE
         c1err = 'Invalid FITMODEL_NAME: ' // FITMODEL_NAME(1:40)
         c2err = 'Check &FITINP namelist'
         CALL MADABORT("FITPAR_INI", c1err, c2err )
      ENDIF

c check for simulated efficiency map to use as prior
      CALL INIT_PRIOR_SIMEFF

C ============================================
c load IFILTMAP_MODEL array and its inverse
c Mar 2013: abort if model filter is not defined in kcor table.

      DO i       = 1, MXFILT_ALL
        IFILTMAP_MODEL(i)    = -9
        IFILTINVMAP_MODEL(i) = -9
      ENDDO
      NFILT_MODEL = INDEX(FILTLIST_MODEL, ' ' ) - 2 ! subtract 2 for char(0)
      CFILT = ''
      CFILT_UNDEFINED = ''
      NF = 0  ! number of undefined filters
      DO i       = 1, NFILT_MODEL
        CFILT    = FILTLIST_MODEL(i:i) 
        ifiltdef = FILTINDX(cfilt)   ! absolute index of model filter
        IFILTMAP_MODEL(i)           = ifiltdef
        IFILTINVMAP_MODEL(ifiltdef) = i

        ifiltr  = IFILTDEF_INVMAP_REST(IFILTDEF)
        IF ( ifiltr < 0 ) then
           NF = NF + 1
           CFILT_UNDEFINED = CFILT_UNDEFINED(1:NF-1) // CFILT(1:1)
        ENDIF
      ENDDO

c abort if more than 3 model filters are not defined.
c This is bit arbitrary, but it allows ignoring some 
c model-wavelength ranges such as the IR.

      IF ( NF > 30 ) THEN
         write(C1ERR,651) NF, CFILT_UNDEFINED(1:NF)
651      format(I3,' undefined rest-frame model filters (',A,')' )
         c2err = 'Defined rest-frame K-cor filters: ' //
     &               RESTKCOR_FILTERS(1:NFILTDEF_REST)
         CALL MADABORT("FITPAR_INI", c1err, c2err )
      ENDIF
c -----------
c set optional filter-dependent cuts on TREST
      CALL SETCUTS_FITWIN_TREST

c ----------------------------------------------

      CUTWIN_FITPAR(1,IPAR_PEAKMJD) = FITWIN_MJD(1)  ! 9/16/2016
      CUTWIN_FITPAR(2,IPAR_PEAKMJD) = FITWIN_MJD(2)
      CUTWIN_FITPAR(1,IPAR_SHAPE) = FITWIN_SHAPE(1)
      CUTWIN_FITPAR(2,IPAR_SHAPE) = FITWIN_SHAPE(2)
      CUTWIN_FITPAR(1,IPAR_AV)    = FITWIN_COLOR(1)
      CUTWIN_FITPAR(2,IPAR_AV)    = FITWIN_COLOR(2)
      CUTWIN_FITPAR(1,IPAR_ZPHOT) = FITWIN_ZPHOT(1)
      CUTWIN_FITPAR(2,IPAR_ZPHOT) = FITWIN_ZPHOT(2)

c cuts on offDiag cov already set since it's the same cut on each element.
c Here set diagonal cuts for each fitPar.
       
      IPAR = IPAR_PEAKMJD ; ERRMAX = FITWIN_PEAKMJD_ERR(2) 
      CUTWIN_FITCOV(2,IPAR,IPAR) = ERRMAX*ERRMAX
      CUTWIN_FITERRz1(2,IPAR)    = FITWIN_PEAKMJD_ERRz1(2)

      IPAR = IPAR_MB ; ERRMAX = FITWIN_MB_ERR(2) 
      CUTWIN_FITCOV(2,IPAR,IPAR) = ERRMAX*ERRMAX
      CUTWIN_FITERRz1(2,IPAR)    = FITWIN_MB_ERRz1(2)

      IPAR = IPAR_SHAPE ; ERRMAX = FITWIN_SHAPE_ERR(2) 
      CUTWIN_FITCOV(2,IPAR,IPAR) = ERRMAX*ERRMAX
      CUTWIN_FITERRz1(2,IPAR)    = FITWIN_SHAPE_ERRz1(2)

      IPAR = IPAR_COLOR ; ERRMAX = FITWIN_COLOR_ERR(2) 
      CUTWIN_FITCOV(2,IPAR,IPAR) = ERRMAX*ERRMAX
      CUTWIN_FITERRz1(2,IPAR)    = FITWIN_COLOR_ERRz1(2)
      
c determin RESTLAMBDA_USEFIT based on user FITRANGE and that
c defined by the model
      RESTLAMBDA_USEFIT(1) = 
     &     MAX(RESTLAMBDA_MODEL(1),RESTLAMBDA_FITRANGE(1))
      RESTLAMBDA_USEFIT(2) = 
     &     MIN(RESTLAMBDA_MODEL(2),RESTLAMBDA_FITRANGE(2))
      
      print*,'  '
      write(6,350) 'SN-MODEL', RESTLAMBDA_MODEL
      write(6,350) 'USER-DEF', RESTLAMBDA_FITRANGE
      write(6,350) 'Final   ', RESTLAMBDA_USEFIT
350   format(T5, A, 2x, 'LAMBDA RANGE: ', F6.0,' - ', F6.0 )

c abort if range makes no sense
      IF( RESTLAMBDA_USEFIT(2) .LT. 1000. ) THEN
         c1err = 'Invalid LAMBDA RANGE (see above).'
         c2err = 'Something is messed up.'
         CALL MADABORT("FITPAR_INI", c1err, c2err )
      ENDIF

c print cuts to reject epochs at 2nd epoch

      print*,'  '
      print*,'  SECOND-ITERATION EPOCH-REJECTION CUTS: '
      print*,'    REJECT  delchi2      > ', DELCHI2_REJECT
      print*,'    REJECT  signal/noise < ', SIGNOISE_REJECT
      print*,'    REJECT  Trest        < ', FITWIN_TREST(1)
      print*,'    REJECT  Trest        > ', FITWIN_TREST(2)
      print*,'    REJECT  MJD          < ', FITWIN_MJD(1)
      print*,'    REJECT  MJD          > ', FITWIN_MJD(2)
      print*,'  ' 

      print*,' '
      print*,'  FINAL FIT CUTS: '
      print*,'    REQUIRE MINOS ERROR for DLAMG        : ', 
     &                 MINOS_ERR_DLMAG
      print*,'    REQUIRE MINOS ERROR for ALL   FITPAR : ', 
     &                 MINOS_ERR_REQALL0
      print*,'    REQUIRE MINOS ERROR for ALL-1 FITPAR : ', 
     &                 MINOS_ERR_REQALL1
      print*,'    FIT-SIGMACHI2     > ', FITWIN_CHI2SIGMA(1)
      print*,'    FIT-PROB(final)   > ', FITWIN_PROB(1)
      print*,'    FIT-PROB(no marg) > ', FITWIN_NOMARG_PROB(1)

      if ( NEARFILT_IGNORE_REST .NE. ' ' ) then
          print*,'    IGNORE NEAREST REST-FRAME FILTERS: ', 
     &            NEARFILT_IGNORE_REST 
      endif

      if ( DOFIT_PHOTOZ ) then
        print*,'    REQUIRE photoZ(SN-host) pull :', 
     &                 FITWIN_ZPULL(1),' to ', FITWIN_ZPULL(2)
        CALL PHOTOZ_ANA(0,0,ISTAT) ! init ZDROP for each filter
        
      endif

      print*,'  '

c print ERRMAX_BAD

      DO ipar = 1, IPAR_MAX

         if ( .not. MINOS_ERRMAX_BAD ) ERRMAX_BAD(ipar) = 0.0

         write(6,88) PARNAME_STORE(ipar), ERRMAX_BAD(ipar)
88       format(T5,'Valid ERROR(', A10, ') must be > ', F9.5 )
      ENDDO
      print*,'  '

c ------------------
c check FUDGE_FITERR to see if some flux-errors should be
c blown up. Set logical(s) DOFUDGE_FITERR(ifilt_obs) to use later.
  
      CALL INIT_FUDGE_FITERR

c -----------------------------------------------    
c initialize priors 

      CALL FITINI_PRIORS

c rest-frame init
      IF ( LREST_FITMODEL ) THEN
         IF( NKCOR_STORE .EQ. 0 ) THEN
           c1err = 'Cannot fit rest-frame model ' 
     &          // FITMODEL_NAME(1:40)
           c2err = 'with no K-cor tables. Check KCOR_FILE.'
           CALL MADABORT("FITPAR_INI", c1err, c2err)
         ENDIF

         CALL FITINI_XTPAR(OPT_SNXT) ! initialize host-galaxy extinction 
      ENDIF

c -------------------------------------------
c Define extra "TABLEVAR" variables for output tables

      CALL FITINI_TABLEVAR

c check for file with interpolated MAGS at specified MJDs.

      IF ( N_INTERP_MJDLIST .GT. 0 ) THEN
         CALL DMP_SNMJD_INTERP(0,0)
      ENDIF

c check for option to compuare Zmax/Vmax
      CALL VMAX_INI()

c ----
      CALL FITINI_EPVAR(-1)

      RETURN
      END  ! end of FITPAR_INI

C ===========================================
+DECK,FITPAR_INI2.
      SUBROUTINE FITPAR_INI2(IERR)
c
c Created May 2012 by R.Kessler
c One-time Initialization after 1st event is read
c but before the fit is performed.
c
c Sep 30, 2012: init FLOATPAR(ipar)
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT. 
+CDE,SNFITCOM.
+CDE,SNLCINP.

      INTEGER IERR ! (O) 0=OK

      INTEGER ipar
      REAL*8    DUMPAR
      CHARACTER FNAM*12
C ------------- BEGIN ----------------
      IERR = 0
      FNAM = 'FITPAR_INI2'
c ------------------------------------------------
c Determine which parameters are floated in fit.
c Use namelist input since the global INISTP array has
c not yet been filled.

      do ipar = 1, IPAR_MAX
         FLOATPAR(ipar) = .TRUE.
      enddo
      FLOATPAR(IPAR_ITER) = .FALSE.
      FLOATPAR(IPAR_ISN)  = .FALSE.  

      IPAR = IPAR_AV
        if (INISTP_AV     .EQ. 0.0 ) FLOATPAR(IPAR) = .FALSE.
      IPAR = IPAR_RV
        if (INISTP_RV     .EQ. 0.0 ) FLOATPAR(IPAR) = .FALSE.
      IPAR = IPAR_ZPHOT
        if (INISTP_PHOTOZ .EQ. 0.0 ) FLOATPAR(IPAR) = .FALSE.
      IPAR = IPAR_SHAPE
        if (INISTP_SHAPE.EQ. 0.0 ) FLOATPAR(IPAR) = .FALSE.
      IPAR = IPAR_DLMAG
        if (INISTP_DLMAG  .EQ. 0.0 ) FLOATPAR(IPAR) = .FALSE.

      IF ( OPT_TABLE(ITABLE_FITRES) > 0 ) THEN
         CALL TABLE_SNFIT(IDTABLE_FITRES,IFLAG_INI) 
      ENDIF

      IF ( OPT_TABLE(ITABLE_MODELSPEC) > 0 .and. 
     &     FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN    
         CALL TABLE_SNSPEC_SALT2(0)
      ENDIF

      IF ( SALT2_DICTFILE .NE. ' ' ) THEN 
         CALL DMP_DICTFILE(0)  ! init dictFile
      ENDIF

      RETURN
      END  ! end FITPAR_INI2

C ===========================================
+DECK,FITPAR_END.
      SUBROUTINE FITPAR_END(IERR)
c
c User end-routine after all analysis/fits are done. 
c [close files, summarize statistics, global analysis, etc ...]
c -------------------------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,INTERPCM.
 
      INTEGER IERR ! (O) 0 => OK

c local var

      INTEGER LL

C ------------------- BEGIN ---------------------
      IERR = 0

      IF ( N_INTERP_MJDLIST .GT. 0 ) THEN
         CALL DMP_SNMJD_INTERP(-9,0)
      ENDIF

      IF ( OPT_COVAR_LCFIT > 0 ) THEN
        write(6,40) N_SNLC_COVFIX
 40     format(T8,'COV(mB,x1,c)-invertability fixed for ', I6,' events')
      ENDIF

      RETURN
      END

C ==========================================
+DECK,FITPAR_PREP.
      SUBROUTINE FITPAR_PREP ( iter, IERR )
c
c For each "isn" supernova, this user-routine is used to
c initialize global variables used as input to the fitter:
c
c NFITPAR             = number of fit parameters
c PARNAME_STORE(1:NFITPAR)  = name of each parameters (<= 10 bytes)
c INIVAL(1:NFITPAR)   = initial value
c INISTP(1:NFITPAR)   = initial step size (0 => fixed parameter!)
c    
c
c Useful notes:
c
c
c It is highly recommened that the first fit parameter
c is INIVAL(1) = DBLE(ISN)  with INISTP(1) = 0.0
c You will need this index in FCNSNLC to get information
c about a particular SN.
c Another useful init is to set your initial MJD_AT_PEAK equal  to
c SNLC_SEARCH_PEAKMJD(isn) from Masao's LC fitter during the survey.
c
c
c Fill MAG_XTMW_REF(ifilt_obs)  so that  USRFUN
c can make the same approx MilkyWay correction that was
c applied to data.
c
c Aug 28, 2012: remove ISN arg from FITINI_ADJUST call
c Dec 05, 2013: remove ISN arg from subroutine
c ----------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
+CDE,SNLCINP.

      INTEGER 
     &   iter  ! (I) fit iteration: 1,2, ... NFIT_ITERATION
     &  ,IERR  ! (O) 0=> init OK; else skip fit

c local var

      INTEGER
     &    NPAR, ipar
     &  , ifilt, ifilt_obs, ifilt_rest1, ifilt_rest2, ifilt_rest_iter1
     &  , istat, NUSE_FILT, OPT, LL, L2, LCHAR

      INTEGER i, cid, ipar1, ipar2, NPT, h1, h2  ! CONTOUR args

      REAL*8 LAMMIN,LAMMAX, LAMAVG, Z8, Z8TEST, GRAD(MXFITPAR)
      REAL*4 Z4, LMIN4

      CHARACTER CFILT*1, CCID*(MXCHAR_CCID), CTMP*8

      LOGICAL 
     &   USE_FILT_ITER1(MXFILT_ALL)
     &  ,FIRST_ITER, NEXT_ITER, NOMATCH, LAMFAIL, LPRINT

c functions
     
      LOGICAL LFITFUN_FILT, FIRST_ITERATION
      INTEGER NEAREST_IFILT_REST

      REAL*8   USRFUN
      EXTERNAL USRFUN

C ---------- BEGIN -------------

      IERR = 0  ! init to OK
      LPRINT = STDOUT_UPDATE

      FIRST_ITER = FIRST_ITERATION(ITER) .and. (.not. LREPEAT_ITER)

      NEXT_ITER  = ((.not. FIRST_ITER) .and. (ITER > 1)) 
     &            .or. LREPEAT_ITER 

      if ( FIRST_ITER ) NEXT_ITER = .FALSE.

      IF ( FIRST_ITER .and. OPT_FILTER_UPDATE .GT. 0 ) THEN

        IF ( LSED_FITMODEL ) CALL SEDMODEL_INI(1,IERR)

        IF ( LREST_FITMODEL ) THEN
          LL = INDEX(FITMODEL_VERSION,' ') - 1
          C1ERR = 'FILTER_UPDATE  option not implemented for ' //
     &              FITMODEL_VERSION(1:LL)
          C2ERR = '(rest-frame model) that uses K-corrections. Sorry.'
          CALL MADABORT("FITPAR_PREP", c1err, c2err)
        ENDIF

      ENDIF

c init Trest-related variables that are set after fit
      IF ( FIRST_ITER ) THEN
        TRESTMIN_FIT        = -999.
        TRESTMAX_FIT        = -999.
        TRESTRANGE_FIT      = -999.
        NFILT_TRESTMIN_FIT  = -9
        NFILT_TRESTMAX_FIT  = -9
        TGAPMAX_FIT         = -9.0
        T0GAPMAX_FIT        = -9.0

        CALL FITINI_EPVAR(-1)    ! added Jan 1, 2014
      ENDIF 

      LBKSNINFO = .FALSE.

      NFITPAR_MN = IPAR_MAX  ! # MINUIT params includes NFIXPAR

      CCID  = SNLC_CCID
      LCHAR = ISNLC_LENCCID

c print global banner

      IF ( LPRINT ) THEN
        ctmp = ''
        if ( LREPEAT_ITER ) CTMP = '(again)'      
        write(global_banner,400) ITER, CCID(1:LCHAR), CTMP
400     format('FITPAR_PREP: Begin FIT-ITERATION ', I2, 
     &         ' for CID ', A, 3x, A )
        CALL PRBANNER( global_banner(1:68) )
      ENDIF
      
c load redshift to use in spec-z fit

      IF ( SNLC_ZHELIO < 0.0  .and. OPT_PHOTOZ == 0 ) then
         write(6,26) SNLC_CCID(1:LCHAR)
26       format(T5,'Z-WARNING for CID=',A, 
     &      ' : no Z_helio => use ZCMB for lc fit' )
      ENDIF

c ------------------------------
c set global REDSHIFT_FIT to use for things like
c getting rest-frame filters and Trest values.

      CALL SET_REDSHIFT_FIT(iter)

      Z8 = DBLE(REDSHIFT_FIT)
      Z4 = REDSHIFT_FIT       ! ensure 4-byte redshift variable

c ---------------------------------
c set redshift-arg for LFITFUN_FILT (below)
c For photoz fit set Z8TEST=-9 so that z-dependent tests are 
c skipped ; they are applied in PHOTOZ_ANA (after 1st fit) instead.

      Z8TEST = Z8   
      IF ( DOFIT_PHOTOZ ) THEN
        Z8TEST = -9.0

c reset DROPFILTER array in first iteration only
        if ( FIRST_ITER ) then
          DO 220 ifilt_obs = 1,  MXFILT_ALL

            PHOTOZ_ADDFILTER(ifilt_obs)  = .FALSE.
            PHOTOZ_DROPFILTER(ifilt_obs) = .FALSE.

c skip initial DROP-FILTER test if cheat-flag is set
            IF ( DOFIT_PHOTOZ_CHEAT ) GOTO 220 

c check option to exclude certain lambda regions on first
c iteration (default is to ignore UV filters).
c Note that any filters dropped here can get added back before
c 2nd iteration depending on the photoZ-fit value.

            LAMAVG  = FILTOBS_LAMAVG(ifilt_obs) 
            LAMFAIL = LAMAVG .LT. PHOTOZ_ITER1_LAMRANGE(1) 
     &          .or.  LAMAVG .GT. PHOTOZ_ITER1_LAMRANGE(2) 

            if ( LAMFAIL ) then
              PHOTOZ_DROPFILTER(ifilt_obs) = .TRUE.
            endif

220         CONTINUE  ! end of IFILT_OBS
        endif  ! end if FIRST_ITER

      ENDIF  ! end of DOFIT_PHTOOZ

c ---------------------------------
c count how many filters to fit; 
c a fit filter must:
c   -  be specified by the user (DOFIT_FILT) 
c   -  exist in the lightcurve.
c   -  transform to rest-frame lambda within RESTLAMBDA_FITRANGE(2)
c

      NFILT_FIT         = 0
      FILTLIST_FIT_USE  = ''
      NFILT_OBS_USEFIT  = 0
      LAMMIN =  99999.
      LAMMAX = -99999.
      USE_FILT(0)  = .FALSE.       ! for protection against IFILT=0
  
c store USE_FILT array from previous iteration in order
c flag any changes in the 2nd iteration.

      if ( NEXT_ITER ) then
         DO ifilt     = 1, NFILTDEF_SURVEY
            ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
            USE_FILT_ITER1(ifilt_obs) = USE_FILT(ifilt_obs)
         ENDDO
      endif

      DO ifilt     = 1, NFILTDEF_SURVEY
         
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         cfilt     = filtdef_string(ifilt_obs:ifilt_obs)

c set USE_FILT based on user-request, existence,
c and valid rest-frame filter.

         USE_FILT(ifilt_obs) = 
     &      LFITFUN_FILT(ifilt_obs,Z8TEST)

         NOMATCH  = 
     &     USE_FILT_ITER1(ifilt_obs) .NEQV. USE_FILT(ifilt_obs) 

c print message if observer-filter is dropped or added on 2nd iteration
         if ( NEXT_ITER .and. NOMATCH ) THEN

             if ( USE_FILT_ITER1(ifilt_obs) ) then
                write(6,24) CCID(1:LCHAR), 'DROPPED', cfilt
             else
                write(6,24) CCID(1:LCHAR), 'ADDED', cfilt
             endif
24           format(T10,'WARNING for SN ',A,' : ',
     &            A,' obs-filter=', A )
         endif

         if ( USE_FILT(ifilt_obs) ) then

            NFILT_FIT = NFILT_FIT + 1
            MAG_XTMW_REF(ifilt_obs) = SNLC_MWXT_MAG(ifilt)

            LAMAVG = FILTOBS_LAMAVG(ifilt_obs)
            IF ( LAMAVG .LT. LAMMIN ) then
               LAMMIN = LAMAVG 
            ENDIF

            IF ( LAMAVG .GT. LAMMAX ) then
               LAMMAX = LAMAVG 
            ENDIF

            LL = INDEX ( FILTLIST_FIT_USE, ' ' ) - 1
            FILTLIST_FIT_USE = FILTLIST_FIT_USE(1:LL) // cfilt
            NFILT_OBS_USEFIT = NFILT_OBS_USEFIT + 1

            if ( LREST_FITMODEL ) then
              OPT = OPT_FILTOBS
              IFILT_REST_MAP(ifilt) = 
     &         NEAREST_IFILT_REST(OPT,ifilt_obs, 1, Z4, LMIN4)
            endif

         endif

      ENDDO
 
c set range of observer filters to evaluate for each obs filter.
c This is needed for the color transformation and for U -> U-BX+B

      CALL SET_IFILT_OBS(LPRINT)

      IF ( NFILT_FIT .EQ. 0 ) THEN
         print*,' '
         print*,' FITPAR_PREP WARNING for CID ', SNLC_CCID
         print*,'   Found no valid observer frame filters to fit.'
         print*,'   '
         IERR = ERRFLAG_FITPREP_NOFILTERS
         RETURN
      ENDIF

c init EP_XXX arrays ( before calling FITINI_ADJUST)
      CALL FITINI_EPVAR(iter)

c set INIVAL and INISTP arrays.
      CALL FITINI_PARVAL(iter)

c init linear FITCOV arrays
      OPT = 1  ! bit 1 => print info to stdout
      CALL FITINI_COV(OPT, ITER, FITVAL(1,ITER-1), IERR)
      IF ( IERR .NE. 0 ) RETURN

c check for photoZ fit (after FITINI_COV)
      IF ( DOFIT_PHOTOZ ) CALL FITINI_PHOTOZ(iter)

c adjust fitpar based on initial Fdata/Fmodel ratios.
      CALL FITINI_ADJUST(iter)

c Apr 29 2022: check 1st iter override from SNCID_LIST_FILE
      CALL FITINI_LIST_FILE(iter)

      IF ( LREST_FITMODEL .and. ITER .EQ. NFIT_ITERATION ) THEN 
        CALL FITINI_PRKCOR()   ! print Kcor info
      ENDIF

c check option to fix all parameters in fit

      IF ( LFIXPAR_ALL .or. LFIXPAR_ADJUST ) THEN
        DO ipar = 1, NFITPAR_MN
           INISTP(ipar)  = 0.0 
        ENDDO
      ENDIF

c Check for contour plots with namelist array CONTOUR_LIST
c Contour plots are initialized for each SN before MINUIT is run.

      IF ( ITER .EQ. NFIT_ITERATION ) THEN
        DO i = 1, 20
           CID   = CONTOUR_LIST(1,i)
           ipar1 = CONTOUR_LIST(2,i)
           ipar2 = CONTOUR_LIST(3,i)
           NPT   = CONTOUR_LIST(4,i)

           h1 = 20000 + i*10  ! histograms go into subdir for each SN
           h2 = h1 + 1
           if ( CID .EQ. SNLC_CID ) then
              CALL BOOK_CONTOUR(h1,h2, NPT, IPAR1, IPAR2 )
           endif
        END DO

      ENDIF

c ---------------
      CALL FLUSH(6)

      RETURN
      END   ! end of FITPAR_PREP


C =====================================
+DECK,FITINI_EPVAR.
      SUBROUTINE FITINI_EPVAR(ITER)
      IMPLICIT NONE

c init R4 and I4 arrays

      INTEGER ITER  ! (I) SN index and iteraion

c local var

+CDE,SNPAR.
cc +CDE,SNDATCOM.
cc +CDE,SNLCINP.
+CDE,SNFITCOM.

      INTEGER  epoch, ifilt, i, ep, ivar

c ----------- BEGIN -------------

      IF ( ITER < 0 ) THEN
         DO ep = 1, MXFIT_DATA

            DO ivar = 1, MXVAR_R4
               R4EP_ALL(ep,ivar)  = NULLVAL
               R4EP_FIT(ep,ivar)  = NULLVAL
               R4EP_LAST(ep,ivar) = NULLVAL
            ENDDO
            DO ivar = 1, MXVAR_I4
               I4EP_ALL(ep,ivar) = -999
               I4EP_FIT(ep,ivar) = -999
            ENDDO
            BANDEP_ALL(ep) = ''
            BANDEP_FIT(ep) = ''
         ENDDO
      ENDIF


c init scalars
      R4SN_TEARLY       = +999
      R4SN_TLATE        = -999.
      R4SN_MJDmin       = +6E8
      R4SN_MJDmax       = -6E8
      R4SN_FFSUM_DATA   = NULLVAL
      R4SN_FFSUM_MODEL  = NULLVAL
      R4SN_FFSUM_CROSS  = NULLVAL
      R4SN_FFSUM_WGT    = NULLVAL
      R4SN_FFSUM_RATIO  = NULLVAL

c init filter-dependent variables.

      DO ifilt = 1, MXFILT_ALL
           PEAKMAG_OBS_MODEL(ifilt)           = NULLVAL
           PEAKMAG_OBS_MODEL_ERR(ifilt)       = 0.0
           PEAKMAG_REST_MODEL(ifilt)          = NULLVAL
           PEAKMAG_REST_MODEL_ERR(ifilt)      = 0.0
           PEAKFLUX_OBS_MODEL(ifilt)          = NULLVAL
           PEAKFLUX_OBS_MODEL_ERR(ifilt)      = 0.0
           PEAKFLUX_OBS_MODEL_COR(ifilt)      = 1.
           PEAK_KCOR_MODEL(ifilt)             = 0.0

           R4BAND_SNRMAX_FIT(ifilt)     = -99.
           R4BAND_SNRMAX_RAW(ifilt)     = NULLVAL          
           R4BAND_TREST_NEARPEAK(ifilt) = -999.
           R4BAND_XTMW_NEARPEAK(ifilt)  = NULLVAL

           if ( ifilt .LE. MXFILT_OBS ) then
              FCN_FITCHI2(ifilt)    = 0.0
           endif
      ENDDO

      RETURN
      END     ! end of FITINI_EPVAR


C ===================================================
+DECK,FITPAR_ANA.
      SUBROUTINE FITPAR_ANA ( isn, iter, ERRFLAG )
c
c User-routine to analyze fit results after each SN.
c Includes incrementing histograms, statistics, etc ...
c
c Fit results are in
c
c   FITPAR(1:NFITPAR)
c   FITERR(1:NFITERR)
c
c Recommend making (REAL*8) equivalence to local
c variables with more appropriate names.
c
c Returns ERRFLAG as follows:
c  =  0 => OK; keep SN
c  = >0 => discard fit (call CDTOPDIR)
c  = -1 => decrement ITER and try again (e.g., for photoZ spike) 
c
c
c
c Oct 26 2015: remove obsolete ISN arg from FITANA_STORE.
c
c Jan 04 2016: if MNSTAT_COV<3 (bad cov matric), set ERRFLAG=-1
c              to fit again
c
c July 27 2017: for photo-z fit, set SNLD_zHD=zPHOT
c
c Oct 24 2017: 
c   move MAKEDIR_OUTPUT() call down inside DOLC_PLOT if-block.
c   Pass FALSE DOPLOT-flag to FITANA_MARGE since the subDir
c   no longer exists when FITANA_MARG is called.
c   This fixes problem of having empty subDir for each
c   SN that passes SNANA cuts but fails FIT cuts.
c
c Jun 21 2018: 
c   check CRAZYFITERR on every iteration to check for NaN
c
c Feb 28 2020:
c   set ERRFLAG = -1 (repeat iter) if both ITER1_MAXFRAC and 
c   DELCHI2_REJECT are set. Fixes long-standing bug.
c
c Aug 28 2020: if ERRFLAG=0 then set CUTFLAG_SNANA += 2 so that
c              correct CUTFLAG_SNANA shows up in FITRES table.
c
c May 18 2021: skip crazyflux check of OPT_SNCID_LIST > 0
c
c --------------------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,INTERPCM.
+CDE,VMAXCOM.

      INTEGER 
     &   isn   ! (I) sparse SN index 
     &  ,iter  ! (I) fit iteration: 1,2, ... NFIT_ITERATION
     &  ,ERRFLAG  ! (O) 

c local var

      INTEGER 
     &   IFILT, IFILT_OBS, CID, LCID, IERR, NFIT_PLOT
     &  ,OPT, hid, i, IERR_MARG

      LOGICAL DOLC_PLOT, LFITOK,  FIRST, LAST, DO_REFIT
      LOGICAL LMAXFRAC, LCHI2REJ, CRAZY
      REAL FRACERRDIF
      character sdir*20, chis*40, ccid*(MXCHAR_CCID)

c function
      LOGICAL CRAZYFITERR, DOPLOT_SNLC

C -------------------- BEGIN ---------------

      ERRFLAG  = 0   ! init output to "accept"
      LAST     = ITER .EQ. NFIT_ITERATION
      FIRST    = ITER .EQ. 1

      CID   = SNLC_CID
      CCID  = SNLC_CCID      
      LCID  = ISNLC_LENCCID
      
c transfer I4/R4EP_ALL arrays to sparse I4/R4EP_FIT arrays (Jan 25 2014)
      CALL LOAD_EPFIT()

c for photoz fit, check for repeat iteration or discard fit 
      IF ( DOFIT_PHOTOZ ) THEN
         CALL PHOTOZ_ANA(1,iter,ERRFLAG)  
         IF ( LAST ) THEN
            CALL SET_ZHD_PHOTOZ()
            IF ( ERRFLAG > 0 ) RETURN
         ENDIF
      ENDIF

c --------------------------------------------
c Jan 2016: fit iteration again if cov matrix has not converged

      DO_REFIT =
     &     OPT_MNSTAT_COV > 0 .and.  ! user option
     &     LAST               .and.  ! last fit iteration
     &     MNSTAT_COV < 3     .and.  ! MINUIT status
     &     (.not. LREPEAT_ITER)      ! not already repeating

      IF ( DO_REFIT ) THEN
         write(6,46) MNSTAT_COV, CCID
46       format(T5,'Bad COV matrix (MNSTAT_COV=',I2,') ' 
     &              '-> repeat fit for CID=',A12 )
         ERRFLAG = ERRFLAG_REPEAT_ITER  ! -1
         RETURN
      ENDIF

c --------------------------------------------
c May 2018 check option to repeat entire fit with MINOS
  
      FRACERRDIF = LCFRACERRDIF_STORE(IPAR_COLOR)
      DO_REFIT =
     &    LAST                  .and.  ! last fit iteration
     &    (.NOT. LREPEAT_MINOS) .and. 
     &    ABS(FRACERRDIF) > FRACERRDIF_REPEATFIT  ! large cERR change
     &   
      IF ( DO_REFIT ) THEN
         write(6,48) FRACERRDIF, CCID(1:12)
 48      format(T5,'Unstable c-error: cFRACERRDIF=',F6.2,
     &              '-> repeat fit with MINOS, CID=',A12 )
         ERRFLAG = ERRFLAG_REPEAT_MINOS  ! -2
         RETURN
      ENDIF

c set default of NFIT=1 to plot (before calling FITRESTMAG or FITMAGDIF)
c This call is not needed, but avoids confusion with NFIT=0 inside the
c sntools_output routines.
      IF ( ITER .EQ. 1 ) THEN
        CALL SNLCPAK_NFIT(1)   ! 5/01/2014
      ENDIF

c check optional rest-mag  (Feb 2012)
      CALL FITRESTMAG_CALC(ITER)

c check optional magdif test (Mar 2013)
      CALL FITMAGDIF_CALC(ITER)

c check optional IDEAL fit with FLUX=TRUEFLUX (Aug 2017)
      CALL SIMFIT_IDEAL_CALC(ITER)


c -------------------------------------------------
c check for crazy errors, unless:
c   + plotchi2-debugger is on, or
c   + OPT_SNCID_LIST is set

      CRAZY = CRAZYFITERR(isn,iter) .and. 
     &    (.not. LPLOTCHI2 .and. OPT_SNCID_LIST==0)

      IF ( CRAZY ) THEN
        write(6,222) CCID(1:LCID)
222     format(T15,'CRAZY ERROR for CID=', A,' ==> SKIP ' )
        ERRFLAG = ERRFLAG_FIT_CRAZYERR
        RETURN 
      ENDIF

c ---------------------------------------
      IF ( ITER < NFIT_ITERATION ) RETURN

c ----- BELOW IS LAST ITERATION -------

c check for special variable computation for SIMSED models;
      CALL SIMSED_RECON()

c if not photo-z fit, increase color error to account for z-error.
cc xxx mark delete      CALL ADD_FITPARERR_FROMz()

c ------------------------------------------------------
c compute SIMCHI2 on last iteration 

cc      IF ( LSIM_SNANA .and. LAST ) then  
cc 4.22.2019: disable because of problem with wrong host redshift
cc         CALL GET_SIMCHI2_CHEAT()  
cc      ENDIF

c -------------------------------------------------
      DOLC_PLOT = DOPLOT_SNLC()

c ---------------------------------------
c check option to marginalize 

      if ( LTRACE ) CALL DMPTRACE("CALLING FITANA_MARG")

      CALL FITANA_MARG(ISN, .FALSE., IERR_MARG) 
      IF ( IERR_MARG > 0 ) THEN
         ERRFLAG = ERRFLAG_FIT_MARGINALIZE
         GOTO 333
         RETURN          ! discard fit
      ENDIF

c ---------------------------------------
c store fit results for plotting

      if ( LTRACE ) CALL DMPTRACE("CALLING FITANA_STORE")

      CALL FITANA_STORE()

c ---------------------------------------
c Use fitted flux to update ERROR CALC from ZPT,PSF and SKY

      if ( LTRACE ) CALL DMPTRACE("CALLING UPD_FLUXERRCALC")
      CALL UPD_FLUXERRCALC()

c -------------------------------
c Nov 2018: Check option to fix non-invertible COV(mB,x1,c)
      CALL FIX_COVAR_LCFIT()

c ----------------------
c check option to compute Zmax for 1/Vmax method 
c (after FITANA_STORE ad before SNTABLE calls)
      do i = 1, NFILT_VMAX
         CALL VMAX_ANA(i)
      enddo

c ----------------------------------------
c on last iteration, check if fit is OK

      if ( LTRACE ) CALL DMPTRACE("CALLING FITANA_CUTS")
      CALL FITANA_CUTS(isn,LFITOK)    ! returns LFITOK
      IF ( .NOT. LFITOK ) THEN
         ERRFLAG = ERRFLAG_FIT_CUTS
         GOTO 333
      ENDIF

      if ( LTRACE ) CALL DMPTRACE("CALLING FITANA_SUMMARY")

      CALL FITANA_SUMMARY(isn) 

 333  CONTINUE  

      IF ( ERRFLAG .NE. 0 ) THEN
c back to topdir
          CALL CDTOPDIR_OUTPUT()
          RETURN
      ENDIF

c - - - - - - - 
c Aug 28 2020: if we get here, set CUTFLAG_SNANA bit for fit success.
      CUTFLAG_SNANA  = IBSET(CUTFLAG_SNANA,1) ! for SNANA tree

c ---------------------------------------------------------
c book plots for this SN; all plots are vs. relative epoch

      IF ( DOLC_PLOT ) THEN

         CCID = SNLC_CCID(1:LCID) // char(0)
         CALL MAKEDIR_OUTPUT(CCID,SNLC_CID,LCID)

        if ( LTRACE ) CALL DMPTRACE("inside DOLC_PLOT if-block")

        CALL SNLCPLOT()

        IF ( LPLOTCHI2 ) CALL HFUNMIN()    ! plot fun near minium

        CALL CDTOPDIR_OUTPUT()  ! back to topdir

      ENDIF

c ---------------------------------
c check for NN-analysis (Apr 2014) after CDTOPDIR_OUTPUT
      IF ( NVAR_NEARNBR > 0 ) CALL FITPAR_NEARNBR_APPLY()

c check tables to fill
      IF ( OPT_TABLE(ITABLE_FITRES) > 0 ) THEN
          CALL PREP_FITRES_TABLEVAR()
          CALL TABLE_SNFIT(IDTABLE_FITRES,IFLAG_ANA)
      ENDIF

      IF ( OPT_TABLE(ITABLE_MODELSPEC) > 0 .and. 
     &     FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN    
         CALL TABLE_SNSPEC_SALT2(isn)
      ENDIF


      IF ( SALT2_DICTFILE .NE. ' ' ) THEN
         CALL DMP_DICTFILE(1)
      ENDIF

c check for single-epoch dump of FLUX & MAG at specified MJD
c See input namelist "SNMJD_LIST_FILE"

      IF ( N_INTERP_MJDLIST > 0 ) THEN
        CALL DMP_SNMJD_INTERP(1,1)  ! evaluate at MJD from LIST file
        CALL DMP_SNMJD_INTERP(1,0)  ! evaluate at PEAK
      ENDIF

      RETURN
      END      ! end of FITPAR_ANA

C ================================================
+DECK,CRAZYFITERR.
      LOGICAL FUNCTION CRAZYFITERR(isn,iter)

c Returns TRUE if a crazy fit error is identified.
c Jan 28 2020: check for crazy-small errors too, only if floated.

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,SNFITCOM.
+CDE,FILTCOM.

      INTEGER ISN, ITER ! (I) ! SN index & fit-iteration
      REAL ERR_COLOR, ERR_SHAPE, ERR_DIST, ERR_PKMJD
      LOGICAL LNAN, FLOAT_COLOR, FLOAT_SHAPE, FLOAT_DIST, FLOAT_PKMJD

C --------------- BEGIN ----------------

      CRAZYFITERR = .FALSE.

      ERR_COLOR =  FITERR(IPAR_COLOR,ITER)
      ERR_SHAPE =  FITERR(IPAR_SHAPE,ITER)  
      ERR_DIST  =  FITERR(IPAR_DLMAG,ITER)  
      ERR_PKMJD =  FITERR(IPAR_PEAKMJD,ITER)

      FLOAT_COLOR = FLOATPAR(IPAR_COLOR)
      FLOAT_SHAPE = FLOATPAR(IPAR_SHAPE)
      FLOAT_DIST  = FLOATPAR(IPAR_DLMAG)
      FLOAT_PKMJD = FLOATPAR(IPAR_PEAKMJD)

c xxxxxxxxxxxxxxxxxxx
c      print*, ' xxx '
c      print*, ' xxx -------- CRAZYFITERR iter=', iter
c      print*, ' xxx ERR(c,s,d,t0) = ',
c     &     ERR_COLOR, ERR_SHAPE, ERR_DIST, ERR_PKMJD
c xxxxxxxxxxxxxxxxxxx
      
c if we are fitting only 1 filter, then don't bother
c checking crazy error

      if ( .NOT. CHECK_CRAZYFITERR ) then
         RETURN
      endif

c check for NaN on every fit iteration
      LNAN = .FALSE.
      if ( ISNAN(ERR_COLOR) ) LNAN = .TRUE.
      if ( ISNAN(ERR_SHAPE) ) LNAN = .TRUE.
      if ( ISNAN(ERR_DIST)  ) LNAN = .TRUE.
      if ( ISNAN(ERR_PKMJD) ) LNAN = .TRUE.

      IF ( LNAN ) THEN
         CRAZYFITERR = .TRUE. 
         RETURN
      ENDIF

c don't do any more until last iteration
      IF ( ITER < NFIT_ITERATION ) THEN
         RETURN         
      ENDIF

c ------------------------
c last fit iteration

      CRAZYFITERR = .TRUE.
      IF ( FLOAT_COLOR ) THEN
        IF ( ERR_COLOR > 3.0  .or. ERR_COLOR < 1.0E-8  ) RETURN
      ENDIF

      IF ( FLOAT_SHAPE ) THEN
        IF ( ERR_SHAPE > 3.0  .or. ERR_SHAPE < 1.0E-8  ) RETURN
      ENDIF

      IF ( FLOAT_DIST ) THEN
        IF ( ERR_DIST  > 3.0  .or. ERR_DIST  < 1.0E-15 ) RETURN
      ENDIF

      IF ( FLOAT_PKMJD ) THEN
        IF ( ERR_PKMJD > 10.0 .or. ERR_PKMJD < 1.0E-8  ) RETURN
      ENDIF

      CRAZYFITERR = .FALSE.

      RETURN
      END

C =====================================
+DECK,FIRST_ITERATION.
      LOGICAL FUNCTION FIRST_ITERATION(ITER)

C Created Aug 2017
C Return TRUE on first iteration of fit.
C Normally this is when ITER=1, but with some exceptions
C involving mutliple/repeat fits

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,FITIDEALCOM.

      INTEGER ITER
C ---------------- BEGIN ---------------

      FIRST_ITERATION = (ITER .EQ. 1) ! .and. (.not. LREPEAT_ITER)

      IF ( DOFIT_IDEAL .and. ITER.EQ.NFIT_ITERATION_ORIG+1 ) then
         FIRST_ITERATION = .TRUE.
      ENDIF

      RETURN
      END


C ===============================
+DECK,ADD_FITPARERR_FROMz.
      SUBROUTINE ADD_FITPARERR_FROMz(ITER)
c
c ****** BAD IDEA ... MARK DELETE *****
c
c Created Jun 30 2020
c If not photo-z fit, estimate color error from redshift error
c and increment fitted color error. Make sure to remove incorrect
c (du/dz)*zerr from Hubble fit error (e.g., BBC)

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,SNFITCOM.

      INTEGER ITER ! (I) iteration

c local var
      REAL*8  CHI2, CHI2MIN, VAL(MXFITPAR), GRAD(MXFITPAR)
      REAL*8  CHI2_REF, z_REF, z_PLUSERR, MU_REF, MU_PLUSERR
      REAL*8  c_REF, c_tmp, c_dif, cmax_dif, c_bin, c_atMIN
      REAL*8  c_err, c_err_add, c_err_ref
      INTEGER IFLAG, ipar, ic, NBINc, ic_atMIN
      LOGICAL LDMP

c functions
      REAL*8   USRFUN, DLMAG8_REF
      EXTERNAL USRFUN
C ----------- BEGIN ------------

      IF ( .NOT. ADD_SALT2ERR_FROMz )        RETURN
      IF ( OPT_PHOTOZ > 0           )        RETURN
      IF ( FITMODEL_INDEX .NE. MODEL_SALT2 ) RETURN
      IF ( ITER < NFIT_ITERATION )           RETURN

cc      LDMP = .TRUE.
      LDMP = .FALSE.

      DO IPAR = 1, NFITPAR_MN 
         VAL(ipar)  = FITVAL(ipar,ITER) ;    GRAD(ipar) = 0.0 
      ENDDO
c if we get here, fit model is SALT2 and redshift was fixed in fit.

      IFLAG     = FCNFLAG_USER       ! flag for FCNSNLC
      c_REF     = VAL(IPAR_COLOR)
      z_REF     = VAL(IPAR_zPHOT)
      z_PLUSERR = z_REF + SNLC_REDSHIFT_ERR
      MU_REF      = DLMAG8_REF(z_REF)
      MU_PLUSERR  = DLMAG8_REF(z_PLUSERR)
      CALL FCNSNLC(NFITPAR_MN, GRAD, CHI2_REF, VAL, IFLAG, USRFUN)

      cmax_dif = 0.6 * (MU_PLUSERR - MU_REF)/SALT2beta
      NBINc    = 20
      c_bin    = cmax_dif / dble(NBINc)

      if ( LDMP ) then
        print*,' xxx -------- DUMP ADD_FITPARERR_FROMz ----------- '
        print*,' xxx CCID     = ', SNLC_CCID(1:10), '   ITER=',ITER
        print*,' xxx z_REF    = ', sngl(z_REF), 
     &             ' +_ ', SNLC_REDSHIFT_ERR
        print*,' xxx c_REF    = ', sngl(c_REF)        
        print*,' xxx CHI2_REF = ', sngl(CHI2_REF)
        print*,' xxx MU       = ', SNGL(MU_REF),' -> ', SNGL(MU_PLUSERR)
        print*,' xxx cmax_dif = ', sngl(cmax_dif)
        print*,' xxx c_bin    = ', sngl(c_bin)
        print*,' xxx NBINc    = ', NBINc
      endif

      VAL(IPAR_zPHOT) = z_PLUSERR
      CHI2MIN = 1.0E9
      c_atMIN = 999. ; ic_atMIN = -9
      DO 100 ic = 1, NBINc
         c_dif = -c_bin * dble(ic)
         c_tmp = c_REF + c_dif
         VAL(IPAR_COLOR) = c_tmp
         CALL FCNSNLC(NFITPAR_MN, GRAD, CHI2, VAL, IFLAG, USRFUN)
         if ( CHI2 < CHI2MIN ) then
            CHI2MIN = CHI2
            c_atMIN = c_tmp
            ic_atMIN = ic
         endif
         if ( LDMP ) then
            write(6,44) c_dif, chi2
 44         format(' xxx c_dif = ', F8.4, ' -> CHI2 = ', F9.2 )
            call flush(6)
         endif
 100  CONTINUE

c update fit color error (plus & minus) to include redshift uncertainty
      c_err_add = abs(c_atmin - c_ref) 

      c_err_ref = FITERR_PLUS(IPAR_COLOR,ITER)
      c_err     = sqrt(c_err_add**2 + c_err_ref**2)
      FITERR_PLUS(IPAR_COLOR,ITER)  = c_err

      c_err_ref = FITERR_MINUS(IPAR_COLOR,ITER)
      c_err     = sqrt(c_err_add**2 + c_err_ref**2)
      FITERR_MINUS(IPAR_COLOR,ITER)  = -c_err

      if ( LDMP ) then
         print*,' xxx c_err_add = ', SNGL(c_err_add)
         print*,' xxx c_err(-) = ', sngl(c_err_ref),' -> ', sngl(c_err)
      endif

c print warning if min c is at edge of grid
      if ( ic_atMIN == 1 .or. ic_atMIN == NBINc ) then
         write(6,660) SNLC_CCID(1:ISNLC_LENCCID), ic_atMIN, NBINc
 660     format(' WARNING(',A,'): min ic=',I2,'/', I2,
     &       'c_err(ADD) = ', F6.2 )
      endif

c restore best-fit values
      VAL(IPAR_zPHOT) = z_REF
      VAL(IPAR_COLOR) = c_REF

      RETURN
      END
C ===============================
+DECK,SIMSED_RECON.
      SUBROUTINE SIMSED_RECON()

c Created Jun 28, 2012
c If SIMSED model has parameters S2c and S2x1,
c compute SIMMB and SIMx0. 
c Beware that ALPHA and BETA are hard-wired.
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNFITINP.

      INTEGER IPAR, IPARx1, IPARc
      REAL S2x1, S2c, S2x0, S2x0inv, arg

C --------------- BEGIN ------------

      IF ( .NOT. LSIM_SNANA   ) RETURN
      IF ( NPAR_SIMSED .LE. 0 ) RETURN

c for SIMSED model with S2x1 and S2c, 
c compute SIM_SALT2mb and SIM_SALT2x0

      IPARx1 = -9
      IPARc  = -9
      DO 100 ipar = 1, NPAR_SIMSED
        if ( SIMSED_PARNAME(IPAR)(1:4) .EQ. 'S2x1' ) then
            IPARx1 = IPAR
        endif
        if ( SIMSED_PARNAME(IPAR)(1:3) .EQ. 'S2c' ) then
            IPARc = IPAR
        endif      
100   CONTINUE

      IF ( IPARx1 .GT. 0 .and. IPARc .GT. 0 ) THEN
         S2c  = SIMSED_PARVAL(IPARc)
         S2x1 = SIMSED_PARVAL(IPARx1)
         arg       = ( SIM_DLMAG - SALT2alpha*S2x1 + SALT2beta*S2c ) ;
         S2x0inv   = 1.0E-12 * (10.0**(0.4*arg) )
         S2x0      = 1./S2x0inv ;
         SIM_SALT2mB = 10.635 - 2.5*log10(S2x0);
         SIM_SALT2x0 = S2x0
      ENDIF

      RETURN
      END

C ======================================
+DECK,FIX_COVAR_LCFIT.
      SUBROUTINE FIX_COVAR_LCFIT()

c Nov 2018
c Check option to fix COV(mB,x1,c) if not invertible.
c Use algorithm for Marriner 2011 (SALT2mu code),
c which is update_covMatrix() function in sntools.c
c
c Uses &FITINP OPT_COVAR_LCFIT mask, with mask options
c defined below as parameters.
c
c There are two options here to fix COV to ensure invertibility:
c 1. M11 (Marriner 2011): 
c    Diagonal COV is ERROR^2, and off-diag is from Minuit's MNEMAT
c    Beware that MNEMAT diagonals correpond to parabolic error,
c    not MINOS error.
c
c 2. RED: use reduced covariance from MNEMAT and MINOS errors to
c    to construct COV matrix.
c
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNANAFIT.
c +CDE,SNLCINP.
+CDE,SNFITCOM.
+CDE,FILTCOM.

      INTEGER 
     &   OPTMASK_COVAR_FIXCOV_M11  ! fix non-invertible COV as in Marriner11
     &  ,OPTMASK_COVAR_FIXCOV_RED  ! fix COV using reduced FITERRMAT
     &  ,OPTMASK_COVAR_DUMPROW     ! one-row dump for each fix
     &  ,OPTMASK_COVAR_DUMPFULL    ! dump COV(old) -> COV(fix)
      PARAMETER ( 
     &   OPTMASK_COVAR_FIXCOV_M11 =   1
     &  ,OPTMASK_COVAR_FIXCOV_RED =   2
     &  ,OPTMASK_COVAR_DUMPROW    = 128 
     &  ,OPTMASK_COVAR_DUMPFULL   = 256
     &     )

      CHARACTER NAME*20
      LOGICAL  L_VALID, L_UPD
      INTEGER  FIXCOV_M11, FIXCOV_RED, LDMP1, LDMP2
      INTEGER  OPT, OPTMASK, IPAR, IPAR2, NPAR, IERR, LENCCID, i,j
      INTEGER  IPAR_LIST(10)
      REAL*8   COV_ORIG(3,3), COV_UPD(3,3), X0JACOB(3,3)
      REAL*8   MBERR, X0, X0ERR, COV_TMP, ERR_TMP, ERR2_TMP,SF,EIGMIN
      REAL*8   COV_MN, COR_MN
      EXTERNAL UPDATE_COVMATRIX

C -------------- BEGIN --------------

      IF ( OPT_COVAR_LCFIT == 0 ) RETURN

      OPT = OPT_COVAR_LCFIT
      FIXCOV_M11 = IAND ( OPT, OPTMASK_COVAR_FIXCOV_M11 )
      FIXCOV_RED = IAND ( OPT, OPTMASK_COVAR_FIXCOV_RED )
      LDMP1      = IAND ( OPT, OPTMASK_COVAR_DUMPROW    )
      LDMP2      = IAND ( OPT, OPTMASK_COVAR_DUMPFULL   )

      L_VALID = .FALSE.
      if ( FIXCOV_M11 > 0 ) L_VALID = .TRUE.
      if ( FIXCOV_RED > 0 ) L_VALID = .TRUE.

      if ( .NOT. L_VALID ) then
         write(C1ERR,66) OPT_COVAR_LCFIT
 66      format('Invalid &FITINP  OPT_COVAR_LCFIT = ', I8 )
         C2ERR = 'Check bit-options in subroutine FIX_COVAR_LCFIT'
         CALL MADABORT("FIX_COVAR_LCFIT", C1ERR, C2ERR)
      endif

c load list of fit-param IPAR used to construct local COV
      NPAR = 3
      IPAR_LIST(1) = IPAR_X0
      IPAR_LIST(2) = IPAR_SHAPE
      IPAR_LIST(3) = IPAR_COLOR

c define jacobian factor for x0err
      X0    = LCVAL_STORE(IPAR_X0)
      SF    = -2.5/(x0*LOGTEN)
       
c set diagonal COV using stored errors ; don't use diagonal FITERRMAT
c since it's not necessarily ERR^2.

      DO i = 1, NPAR
         IPAR    = IPAR_LIST(i)
         ERR_TMP = LCERR_STORE(IPAR)
         do j = 1, NPAR
            IPAR2 = IPAR_LIST(j)
            ERR2_TMP = LCERR_STORE(IPAR2)
            X0JACOB(i,j) = 1.0
            COV_MN       = FITERRMAT(IPAR,IPAR2) ! minuit COV
            COR_MN       = FITCORMAT(IPAR,IPAR2) ! minuit reduced corr
            if ( IPAR  == IPAR_X0 ) X0JACOB(i,j) = X0JACOB(i,j)*SF
            if ( IPAR2 == IPAR_X0 ) X0JACOB(i,j) = X0JACOB(i,j)*SF

            if ( i == j ) then
               COV_ORIG(i,i) = (ERR_TMP * ERR_TMP) 
            else
               if ( FIXCOV_M11 > 0 ) then
                  COV_ORIG(i,j) = COV_MN
               else
                  COV_ORIG(i,j) = (ERR_TMP*ERR2_TMP) * COR_MN
               endif
            endif
            COV_ORIG(i,j) = COV_ORIG(i,j)*X0JACOB(i,j)
            COV_UPD(i,j)  = COV_ORIG(i,j)
         enddo
      ENDDO


c ----------------------------------
c prepare arguments for update_covmatrix

      LENCCID = INDEX(SNLC_CCID,' ') - 1
      NAME    = SNLC_CCID(1:LENCCID) // char(0)
      OPTMASK = 0
      if ( LDMP2>0 ) OPTMASK = 4   ! 1=abort on bad COV,  4=dump
      EIGMIN  = 0.0001

cc      print*,' xxx LDMP(1,2) = ', LDMP1, LDMP2, OPTMASK

      call update_covmatrix(NAME, OPTMASK, NPAR, COV_UPD, EIGMIN, 
     &           IERR, LENCCID)

      L_UPD = ( (IERR .NE. 0) .or. FIXCOV_RED>0 )
      if ( L_UPD ) then
         N_SNLC_COVFIX = N_SNLC_COVFIX + 1

         DO i = 1, 3
            IPAR = IPAR_LIST(i)

            DO j = 1, 3
               IPAR2 = IPAR_LIST(j)
               COV_TMP = COV_UPD(i,j)
               if ( i == j ) then
                  LCERR_STORE(IPAR) = sqrt(COV_TMP/X0JACOB(i,i))
               else
                  FITERRMAT(IPAR,IPAR2) = COV_TMP/X0JACOB(i,j)
               endif
            ENDDO
         ENDDO         

c update MBERR based on updated x0ERR
         X0ERR = LCERR_STORE(IPAR_X0) 
         MBERR = X0ERR * abs(SF)
         LCERR_STORE(IPAR_MB) = MBERR
      ENDIF

c --- check dump options ----

      if ( LDMP1>0 .and. L_UPD ) then
         write(6,20) SNLC_CCID(1:12)
 20      format(T8,'Fix COV(mB,x1,c) for CID ', A)
      endif

      RETURN
      END

C ======================================
+DECK,UPDECALC.
      SUBROUTINE UPD_FLUXERRCALC()

c Feb 24, 2012
c Loop over fitted epochs and call FLUXERRCALC
c with fitted flux rather than the FLUXCAL from
c the data file.
c
c Nov 27, 2012: remove ISN argument from subroutine and from
c                FLUXERRCALC call.
c
c -------------------------

      IMPLICIT NONE

+CDE,SNDATCOM. 

c +CDE,SNANAFIT.
c +CDE,SNLCINP.
+CDE,SNFITCOM.
+CDE,FILTCOM.

      INTEGER IFITDATA, iep, imjd, ifilt
      REAL    FLUXCAL, FLUXCAL_ERR

C -------------- BEGIN -------------

      IF ( .NOT. DO_FLUXERRCALC ) RETURN

      DO 200 ifitdata  = 1, NFITDATA 
         iep           = EPLIST_FIT(ifitdata)
         FLUXCAL       = R4EP_ALL(iep,JEP_MODELFLUX)
         FLUXCAL_ERR   = R4EP_ALL(iep,JEP_DATAFLUX_ERR)
         CALL FLUXERRCALC(iep, FLUXCAL, FLUXCAL_ERR)

200   CONTINUE
      RETURN
      END

C ==================================
+DECK,SETCUTTR.
      SUBROUTINE SETCUTS_FITWIN_TREST

c Jan 2012
c By default set each FITWIN_TREST_FILT = global FITWIN_TREST
c Then check user-namelist strings FITWIN_TREST_FILTER
c for tighter TREST-windows. 
c
c Initial use is to limit the SNACC-filter Trest-range
c because the FUDGE_FITERR options allow downweighting
c but not removing epochs. The FITWIN_TREST_FILTER option
c allow removing epochs in specific filters.
c
c May 26, 2012: 
c  fix aweful bug. First do-loop to init FITWIN_TREST_FILT
c  is now up to MXFILT_ALL=80 instead of MXFILT_OBS=62. 
c  Previously FITWIN_TREST_FILT with IFILT_OBS > 62 were 
c  not initialized, and thus these filters were likely
c  dropped on 2nd fit iteration.
c
c ------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,FILTCOM.

      INTEGER ifilt_obs, iwd, NWD, NFILT, ifilt, LEN, MSKOPT
      REAL    TMIN, TMAX
      CHARACTER CFILT*(MXFILT_ALL), CFILT1*2, CWD*60

c function
      INTEGER FILTINDX

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------ BEGIN -----------

c first set each filter-Trest window to the global default.
ccc   DO ifilt_obs = 1, MXFILT_OBS !!! aweful bug fixed May 2012
      DO ifilt_obs = 1, MXFILT_ALL
        FITWIN_TREST_FILT(1,ifilt_obs) = FITWIN_TREST(1)
        FITWIN_TREST_FILT(2,ifilt_obs) = FITWIN_TREST(2)
      ENDDO

c count how many FITWIN_TREST_FILTER cuts have been  specified.
      IF ( FITWIN_TREST_FILTER .EQ. ' ' ) RETURN   

      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD = STORE_PARSE_WORDS(MSKOPT, FITWIN_TREST_FILTER//char(0),80)  

c make sure that number of elements is a multiple of 
c three (filters, TMIN, TMAX)

      IF ( mod(NWD,3) .NE. 0 ) then
        C1ERR = 'Invalid FITWIN_TREST_FILTER = '
        C2ERR = FITWIN_TREST_FILTER 
        CALL MADABORT("SETCUTS_FITWIN_TREST", C1ERR, C2ERR)
      ENDIF

      DO 100 iwd  = 1, NWD, 3

        CALL get_PARSE_WORD_fortran(iwd+0, CWD, LEN) 
        CFILT = CWD

        CALL get_PARSE_WORD_fortran(iwd+1, CWD, LEN) 
        read(CWD,*) TMIN
        CALL get_PARSE_WORD_fortran(iwd+2, CWD, LEN) 
        read(CWD,*) TMAX

c xxxxxxx mark delete xxxxxxxxxxxxxxxxxxx
c        CFILT = fileword_list(iwd+0)        
c        read(fileword_list(iwd+1),*) TMIN
c        read(fileword_list(iwd+2),*) TMAX
c xxxxxxxxxxxxxxxxxxxxxxxx

        NFILT = INDEX(CFILT,' ') - 1 
        do ifilt = 1, NFILT 
           cfilt1 = CFILT(ifilt:ifilt)
           ifilt_obs = FILTINDX(cfilt1)
           FITWIN_TREST_FILT(1,ifilt_obs) = TMIN
           FITWIN_TREST_FILT(2,ifilt_obs) = TMAX
           write(6,20) CFILT1, TMIN, TMAX
20         format(T5,'Set special FITWIN_TREST(filt=',A1,') : ',
     &              F6.1,' to ', F6.1)
        enddo

100   CONTINUE

      CALL FLUSH(6)

      RETURN
      END

C ===================================================
+DECK,SEDMODINI.
      SUBROUTINE SEDMODEL_INI(IFLAG,IERR)
c
c Created Nov 09, 2010 by R.Kessler
c
c Called from FITPAR_INI to initialize model(s) based
c on a SED spectral surface. This init includes 
c primary reference, filters, and the model-dependent 
c INIT_GENMAG_XXX() function.
c
c Models supported:
c  - SALT2
c  - SIMSED
c
c
c  IFLAG = 0 => called before any SN have been fitted (init stage)
c  IFLAG > 0 => called just before fitting each SN
c 
c Jan 19, 2011: for DOFIT_PHOTOZ, extend ZMAX the same way
c               as in FITINI_PHOTOZ.
c
c
c Mar 28, 2011: protect Zmax from unset CUTWIN_REDSHIFT(2) = 1E9
c
c Mar 13, 2012: pass OPT=1 to get_LAMRANGE_SEDMODEL
c
c May 26, 2012: remove check on LKCOR_BXDEF
c
c Aug 28, 2012: set OPT_COVAR=1 as default for SALT2 model
c
c Jan 17, 2013: for OPT_FILTER_UPDATE>0, allow init when IFLAG=0
c               because we need the RESTLAM range 
c
c Jun 24 2018: pass NONE argument to INIT_GENMAG_SALT2
c
c Jul 09 2019: call set_UVLAM_EXTRAPFLUX_SEDMODEL
c 
c Apr 20 2020: fix dimenstion of TMP_FITMODEL to allow paths
c
c ---------------------------------------------------------

      IMPLICIT NONE

c subroutine args
      INTEGER  IFLAG   ! (I) 0-> one-time init
      INTEGER  IERR    ! (O) 0 => OK

c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT. 
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
+CDE,SNLCINP.

      INTEGER 
     &   IFILT_OBS, IFILT, ILAM, LEN_SURVEY
     &  ,LEN1, LEN2, LEN_NAME, ISTAT, NLAM, OPTMASK
     &  ,NZBIN, OPT_FILTER_UPDATE_SAVE

      REAL*8  
     &   LAM(MXLAMBIN_PRIM)
     &  ,VALa(MXLAMBIN_PRIM)
     &  ,VALb(MXLAMBIN_PRIM)
     &  ,LAMSHIFT, MAGPRIM, LAMRANGE(2)
     &  ,ZMIN, ZMAX, LOGZDIF, RVMW

      CHARACTER 
     &   tmpname*20
     &  ,SURVEY_NAME_FILTER*(2*MXCHAR_SURVEY)
c     &  ,SURVEY_NAME_LOCAL*(MXCHAR_SURVEY)
     &  ,TMP_FITMODEL*(MXCHAR_FILENAME)
     &  ,BLANK*8, CFILT1*2, cfilt*(MXFILT_ALL)

      LOGICAL LBX

c functions

      INTEGER
     &   RESET_SEDMODEL
     &  ,INIT_PRIMARY_SEDMODEL
     &  ,INIT_FILTER_SEDMODEL
     &  ,INIT_GENMAG_SALT2
     &  ,INIT_GENMAG_SIMSED

      EXTERNAL
     &   RESET_SEDMODEL
     &  ,INIT_PRIMARY_SEDMODEL
     &  ,INIT_FILTER_SEDMODEL
     &  ,INIT_GENMAG_SALT2
     &  ,INIT_GENMAG_SIMSED
     &  ,init_redshift_sedmodel
     &  ,init_mwxt_sedmodel
     &  ,set_UVLAM_EXTRAPFLUX_SEDMODEL

C ------------------- BEGIN ---------------

      IERR = 0
      LEN_NAME   = INDEX(FITMODEL_NAME,' ') - 1

c xxxxxxxx mark delete xxxxxxx
c Nov 11 2020: get SURVEY name, or SUBSURVEY name
c      IF ( SUBSURVEY_NAME .EQ. '' ) THEN
c        SURVEY_NAME_LOCAL = SURVEY_NAME
c      ELSE
c        SURVEY_NAME_LOCAL = SUBSURVEY_NAME
c      ENDIF
c      LEN_SURVEY = INDEX(SURVEY_NAME_LOCAL,  ' ') - 1
c xxxxxxxxx end mark xxxxxxxxxxxx

c reset SEDMODEL to init and/or erase previous instance
      ISTAT = RESET_SEDMODEL()

c init primary spectrum

      CALL GET_PRIMARY(tmpname, NLAM, LAM, VALa)
      LEN1 = INDEX(tmpname,' ' ) - 1
      ISTAT = INIT_PRIMARY_SEDMODEL(tmpname,NLAM,LAM,VALa,LEN1)

      RVMW = DBLE(RV_MWCOLORLAW)
      CALL init_MWXT_SEDMODEL( OPT_MWCOLORLAW, RVMW ) ;

c set entire redshift range if same filters are used for each SN;
c for SN-dependent filters, set exact z-range (and 1 Z-bin) 
c to avoid lots of uncecessary CPU time.

      IF ( IFLAG .EQ. 0 .or. DOFIT_PHOTOZ ) THEN
        zmin    = CUTWIN_REDSHIFT(1)
        zmax    = CUTWIN_REDSHIFT(2)

        zmin    = max(zmin,0.005)
        zmax    = min(zmax,3.0)   ! avoid crazy Zmax = E4

        if ( DOFIT_PHOTOZ ) then
          ZMAX = Zrange_KCOR(2) + 4.0 * Zbinsize_KCOR    
          ZMAX = min ( ZMAX, PHOTOZ_BOUND(2) )
        endif

        logzdif = log10(zmax) - log10(zmin)
        NZBIN    = int(100.* logzdif) + 1
      ELSE
        zmin = SNLC_REDSHIFT
        zmax = SNLC_REDSHIFT
        NZBIN = 1
      ENDIF

      CALL init_redshift_sedmodel(NZBIN, zmin, zmax)

c now init each filter.
      IF ( IFLAG .EQ. 0 ) THEN
         OPT_FILTER_UPDATE_SAVE = OPT_FILTER_UPDATE
         OPT_FILTER_UPDATE      = 0 ! needed to read kcor-filters
      ENDIF

      DO 44 ifilt  = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)

         LAMSHIFT = DBLE(FILTOBS_LAMSHIFT(ifilt_obs))

c pass ifilt_obs; everything else is returned.
c VALa = transSN, VALb = transREF8

         CALL GET_FILTTRANS(OPT_FILTOBS, ifilt_obs, SURVEY_NAME_FILTER,
     &            CFILT, MAGPRIM, NLAM, lam, VALa, VALb)

         LEN1  = INDEX(cfilt,' ' ) - 1
         LEN2  = INDEX(SURVEY_NAME_FILTER,' ') - 1
         ISTAT = INIT_FILTER_SEDMODEL(IFILT_OBS, cfilt,
     &              SURVEY_NAME_FILTER,
     &              MAGPRIM, NLAM, LAM, VALa, VALb, LAMSHIFT,
     &              LEN1, LEN2 )

      CALL FLUSH(6)

44    CONTINUE  ! end of IFILT loop


      IF ( IFLAG .EQ. 0 ) THEN        
         OPT_FILTER_UPDATE      = OPT_FILTER_UPDATE_SAVE
      ENDIF

      CALL set_UVLAM_EXTRAPFLUX_SEDMODEL(UVLAM_EXTRAPFLUX)

c ----------------------------------------
c now do general model-dependent init.
c TMP_FITMODEL has the special end-string char(0) need for C functions.

      TMP_FITMODEL = FITMODEL_NAME(1:LEN_NAME) // char(0)
      BLANK        = "" // char(0)

      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN

        OPTMASK = 0
        IF ( REQUIRE_DOCANA > 0 )           OPTMASK = OPTMASK + 2
        IF ( .NOT. ENABLE_MAGSHIFT_SALT2  ) OPTMASK = OPTMASK + 4
        IF ( .NOT. ENABLE_WAVESHIFT_SALT2 ) OPTMASK = OPTMASK + 8
	IF ( .NOT. ALLOW_NEGFLUX_SALT2    ) OPTMASK = OPTMASK + 16 ! Mar 2021
        IF ( DEBUG_FLAG==-4077 ) OPTMASK = OPTMASK + 1024 ! PantheonPlus arxiv number includes 04077

        ISTAT = INIT_GENMAG_SALT2( TMP_FITMODEL, BLANK, OPTMASK, 
     &            LEN_NAME, 40 )

c turn on covariance model by default, 
c unless user specifically sets OPT_COVAR=0
        IF ( OPT_COVAR_FLUX .EQ. -9 ) OPT_COVAR_FLUX    = 1
        if ( .not. USE_MODEL_MAGERR ) OPT_COVAR_FLUX    = 0 

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SIMSED ) THEN

cc         ISTAT = INIT_GENMAG_SIMSED( TMP_FITMODEL, LEN_NAME )

      ELSE
         LEN1 = INDEX(FITMODEL_VERSION,' ') - 1
         C1ERR = 'Invalid FITMODEL_VERSION = ' 
     &                 // FITMODEL_VERSION(1:LEN1)
         C2ERR = 'Model must be based on spectral surface(s).'
         CALL MADABORT("SEDMODEL_INI", c1err, c2err)
      ENDIF

      LKCOR_AVWARP  = .FALSE.
      OPTMASK = 1
      CALL GET_LAMRANGE_SEDMODEL(OPTMASK,LAMRANGE(1),LAMRANGE(2))
      RESTLAMBDA_MODEL(1) = LAMRANGE(1)
      RESTLAMBDA_MODEL(2) = LAMRANGE(2)

      CALL FLUSH(6)
      RETURN
      END   ! end SEDMODEL_INI


C =====================
+DECK,GTCHEAT.
      SUBROUTINE GET_SIMCHI2_CHEAT()

c Created Feb 2, 2014 
c
c Call FCNSNLC with  IFLAG = FCNFLAG_USESIM to replace the
c fitted parameters with the true simulated parameters.
c Store resulting chi2 in global SIMCHI2_CHEAT.
c This works fine for 4-parameter fits, but there is a
c subtle issue for 5-par (photo-z) fits; if the true
c redshift (ZSIM) is very far away from the fitted ZPHOT
c then the wrong filters are used and the program will abort.
c For example, ZPHOT=.4 will use z-band, but if ZSIM=0.1 
c then z-band goes outside the 9200 range of SALT2 and
c will abort.
c
c If any obs-frame filter is undefined in the rest-frame
c [ based on range of LAMOBS/(1+ZSIM) ] then skip chi2
c computation and set SIMCHI2_CHEAT = -1 * NFILT_UNDEFINED
c
c Apr 4 2018: fix bug, RESTLAMBDA_MODEL -> RESTLAMBDA_FITRANGE
c
      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
c+CDE,SNLCINP.
+CDE,SNFITCOM.
+CDE,FILTCOM.

      LOGICAL   USED, LAM1, LAM2
      INTEGER   ifilt, IFILT_OBS, NFILT_UNDEFINED
      CHARACTER cfilt*2
      DOUBLE PRECISION GRAD(MXFITPAR), ZSIM, Z1SIM, LAMREST

c function(s)
      DOUBLE PRECISION  USRFUN   ! for SIMCHI2_CHEAT
      EXTERNAL          USRFUN

C ---------------- BEGIN -----------------

c first check that each filter used in the fit 
c is defined by the model in the rest frame.

      NFILT_UNDEFINED = 0
      Z1SIM  = 1.0 + SIM_REDSHIFT_HELIO
      DO 100 ifilt     = 1, NFILTDEF_SURVEY
         
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         cfilt     = filtdef_string(ifilt_obs:ifilt_obs)
         USED      = USE_FILT(ifilt_obs)  ! used in nominal fit
         if ( .NOT. USED ) GOTO 100

         LAMREST = FILTOBS_LAMAVG(ifilt_obs)/Z1SIM
c xxx mark delete         LAM1    = LAMREST .GE. RESTLAMBDA_MODEL(1)
c xxx mark delete         LAM2    = LAMREST .LE. RESTLAMBDA_MODEL(2)
         LAM1    = LAMREST .GE. RESTLAMBDA_FITRANGE(1)
         LAM2    = LAMREST .LE. RESTLAMBDA_FITRANGE(2)

         if ( .not. (LAM1 .and. LAM2) ) THEN
            NFILT_UNDEFINED = NFILT_UNDEFINED + 1

            write(6,30) SNLC_CCID, cfilt(1:1), SIM_REDSHIFT_HELIO
 30         format(T3,'WARNING: CID ', A8,' has ', 
     &        A,'-band undefined for SIMCHI2_CHEAT(zsim=',F5.3,')' )
            call flush(6)
         endif

 100  CONTINUE

c bail if there are any undefined filters in the rest-frame.
      if ( NFILT_UNDEFINED > 0 ) THEN
         SIMCHI2_CHEAT = -1.0 * DBLE(NFILT_UNDEFINED)
         return
      endif

c if we get here, filters are OK so compute SIMCHI2_CHEAT.

      CALL FCNSNLC(NFITPAR_MN, GRAD, SIMCHI2_CHEAT,
     &     INIVAL, FCNFLAG_USESIM, USRFUN)

      RETURN
      END    ! end of GET_SIMCHI2_CHEAT

C ===================================================
+DECK,PHZANA.
      SUBROUTINE PHOTOZ_ANA ( IFLAG, iter, ERRFLAG )
c 
c Created Aug 2009 by R.Kessler
c Analyze PHOTOZ fit.
c
c On ITER=0, init & print ZDROP for each filter.
c    Also remove SNANA-Trest cuts and store cuts in PHOTOZ-cut variables
c
c On 1st iteration, check for filters to drop.
c On 2nd iteration, do nothing but fill global variables.
c
c If filter(s) are dropped, set ERRFLAG = -1
c so that the 1st iteration is repeated (LREPEAT_ITER=T)
c
c Fill global variables  
c  PHOTODZ_MIN(iter)   MIN distance to model-boundary over all filters,
c  PHOTODZ1Z_MIN(iter)
c  IFILT_NEARDROP     ! filter-index closest to being dropped
c
c
c Feb 01, 2012: reTest NFILT < NFILT_CUT-1 instead of NFILT;
c               i.e., don't make the full cut in case a filter is added.
c  
c Apr 29, 2012: set DOFIT_PHOTOZ_CHEAT flag when ISN=ITER=0
c
c May 21, 2012: replace ISN with IFLAG
c
c Nov 26, 2012: RESTLAMBBDA_MODEL -> RESTLAMBDA_USEFIT
c
c Jan 4, 2013: replace ISTAT_FITANA -> ERRFLAG
c
c -----------------------------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FITRESTCOM.

c subroutine args

      INTEGER 
     &   IFLAG   ! (I) 0= one time init; 1= each SN
     &  ,iter    ! (I) fit iteration: 1,2, ... NFIT_ITERATION
     &  ,ERRFLAG  ! (O) 

c local var

      REAL*8
     &   PHOTOZ_VAL, PHOTOZ1_VAL, PHOTOZ_ERR, Z, ZZ
     &  ,LAMOBS, LAMREST
     &  ,ZMIN, Z1MIN,  DZatMIN, DZ1ZatMIN
     &  ,ZMAX, Z1MAX,  DZatMAX, DZ1ZatMAX
     &  ,MJD, PEAKMJD, Trest, Z1

      REAL
     &   CUTWIN_SNANA(2)
     &  ,TLIST(MXEPOCH)
     &  ,Z4

      INTEGER 
     &   IFILT, IFILT_OBS, N, NFILT_CUT, NFILT
     &  ,IFITDATA, NTLIST, iep, LCID, MSKCUT
     &  ,FLIST(MXEPOCH)
     &  ,NFILTDROP, IFILTDROP
     &  ,NTCUT, LENF

      LOGICAL   LCUT, LDMP, LZTEST, LDROP, LADD
      CHARACTER cfilt1*12, cfiltdrop*12, cfiltadd*12, ccid*(MXCHAR_CCID)
      character VERB*8

c function
      REAL TRESTzCUT 
      LOGICAL LFITFUN_FILT, LTEST_ZPHFILTER
  
c ------------------ BEGIN --------------

c check for cheater flag.  
      IF ( IFLAG .EQ. 0 .and. ITER .EQ. 0 ) THEN
        IF ( BTEST(OPT_PHOTOZ,BIT_PHOTOZ_CHEAT) ) THEN
           DOFIT_PHOTOZ_CHEAT = .TRUE.       ! set global flag
           OPT_PHOTOZ = IBSET(OPT_PHOTOZ,BIT_PHOTOZ_GAUSS)  ! set host-prior bit to be safe
        ELSE
           DOFIT_PHOTOZ_CHEAT = .FALSE.
        ENDIF
      ENDIF

      ERRFLAG = 0  ! default is OK
      LDROP = .FALSE.
      LADD  = .FALSE.

c bail if we just did 2-band FITRESTMAG since it makes no sense to repeat.
      if( IFILTOBS_BRACKET(1) > 0 ) RETURN

      if ( IFLAG .GT. 0 ) THEN
        CCID = SNLC_CCID
        LCID = ISNLC_LENCCID
      ENDIF

      IF ( ITER > 0 ) THEN
        PHOTODZ_MIN(iter)    = 9999.
        PHOTODZ1Z_MIN(iter)  = 9999.
        PHOTOZ_VAL           = FITVAL(IPAR_ZPHOT,iter)
        PHOTOZ_ERR           = FITERR(IPAR_ZPHOT,iter)
        PHOTOZ1_VAL          = 1. + PHOTOZ_VAL
      ENDIF

c check LREPEAT after PHOTOZ_VAL/ERR are defined
      IF ( LREPEAT_ITER ) THEN
        GOTO 800     ! never process repeated iteration 
      ENDIF

      IFILT_NEARDROP       = -9
      LDMP = LDMP_PHOTOZ_DROPFILTER

      if ( ITER .EQ. 0 ) then

        print*,' '
        print*,
     &   '  APPLY THESE TREST-RELATED CUTS BEFORE/AFTER PHOTOZ FIT: '
        call flush(6)

        Z  = PHOTOZ_BOUND(2)
        ZZ = 1. + PHOTOZ_BOUND(2)
        Z4 = SNGL(Z)

        cutwin_snana(1) = TRESTzCUT(1, Z4, CUTWIN_Trest(1) )
        cutwin_snana(2) = TRESTzCUT(2, Z4, CUTWIN_Trest(2) )
        CALL PHOTOZ_SAVECUT('TREST',
     &     cutwin_trest, cutwin_snana, FITANA_cutwin_trest )

        cutwin_snana(1) = TRESTzCUT(1, Z4, CUTWIN_Trestmin(1) )
        cutwin_snana(2) = TRESTzCUT(2, Z4, CUTWIN_Trestmin(2) )
        CALL PHOTOZ_SAVECUT('TRESTMIN',
     &     cutwin_trestmin, cutwin_snana, FITANA_cutwin_trestmin )

        cutwin_snana(1) = TRESTzCUT(1, Z4, CUTWIN_Trestmax(1) )
        cutwin_snana(2) = TRESTzCUT(2, Z4, CUTWIN_Trestmax(2) )
        CALL PHOTOZ_SAVECUT('TRESTMAX',
     &     cutwin_trestmax, cutwin_snana, FITANA_cutwin_trestmax )

        cutwin_snana(1) = TRESTzCUT(1, Z4, CUTWIN_T0gapmax(1) )
        cutwin_snana(2) = TRESTzCUT(2, Z4, CUTWIN_T0gapmax(2) )
        CALL PHOTOZ_SAVECUT('T0GAPMAX',
     &     cutwin_t0gapmax, cutwin_snana, FITANA_cutwin_t0gapmax )

        cutwin_snana(1) = TRESTzCUT(1, Z4, CUTWIN_Tgapmax(1) )
        cutwin_snana(2) = TRESTzCUT(2, Z4, CUTWIN_Tgapmax(2) )
        CALL PHOTOZ_SAVECUT('TGAPMAX',
     &     cutwin_tgapmax, cutwin_snana, FITANA_cutwin_tgapmax )

c change SNANA-Trest cuts

        print*,' '
        print*,'  FIRST-ITERATION FILTER SELECTION: '
        call flush(6)
      endif

      IF( LDMP .and. (ITER .EQ. 1) .and. (.NOT. LREPEAT_ITER) ) then 
         print*,' ----------------------------------------------- '
         print*,'  DROP-FILTER DUMP for CID = ' , CCID
      ENDIF

      NFILTDROP = 0
      cfiltdrop = ''
      cfiltadd  = ''

      DO 100 ifilt   = 1, NFILTDEF_SURVEY
          ifilt_obs  = IFILTDEF_MAP_SURVEY(ifilt)
          cfilt1     = filtdef_string(ifilt_obs:ifilt_obs)

c only check FILTLIST_FIT filters specified by user
          if ( .NOT. DOFIT_FILT(ifilt_obs) ) goto 100

          LAMOBS = FILTOBS_LAMAVG(ifilt_obs)

c get min/max redshift allowed by model
          ZMIN = LAMOBS/RESTLAMBDA_USEFIT(2) - 1.0
          ZMAX = LAMOBS/RESTLAMBDA_USEFIT(1) - 1.0

c print filter range in ITER=0 only
          if ( ITER .EQ. 0 ) then
             write(6,600) cfilt1(1:1), ZMIN, ZMAX
600          format(T6,'Keep ',A,' if ', F7.3,' < Zphot < ', F7.3 )
             call flush(6)
             goto 100
          endif

c store valid z-range in global
          PHOTOZ_DROPFILTER_MIN(ifilt_obs) = ZMIN
          PHOTOZ_DROPFILTER_MAX(ifilt_obs) = ZMAX

          Z1MIN = 1. + ZMIN
          Z1MAX = 1. + ZMAX

c note that negative DZ always means outside the ZMIN/ZMAX range
c defined by the model.

          DZatMIN   = (PHOTOZ_VAL - ZMIN) ! should be roughly positive
          DZatMAX   = (ZMAX - PHOTOZ_VAL) ! idem
          DZ1ZatMIN = (PHOTOZ_VAL - ZMIN) / Z1MIN 
          DZ1ZatMAX = (ZMAX - PHOTOZ_VAL) / Z1MAX

c keep track of filter that is closest to getting dropped.
          if ( abs(DZatMIN) < abs(PHOTODZ_MIN(iter)) ) then
            PHOTODZ_MIN(iter)   = DZatMIN
            PHOTODZ1Z_MIN(iter) = DZ1ZatMIN
            IFILT_NEARDROP      = IFILT_OBS
          endif

          if ( abs(DZatMAX) < abs(PHOTODZ_MIN(iter)) ) then
            PHOTODZ_MIN(iter)   = DZatMAX
            PHOTODZ1Z_MIN(iter) = DZ1ZatMAX
            IFILT_NEARDROP      = IFILT_OBS
          endif

c apply cut to see if this filter should be tossed;

          LCUT = .FALSE.
          IF ( DZatMIN   .LT. PHOTODZ_REJECT   ) LCUT = .TRUE.
          IF ( DZatMAX   .LT. PHOTODZ_REJECT   ) LCUT = .TRUE.
          IF ( DZ1ZatMIN .LT. PHOTODZ1Z_REJECT ) LCUT = .TRUE.
          IF ( DZ1ZatMAX .LT. PHOTODZ1Z_REJECT ) LCUT = .TRUE.

c set cut logical only on first iteration
          IF ( ITER .EQ. 1 .and. .not. LREPEAT_ITER ) then
             PHOTOZ_DROPFILTER(ifilt_obs) = LCUT
             if ( LCUT  ) then
                ERRFLAG   = -1          ! set repeat flag
                NFILTDROP = NFILTDROP + 1  ! local counter
                LENF = index(cfiltdrop,' ') -1 
                cfiltdrop = cfiltdrop(1:LENF) // cfilt1(1:1)
                LDROP = .TRUE.
             endif
          ENDIF

          if ( LDMP ) then                        
            print*,'  DROPFILTER(', cfilt1(1:1), ') = ', LCUT
            write(6,666) ZMIN, ZMAX, DZatmin, DZatMAX
666         format(T10,'ZMIN,ZMAX=',2F6.3, 3x, 'DZatMIN/MAX=',2F7.3)
            CALL FLUSH(6)
          endif

c 4/24/2011: check if a filter will be added
          LZTEST =  LFITFUN_FILT(ifilt_obs,PHOTOZ_VAL)
          if ( LZTEST .and. .not. USE_FILT(ifilt_obs) ) then
             PHOTOZ_ADDFILTER(ifilt_obs) = .TRUE.
             ERRFLAG  = -1          ! set repeat flag
             LENF = index(cfiltadd,' ') -1 
             cfiltadd = cfiltadd(1:LENF) // cfilt1(1:1)
             LADD = .TRUE.
          endif

c          print*,'  xxxx ITER=', ITER,
c     &          '   USE_FILT(', cfilt1(1:1), ') = ', USE_FILT(ifilt_obs),
c     &          '   LZTEST=', LZTEST,
c     &          '   DROP=', PHOTOZ_DROPFILTER(ifilt_obs)

100   CONTINUE  ! IFILT loop over all filters


      IF ( ITER .EQ. 0 ) RETURN

c On last iteration, set NEARDROP-filter index to negative 
c if it was dropped. This is to identify dropped filters
c in the analysis-ntuple (ntid 7788)

      LCUT = PHOTOZ_DROPFILTER(IFILT_NEARDROP)
      IF ( ITER .EQ. NFIT_ITERATION .and. LCUT ) THEN
         IFILT_NEARDROP = -IFILT_NEARDROP
      ENDIF


c if filters are dropped, then check if Trest-related 
c SNANA cuts are still satisfied. If not, set ERRFLAG
c to SKIP this turkey. Use the loose snana cuts instead of the
c tighter (final) cuts.

      IF ( ERRFLAG .EQ. -1 ) THEN

        VERB = ''
        IF( LDROP ) THEN
           VERB = 'Dropped'
           CFILT1 = cfiltdrop
        ENDIF
        IF( LADD  ) THEN
           VERB = 'Added'
           CFILT1 = cfiltadd
        ENDIF

        LENF = index(CFILT1,' ') - 1
        write(6,190) VERB, CCID(1:LCID), cfilt1(1:LENF)
190     format(T8, A, 2x, A,'-', A, 
     &             ' : retest Trest-related cuts: ', $ )
        call flush(6)

        PEAKMJD = FITVAL(IPAR_PEAKMJD,iter) 
        Z1      = FITVAL(IPAR_ZPHOT,iter)  + 1.0
        NTLIST = 0 
        DO 200 ifitdata = 1, NFITDATA

          iep       = EPLIST_FIT(ifitdata)
          ifilt_obs = I4EP_ALL(iep,IEP_IFILT_OBS)

          if ( PHOTOZ_DROPFILTER(ifilt_obs) ) GOTO 200

          MJD           = SNLC8_MJD(iep) - MJDOFF 
          Trest         = (MJD - PEAKMJD) / z1
          NTLIST        = NTLIST + 1 
          TLIST(NTLIST) = Trest  
          FLIST(NTLIST) = ifilt_obs

200     CONTINUE 

c if we don't have enough measurements after filter-drop, bail ASAP.
        if ( NTLIST .LT. CUTWIN_NEPOCH(1) ) then
          ERRFLAG = ERRFLAG_ZFIT_DROPFILTCUTS
          return
        endif

c get Nfilt passing Trestmin & Trestmax cuts.

        CALL GET_TRESTVAR (
     &        NTLIST, TLIST, FLIST          ! (I) Trest & IFILT arrays
     &       ,CUTWIN_TREST                  ! (I) user cutwin
     &       ,CUTWIN_TRESTMIN               ! (I) idem 
     &       ,CUTWIN_TRESTMAX               ! (I) idem
     &       ,CUTWIN_TREST2                 ! (I)
     &       ,NFILT                         ! (O) Nfilt within TREST-range
     &       ,TRESTMIN_FIT, TRESTMAX_FIT    ! (O) Trestmin,max after fit
     &       ,NFILT_TRESTMIN_FIT            ! (O)
     &       ,NFILT_TRESTMAX_FIT            ! (O)
     &       ,NFILT_TREST2_FIT              ! (O)
     &       ,TGAPMAX_FIT, T0GAPMAX_FIT )   ! (O) 


        TRESTRANGE_FIT = TRESTMAX_FIT - TRESTMIN_FIT  ! De 18 2017

c require at least enough filters to have a chance at NFILT_SNRMAX cut

        MSKCUT = 0

        NTCUT = int(CUTWIN_NEPOCH(1)) 
        if ( NTLIST < NTCUT ) then
          MSKCUT = MSKCUT + 1
          ERRFLAG = ERRFLAG_ZFIT_DROPFILTCUTS
        endif

        NFILT_CUT = int(CUTWIN_NFILT_SNRMAX(1))
        if ( NFILT < (NFILT_CUT-1) ) then
           MSKCUT = MSKCUT + 2
           ERRFLAG = ERRFLAG_ZFIT_DROPFILTCUTS
        endif

        NFILT_CUT = int(CUTWIN_NFILT_SNRMAX2(1))
        if ( NFILT < (NFILT_CUT-1) ) then
           MSKCUT = MSKCUT + 4
           ERRFLAG = ERRFLAG_ZFIT_DROPFILTCUTS
        endif

        NFILT_CUT = int(CUTWIN_NFILT_TRESTMIN(1))
        if ( NFILT_TRESTMIN_FIT < NFILT_CUT )  then
           MSKCUT = MSKCUT + 8
           ERRFLAG = ERRFLAG_ZFIT_DROPFILTCUTS
        endif

        NFILT_CUT = int(CUTWIN_NFILT_TRESTMAX(1))
        if ( NFILT_TRESTMAX_FIT < NFILT_CUT )  then
           MSKCUT = MSKCUT + 16
           ERRFLAG = ERRFLAG_ZFIT_DROPFILTCUTS
        endif

        if ( ERRFLAG > 0 ) then
           write(6,196) 'FAIL', MSKCUT
        else
           write(6,191) 'PASS'
        endif
        call flush(6)
191     format(A)
196     format(A,' (MSKCUT=',I3,')' )

c ----------------------
c        print*,' xxxx TRESTMIN, TRESTMAX = ', 
c     &          TRESTMIN_FIT, TRESTMAX_FIT
c        print*,' xxxx NFILT(TRESTMIN,TRESTMAX) = ', 
c     &          NFILT_TRESTMIN_FIT, NFILT_TRESTMAX_FIT
c ----------------------

      ENDIF  ! end of ERRFLAG = -1

c -------------------------

c after 1st iteration, SKIP SN if photoz no longer respects
c the z-range for each filter. 

800   CONTINUE

      IF ( ITER > 1 .OR. LREPEAT_ITER ) THEN
         LZTEST = LTEST_ZPHFILTER(ITER, PHOTOZ_VAL, PHOTOZ_ERR,
     &             IFILTDROP)
         IF ( .NOT. LZTEST ) ERRFLAG = ERRFLAG_ZFIT_RANGE
      ENDIF

      RETURN
      END            ! end of PHOTOZ_ANA

C =================
+DECK,LZPHFILT.
      LOGICAL FUNCTION LTEST_ZPHFILTER(ITER,ZPH,ZPH_ERR,IFILTBAD)
c
c Created Aug 25, 2011 by R.Kessler
c Returns TRUE of all filters respect their photoz range
c defined by PHOTOZ_DROPFILTER_MIN/MAX(ifilt_obs).
c This function is used to weed out fits in which the
c photoz changes dramatically between iterations,
c causing one or more filters to be undefined.
c
c Dec 18, 2011: add IFILTBAD arg.
c
c --------------

      IMPLICIT NONE

      INTEGER ITER            ! (I) fit-iter
      REAL*8  ZPH, ZPH_ERR    ! (I) ZPHOT and its error
      INTEGER IFILTBAD        ! (O) absolute filter index bad filter

c local var

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,SNFITCOM.
+CDE,FILTCOM.

      REAL*8  ZMIN, ZMAX
      INTEGER IFILT, IFILT_OBS, LCID
      LOGICAL LZTEST
      CHARACTER CFILT1*1, CCID*(MXCHAR_CCID)

C ------------- BEGIN -------------

      IFILTBAD        = -9
      LTEST_ZPHFILTER = .TRUE.

      DO 300 ifilt     = 1, NFILTDEF_SURVEY
          ifilt_obs  = IFILTDEF_MAP_SURVEY(ifilt)
          if ( .NOT. USE_FILT(ifilt_obs) ) goto 300

          cfilt1  = filtdef_string(ifilt_obs:ifilt_obs)

          ZMIN = PHOTOZ_DROPFILTER_MIN(ifilt_obs)
          ZMAX = PHOTOZ_DROPFILTER_MAX(ifilt_obs)
          LZTEST = ( ZPH - ZPH_ERR .GE. ZMIN ) .and.
     &             ( ZPH + ZPH_ERR .LE. ZMAX )

          IF ( .NOT. LZTEST ) THEN
            LTEST_ZPHFILTER = .FALSE.
            LCID = ISNLC_LENCCID
            CCID = SNLC_CCID
            write(6,301) CCID(1:LCID), ZPH, cfilt1, ITER
301         format(T2,'WARNING SN=',A,' : PHOTOZ=', F5.3,
     &                 ' is outside range for ',
     &                  A,'-band (ITER=',I1, ') => SKIP ' )
            IFILTBAD = IFILT_OBS 
            RETURN
          ENDIF

300   CONTINUE

      RETURN
      END

C ============
+DECK,TRESTzCUT.
      REAL FUNCTION TRESTzCUT(OPT, z, Trest)
      IMPLICIT NONE

c Created Aug 19, 2009
c Returns either 1+z or  1/(1+z) times Trest
c
c OPT = 1 : return TRESTzCUT that is smaller than Trest
c OPT = 2 : return TRESTzCUT that is larger than Trest
c
      INTEGER OPT    ! (I) option
      REAL Z, TREST  ! (I) redshift, Trest 

c local

      REAL Z1, Z1FAC

c ----------- BEGIN ----------

      TRESTzCUT = -999.
      Z1 = 1. + z

      IF ( OPT .EQ. 1 ) THEN
        if ( Trest .GE. 0.0 ) then
            Z1FAC = 1./Z1
        else
            Z1FAC = Z1 
        endif

      ELSE IF ( OPT .EQ. 2 ) THEN

        if ( Trest .GE. 0.0 ) then
            Z1FAC = Z1
        else
            Z1FAC = 1./Z1 
        endif
      ENDIF

      TRESTzCUT = Trest * Z1FAC

      RETURN
      END

C ============================================================
+DECK,PHZSAVECUT.
      SUBROUTINE PHOTOZ_SAVECUT(name, 
     &        cutwin_orig, cutwin_snana, cutwin_save )

c Created Aug 15, 2009 by R.Kessler
c
c Save SNANA cut-window in CUTWIN_SAVE; then open
c cutwin_orig to be wide open so that cut is not
c applied in snana.

      IMPLICIT NONE
      CHARACTER NAME*(*)   ! (I) name of cut
      REAL 
     &   CUTWIN_ORIG(2)    ! (I) original SNANA cut
     &  ,CUTWIN_SNANA(2)   ! (I) loosened SNANA cut
     &  ,CUTWIN_SAVE(2)    ! (O) address to save orig-snana cut for later

c ------------ BEGIN ---------

      CUTWIN_SAVE(1) = CUTWIN_ORIG(1)
      CUTWIN_SAVE(2) = CUTWIN_ORIG(2)

      CUTWIN_ORIG(1) = CUTWIN_SNANA(1)
      CUTWIN_ORIG(2) = CUTWIN_SNANA(2)

      write(6,20) name, CUTWIN_SNANA
20    format(T8,'Relaxed ',A10,' cut before photoZ fit: ',
     &    F8.3,' to ', F8.3 )

      write(6,30) name, CUTWIN_SAVE
30    format(T8,'Nominal ',A10,' cut after  photoZ fit: ',
     &    F8.3,' to ', F8.3 )

      RETURN
      END

C ====================================================
+DECK,SET_ZHD_PHOTOZ.
      SUBROUTINE SET_ZHD_PHOTOZ()

c Created Jan 26 2018
c Set redshift globals for output tables:
c    SNLC_zHELIO[_ERR]
c    SNLC_zCMB[_ERR]
c    SNLC_zHD[_ERR]
c
c For zHD, translate heliocentric fitted photo into cmb frame,
c and include ZPECERR in zHDERR
c
c ASSUMPTION: HOSTGAL_ZPHOT is in heliocentric frame.
c

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER OPT
      CHARACTER EQ*4
      REAL*8  ZHEL, ZCMB, ZERR, ZERR1, ZERR2
 
c function
      REAL*8 zhelio_zcmb_translator

C -------------- BEGIN -------------
      OPT   = 1 ! --> convert ZHEL to ZCMB
      EQ    = 'eq' // char(0)
      ZHEL  = DBLE(LCVAL_STORE(IPAR_ZPHOT))
      ZCMB  = 
     &   zhelio_zcmb_translator(ZHEL,SNLC8_RA,SNLC8_DEC,EQ,OPT,4)

      ZERR1 = DBLE( LCERR_STORE(IPAR_ZPHOT) )
      ZERR2 = DBLE( SNLC_ZPEC_ERR * ( 1.0 + zCMB ) )
      ZERR  = sqrt(ZERR1*ZERR1 + ZERR2*ZERR2)

      SNLC_ZHELIO     = SNGL(ZHEL)
      SNLC_ZHELIO_ERR = SNGL(ZERR1)

      SNLC_zCMB       = SNGL(ZCMB)
      SNLC_zCMB_ERR   = SNGL(ZERR1) ! do not include vpec error here 

      SNLC_zHD        = SNGL(ZCMB)
      SNLC_zHD_ERR    = SNGL(ZERR)  ! include vpec error

      RETURN
      END     ! ene SET_ZHD_PHOTOZ

C ====================================================
+DECK,FITANA_MARG.
      SUBROUTINE FITANA_MARG(isn,DOPDFPLOT,ERRFLAG)
      IMPLICIT NONE
c
c Shell to call MARG_DRIVER
c Returns ERRFLAG=0 (OK) or ERRFLAG > 0 (discard fit)
c
c
c Jul 8, 2009: skip marg if fitprob(before marginalization)
c              fails CUTWIN_NOMARG_PROB(2)
c
c Oct 7,2009: fix logic to avoid fbounds-check with ifilt=0.
c             Code runs the same as before
c
c Oct 20, 2009: add DOPLOT argument  for monitor plots
c
c Nov 11, 2009: add LMCMC option 
c
c Mar 2011: 
c   skip marginalization if DOCHI2_SIGMA=T and chi2(sigma)
c   fails cut since it won't change after marg.
c
c Dec 18, 2011: 
c  - add ISTAT arg
c  - LZPHOT = LTEST_ZPHFILTER after marginalization and set 
c    ISTAT=0 if a filter is dropped => discard fit
c
c Jan 4, 2013: replace ISTAT with ERRFLAG
c              Success is now ERRFLAG=0 rather than ISTAT=1.
c
c -----------
      INTEGER ISN       ! (I) SN sparse index
      LOGICAL DOPDFPLOT ! (I) T => make PDF monitor plots
      INTEGER ERRFLAG   ! (O) returns 0=> OK, >0 => discard

c local var

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,MCMCCOM.
+CDE,SNFITCOM.
+CDE,FILTCOM. 


      REAL NSIGMA, Z1
      INTEGER 
     &   OPT, HOFF, iep, ifilt, ifilt_obs, NDOF, LL
     &  ,ITER, IFILTBAD

      LOGICAL LTMP

      REAL FITPROB, CHI2
      LOGICAL  LFITPROB, LMARG, LZPHOT
      
      REAL*8  CHI8, ZPH8, ZPHERR8

      CHARACTER CFILT1*1

c functions
      REAL    LCPROBCHI2
      REAL*8  PROB_CHI2NDOF
      LOGICAL LTEST_ZPHFILTER

C --------------- BEGIN ---------------

      ERRFLAG = 0  ! init to OK

c store filter-dependent chi2 before continuing
c These are just the fit chi2 from minimization.

      DO ifilt = 0, NFILTDEF_SURVEY

         if ( ifilt .GT. 0 ) then
            ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
            LTMP      = USE_FILT(ifilt_obs) 
         else
            LTMP = .FALSE.
         endif

         if ( ifilt .EQ. 0 .or. LTMP ) then
           NDOF = NEPOCH_FIT(ifilt) - NFITPAR(ifilt)
           LC_FITCHI2(ifilt)  = FCN_FITCHI2(ifilt)
           LC_MARGCHI2(ifilt) = FCN_FITCHI2(ifilt)

           CHI8 = DBLE(LC_FITCHI2(ifilt))
           LC_FITPROB(ifilt)  = PROB_CHI2NDOF(CHI8, NDOF)
           LC_MARGPROB(ifilt) = LC_FITPROB(ifilt)
         endif

      ENDDO  ! ifilt

      LMARG = NGRID_PDF .GT. 0

      IF ( LMCMC .and. LMARG ) THEN
        c1err = 'Cannot marginalize and use MCMC'
        c2err = 'Choose one or the other (not both!)'
        CALL MADABORT("FITANA_MARG", c1err, "")
      ENDIF

      
c make sure that either MARGINALIZATION or MCMC is specified.

      IF ( .not. ( LMCMC .or. LMARG ) ) RETURN

c ---------------------------------------------------------
c skip marginalization if fitted chi2-prob fails cut

      LL = ISNLC_LENCCID

      FITPROB  = LCPROBCHI2_STORE(1)  ! fitprob before marginalization
      LFITPROB = ( FITPROB .GT. FITWIN_NOMARG_PROB(1) )
      IF ( .NOT. LFITPROB ) THEN
        write(6,600) 'FITPROB', SNLC_CCID(1:LL), FITPROB
        RETURN
      ENDIF

600     format(t5,A,'(CID ',A,') = ',G12.4,
     &       ' FAILS CUT => SKIP MARGINALIZATION' )

c skip marg if chi2(sigma) fails cut since it won't change after marg.
      CHI2 = FITCHI2_STORE(4)
      LTMP = (CHI2 .GE. FITWIN_CHI2SIGMA(1) ) .and.
     &       (CHI2 .LE. FITWIN_CHI2SIGMA(2) )

      IF ( DOCHI2_SIGMA .and. .not. LTMP ) THEN
        write(6,600) 'CHI2SIGMA', SNLC_CCID(1:LL), CHI2
        RETURN
      ENDIF

c ---------------------------------------------------------
      
      IF ( DOPDFPLOT ) THEN
         HOFF   = 700                ! hbook offset for 1d pdf plots
      ELSE
         HOFF = 0
      ENDIF

c Check for too-tiny errors.
      CALL FITERR_ADJUST()

c marginalize !

      IF ( LMARG ) THEN

        NSIGMA = float(NSIGMA_PDF)
        OPT    = OPT_INTEGPDF_FULL  ! default is full chi2 evaluation

c now check for reasons to quit FCNSNLC early (to save CPU time)

        IF ( OPT_COVAR_FLUX .LE. 0 .or. COVMAT_MIN .GE. 0.0 ) then
          OPT = OPT_INTEGPDF_QUITCHI2  
        ENDIF

        CALL MARG_DRIVER(HOFF, OPT, 
     &                MAX_INTEGPDF, NGRID_PDF, NSIGMA )

c   for PHOTOZ fit, check if filters were added/dropped which 
c   can happen if photoZ_marg - photoZ_fit is  large enough.

        IF ( DOFIT_PHOTOZ ) THEN 
          ZPH8    = LCVAL_STORE(IPAR_zPHOT)
          ZPHERR8 = 0.0
          ITER    = NFIT_ITERATION+1
          LZPHOT  = LTEST_ZPHFILTER(ITER, ZPH8, ZPHERR8, IFILTBAD)      
          if ( .NOT. LZPHOT ) then
             ERRFLAG = ERRFLAG_ZFIT_RANGE
             return
          endif

        ENDIF

      ELSE IF ( LMCMC ) THEN
         CALL MCMC_DRIVER( HOFF
     &        ,NMCMC_CHAINS, NMCMC_EVAL, NMCMC_BURN
     &        ,LTUP_MCMC, IMCMC_STORE, MCMC_NSIG_STEP
     &        ,NSIG_MCMC_START
     &        )

      ENDIF

c store marginalized chi2 per filter

      DO ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)

         if ( ifilt_obs.GT.0 .and. USE_FILT(ifilt_obs) ) then

           NDOF = NEPOCH_FIT(ifilt) - NFITPAR(ifilt)
           LC_MARGCHI2(ifilt) = FCN_FITCHI2(ifilt)

           LTMP = NDOF .GT. 0 .and. LC_MARGCHI2(ifilt) .GE. 0.0 
           if ( LTMP ) then
              CHI8 = DBLE( LC_MARGCHI2(ifilt) )
              LC_MARGPROB(ifilt) = PROB_CHI2NDOF(CHI8, NDOF)
           else
              LC_MARGPROB(ifilt) = 1.0
           endif
         endif
      ENDDO

      RETURN
      END


C ============================================
+DECK,FCNSNLC.
      SUBROUTINE FCNSNLC(NVAR,GRAD,CHI2,XVAL,IFLAG, USRFUN )
c
c User function to be minimized (chi2, log-likelihood, etc ...).
c "USRFUN" is an optional function, for example from MC.
c YOU are responsible to sync XVAL(1:NFITPAR) in this function with
c INIVAL(1:NFITPAR) in FITPAR_PREP and with FITPAR(1_NFITPAR) 
c in FITPAR_ANA.
c
c The prior-chi2 "CHI2INI" is used for minimization.
c However, the stored chi2 "FCN_FITCHI2(0)" does NOT include
c CHI2INI so that the probability is based on the data and
c model, and not on the prior.  
c
c
c
c The data to compare the function to are in KEEP,SNCUTS
c in snana.car. A few useful variables are
c   
c   SNLC_CID         ! CID vs. sparse SN index
c   SNLC_NEPOCH_STORE      ! Number of Epochs
c
c   SNLC_RA          ! RA   vs. SN
c   SNLC_DECL        ! OBDECL vs. SN
c   SNLC_REDSHIFT    ! redshift used for analysis 
c
c   SNLC_XTINC_MW(MXFILT_ALL)  ! interstellar extinction
c
c   SNLC_FLUXCAL(MXFILT_OBS,MXEPOCH)
c   SNLC_FLUXCAL_ERRSTAT(MXFILT_OBS,MXEPOCH)
c   SNLC_FLUXCAL_ERRSYST(MXFILT_OBS,MXEPOCH)
c   SNLC_FLUXCAL_ERRTOT(MXFILT_OBS,MXEPOCH)
c
c   chi2 = D_i  COV_ij D_j
c
c
c
c  HISTORY
c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c
c Mar 1 2017: load R4EP(iep,JEP_MAGDIF)
c
c Jun 23 2019: protect I4EP_ALL array bound
c Jul 13 2019: 
c   + compute RATIO_ERR only if LFLAG_USER=T (to reduce compute time)
c   + apply SNR_RAW cut to compute R4SN_FFSUM_XXX
c
c Feb 28 2020: 
c   define DELCHI2_NOFUDGE to make test with DELCHI2_REJECT;
c   fixes long-standing bug when FUDGEALL_ITER1_MAXFRAC is set.
c
c ---------------------------------------------------
      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITIDEALCOM.

c subroutine ars

      INTEGER  
     &    NVAR    ! numnber of VARIABLE params only
     &   ,IFLAG

      DOUBLE PRECISION  GRAD(*), XVAL(*), chi2, USRFUN

      EXTERNAL USRFUN

c local arguments

      INTEGER
     &   ISN, ITER, ifilt, ipar, IFILT_obs, epoch, imjd, ifitdata
     &  ,NFITDATA_LOC, irow, icol, IERR, IDTEL
     &  ,NFITDATA_FILT(MXFILT_OBS), NDMPFCN(0:MXFILT_OBS)

      character cfilt*1

      DOUBLE PRECISION 
     &   ZSN, ZZ, CHI2INI, SHAPEPAR(2), DISTPAR, COLORPAR
     &  ,x0, S2a, S2b, MU, RVHOST, PEAKMJD, Trest, Tobs
     &  ,AVRV, MWAV, MWEBV, XTAV, XTMW, MJD, MJDFIT
     &  ,flux_data, flux_data_errtot, flux_data_sqerrtot
     &  ,signoise_data, signoise_model
     &  ,flux_model, flux_model_err ,flux_model_sqerr
     &  ,flux_fudge_sqerr, flux_fudge_err, flux_errtot
     &  ,errtmp, arg, RATIO, RATIO_ERR, WGT, MAGDIF, SNR_FIT, SNR_RAW
     &  ,AVwarp, mag_kcor(2), mag_tmp, mag_err
     &  ,dif, sqdif, sqsig, inv_sqsig, sqsig_nofudge
     &  ,delchi2, delchi2_diag, delchi2_sigma, delchi2_nofudge
     &  ,chi2filt_sigma(MXFILT_OBS),chi2sum_sigma,chi2filt(MXFILT_OBS)
     &  ,errfrac, DEL_FLUX(MXFIT_DATA)
     &  ,FF, COV_INV, x1, DT1, DT2, CHI2PRIOR(0:MXFITPAR)
     &  ,LAMAVG, XVAL4COV(MXFITPAR)

      LOGICAL 
     &   LFLAG_FIRST_MN  ! first call from MINUIT (IFLAG=2)
     &  ,LFLAG_LAST_MN   ! last call from MINUIT  (IFLAG=3)
     &  ,LFLAG_USER      ! called from user (IFLAG=30)
     &  ,LFLAG_USESIM    ! use SIM params instead of XVAL (IFLAG=99)
     &  ,LFLAG_FAST      ! speed up if possible (for pdf integration)
     &  ,LFLAG_FIT, LFLAG_PRIOR_ONLY, LFLAG_SIGMA_ONLY
     &  ,LAST, LDMPFCN_LOC, LDMPFUN_LOC, LREJECT, LREJECT2, LFITDATA  
     &  ,FIRSTFILT, LASTFILT, LMWCOR, LIGNORE, LTMP, LMUFIX, LPOSFLUX
     &  ,FIRST_ITER
     &  ,REJECT_TREST, REJECT_MJD, REJECT_SIGNOISE, REJECT_DELCHI2

      CHARACTER CVAR*8, star*1
      REAL*8 delchi2_off(2000)
      REAL*4 LAMREST4

c functions
      REAL*8  
     &   FCNCHI2_PRIOR, FCNCHI2_SIGMA, DLMAG8_REF
     &  ,GET_RV8, GET_DIST8, SALT2xx1

      LOGICAL FIRST_ITERATION

C ----------- BEGIN ------------

      CHI2 = 1.0E7

      LFLAG_FIRST_MN   = IFLAG .EQ.  2   ! first MINUIT call
      LFLAG_LAST_MN    = IFLAG .EQ.  3   ! last MINUIT call here => store info
      LFLAG_FIT        = IFLAG .EQ.  4   !
      LFLAG_USER       = IFLAG .EQ. FCNFLAG_USER ! user-call (NOT from MINUIT)
      LFLAG_USESIM     = IFLAG .EQ. FCNFLAG_USESIM ! use sim params 
      LFLAG_FAST       = IFLAG .EQ. FCNFLAG_FAST
      LFLAG_PRIOR_ONLY = IFLAG .EQ. FCNFLAG_PRIOR_ONLY
      LFLAG_SIGMA_ONLY = IFLAG .EQ. FCNFLAG_SIGMA_ONLY

      LAST = LFLAG_LAST_MN .or. LFLAG_USER .or. LFLAG_USESIM
cc      LAST = LFLAG_LAST_MN .or. LFLAG_USESIM ! xxx TEST

      R4SN_FFSUM_DATA  = 0.0
      R4SN_FFSUM_MODEL = 0.0 
      R4SN_FFSUM_CROSS = 0.0 
      R4SN_FFSUM_WGT   = 0.0 
      R4SN_FFSUM_RATIO = 0.0 

      IF ( LAST ) THEN
c include rejects on last iter
         NFITDATA_LOC = NFITDATA + NFITDATA_REJECT 
      ELSE
         NFITDATA_LOC = NFITDATA
      ENDIF

c extract parameters into local variables

      ITER       = int ( XVAL(IPAR_ITER) )
      ISN        = int ( XVAL(IPAR_ISN)  )
      if ( ITER .EQ. 0 .OR. ISN .EQ. 0 ) RETURN

      FIRST_ITER = FIRST_ITERATION(ITER) 

      COLORPAR    = XVAL(IPAR_AV)       !  AV or c
      AVRV        = XVAL(IPAR_AVRV) 
      SHAPEPAR(1) = XVAL(IPAR_SHAPE)
      SHAPEPAR(2) = XVAL(IPAR_SHAPE2)
      PEAKMJD     = XVAL(IPAR_PEAKMJD)
      DISTPAR     = XVAL(IPAR_DLMAG)    ! MU or x0
      ZSN         = XVAL(IPAR_zPHOT)
      RVHOST      = GET_RV8(XVAL)
      MWEBV       = DBLE( SNLC_MWEBV )
      MWAV        = MWEBV/RV_MWCOLORLAW

c check for photoZ fit that constrains DLMAG to input cosmology.

      LMUFIX = (DOFIT_PHOTOZ .and. (INISTP_DLMAG .EQ. 0.0) )
      IF ( LMUFIX ) THEN
         DISTPAR = GET_DIST8(ZSN,SHAPEPAR(1),COLORPAR,ONE8)
      ENDIF 

      ZZ  = 1.0 + ZSN

      IF ( LFLAG_USESIM .and. LSIM_SNANA ) THEN
         COLORPAR     = SIMVAL_STORE(IPAR_AV)
         RVHOST       = SIMVAL_STORE(IPAR_RV)
         DISTPAR      = SIMVAL_STORE(IPAR_DLMAG)
         SHAPEPAR(1)  = SIMVAL_STORE(IPAR_SHAPE)
         SHAPEPAR(2)  = SIMVAL_STORE(IPAR_SHAPE2)
         PEAKMJD      = SIMVAL_STORE(IPAR_PEAKMJD) - MJDOFF
         ZSN          = SIMVAL_STORE(IPAR_zPHOT)
      ENDIF

c ------------------------------------
c Get initial CHI2 from priors.

      IF ( LFLAG_SIGMA_ONLY ) THEN
        CHI2INI = 0.0
      ELSE
        CHI2INI = FCNCHI2_PRIOR(XVAL,CHI2PRIOR)      
      ENDIF

      CHI2    = CHI2INI
      chi2sum_sigma = 0.0

c bail on large CHI2INI unless we are dumping.

      if ( CHI2 .GT. 1.0E7  .and. .not. LDMPFCN(0) ) RETURN
      if ( LFLAG_PRIOR_ONLY ) RETURN

c -------------------------------------------

      DO ifilt = 1, MXFILT_OBS
         CHI2FILT(ifilt)       = 0.0
         CHI2FILT_SIGMA(ifilt) = 0.0
         NFITDATA_FILT(ifilt)  = 0
         NDMPFCN(ifilt)        = 0
      ENDDO
         NDMPFCN(0)        = 0

      FIRSTFILT = .TRUE.

c ------------------------------------

      DO 102 ifitdata   = 1, NFITDATA_LOC

        epoch           = EPLIST_FIT(ifitdata)
        ifitdata_usrfun = ifitdata  ! load common block for USRFUN

        LFITDATA = ifitdata .LE. NFITDATA

        ifilt     = I4EP_ALL(epoch,IEP_IFILT)
        ifilt_obs = I4EP_ALL(epoch,IEP_IFILT_OBS)
        cfilt     = filtdef_string(ifilt_obs:ifilt_obs) ! for debug only

c    protect model against invalid rest-frame lambda values (Mar 29, 2011)
        LAMAVG    = DBLE( FILTOBS_LAMAVG(ifilt_obs) )
        LAMREST4  = SNGL(LAMAVG /ZZ)

        if ( LAMREST4 > RESTLAMBDA_USEFIT(2) ) GOTO 102
        if ( LAMREST4 < RESTLAMBDA_USEFIT(1) ) GOTO 102

        MJD                = R8EP_MJD(ifitdata)
        MJDFIT             = MJD - MJDOFF

        flux_data        = dble ( R4EP_ALL(epoch,JEP_DATAFLUX) )
        flux_data_errtot = dble ( R4EP_ALL(epoch,JEP_DATAFLUX_ERR) )
        flux_fudge_err   = dble ( R4EP_ALL(epoch,JEP_FUDGEFLUX_ERR) )

        flux_fudge_sqerr   = flux_fudge_err   * flux_fudge_err
        flux_data_sqerrtot = flux_data_errtot * flux_data_errtot  

c compute data SNR with/without fudged error
        errtmp = dsqrt(flux_data_sqerrtot + flux_fudge_sqerr)
        SNR_FIT   = flux_data / errtmp
        SNR_RAW   = flux_data / flux_data_errtot
        
        Tobs      = MJDFIT - PEAKMJD    ! observation time, days
        Trest     = Tobs / ZZ 
  
        Nfitdata_filt(ifilt) = Nfitdata_filt(ifilt) + 1
        LASTFILT  = Nfitdata_filt(ifilt) .EQ. NEPOCH_FIT(ifilt)

c set local dump logicals = namelist flag .and. (debug option)     

         LDMPFCN_LOC = LDMPFCN(ifilt_obs) 
     &        .and. LFITDATA  ! .and. FIRST_ITERATION(ITER) 
  
         if(DOFIT_IDEAL .and. ITER<3 ) LDMPFCN_LOC = .FALSE. ! xxx DEBUG ONLY
 
         LDMPFUN_LOC = LDMPFUN(ifilt_obs) 
     &           .and. Trest .GE. TREST_DMPFUN(1)
     &           .and. Trest .LE. TREST_DMPFUN(2)
     &           .and. LFITDATA 

c dumpe header just once per filter.
         if(LDMPFCN_LOC .and. FIRSTFILT ) then

              print*,' '
              print*,' -------------------------------------- '
              write(6,602) SNLC_CCID,  ITER, IFLAG
602           format(T5,'PREPARE FCNSNLC DUMP for CID= ', A16, 
     &              3x,'   (ITER=',I2, 2x, 'IFLAG=',I2, ')' ) 

c print  fit-pars to see crazy values.

              write(6,603) 'ZSN', ZSN
              write(6,604) 'PEAKMJD', PEAKMJD
              write(6,603)  PARNAME_STORE(IPAR_AV)(1:6), COLORPAR
              if ( INISTP_AVRV .GT. 0.0 ) then
                write(6,603)  PARNAME_STORE(IPAR_AVRV)(1:6), AVRV
                write(6,603)  'RVHOST', RVHOST
              endif

              write(6,603) 'MWAV', MWAV
              write(6,603) 'SHAPE', SHAPEPAR(1)
              write(6,603)  PARNAME_STORE(IPAR_DLMAG)(1:6), DISTPAR

603           format(T7, A, T17,'= ', G14.6 )
604           format(T7, A, T17,'= ', F12.4 )

c print non-zero chi2prior contributions

              print*,' '
              DO ipar = 0, IPAR_MAX
                if ( ipar .EQ. 0 ) then
                    CVAR = 'SIMEFF'
                else
                    CVAR = PARNAME_STORE(ipar)
                endif
                if ( CHI2PRIOR(ipar) .GT. 0.0 ) then
                  write(6,690) CVAR, CHI2PRIOR(ipar)
690               format(T8,'CHI2PRIOR(', A8, ') = ', G12.4 )
                endif
                CALL FLUSH(6)
              ENDDO

c always print total prior-chi2
              print*,'      CHI2PRIOR(TOTAL) = ', SNGL(CHI2INI)
             
              CALL FLUSH(6)
         endif  ! end of DUMP

         IF ( FIRSTFILT ) FIRSTFILT = .FALSE.

c =====================
c get flux (observer frame) from model
c Note that info on all five filters is passed.

        flux_model = 
     &       USRFUN ( ITER, IFILT_OBS, ZSN, Tobs  ! (I)
     &          ,SHAPEPAR           ! (I) delta, stretch, x1 ...
     &          ,DISTPAR            ! (I) MU or x0
     &          ,COLORPAR           ! (I) AV or c
     &          ,RVHOST             ! (I) color law
     &          ,MWEBV              ! (I) MW extinct
     &          ,LDMPFUN_LOC        ! (I)
     &          ,AVwarp             ! (O) AV warp for SEC
     &          ,MAG_KCOR           ! (O) K-correction & error
     &          ,XTAV               ! (O) host-gal extinct in rest-filter
     &          ,XTMW               ! (O) MW extinct in obs-filter (mag)
     &          ,MAG_ERR            ! (O) mag error from model
     &                )

c convert MAG_ERR into flux-error

        errfrac          = 1.0 - TEN8**(-0.4*MAG_ERR)   
        flux_model_err   = flux_model * errfrac
        flux_model_sqerr = flux_model_err * flux_model_err 

c ---------------------------------------------
c get data-model chi2 ;
c if USE_FITCOV=T, then sum diagonal elements of cov matrix.

        dif      = flux_data - flux_model
        sqdif    = dif * dif

        IF ( USE_FITCOV ) THEN
           sqsig         = 1.0 / covmat2(ifitdata,ifitdata)
           delchi2_diag  = sqdif / sqsig 
        ENDIF

c always evaluate simple chi2 ignoring covariance
        sqsig   = flux_data_sqerrtot + flux_model_sqerr
     &          + flux_fudge_sqerr
        sqsig_nofudge = flux_data_sqerrtot + flux_model_sqerr
        inv_sqsig     = 1.0/sqsig

        flux_errtot = dsqrt(sqsig)
                
        delchi2         = sqdif * inv_sqsig
        delchi2_nofudge = sqdif/sqsig_nofudge
        IF ( RESTORE_DES3YR ) delchi2_nofudge = delchi2

        IF ( LFLAG_SIGMA_ONLY ) THEN
          delchi2         = 0.0
          delchi2_diag    = 0.0
          delchi2_nofudge = 0.0
        ENDIF

c 5/08/2009: tack on chi2 from model-error (2nd iter only)
        delchi2_sigma = FCNCHI2_SIGMA(iter,epoch,flux_errtot)

        IF ( LFITDATA ) then
          DEL_FLUX(ifitdata)  = dif
          chi2filt(ifilt) = chi2filt(ifilt) + delchi2

          chi2filt_sigma(ifilt) = 
     &    chi2filt_sigma(ifilt) + delchi2_sigma

c sum chi2_sigma over all epochs ... sum used only for OPT_COVAR_FLUX > 0
          chi2sum_sigma = chi2sum_sigma   + delchi2_sigma

          if ( USE_FITCOV ) then
             chi2  = chi2  + delchi2_diag   ! diag part of chi2
          else  
             chi2  = chi2  + delchi2        ! add conventional chi2
          endif

c always tack on chi2 from log(sigma) term
          chi2  = chi2 + delchi2_sigma 

        ENDIF

c if fast-flag is set, quit when chi2 is too big;
c this corresponds to tiny pdf in integral.

        if ( LFLAG_FAST .and.  chi2 .GT. FITCHI2_QUIT ) return
   
c check dump-flag again; print every epoch here

        if ( LDMPFCN_LOC ) then
            write(6,666) cfilt, Trest, delchi2
     &          ,flux_model, flux_model_err
     &          ,flux_data, flux_data_errtot

666         format(2x,A,  2x, 'Trest=',F6.2, 2x,'dchi2=',F9.5, 2x,
     &        'Fmodel=',E9.3,'+-',E8.3, 2x, 
     &        'Fdata=', E9.3,'+-',E8.3  )

            NDMPFCN(0)     = NDMPFCN(0) + 1
            NDMPFCN(ifilt) = NDMPFCN(ifilt) + 1
            CALL FLUSH(6)

        endif 

c always store flux for model in case we need to re-compute
c covariance matrix each time. The other EP_XXX arrays are
c computed inside LAST if-block.

        R4EP_ALL(epoch,JEP_MODELFLUX)     = flux_model 
        R4EP_ALL(epoch,JEP_MODELFLUX_ERR) = flux_model_err
        R4EP_ALL(epoch,JEP_FLUX_ERRTOT)   = flux_errtot 

        IF ( LAST ) THEN

c increment SNRMAX for fitted epochs only
           if ( LFITDATA ) then
             R4BAND_SNRMAX_FIT(ifilt) = 
     &          MAX ( R4BAND_SNRMAX_FIT(ifilt), SNR_FIT )
             R4BAND_SNRMAX_RAW(ifilt) = 
     &          MAX ( R4BAND_SNRMAX_RAW(ifilt), SNR_RAW )
           endif

           if ( flux_model .GT. 0.0 ) then
             mag_tmp = -2.5 * dlog10(flux_model)   ! model-mag_{obs}
     &               + ZEROPOINT_FLUXCAL_DEFAULT

             R4EP_ALL(epoch,JEP_MODELMAG)     = mag_tmp
             R4EP_ALL(epoch,JEP_MODELMAG_ERR) = mag_err
           endif

           mag_tmp = SNLC_MAG(epoch)
           IF( USE_MWCOR) mag_tmp = mag_tmp - SNLC_MWXT_MAG(ifilt)  
           R4EP_ALL(epoch,JEP_DATAMAG)     = mag_tmp
           R4EP_ALL(epoch,JEP_DATAMAG_ERR) = SNLC_MAG_ERRPLUS(epoch) 

           R4EP_ALL(epoch,JEP_XTHOST)   = XTAV 
           R4EP_ALL(epoch,JEP_MWXT)     = XTMW 

           IF ( LREST_FITMODEL ) THEN
             R4EP_ALL(epoch,JEP_KCOR)       = MAG_KCOR(1)
             R4EP_ALL(epoch,JEP_KCOR_ERR)   = MAG_KCOR(2)
             R4EP_ALL(epoch,JEP_AVWARP)     = AVWARP

c xxx remove harmless bug, Jan 2020  arg = 0.4*(MAG_KCOR(1) + SNLC_DLMAG)
             arg = 0.4*(MAG_KCOR(1) + DISTPAR)
             R4EP_ALL(epoch,JEP_DATAFLUX_REST)= flux_data * 10.0**(arg)
           ENDIF


c data/Model ratio
           RATIO=0.0; RATIO_ERR=0.0; MAGDIF=-9.0
           LPOSFLUX = ( abs(flux_model) .GT. 1.0E-21 )
           if ( LPOSFLUX )      RATIO  = flux_data / flux_model
           if ( RATIO > .001 )  MAGDIF = -2.5*log10(RATIO)

           if ( LPOSFLUX .and. LFLAG_USER ) then ! limit calc to USER only
              sqsig = ( flux_data_errtot  / flux_data  )**2
     &              + ( flux_model_err    / flux_model )**2
              errfrac    = dsqrt(sqsig)
              RATIO_ERR  = abs(RATIO) * errfrac
           endif

           sqsig = flux_data_errtot**2 + flux_model_err**2

           R4EP_ALL(epoch,JEP_RATIO)       = RATIO
           R4EP_ALL(epoch,JEP_RATIO_ERR)   = RATIO_ERR
           R4EP_ALL(epoch,JEP_RESID)       = dif
           R4EP_ALL(epoch,JEP_RESID_ERR)   = dsqrt ( sqsig )
           R4EP_ALL(epoch,JEP_MAGDIF)      = magdif
           R4EP_ALL(epoch,JEP_TREST)       = Trest
           R4EP_ALL(epoch,JEP_TOBS)        = Tobs
           R4EP_ALL(epoch,JEP_MJD)         = MJDFIT
           R4EP_ALL(epoch,JEP_DELCHI2)     = DELCHI2   
           FCN_FITCHI2(0)          = chi2 - CHI2INI

           DT1 = abs(Trest)
           DT2 = abs( R4BAND_TREST_NEARPEAK(ifilt_obs) )
           if ( DT1 < DT2 ) then
             R4BAND_XTMW_NEARPEAK(ifilt_obs)  = XTMW
             R4BAND_TREST_NEARPEAK(ifilt_obs) = Trest
             I4BAND_EP_NEARPEAK(ifilt_obs)    = epoch
           endif

c check for epochs to reject at end of 1st iteration only (note LAST=T here)

           if ( FIRST_ITER .and. IFLAG <= 4 ) then  ! includes iter=1 repeat

              signoise_data  = flux_data  / flux_data_errtot
              signoise_model = flux_model / flux_data_errtot

              REJECT_TREST   = 
     &           (Trest < FITWIN_TREST_FILT(1,ifilt_obs) ) .or. 
     &           (Trest > FITWIN_TREST_FILT(2,ifilt_obs) )
              REJECT_MJD = 
     &          (MJD < FITWIN_MJD(1)) .or. (MJD > FITWIN_MJD(2))

              REJECT_DELCHI2  = (delchi2_nofudge  > DELCHI2_REJECT  )
              REJECT_SIGNOISE = (signoise_data < SIGNOISE_REJECT)

              LREJECT  = 
     &              REJECT_DELCHI2 .or. REJECT_SIGNOISE .or. 
     &              REJECT_TREST   .or. REJECT_MJD
              
              LREJECT2  = 
     &            (REJECT_DELCHI2 .or. REJECT_SIGNOISE) .and.
     &            (.not. REJECT_TREST )

              if ( epoch < MXFIT_DATA ) then
                I4EP_ALL(epoch,IEP_REJECT)  = 0
                I4EP_ALL(epoch,IEP_REJECT2) = 0
                if ( LREJECT  ) I4EP_ALL(epoch,IEP_REJECT)  = 1          
                if ( LREJECT2 ) I4EP_ALL(epoch,IEP_REJECT2) = 1  ! Mar 2020
              endif

           endif  ! end FIRST_ITERATION

           if ( LFITDATA .and. (.NOT.LFLAG_USESIM) ) then

             FCN_FITCHI2(ifilt)  = 
     &       FCN_FITCHI2(ifilt)  + sqdif / sqsig_nofudge  ! DELCHI2

             if ( Trest .LT. R4SN_Tearly ) R4SN_Tearly = Trest
             if ( Trest .GT. R4SN_Tlate  ) R4SN_Tlate  = Trest

             if ( MJD .LT. R4SN_MJDmin ) R4SN_MJDmin = MJD
             if ( MJD .GT. R4SN_MJDmax ) R4SN_MJDmax = MJD

             ! sums used for initializing photoz x0/MU
             if ( LFLAG_USER .and. SNR_RAW > 3.0 .and. 
     &            ISCALE_COURSEBIN_PHOTOZ > 0 ) then
                R4SN_FFSUM_DATA   = R4SN_FFSUM_DATA  
     &               + (flux_data**2)*inv_sqsig
                R4SN_FFSUM_MODEL  = R4SN_FFSUM_MODEL  
     &               + (flux_model**2)*inv_sqsig
                R4SN_FFSUM_CROSS  = R4SN_FFSUM_CROSS  
     &               + (flux_data*flux_model)*inv_sqsig


             endif

           endif

        ENDIF  ! end of LAST if-block

102   CONTINUE  ! end of IFITDATA loop     

c -----------------------

c check DUMP flags.

      IF ( NDMPFCN(0) .GT. 0 ) THEN

        star = ' '
        if ( LREPEAT_ITER ) star = '*'

        DO ifilt = 1, MXFILT_OBS

          LTMP = NFITDATA_FILT(ifilt)>0 .and. NDMPFCN(ifilt).GT.0  
          IF ( LTMP ) THEN
            ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
            cfilt     = filtdef_string(ifilt_obs:ifilt_obs)

           write(6,672) ITER, star
     &          ,NEPOCH_ALL(ifilt)
     &          ,NEPOCH_REJECT(ifilt)
     &          ,cfilt, chi2filt(ifilt)
     &          ,chi2filt_sigma(ifilt)

672        format(T3, 'ITER=',I1,A, '  NEPOCH=',I3,'-',I2,' : ', 
     &         'CHI2-TOT(',A1,')=', G10.5, 2x ,
     &         'CHI2(SIGMA)=', G12.3 )

          ENDIF
        ENDDO
        print*,'   CHI2-TOT(all filters) = ', chi2
        print*,'      ********* END OF FCN DUMP ********** '
        CALL FLUSH(6)
      ENDIF

c ----------------------------------

      IF ( LFLAG_SIGMA_ONLY ) RETURN
      IF ( LFLAG_USESIM     ) RETURN

c ----------------------
c compute chi2 from covariance matrix
       
      IF ( USE_FITCOV ) THEN
        chi2    = CHI2INI + chi2sum_sigma

c  check option to re-compute covariance inside minuit function
        if ( OPT_COVAR_FLUX .EQ. 2 ) then
           DO ipar = 1, NFITPAR_MN
             XVAL4COV(ipar) = XVAL(ipar)  ! used for COV opt
           ENDDO

c    modify x1 for SALT2 model.
           if  ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN
             x1 = XVAL4COV(IPAR_SHAPE)
             XVAL4COV(IPAR_SHAPE)  = SALT2xx1(ITER,x1)
           endif

c  re-compute COVARIANCE and its inverse => COVMAT2
c  1st arg OPT=0 suppresses printing.
           CALL FITINI_COV(0,iter,XVAL4COV,IERR)
        endif

c loop over COV_INV elements and compute chi2

        DO 801 irow = 1,    NFITDATA
        DO 802 icol = irow, NFITDATA
           COV_INV  = covmat2(irow,icol)
           if ( COV_INV .EQ. 0.0 ) GOTO 802

           FF   = del_flux(irow) * del_flux(icol)
           if ( irow .EQ. icol ) then         
              chi2 = chi2 + (FF * COV_INV)
           else
              chi2 = chi2 + (FF * COV_INV * 2.)  ! include ij + ji terms
           endif

c   check option to include log[det(COV_INC)] term
ccc xxx not yet ...  chi2 = chi2 - log(DETERM_COVMAT2)

802     CONTINUE
801     CONTINUE


        FCN_FITCHI2(0) = chi2 - chi2ini

      ENDIF  ! end of LFLAG_COVAR loop

      RETURN
      END  ! FCNSNLC


C ==============================================================
+DECK,FCNCHI2_PRIOR.
      DOUBLE PRECISION FUNCTION FCNCHI2_PRIOR(XVAL,CHI2PRIOR)
c
c Created Apr 03, 2009 by R.Kessler
c Evaluate prior-chi2 and return total prior-chi2.
c
c Jul 17, 2009: add RV as argument to SNLC_SIMEFF
c
c Jul 27, 2009: evaluate MJD-prior directory instead of
c               using CHI2_PRIOR ; when OPT_PRIOR=0, still
c               uses MJD prior to protect against crazy values.
c
c               When OPT_PRIOR=0, goto 888 (instead of return)
c               to add up protective priors.
c
c Jul 28, 2009: add protection against MU < MUMIN(=10)
c
c Jul 25, 2011: call new get_SIMEFFMAP() and allow effic-prior
c               to work on any model (not just MLCS)
c
c May 06, 2013: fix subtle bug checking for NaN ... skip ITER and ISN 
c               because INIBND is not set for these parameters.
c
c Apr 3 2018: include color-prior chi2
c
c Jun 2022: check option to use zphot quantiles
c
c --------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.

c function args
      REAL*8
     &   XVAL(MXFITPAR)         ! (I) fit parameters
     &  ,CHI2PRIOR(0:MXFITPAR)  ! (O) prior-chi2 for SEEFF & each parameter

c local args

      INTEGER  IPAR, ISN, IERR, IPAR_DIST, q

      REAL*8
     &   CHI2INI, CHI2TMP
     &  ,COLOR, COLORMAX, RV, SHAPE(2), PEAKMJD, DIST, MU, ZSN
     &  ,arg_tmp, DIF, pull, EFF, SQSIG, PROBZ 

      LOGICAL LTMP, LBADVAL

c define max color and MU for which exponential priorchi2 is used
c to prevent MINUIT from probing extreme values.

      REAL*8  CMAX_SALT2, AVMAX, MUMIN, MUMAX
      PARAMETER (
     &   CMAX_SALT2 = 0.5  ! max abs(color) for SALT2
     &  ,AVMAX      = 5.0  ! max AV for host-galaxy extinction
     &  ,MUMIN      = 10.  ! min dist mod
     &  ,MUMAX      = 60.  ! max distance mod.
     &     )

c functions
      REAL*8 
     &   CHI2_PRIOR
     &  ,PRIOR_ZPULL
     &  ,PRIOR_MUPULL
     &  ,GET_RV8
     &  ,SNLC_FIT_SIMEFF
     &  ,eval_zPDF_spline

      EXTERNAL eval_zPDF_spline

c ------------- BEGIN --------------


c init output
      FCNCHI2_PRIOR = 0.0  
      LBADVAL = .FALSE.
    
c init CHI2PRIOR and check for crazy fit params
      
      CHI2PRIOR(0) = 0.0
      DO 100 IPAR = 1, MXFITPAR
         CHI2PRIOR(ipar) = 0.0

         IF ( IPAR .EQ. IPAR_ITER ) GOTO 100
         IF ( IPAR .EQ. IPAR_ISN  ) GOTO 100

c check for NANs
         LTMP = XVAL(ipar) .GE. INIBND(1,ipar) 
     &    .and. XVAL(ipar) .LE. INIBND(2,ipar) 

         if ( .NOT. LTMP ) then
            CHI2PRIOR(ipar) = 1.111E9
            LBADVAL = .TRUE.
         endif
100   CONTINUE

      if ( LBADVAL ) goto 888

c strip off XVAL parameters into local variables.

      ISN        = int ( XVAL(IPAR_ISN) )
      COLOR      = XVAL(IPAR_AV)       !  AV or c
      RV         = GET_RV8(XVAL)
      SHAPE(1)   = XVAL(IPAR_SHAPE)
      SHAPE(2)   = XVAL(IPAR_SHAPE2)
      PEAKMJD    = XVAL(IPAR_PEAKMJD)
      DIST       = XVAL(IPAR_DLMAG)    ! MU or x0
      ZSN        = XVAL(IPAR_zPHOT)


      IF ( PARNAME_STORE(IPAR_DLMAG) .EQ. 'DLMAG' ) THEN
         MU = DIST
         COLORMAX = AVMAX
      ELSE

c translate SALT2 params into distance modulus
         MU = 30.0 - 2.5*log10(DIST) 
     &      + (SALT2alpha*SHAPE(1)) - (SALT2beta * COLOR)

         COLORMAX = CMAX_SALT2
      ENDIF


c priors for all models to protect against crazy MINUIT excursions

      DIF     = PEAKMJD  - INIVAL(IPAR_PEAKMJD)
      CHI2PRIOR(IPAR_PEAKMJD)
     &        = CHI2_PRIOR(ipar_PEAKMJD,DIF)

c protect against crazy COLOR values
      if ( abs(COLOR) .GT. COLORMAX ) then
          DIF     = abs(COLOR) - COLORMAX
          arg_tmp = 0.5 * (DIF * DIF)
          CHI2PRIOR(IPAR_AV) = dexp(arg_tmp) - 1.0
      endif


c protect against against absurdly small & large distances
c (because MINUIT sometimes tries really crazy values)

      IPAR_DIST = IPAR_DLMAG  ! MU or x0

      if ( MU .LT. MUMIN ) then
         DIF     = MUMIN - MU
         arg_tmp = 0.5 * (DIF*DIF)
         CHI2PRIOR(IPAR_DIST) = dexp(arg_tmp) - 1.0
      endif
      if ( MU .GT. MUMAX ) then
         DIF     = MU - MUMAX
         arg_tmp = 0.5 * (DIF*DIF)
         CHI2PRIOR(IPAR_DIST) = dexp(arg_tmp) - 1.0
      endif

      IF ( OPT_PRIOR .EQ. 0 ) GOTO 888

c avoid crazy redshift value
      if ( ZSN .LT. Zat10pc ) then
          CHI2PRIOR(IPAR_zPHOT) = 1.0E8
          GOTO 888
      endif 


c -----------------------------------------
c Prior on photoZ

      IF ( DOFIT_PHOTOZ ) THEN

        if ( btest(OPT_PHOTOZ,BIT_PHOTOZ_QUANTILES) ) then
          ! get the probability at this redshift
c          Print *, 'xxx Evaluating spline at ', ZSN
          PROBZ = eval_zPDF_spline(ZSN)
c          Print *, 'xxx Probability is ', PROBZ
          if ( PROBZ .le. 0. ) PROBZ = 1.0E-20
          CHI2PRIOR(IPAR_zPHOT) = -2.0*DLOG( PROBZ )
c          Print *, 'xxx Chi2 is ', CHI2PRIOR(IPAR_zPHOT)
        else
          pull   = PRIOR_ZPULL(ZSN)
          CHI2PRIOR(IPAR_zPHOT) = CHI2_PRIOR(ipar_zPHOT,pull)
        endif

        pull   = PRIOR_MUPULL(isn,ZSN,MU)
        CHI2PRIOR(IPAR_DLMAG) = CHI2PRIOR(IPAR_DLMAG) +
     &  CHI2_PRIOR(ipar_DLMAG,pull)

      ENDIF

c -------------------------
c prior on shape
      CHI2PRIOR(IPAR_SHAPE) 
     &          = CHI2_PRIOR(IPAR_SHAPE,SHAPE(1))

c ----------------------
c prior on SALT2 color (Apr 2018)

      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN
        CHI2PRIOR(IPAR_COLOR) 
     &          = CHI2_PRIOR(IPAR_COLOR,COLOR)
      ENDIF

c ----------------------------------------------
c Jul 25, 2011: prior for simulated efficiency

      IF ( OPT_PRIOR_SIMEFF .GT. 0  ) THEN
         EFF = SNLC_FIT_SIMEFF(ISN,XVAL)
         CHI2PRIOR(0) = -2.0*DLOG( EFF ) 
      ENDIF


c =================================================
cc      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) GOTO 888
      IF ( LOBS_FITMODEL ) GOTO 888  ! Jul 25, 2011
c =================================================

c Prior on AV
      IF ( INISTP_AV .NE. 0.0 ) then
        CHI2PRIOR(IPAR_AV)      
     &          = CHI2_PRIOR(ipar_av,COLOR)
        CHI2PRIOR(IPAR_RV)      
     &          = CHI2_PRIOR(ipar_rv,XVAL(IPAR_RV) )
      ENDIF


888   CONTINUE
c sum all the pieces
      DO IPAR = 0, MXFITPAR
         FCNCHI2_PRIOR = FCNCHI2_PRIOR + CHI2PRIOR(ipar) 
      ENDDO

      RETURN
      END

C ==============================================
+DECK,FCNCHISIG.
      DOUBLE PRECISION FUNCTION FCNCHI2_SIGMA(iter,iepoch,fluxerr)

c --------------------------
c Created April 23, 2011
c [moved code out of FCNSNLC to clean up and fix bug]
c
c Return chi2 contribution from error-term, relatiave to last interation.
c The nominal term is -2ln(FLUXERR) but instead here we compute
c
c      FCNCHI2_SIGMA = -2ln(FLUXERR/LAST_FLUXERR)
c
c so that this is nominally ~zero if the flux-error does not
c change much between iterations.
c
c Also fix bug by returning zero if 1st-iteration FLUXERR=0 ...
c this can happen if a new filter is added in the 2nd iteration.
c 
c Aug 22, 2011: allow CHI2_SIGMA calc if OPT_COVAR_FLUX > 0
c Jan 25, 2014: 
c   * use new R4EP_LAST array
c   * pass iepoch instead of ifitdata
c
c ------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNFITCOM.
c +CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.

c function args
      INTEGER 
     &   ITER         ! (I) fit iteration
     &  ,IEPOCH       ! (I) index to R4EP arrays
     
      REAL*8 FLUXERR ! (I) error on flux

c local args

      INTEGER IFILT_OBS
      REAL*8  SIGRAT, LAST_FLUXERR
      CHARACTER CFILT*2

c function
      LOGICAL FIRST_ITERATION

c ----------- BEGIN -----------

      FCNCHI2_SIGMA = 0.0               ! init to zero chi2
      IF ( FIRST_ITERATION(ITER) ) RETURN 
      IF ( .NOT. DOCHI2_SIGMA    ) RETURN  ! check user option

      LAST_FLUXERR = DBLE( R4EP_LAST(iepoch,JEP_FLUX_ERRTOT) )

      if ( LAST_FLUXERR .LE. 1.0E-11 ) RETURN

c      ifilt_obs = I4EP_ALL(iepoch,IEP_IFILT_OBS)  ! for debug only
c      cfilt     = filtdef_string(ifilt_obs:ifilt_obs) ! for debug only

      SIGRAT = FLUXERR/LAST_FLUXERR
      FCNCHI2_SIGMA = 2.*dlog(sigrat)

      RETURN
      END

C ==============================================
+DECK,USRFUN.
      DOUBLE PRECISION FUNCTION USRFUN (
     &   ITER        ! (I) fit iteration used for parm-dependent error calc
     &  ,IFILT_OBS   ! (I) index of observer -filter
     &  ,ZSN         ! (I) redshift
     &  ,Tobs        ! (I) T - Tpeak, observer frame
     &  ,SHAPE       ! (I) shape-par (DELTA, STRETCH, ETC ... )
     &  ,DIST        ! (I) MU=5*LOG10(10pc/DL) or x0
     &  ,AVHOST      ! (I) extinction in SN host galaxy (not used)
     &  ,RVHOST      ! (I) RV in SN host gal (not used)
     &  ,MWEBV       ! (I) local MW extinction (add 1/25/2007)
     &  ,LDMP        ! (I) dump-option
     &  ,AVwarp      ! (O) "AV" used to warp spectral template
     &  ,mag_kcor    ! (O) K-correction & error used
     &  ,mag_xtav    ! (O) host-gal extinction in rest-frame filter
     &  ,mag_xtmw    ! (O) MW extinction on obs-frame filter
     &  ,mag_err     ! (O) mag-error from model
     &    )

c ----------------------------------------------------
c  Returns predicted Flux based on input parameters.
c
c
c Jan 16, 2012: fix long-standing patchy bug NOAVWARP;
c               test-code had always been included, 
c               thus blowing up the errors.
c
c Jul 2013: change name of MU argument to DIST
c
c Sep 22 2013: add args RV and OPT_MWCOLORLAW to get_mwxt8().
c
c Mar 19 2018: call SALT2zz to get redshift used in error calc.
c              Goal is to remove photo-z pathologies.
c
c ----------------------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNFITCOM.
+CDE,SNANAFIT.  PARNAME_STORE is here
+CDE,FILTCOM.
+CDE,SNLCINP.  NFIT_ITERATION is here

cc      DOUBLE PRECISION USRFUN

c function args

      INTEGER ITER, IFILT_OBS  ! (I)

      DOUBLE PRECISION 
     &   ZSN, Tobs, SHAPE(2), DIST        ! (I)
     &  ,AVHOST, RVHOST, MWEBV            ! (I)
     &  ,AVWARP, MAG_KCOR(2)              ! (O)  
     &  ,MAG_XTAV, MAG_XTMW, MAG_ERR      ! (O)

c local args

      DOUBLE PRECISION
     &   Z1, Z0
     &  ,Trest
     &  ,MAG_REST(MXFILT_ALL)
     &  ,MAG_BESSELL_REST(MXFILT_ALL)
     &  ,MAG_BESSELL_OBS(MXFILT_ALL)
     &  ,MAG_LANDOLT_REST(MXFILT_ALL)
     &  ,MAG_LANDOLT_OBS(MXFILT_ALL)
     &  ,MAGERR_REST(MXFILT_ALL)
     &  ,MAGERR_OBS_TMP(MXFILT_ALL)
     &  ,MAG_XTAV_REST(MXFILT_ALL)
     &  ,MAG_XTMW_OBS(MXFILT_ALL)
     &  ,KCOR_TMP(MXFILT_ALL)
     &  ,KCORERR_TMP(MXFILT_ALL)
     &  ,KCOR_NOAVWARP(MXFILT_ALL)
     &  ,AVWARP_TMP(MXFILT_ALL)
     &  ,MAG_OBS_TMP(MXFILT_ALL)
     &  ,MAG_TMP1, MAG_TMP2
     &  ,SQMAGERR, MAGERR_KCOR
     &  ,MAG_COR, MAG_PEAK, MAG_OBS
     &  ,FLUX, ARG, MJD
     &  ,STR1, STR2, DELTA, DM15
     &  ,BX_synth, B_synth
     &  ,SALT2x0, SALT2x1, xx1, SALT2c, zz, RVDUM, AVDUM
     &  ,AVMW, LAMAVG, LAMREST, WGT1, WGT2
     &  ,LAMDIF12, LAMDIF13, DIF
     &  ,ERRTMP1, ERRTMP2
     &  ,MUTMP, MWEBV_MODEL, RVMW

      INTEGER 
     &   istat
     &  ,ifilt
     &  ,ifilt_rest
     &  ,ifilt_rest1
     &  ,ifilt_rest2
     &  ,ifilt_rest3
     &  ,ifilt_rest_tmp(3)
     &  ,ifilt_tmp
     &  ,ifilt2
     &  ,ifilt2_obs
     &  ,Nepoch
     &  ,VBOSE
     &  ,LL, LPAR
     &  ,OPT, inear
     &  ,ISN, CID
     &  ,NFILT_FITMAP_REST
     &  ,IFILT_FITMAP_REST(MXFILT_OBS)
     &  ,MSKTMP, NFTMP
     &  ,MSKSALT2

      INTEGER*8 MSKFILT8(2), MSKTMP8(2)

      CHARACTER CPAR*20, CFILT*2, CTMP2*2, CCID*(MXCHAR_CCID)
      REAL*4 Z4, LAMDIF4(3)

c KCORFUN8 args
      INTEGER IFILT_REST_KCORFUN(3)
      REAL*8  
     &    MAG_REST_KCORFUN(3)
     &   ,LAMDIF_KCORFUN(3)
     &   ,AVWARP_KCORFUN(3)

      LOGICAL 
     &    LTMP
     &   ,LBESS_OBS, LSNXTAV, LSNXTMW, ISREST, ISOBS
     &   ,LDMP, NEEDU,  DOKCOR13, LCRAZYMAG, DOMBSALT2
     &   ,ABORT_ON_DMP


c functions
      INTEGER 
     &   NEAREST_IFILT_REST
     &  ,GENMAG_STRETCH2
     &  ,GENMAG_MLCS2K2
     &  ,GENMAG_SNOOPY
     &  ,LANDOLT_CONVERT
c     &  ,FILTINDX

      LOGICAL FILTBTEST

      REAL*8  
     &   GET_MAGLC8
     &  ,GET_MWXT8     ! get MW extinct
     &  ,GET_SNXT8     ! get hostgal extinct
     &  ,GET_AVWARP8   ! get AV needed to warp SN SED
     &  ,GET_KCORERR8  ! get Kcor error
     &  ,GALextinct    ! returns approx MW extinction
     &  ,KCORFUN8
     &  ,DLMAG8_REF
     &  ,SALT2x0calc, SALT2xx1, SALT2zz
     &  ,PARLIST_SN(10), PARLIST_HOST(10)

c ------------- BEGIN ------------

c init output args
      AVWARP       = NULLVAL
      MAG_KCOR(1)  = NULLVAL
      MAG_KCOR(2)  = NULLVAL
      mag_xtav     = NULLVAL
      mag_xtmw     = NULLVAL
      mag_err      = NULLVAL
c -----------------

      ABORT_ON_DMP = .FALSE.

      USRFUN   = 1.0
      Nepoch   = 1     ! 1 epoch
      VBOSE    = 0

      Z0      = Zat10pc 
      Z1      = 1.0 + ZSN
      Trest   = Tobs / Z1
      RVMW    = DBLE(RV_MWCOLORLAW)

c check for special case where IFILT_OBS is really a rest-filter
      IF ( ZSN .LT. Z0*1.001 ) then
        ISREST = .TRUE.
      ELSE
        ISREST = .FALSE.
      ENDIF
         
      IF ( ISREST ) THEN
        LAMAVG  = DBLE( FILTREST_LAMAVG(ifilt_obs) )
        LAMREST = DBLE( FILTREST_LAMAVG(ifilt_obs) )
      ELSE
        LAMAVG  = DBLE( FILTOBS_LAMAVG(ifilt_obs) )
        LAMREST = DBLE( FILTOBS_LAMAVG(ifilt_obs) ) / Z1
      ENDIF

      NFILT_FITMAP_REST    = 0

      MWEBV_MODEL = MWEBV
      IF ( USE_MWCOR ) MWEBV_MODEL = 0.0 ! data already corrected

      LBESS_OBS = IFILT_OBS .GE. IFILT_BESS_U .and. 
     &            IFILT_OBS .LE. IFILT_BESS_I

c get approx MW extinction (for printout only ... not for calculation)
      AVMW     = RVMW * mwebv_model ; 
      MAG_XTMW = GALextinct ( RVMW, AVMW, LAMAVG, 94 );

c if we have observer-frame model, then skip all 
c the rest-frame stuff.

      IF ( LOBS_FITMODEL ) GOTO 333

c get nearest and 2nd nearest filter in rest frame.
c Note that IFILT_REST1[2] are absolute (NOT sparse) filter indices.

      IF ( ISREST ) then
        OPT = OPT_FILTREST
      ELSE 
        OPT = OPT_FILTOBS
      ENDIF
      Z4  = sngl(ZSN)

      ifilt_rest1 = 
     &  NEAREST_IFILT_REST( opt, ifilt_obs, 1, Z4, LAMDIF4(1))
      ifilt_rest2 = 
     &  NEAREST_IFILT_REST( opt, ifilt_obs, 2, Z4, LAMDIF4(2))
      ifilt_rest3 = 
     &  NEAREST_IFILT_REST( opt, ifilt_obs, 3, Z4, LAMDIF4(3))


c check if KCOR13 (based on warping other neighbor) should be 
c wgt-averaged with nominal KCOR12.
c First that order is 3-1-2  or  2-1-3.

      LAMDIF12 = DBLE(  FILTREST_LAMAVG(ifilt_rest2)
     &                - FILTREST_LAMAVG(ifilt_rest1) )
      LAMDIF13 = DBLE( FILTREST_LAMAVG(ifilt_rest1)
     &               - FILTREST_LAMAVG(ifilt_rest3) )
      DOKCOR13 = (LAMDIF12/LAMDIF13) .GT. 0.0

c update rest-frame map for photoZ fit (if IFILT is defined)

      if ( DOFIT_PHOTOZ ) then
          ifilt = IFILTDEF_INVMAP_SURVEY(ifilt_obs)

          if ( ifilt .GT. 0 ) then
            IFILT_REST_MAP(ifilt) = ifilt_rest1  
          endif

      endif

c check option for rest-frame mags only with no K-correction

      IF ( ISREST ) then
        NFILT_FITMAP_REST    = 1
        IFILT_FITMAP_REST(1) = IFILT_REST1
        IFILT_REST1          = IFILT_REST1
        IFILT_REST2          = IFILT_REST1
        IFILT_REST3          = IFILT_REST1
        GOTO 333
      ENDIF
   
      NEEDU = ifilt_rest1 .EQ. ifilt_BESS_U .or.
     &        ifilt_rest2 .EQ. ifilt_BESS_U 

      NFILT_FITMAP_REST    = 2
      IFILT_FITMAP_REST(1) = ifilt_rest1
      IFILT_FITMAP_REST(2) = ifilt_rest2

      IF ( DOKCOR13 ) THEN
        NFILT_FITMAP_REST    = 3
        IFILT_FITMAP_REST(3) = ifilt_rest3
      ELSE
        ifilt_rest3 = -9
      ENDIF

c expand filter ranges if Landolt option is set.

      IF ( USE_LANDOLT_REST  ) THEN

         NFILT_FITMAP_REST = 0
         do ifilt = 1, NFILTDEF_REST
            ifilt_rest = IFILTDEF_MAP_REST(ifilt)
            if ( ifilt_rest .NE. IFILT_BESS_BX ) then
              NFILT_FITMAP_REST = NFILT_FITMAP_REST + 1
              IFILT_FITMAP_REST(ifilt) = ifilt_rest
            endif

         enddo         

      ENDIF

c init filter-dependent variables.

333   CONTINUE

      DO ifilt = 1, MXFILT_ALL
         MAG_REST(ifilt)         = 0.0
         MAGERR_REST(ifilt)      = 0.0
         MAG_XTAV_REST(ifilt)    = 0.0
         KCOR_TMP(ifilt)         = 0.0
         KCORERR_TMP(ifilt)      = 0.0
         MAG_XTMW_OBS(ifilt)     = 0.0
         MAG_OBS_TMP(ifilt)      = 0.0
         MAG_LANDOLT_REST(ifilt) = 0.0
         MAG_LANDOLT_OBS(ifilt)  = 0.0
         MAG_BESSELL_REST(ifilt) = 0.0
         MAG_BESSELL_OBS(ifilt)  = 0.0
         AVwarp_tmp(ifilt)       = 0.0 
      ENDDO

c -------------------------------------------
c get MAG_REST1 = magnitude in rest frame for closest filter
c     MAG_REST1 = mag in rest-frame for 2nd closest filter (for color)
c Use "genmag_xxx" function that are used in simulation.

500   CONTINUE

      IF ( FITMODEL_INDEX .EQ. MODEL_STRETCH ) THEN

         STR1       = SHAPE(1) 
         STR2       = STR1

         do ifilt = 1, NFILT_FITMAP_REST
            IFILT_REST = IFILT_FITMAP_REST(ifilt)

c return MAG_REST
            istat = genmag_stretch2 (
     &           STR1, STR2, IFILT_REST, Nepoch, Trest    ! input
     &         , MAG_REST(ifilt_rest)          ! (O)
     &         , MAGERR_REST(ifilt_rest) )     ! (O)
         enddo

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_STRETCH2 ) THEN

         STR1       = SHAPE(1) 
         STR2       = SHAPE(2) 

         do ifilt = 1, NFILT_FITMAP_REST
            IFILT_REST = IFILT_FITMAP_REST(ifilt)

c return MAG_REST
            istat = genmag_stretch2 ( 
     &           STR1, STR2, IFILT_REST, Nepoch, Trest   ! input
     &         , MAG_REST(ifilt_rest)       ! (O)
     &         , MAGERR_REST(ifilt_rest) )  ! (O)

         enddo

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_MLCS2k2 ) THEN

          DELTA  = SHAPE(1)

         do ifilt       = 1, NFILT_FITMAP_REST
             IFILT_REST = IFILT_FITMAP_REST(ifilt)

c note that genmag_mlcs starts at 0, so subtract 1 from index.
             ifilt_tmp  = IFILTINVMAP_MODEL(ifilt_rest) - 1 
             if ( ifilt_tmp < 0 ) then
               c1err = 'Invalid rest-frame filt for genmag_mlcs2k2: '// 
     &               FILTDEF_STRING(IFILT_REST:IFILT_REST)
               c2err = 'Valid rest-frame filters: ' // 
     &               FILTLIST_MODEL(1:NFILT_MODEL)
               CALL MADABORT("USRFUN", c1err, c2err )   
             endif
             
             istat = genmag_mlcs2k2(
     &              ifilt_tmp, DELTA, Nepoch, Trest  ! (I)
     &            , MAG_REST(ifilt_rest)       ! (O)
     &            , MAGERR_REST(ifilt_rest) )  ! (O)

          enddo

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SNOOPY ) THEN

         DM15     = SHAPE(1)

         do ifilt = 1, NFILT_FITMAP_REST
            IFILT_REST = IFILT_FITMAP_REST(ifilt)
            ifilt_tmp  = IFILTINVMAP_MODEL(ifilt_rest) - 1  ! C index
 
            if ( ifilt_tmp < 0 ) then
               c1err = 'Invalid rest-frame filter for genmag_snoopy: '// 
     &               FILTDEF_STRING(IFILT_REST:IFILT_REST)
               c2err = 'Valid rest-frame filters: ' // 
     &               FILTLIST_MODEL(1:NFILT_MODEL)
               CALL MADABORT("USRFUN", c1err, c2err )   
            endif

            istat = genmag_snoopy(ifilt_tmp, DM15, Nepoch, Trest
     &            ,MAG_REST(ifilt_rest)       ! (O)
     &            ,MAGERR_REST(ifilt_rest) )  ! (O)

          enddo

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN

          MSKSALT2  = 0   ! bit0 => nominal, return flux 
          SALT2x1 = SHAPE(1)
          SALT2c  = AVHOST
          xx1     = SALT2xx1(ITER,SALT2x1)  ! x1 used in model-err calc
          zz      = SALT2zz(ITER,ZSN)       ! z  used in model-err calc

c translate fit-params into SALT2 language
         
          if ( OPT_SALT2FIT .EQ. 0  ) then  ! default
             SALT2x0 = DIST      

          else if ( OPT_SALT2FIT .EQ. 1  ) then
             SALT2x0 = TEN8**DIST    ! MU

          else if ( OPT_SALT2FIT .EQ. 2  ) then
             MUTMP = (DIST + DLMAG8_REF(ZSN))   ! DIST is really MUDIF
             SALT2x0 = SALT2x0calc(ZERO8,ZERO8, ZERO8, ZERO8, MUTMP )

          else if ( OPT_SALT2FIT .EQ. 4  ) then  ! emulate Julien/snfit
             SALT2x0 = DIST      ! same as for default
             if ( ITER .LE. 2 ) then
                MSKSALT2 = 4     ! set errors to zero
                xx1      = 0.0   ! redundant
             endif
          endif

          MSKFILT8(1) = IFILT_OBS_EVAL_MASK(1,ifilt_obs)
          MSKFILT8(2) = IFILT_OBS_EVAL_MASK(2,ifilt_obs)

          NFTMP = NFILTDEF_SURVEY

c loop over all needed obs-filters;
c multiple filters are needed for Landolot color transf.

          RVDUM = 0.0 ; AVDUM=0.0  ! cannot fit for Mandel's extinc params
          PARLIST_SN(1) = SALT2x0
          PARLIST_SN(2) = SALT2x1
          PARLIST_SN(3) = SALT2c
          PARLIST_SN(4) = xx1
	  PARLIST_HOST(1) = RVDUM
          PARLIST_HOST(2) = AVDUM
	  PARLIST_HOST(3) = -9.0   ! logMass

          DO ifilt2 = 1, NFTMP
             ifilt2_obs = IFILTDEF_MAP_SURVEY(ifilt2)
             mag_obs_tmp(ifilt2_obs) = 0.0
             LTMP = FILTBTEST(MSKFILT8,ifilt2_obs)
             if ( LTMP ) then              	       
               CALL genmag_salt2( MSKSALT2, ifilt2_obs
     &          , PARLIST_SN, PARLIST_HOST, MWEBV_MODEL
     &          , ZSN,ZZ, Nepoch, Tobs
     &          , MAG_OBS_TMP(ifilt2_obs)       ! return arg
     &          , MAGERR_OBS_TMP(ifilt2_obs)  ) ! return arg 

             endif
          ENDDO  ! ifilt2 loop


c mag error is from the nominal filter ... ignore mag_err
c from other filters used for Landolt color trans.

          MAG_ERR = MAGERR_OBS_TMP(ifilt_obs)
        
          GOTO 501  ! skip K-corrections and other rest-frame stuff

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SIMSED ) THEN

c translate fit-params into SALT2 language

          MUTMP   = (DIST + DLMAG8_REF(ZSN))   ! DIST is really MUDIF
          SALT2x0 = TEN8** (-0.4*MUTMP )      ! borrow SALT2x0 for now

          SALT2x1 = 0.0  ! unused shape-par variable for SIMSED

          MSKTMP  = 1  ! bit0 => return flux instead of mag
          CALL genmag_simsed( MSKTMP, ifilt_obs
     &          , SALT2x0, SALT2x1
     &          , MWEBV_MODEL, ZSN, Nepoch, Tobs
     &          , flux, mag_err )  ! returns FLUX and MAG_ERR

          GOTO 502  ! skip K-corrections and other rest-frame stuff

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_FIXMAG ) THEN


      ENDIF

c -----------------------------------
c check option for rest-frame mag only
c Include host extinction to get rest-frame colors.

      IF ( ISREST ) THEN
        MAG_XTAV_REST(ifilt_obs) = 
     &  GET_SNXT8(OPT_SNXT, ifilt_obs, Trest, AVHOST, RVHOST)

        MAG_OBS_TMP(ifilt_obs) = 
     &  MAG_REST(IFILT_OBS) + MAG_XTAV_REST(ifilt_obs)
        
        GOTO 777  ! skip K-corr and extinction
      ENDIF

c check for option to smooth rest-frame model
c across filter boundaries

      IF ( LREST_FITMODEL ) THEN

         CALL RESTFILT_WGT(LAMREST, ifilt_rest1, ifilt_rest2,   ! (I)
     &             WGT1, WGT2) ! (O) return wgts (sum to 1)

         ERRTMP1 = MAGERR_REST(ifilt_rest1) 
         ERRTMP2 = MAGERR_REST(ifilt_rest2) 

c smooth the errors
         MAGERR_REST(ifilt_rest1) = WGT1*ERRTMP1 + WGT2*ERRTMP2
         MAGERR_REST(ifilt_rest2) = WGT1*ERRTMP2 + WGT2*ERRTMP1

      ENDIF


c set temp arrays MAG_BESSELL and MAG_LANDOLT

      DO ifilt      = 1, NFILT_FITMAP_REST
         ifilt_rest = IFILT_FITMAP_REST(ifilt)
         MAG_BESSELL_REST(ifilt_rest) = MAG_REST(ifilt_rest)
         MAG_LANDOLT_REST(ifilt_rest) = MAG_REST(ifilt_rest)
      ENDDO  ! end of IFILT loop

c -----------------------------------------------------------
c If Landolt option is set, then assume MAG_REST is in Landolt system
c and convert to Bessell system before applying Kcor to observer frame.

      IF ( USE_LANDOLT_REST ) THEN  ! rest-frame conversions

c If U-band is needed (NEEDU), first get synthetic BX-B needed to 
c convert Landolt-U back to synth Bessell.
c Store BX-B in the memory slot for Landolt-BX.

         MAG_LANDOLT_REST(IFILT_BESS_BX) = 0.0

         if ( NEEDU ) then

           AVWARP = GET_AVWARP8(Trest, Z0
     &             ,MAG_LANDOLT_REST(ifilt_rest1)
     &             ,MAG_LANDOLT_REST(ifilt_rest2)
     &             ,IFILT_REST1, IFILT_REST2, ISTAT )

           BX_synth = GET_MAGLC8(ifilt_bess_BX, Trest, Z0, AVwarp)
           B_synth  = GET_MAGLC8(ifilt_bess_B , Trest, Z0, AVwarp)
           MAG_LANDOLT_REST(IFILT_BESS_BX) = BX_synth - B_synth

         endif

c now convert to synthetic Bessell.

         opt   = -1   ! flag for Landolt -> Bessell conversion
         istat = Landolt_convert(opt
     &              ,MAG_LANDOLT_REST(IFILT_BESS_U)  ! input  UBVRI,BX-B
     &              ,MAG_BESSELL_REST(IFILT_BESS_U)  ! output UBVRI
     &                  )

         DO IFILT = 1,NFILT_FITMAP_REST
            IFILT_REST = IFILT_FITMAP_REST(ifilt)
            MAG_REST(ifilt_rest) = MAG_BESSELL_REST(ifilt_rest)
         ENDDO

c convert synthetic U into reported U by subtracting BX-B :
         MAG_REST(IFILT_BESS_U) = MAG_BESSELL_REST(IFILT_BESS_U)
     &                          - MAG_LANDOLT_REST(IFILT_BESS_BX)  ! -(BX-B)

         MAG_REST(ifilt_bess_BX) = MAG_REST(ifilt_bess_B)     ! B
     &                           + MAG_LANDOLT_REST(IFILT_BESS_BX) ! BX-B

      ENDIF  !  end of USE_LANDOLT_REST  if-block

c ----------------------------------------------------
c Now MAG_REST is in synthetic Bessell system; 
c apply host extinction for rest-frame models.

      LSNXTAV = LREST_FITMODEL .and. AVHOST .NE. 0.0

      DO IFILT      = 1, NFILT_FITMAP_REST
         IFILT_REST = IFILT_FITMAP_REST(ifilt)

        IF ( LSNXTAV ) THEN
           MAG_XTAV_REST(ifilt_rest) = 
     &     GET_SNXT8(OPT_SNXT, ifilt_rest, Trest, AVHOST, RVHOST)

           MAG_REST(ifilt_rest) = 
     &     MAG_REST(ifilt_rest) + MAG_XTAV_REST(ifilt_rest)

           MAG_BESSELL_REST(ifilt_rest) = 
     &     MAG_BESSELL_REST(ifilt_rest) + MAG_XTAV_REST(ifilt_rest) 

        ENDIF
      ENDDO

c --------------------------------------------
c determine K-correction; note that rest-frame mags
c include host-galaxy extinction.

      LSNXTMW = (ZSN .GT. 1.1 * Zat10pc) .and. (MWEBV .NE. 0.0)
      MSKTMP8(1) = IFILT_OBS_EVAL_MASK(1,ifilt_obs)
      MSKTMP8(2) = IFILT_OBS_EVAL_MASK(2,ifilt_obs)

      DO 155 ifilt2  = 1, NFILTDEF_SURVEY
         ifilt2_obs = IFILTDEF_MAP_SURVEY(ifilt2)

c check filter bit-mask to see if this IFILT needs to be evaluated.

        LTMP = FILTBTEST(MSKTMP8,ifilt2_obs)

        IF ( .not. LTMP ) goto 155

c get closest rest-frame filters for this observer "ifilt2_obs"
        OPT = OPT_FILTOBS
        DO inear = 1, 3
          ifilt_rest_tmp(inear) = 
     &    NEAREST_IFILT_REST(opt,ifilt2_obs,inear,Z4,LAMDIF4(inear))

c load KCORFUN8 args   
          ifilt_tmp                 = ifilt_rest_tmp(inear)
          IFILT_REST_KCORFUN(inear) = ifilt_tmp
          MAG_REST_KCORFUN(inear)   = MAG_BESSELL_REST(ifilt_tmp)
          LAMDIF_KCORFUN(inear)     = DBLE( LAMDIF4(inear) )
        ENDDO

        KCOR_TMP(ifilt2_obs) = KCORFUN8 ( ifilt2_obs
     &     ,IFILT_REST_KCORFUN, MAG_REST_KCORFUN
     &     ,LAMDIF_KCORFUN, Trest, ZSN
     &     ,AVWARP_KCORFUN    ! (O)
     &        )

c save AVwarp
        AVwarp                 = AVwarp_KCORFUN(2)
        AVwarp_tmp(ifilt2_obs) = AVwarp  ! save in case of dump

        KCORERR_TMP(ifilt2_obs) = GET_KCORERR8 ( OPT_KCORERR,
     &        ifilt_rest_tmp(1), ifilt2_obs, Trest, ZSN, AVwarp) 

        MAG_XTMW_OBS(ifilt2_obs) = 0.0
        if ( LSNXTMW ) then
           MAG_XTMW_OBS(ifilt2_obs) =
     &      GET_MWXT8(ifilt2_obs, Trest, ZSN, AVWARP, 
     &                MWEBV, RVMW, OPT_MWCOLORLAW )
        endif

c Add up all the pieces for observer mag prediction.

        MAG_OBS_TMP(ifilt2_obs) = 
     &       MAG_BESSELL_REST(ifilt_rest_tmp(1)) ! rest-mag including host-AV
     &     + KCOR_TMP(ifilt2_obs)        ! K correction
     &     + DIST                        ! MU = 5*log10(10pc/DL)
     &     + MAG_XTMW_OBS(ifilt2_obs)    ! MilkyWay extinction

c check for option to subtract MWgalaxy extinction from model
c just like for the data.

        if ( USE_MWCOR ) then
          MAG_OBS_TMP(ifilt2_obs) = 
     &    MAG_OBS_TMP(ifilt2_obs) - MAG_XTMW_REF(ifilt2_obs)
        endif

155   CONTINUE

c ---------------------------------------------
c load output args for function
c note that MAG_OBS is loaded below the 501-continue 

777   CONTINUE   
      AVwarp       = AVwarp_tmp(ifilt_obs)
      MAG_KCOR(1)  = KCOR_TMP(ifilt_obs) 
      MAG_KCOR(2)  = KCORERR_TMP(ifilt_obs) 
      MAGERR_KCOR  = KCORERR_TMP(ifilt_obs) 
      MAG_XTAV     = MAG_XTAV_REST(ifilt_rest1)
      MAG_XTMW     = MAG_XTMW_OBS(ifilt_obs) 

c determine model error as contribution from model and K-corr.

      SQMAGERR = 0.0
      IF ( USE_MODEL_MAGERR ) THEN
         SQMAGERR = MAGERR_REST(ifilt_rest1)**2 + MAGERR_KCOR**2
      ENDIF
      MAG_ERR = DSQRT(SQMAGERR)

c -------------------------------------

501   CONTINUE  ! come here when observer mag is calculated

c -------------------------------------------------
c if observer-frame is Bessell, and Landolt option is set,
c then transform observer-frame Bessell mags (MAG_BESSELL) 
c to Landolt.

      IF ( USE_LANDOLT_OBS .and. 
     &     LBESS_OBS       .and. 
     &     .not. ISREST   ) THEN

c transfer MAG_OBS_TMP to temporary MAG_BESSELL_OBS array
c => input argument for LANDOLOT_CONVERT below.

         LCRAZYMAG = .FALSE.
         DO  ifilt2  = 1, NFILTDEF_SURVEY
           ifilt2_obs = IFILTDEF_MAP_SURVEY(ifilt2)                      
           if ( ifilt2_obs .GT. 0 ) then
             MAG_TMP2 = MAG_OBS_TMP(ifilt2_obs)
             MAG_BESSELL_OBS(ifilt2_obs) = MAG_TMP2
             if ( MAG_TMP2 .GT. 40.0 ) LCRAZYMAG = .TRUE.
           endif
         ENDDO
         
         if ( .not. LCRAZYMAG ) then
           opt   = +1   ! flag for Bessell -> Landolt 
           istat = Landolt_convert(opt
     &              ,MAG_BESSELL_OBS(IFILT_BESS_U)  ! input  UBVRI,BX
     &              ,MAG_OBS_TMP(IFILT_BESS_U)      ! output Landolt UBVRI
     &                  )
         endif

c abort if Landolt correction makes more than 3 mag change.
c Check only if SHAPE and COLOR have sane values,
c and also require reasonable Trest.
c
c
         DIF = MAG_BESSELL_OBS(ifilt_obs)-MAG_OBS_TMP(ifilt_obs)
         if (   abs(DIF)     .GT. 4.0   ! was 3.0 
     &    .and. TREST        .LT. +50.0
     &    .and. TREST        .GT. -16.0
     &    .and. SHAPE(1)     .GT. PRIOR_SHAPE_RANGE(1)
     &    .and. SHAPE(1)     .LT. PRIOR_SHAPE_RANGE(2) 
     &    .and. abs(AVHOST)  .LT. 10.0 ) then

	   CALL PRINT_PREABORT_BANNER("USRFUN"//CHAR(0), 40)
           cfilt = filtdef_string(ifilt_obs:ifilt_obs) 
           print*,' Filter = ', cfilt,' : '
           print*,' MAG(LANDOLT)-MAG(BESSELL) = ',
     &         MAG_OBS_TMP(ifilt_obs), ' - ',
     &         MAG_BESSELL_OBS(ifilt_obs), ' = ', DIF

           ABORT_ON_DMP = .TRUE.
           LDMP = .TRUE.

           c1err = 'Landolt-Bessell mag-dif is too large'
           c2err = 'Check Landolt transformation'
         endif

      ENDIF  ! end of USE_LANDOLT_OBS

c  strip off final observer-frame mag

      MAG_OBS      = MAG_OBS_TMP(ifilt_obs)

c ------------------------------------------
c Convert to calibrated flux if MAG_OBS has reasonable value;
c otherwise set flux to zero.

      ISOBS = (ZSN .GT. 1.0E-7)

      IF ( ISOBS ) THEN
         LTMP = (MAG_OBS .LT.  40.0) .and. (MAG_OBS .GT. 5.0)
      ELSE
         LTMP = (MAG_OBS .LT. -10.0) .and. (MAG_OBS .GT. -30.0)
      endif

c allow any MAG for TEST option
      if ( FITMODEL_INDEX .EQ. MODEL_FIXMAG ) LTMP = .TRUE.

      if ( LTMP ) then
         arg   = -0.4 * (MAG_OBS - ZEROPOINT_FLUXCAL_DEFAULT)
         FLUX  =  TEN8**(ARG)
      else
         FLUX = 0.0
      endif

c --------------------------------------------------------
502   CONTINUE  ! come here when observer-flux is calculated

      USRFUN = FLUX

      IF ( .not. USE_MODEL_MAGERR ) THEN
          MAG_ERR = 0.0   ! Apr 5 2016
      ENDIF
      IF ( FUDGE_MAGERR_MODEL .GE. 0.0 ) THEN
         MAG_ERR = FUDGE_MAGERR_MODEL
      ENDIF

c --------------------------------------------
c CHECK DUMP UTILITIES

      IF ( LDMP ) THEN  ! strip things for both obs- and rest-frame model

        ISN  = int( INIVAL(ipar_isn) )
        CID  = SNLC_CID
        MJD  = R8EP_MJD(IFITDATA_USRFUN) 

        CPAR   = PARNAME_STORE(IPAR_SHAPE)
        LPAR = index ( CPAR, ' ' ) - 1

      ENDIF

      IF ( LDMP .and. LREST_FITMODEL ) THEN

c write fit parameters

        print*,' - - -  - - - - - - - - - - - - - - - - - - - - -'
        write(6,701) DIST, AVHOST, CPAR(1:LPAR), SHAPE(1), MJD, ZSN

701     format(T2,'USRFUN: MU=',F6.2, 2x,'AV=',F6.3,2x,
     &              A,'=',F6.3, 2x, 'MJD=',F9.3, 2x,'Z=',F7.5 )

        cfilt = filtdef_string(ifilt_obs:ifilt_obs) 
        ctmp2 = filtdef_string(ifilt_rest1:ifilt_rest1) 
        write(6,702) cfilt, Tobs, ctmp2, Trest    
702     format(T10, 'Tobs(',A1,')=',F7.2,2x, 
     &        'Trest(',A1,')=',F7.2  )

        CALL FLUSH(6)

+SELF,IF=XXXDBG.
        print*,' xxxxxxxxxxxx '
        print*,'  MAG_XTAV= ', MAG_XTAV_REST
        print*,'  MAG_REST= ', MAG_REST
        print*,'  KCOR_TMP= ', KCOR_TMP

        print*,'  IFILT_REST[1,2,3] = ', 
     &        IFILT_REST1, IFILT_REST2, IFILT_REST3,
     &        '   LAMREST=', SNGL(LAMREST)

        print*,'  AVWARP_TMP=', AVWARP_TMP
        print*,'  MAG_XTMW= ', MAG_XTMW_OBS
        print*,'  MAG_OBS = ', MAG_OBS_TMP
        print*,'  MAG_LAND_REST = ', MAG_LANDOLT_REST
        print*,'  MAG_BESS_REST = ', MAG_BESSELL_REST
        print*,'  MAG_BESS_OBS  = ', MAG_BESSELL_OBS
        print*,'  IFILT_FITMAP_REST   = ',IFILT_FITMAP_REST
 
        print*,'  ifilt_rest1 = ', ifilt_rest1
        print*,'  MAGERR[REST,KCOR,TOTAL] = ',
     &    MAGERR_REST(ifilt_rest1), MAGERR_KCOR, MAG_ERR
        print*,' xxxxxxxxxxxx '
+SELF.

c write rest-frame info

c unextincted mag in rest frame
        MAG_TMP1 = MAG_REST(ifilt_rest1) - MAG_XTAV_REST(ifilt_rest1)

        write(6,703) 
     &   filtdef_string(ifilt_rest1:ifilt_rest1), MAG_TMP1
     &  ,int(100.0*MAG_ERR+0.5)
     &  ,filtdef_string(ifilt_rest1:ifilt_rest1)
     &  ,MAG_REST(ifilt_rest1)

703     FORMAT(T10,'Mrest(',A,')=',F7.2,'(',I2.2,')',  2x,
     &            'XMrest(',A,')=',F7.2 )

c write rest color, AVwarp and Kcor

        write(6,704) 
     &      filtdef_string(ifilt_rest1:ifilt_rest1)
     &     ,filtdef_string(ifilt_rest2:ifilt_rest2)
     &     ,MAG_REST(ifilt_rest1) - MAG_REST(ifilt_rest2)
     &     ,AVwarp
     &     ,filtdef_string(ifilt_rest1:ifilt_rest1)
     &     ,filtdef_string(ifilt_obs:ifilt_obs)
     &     ,MAG_KCOR(1), MAG_KCOR(2)

704      format(T10,'Xcol(',A,'-',A,')=', F6.3, 2x,'AVwarp=',F6.3,
     &           2x,'K_',A,A,'=',F6.3,'+-',F6.3 )

c write observer mag and flux

         write(6,706) filtdef_string(ifilt_obs:ifilt_obs),
     &                MAG_OBS, MAG_XTMW, FLUX
706      format(T10,'m_obs(',A,')=',F8.3, 2x, 'm(XTMW)=',F6.3,  
     &              2x, 'Flux=',G12.3 )

c now write single line with CID keyword ;
c grep "CID" > bla creates easy-to-read column-formatted file 
c Columns are 
c   1. CID 
c   2. obsFilt  
c   3. restColor 
c   4. MJD
c   5. Trest 
c   6. Unextincted mag in rest-frame
c   7. rest-frame mag
c   8. rest-frame color used for SED warping
c   9. AV warp
c  10. Kcor
c  11. observed mag

         CALL CIDSTRING(CID,CCID,LL)
         write(6,710) CCID(1:LL)
     &     ,filtdef_string(ifilt_obs:ifilt_obs)
     &     ,filtdef_string(ifilt_rest1:ifilt_rest1)
     &     ,filtdef_string(ifilt_rest2:ifilt_rest2)
     &     ,MJD, Trest
     &     ,MAG_TMP1, MAG_REST(ifilt_rest1)
     &     ,MAG_REST(ifilt_rest1) - MAG_REST(ifilt_rest2)
     &     ,AVwarp, MAG_KCOR(1), MAG_OBS

710      format(T2,A,  2x,A,1x,A,'-',A,1x,  F10.3, 7F9.4 )
         CALL FLUSH(6)

         IF ( ABORT_ON_DMP ) THEN
           CALL MADABORT("USRFUN", c1err, c2err )   
         ENDIF

      ENDIF  ! end of dump for rest-frame model


c ===========================
c Now check dump for observer-frame model

      IF ( LDMP .and. LOBS_FITMODEL ) THEN

        print*,' - - -  - - - - - - - - - - - - - - - - - - - - -'

        write(6,751) DIST, AVHOST, CPAR(1:LPAR), SHAPE(1), MJD

751     format(T2,'USRFUN: x0=',G10.3, 2x,'c=',F6.3, 2x,
     &              A,'=',F6.3, 2x, 'MJD=',F9.3 )

        write(6,752) Tobs, Trest, Zsn
752     format(T10, 'Tobs=',F7.2,2x, 'Trest=',F7.2, 2x,'Z=',F6.4 )

        cfilt = filtdef_string(ifilt_obs:ifilt_obs)
        write(6,754) cfilt, Flux, MAG_ERR
754     format(T5,'Observer Flux(',A1,') = ', 
     &             G12.3, 3x,'MAG_ERR=', F5.2 )

        CALL FLUSH(6)

        IF ( USE_LANDOLT_OBS .and. LBESS_OBS ) then

           write(6,766) 'BESSELL',
     &        (MAG_BESSELL_OBS(ifilt_tmp), 
     &          ifilt_tmp=IFILT_BESS_U, IFILT_BESS_BX)

           write(6,766) 'LANDOLT',
     &        (MAG_OBS_TMP(ifilt_tmp), 
     &          ifilt_tmp=IFILT_BESS_U, IFILT_BESS_BX)

766        format(T5,'MAG_',A,'(UBVRIX)=', 6F9.4 )

           print*, '      MAG_BESSELL(',cfilt,') = ',
     &     MAG_BESSELL_OBS(ifilt_obs),' -> ', MAG_OBS_TMP(ifilt_obs),
     &     ' (Landolt)'

        ELSE
            print*,'      MAG_OBS(',cfilt,') = ',MAG_OBS
            print*,'      MAG_REST = ', MAG_REST(IFILT_OBS) 
            print*,'      MAG_XTAV = ', MAG_XTAV_REST(ifilt_obs)
        ENDIF
 

        IF ( ABORT_ON_DMP ) THEN
          CALL MADABORT("USRFUN", c1err, c2err )   
        ENDIF

      END IF  ! end of dump for observer-frame model


      RETURN
      END   ! end of USRFUN
 
C ====================================================
+DECK,GET_DIST8.
      DOUBLE PRECISION FUNCTION GET_DIST8(Z, SHAPE, COLOR, SCALE)
c
c Created Aug 13, 2009 by R.Kessler
c
c Return "DISTANCE" estimate based on model;
c => MUREF - 2.5log10(SCALE) (distance modulus) for mlcs, stretch ...
c => X0*SCALE for SALT2
c
c Mar 24, 2012: add SCALE argument
c -------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNFITCOM.

c +CDE,SNANAFIT. 
c +CDE,FILTCOM.
c +CDE,SNLCINP.  

c function inputs

      DOUBLE PRECISION
     &   Z, SHAPE, COLOR  ! (I) z, DELTA/x1,   c/AV
     &  ,SCALE            ! (I) include this multiplicative scale

c local var
      DOUBLE PRECISION  S2a, S2b, x0, MUREF

c function
      DOUBLE PRECISION  SALT2x0calc, DLMAG8_REF

C ---------- BEGIN -----------

      GET_DIST8 = 0.0
      MUREF     = DLMAG8_REF(Z) 

      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN
         S2a = DBLE(SALT2alpha)
         S2b = DBLE(SALT2beta)
         x0  = SCALE * SALT2x0calc( S2a, S2b, SHAPE, COLOR, MUREF)

         if ( OPT_SALT2FIT .EQ. 0 ) then
           GET_DIST8 = x0
         else if ( OPT_SALT2FIT .EQ. 1 ) then
           GET_DIST8 = log10(x0)
         else if ( OPT_SALT2FIT .EQ. 2 ) then
           GET_DIST8 = 0.0 ! MUDIF  estimate
         endif

      ELSE
         GET_DIST8 = MUREF - 2.5*LOG10(SCALE)
      ENDIF

      RETURN
      END  ! end of GET_DIST8

C ===================================================
+DECK,GTSIMEFF.
      DOUBLE PRECISION FUNCTION SNLC_FIT_SIMEFF(isn,XVAL)
c
c Created Jul 25, 2011
c Return simulated efficiency for this SN (ISN) 
c and fit-parameters (XVAL)
c Fill variables needed to get efficiency,
c and then call utility GET_SIMEFFMAP().
c
c -----------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.
+CDE,SIMEFFCM.

c function args
      INTEGER ISN          ! (I) sparse SN index
      REAL*8  XVAL(*)      ! (I) current fit parameters

c local variables

      REAL*8  EFF
      INTEGER OPTEFF, ipar, ipar2, j
 
c define EFFMIN so that EFF > 0 to avoid log(0) problems
      REAL*8 EFFMIN
      PARAMETER (EFFMIN = 1.0E-10) 

c functions
      REAL*8   GET_SIMEFFMAP
      EXTERNAL GET_SIMEFFMAP  ! inside sntools.c

c  ------------- BEGIN ------------

      IF ( DOFIT_PHOTOZ ) THEN
        OPTEFF = 1     !   EFF -> EFF/EFFMAX 
      ELSE
        OPTEFF = 0
      ENDIF

c load up the PARVAL_SIMEFF
      DO 100 ipar   = 1, NPAR_SIMEFF

         PARVAL8_SIMEFF(ipar) = -999.
         ipar2  = IPAR_SIMEFF(ipar)
         
         if ( ipar2 .LE. IPAR_MAX ) then
            PARVAL8_SIMEFF(ipar) = XVAL(IPAR2)
            goto 100
         endif

         if ( ipar2 .EQ. IPAR_SIMEFF_REDSHIFT ) then
            PARVAL8_SIMEFF(ipar) = ZSCALE_SIMEFF * XVAL(IPAR_zPHOT)
            goto 100
         endif

         if ( ipar2 .EQ. IPAR_SIMEFF_MWEBV ) then
            PARVAL8_SIMEFF(ipar) = SNLC_MWEBV
            goto 100
         endif

c if we get here then abort


100   CONTINUE


c get efficiency 

      EFF = GET_SIMEFFMAP(OPTEFF, NPAR_SIMEFF, PARVAL8_SIMEFF )
      SNLC_FIT_SIMEFF = MAX(EFF,EFFMIN)

+SELF,IF=DEBUG.
      print*,' xxx -------------------------------------------- '
      print*,' xxx OPTEFF = ', OPTEFF, 
     &             '  NPAR_SIMEFF=', NPAR_SIMEFF
      print*,' xxx Z, DELTA,AV = '
     &          ,sngl(PARVAL8_SIMEFF(1))
     &          ,sngl(PARVAL8_SIMEFF(2))
     &          ,sngl(PARVAL8_SIMEFF(3))
      print*,' xxx EFF =', EFF
      CALL FLUSH(6)
+SELF.

      RETURN
      END   ! end of SNLC_FIT_SIMEFF


C ====================================================
+DECK,FITMODEL_INI.
      SUBROUTINE FITMODEL_INI()
c
c Created Nov 2010 by R.Kessler
c Use namelist input FITMODEL_NAME to initialize global 
c variables
c   FITMODEL_PATH, FITMODEL_VERSION, FITMODEL_INDEX
c
c Feb 22 2017: 
c   + allow FITMODEL_NAME to include path; see EXTRACT_MODELNAME().
c
c May 31 2019: check for SALT3 model.
c
c -----------------------------------------
      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.  
+CDE,SNFITCOM.

c local var

      INTEGER  
     &    j, LM, L0, L1, L2, L3
     &   ,LEN_MODELNAME, LEN_ROOT, LEN_PATH, LEN_VERS

      character 
     &   STRUP*(MXCHAR_MODELNAME)
     &  ,STRLO*(MXCHAR_MODELNAME)
     &  ,tmpFile*(MXCHAR_FILENAME)
     &  ,mtmp*(MXCHAR_MODELNAME)
     &  ,strdefault*20
     &  ,USER_FITMODEL_NAME*(MXCHAR_FILENAME)
     &  ,C_FITMODEL*(MXCHAR_FILENAME)
     &  ,C_PATH*(MXCHAR_FILENAME), C_VERSION*(MXCHAR_MODELNAME)

      LOGICAL USE_DEFAULT

c functions
      CHARACTER*80 RDSTRING

c ------------ BEGIN --------------

      LM = INDEX(FITMODEL_NAME,' ') - 1
      IF ( LM .GE. MXCHAR_FILENAME .or. LM < 1 ) THEN
         write(c1err,61) MXCHAR_FILENAME
 61      format('len(FITMODEL_NAME) exceeds MXCHAR_FILENAME=',I3)
         c2err = 'Please try a shorter FITMODEL_NAME.'
         CALL MADABORT("FITMODEL_INI", c1err, c2err)
      ENDIF

      FITMODEL_INDEX   = -9
      FITMODEL_PATH    = ''
      FITMODEL_VERSION = ''

      DO 10  j = 1, MXMODEL_INDEX 
        FITMODEL_LIST(j) = ''
10    CONTINUE

c first  hard-wird generic name for each model
      FITMODEL_LIST(MODEL_STRETCH)  = 'stretch'
      FITMODEL_LIST(MODEL_STRETCH2) = 'stretch2'
      FITMODEL_LIST(MODEL_mlcs2k2)  = 'mlcs2k2'
      FITMODEL_LIST(MODEL_SALT2)    = 'SALT2'
      FITMODEL_LIST(MODEL_SALT3)    = 'SALT3'
      FITMODEL_LIST(MODEL_snoopy)   = 'snoopy'
      FITMODEL_LIST(MODEL_SIMSED)   = 'SIMSED'

      USER_FITMODEL_NAME = FITMODEL_NAME ! transfer to local variable

c Special case for backward compatibility: for mlcs, change to mlcs2k2 ...
c remove this dumb logic if/when a new MLCS model is provided by the ESSENCE group.
      if ( FITMODEL_NAME .EQ. 'mlcs' .or. 
     &     FITMODEL_NAME .EQ. 'MLCS' ) then
        USER_FITMODEL_NAME = FITMODEL_LIST(MODEL_mlcs2k2) 
      endif

c Feb 22 2017: 
c  check if FITMODEL_NAME includes path. 
c  Note that C function return termination string
      L0 = INDEX(USER_FITMODEL_NAME,' ') - 1
      C_FITMODEL = USER_FITMODEL_NAME(1:L0) // char(0)

      CALL EXTRACT_MODELNAME(C_FITMODEL,    ! input
     &      C_PATH, C_VERSION,              ! output
     &      MXCHAR_FILENAME, MXCHAR_FILENAME, MXCHAR_MODELNAME)

      LEN_PATH = INDEX(C_PATH,    char(0) ) - 1
      LEN_VERS = INDEX(C_VERSION, char(0) ) - 1
      FITMODEL_PATH    = C_PATH(1:LEN_PATH)
      FITMODEL_VERSION = C_VERSION(1:LEN_VERS)

c now get FITMODEL_INDEX ....

      DO 20  j = 1, MXMODEL_INDEX 
         if ( FITMODEL_LIST(j) .EQ. ' ' ) GOTO 20

c check both upper & lower case
         CALL UPCASE(FITMODEL_LIST(j),STRUP)
         CALL LOCASE(FITMODEL_LIST(j),STRLO)
         LM = INDEX(FITMODEL_LIST(j),' ') - 1

         IF ( STRUP(1:LM) .EQ. FITMODEL_VERSION(1:LM)  .or.
     &        STRLO(1:LM) .EQ. FITMODEL_VERSION(1:LM) ) THEN
            FITMODEL_INDEX = j
            LEN_MODELNAME  = LM
         ENDIF
20    CONTINUE

c May 31 2019 hack: if SALT3, switch to SALT2 to avoid lots of code refactor.
      if ( FITMODEL_INDEX == MODEL_SALT3 ) FITMODEL_INDEX=MODEL_SALT2

c abort if FITMODEL_INDEX has not been found.

      IF ( FITMODEL_INDEX .LE. 0 ) THEN
        LM = INDEX(FITMODEL_NAME,' ') - 1
        c1err = 'Unknown FITMODEL_NAME = ' //  FITMODEL_NAME(1:LM)
        c2err = 'Check &FITINP namelist parameter'
        CALL MADABORT("FITMODEL_INI", c1err, c2err)
      ENDIF



c ----------------------------
c finally, if FITMODEL_PATH is not already set above
c with EXTRACT_MODELNAME, then set it here to default path.

      LEN_PATH = INDEX(FITMODEL_PATH, ' ') -1
      IF ( LEN_PATH == 0 ) THEN
         LEN_VERS = INDEX(FITMODEL_VERSION,' ') - 1
         FITMODEL_VERSION = FITMODEL_VERSION(1:LEN_VERS)

         LEN_ROOT = INDEX(SNDATA_ROOT,' ') - 1
         FITMODEL_PATH = SNDATA_ROOT(1:LEN_ROOT) // 
     &       '/models/' // MTMP(1:L0)  //  '/' // 
     &       FITMODEL_VERSION(1:LEN_VERS)
      ENDIF

      RETURN
      END   ! end FITMODEL_INI

C ========================
+DECK,GET_FITFLUX.
      SUBROUTINE GET_FITFLUX(ep, FIT_FLUXCAL, FIT_FLUXCAL_ERR, REJECT)

c Created Mar 17 2021
c Interface for snana to fetch fitted FLUXCAL and error;
c e.g., for OUTLIER table.

      IMPLICIT NONE
      INTEGER EP                         ! (I) epoch index
      REAL FIT_FLUXCAL, FIT_FLUXCAL_ERR  ! (O) fitted flux and erro
      LOGICAL  REJECT                    ! (O) T -> epoch rejected

+CDE,SNDATCOM. 
+CDE,SNANAFIT.    public snana.car
+CDE,SNFITCOM.    local fitter info
C  -------------- BEGIN ------------
      FIT_FLUXCAL       = R4EP_ALL(ep,JEP_MODELFLUX)
      FIT_FLUXCAL_ERR   = R4EP_ALL(ep,JEP_MODELFLUX_ERR)

      REJECT = 
     &  ( I4EP_ALL(ep,IEP_REJECT)  > 0 ) .or.
     &  ( I4EP_ALL(ep,IEP_REJECT2) > 0 )

      RETURN
      END     ! end GET_FITFLUX

C ========================================================
+DECK,GET_FLUX_FITFUN.
      DOUBLE PRECISION FUNCTION GET_FLUX_FITFUN 
     &                    ( ifilt_obs, T8obs, opt )
c
c Wrapper to call USRFUN with final "FITVAL" arguments.
c Call this after fit to get function value; do NOT use
c this before or during fit !!!
c
c OPT = 0  : return nominal function: observer-frame flux
c OPT = 1  : return rest-frame flux 
c                (i.e.; no K-cor, no dL, include AV)
c
c OPT = 2  : return rest-frame flux based on cosmology and XMW
c              (for training)
c OPT = 3  : same as OPT=2, but subtract host-extinction too
c
c OPT = 6  : return rest-frame mag-error instead of flux
c OPT = 10 : return K-correction only
c OPT = 60 : return error on observer-frame flux
c OPT = 99 : return simulated observer flux with no smearing (LSIM=T only) 
c
c
c     HISTORY 
c  ~~~~~~~~~~~~
c Jan 25, 2007: add AVMW arg to USRFUN
c
c Apr 26, 2007: use LCVAL_STORE instead of FITVAL in order
c               to use marginalized values.
c  
c Mar 24, 2008: add OPT=2 to return rest-flux based on cosmology
c               and ignoring MLCS model.
c
c Feb 13, 2012: For REST option
c     - set MWEBV=0 
c     - set DISTPAR8 = GET_DIST8(Zat10pc ...)
c
c May 21, 2012: remove ISN arg.
c --------------------------------------

      IMPLICIT NONE

c define function input
      INTEGER IFILT_OBS    ! (I) SN and obs filter index 
      REAL*8  T8obs             ! (I) MJD - MJDatPk1
      INTEGER opt               ! (I) option      


c local args

+CDE,SNDATCOM. 
+CDE,SNANAFIT.    public snana.car
+CDE,SNFITCOM.    local fitter info
+CDE,SNLCINP.     NFIT_ITERATION is here
  
      REAL*8  
     &   Flux8, Z8, DISTPAR8, COLORPAR8
     &  ,RVHOST8, DLMAG8, SHAPEPAR8(2)
     &  ,AVwarp8, KCOR8(2), MAGERR8, MWEBV8
     &  ,ERRFRAC8, XTAV, XTMW
     &  ,FITPARLOC8(IPAR_MAX)
     &  ,SIMPARLOC8(IPAR_MAX)
     &  ,MAGTMP8, ARG8
     &  ,X08, S2a, S2b

      INTEGER ipar
      LOGICAL LDMP, LFLUX, LREST_COSMO, LMUFIX


c function
      REAL*8  USRFUN, DLMAG8_REF, GET_RV8, GET_DIST8
      INTEGER NEAREST_IFILT_OBS

C -------------- BEGIN ----------------

      GET_FLUX_FITFUN = -9.0

      DO ipar = 1, IPAR_MAX
        FITPARLOC8(ipar) = LCVAL_STORE(ipar)
        SIMPARLOC8(ipar) = SIMVAL_STORE(ipar)
      ENDDO
      MWEBV8 = DBLE ( SNLC_MWEBV ) 

      LREST_COSMO = OPT.EQ.2 .or. OPT.EQ. 3

      IF ( OPT.EQ.1 .or.  OPT.EQ.6 ) then  ! fit-model flux, rest-frame 
          Z8           = Zat10pc
          COLORPAR8    = FITPARLOC8(IPAR_AV) 
          RVHOST8      = GET_RV8(FITPARLOC8)
          SHAPEPAR8(1) = FITPARLOC8(IPAR_SHAPE)
          SHAPEPAR8(2) = FITPARLOC8(IPAR_SHAPE2)
          DISTPAR8     = GET_DIST8(Zat10pc,SHAPEPAR8(1),COLORPAR8,ONE8)
          MWEBV8       = 0.0

      ELSE IF ( OPT .EQ.  0 .or. 
     &          OPT .EQ. 60 .or. 
     &          OPT .EQ. 10 .or.
     &          LREST_COSMO
     &            ) THEN

c  fit-model flux, observer
          Z8           = FITPARLOC8(IPAR_zPHOT)
          DISTPAR8     = FITPARLOC8(IPAR_DLMAG)
          COLORPAR8    = FITPARLOC8(IPAR_AV) 
          RVHOST8      = GET_RV8(FITPARLOC8)
          SHAPEPAR8(1) = FITPARLOC8(IPAR_SHAPE)
          SHAPEPAR8(2) = FITPARLOC8(IPAR_SHAPE2)

          LMUFIX = DOFIT_PHOTOZ .and. (INISTP_DLMAG .EQ. 0.0)
          if ( LMUFIX ) THEN
             DLMAG8   = DLMAG8_REF(Z8) 
             DISTPAR8 = GET_DIST8(Z8,SHAPEPAR8(1),COLORPAR8,ONE8)
          endif  ! LMMUFIX

      ELSE IF ( OPT .EQ. 99 ) THEN
          Z8           = SIMPARLOC8(IPAR_zPHOT) 
          COLORPAR8    = SIMPARLOC8(IPAR_AV) 
          RVHOST8      = GET_RV8(SIMPARLOC8)
          DISTPAR8     = SIMPARLOC8(IPAR_DLMAG)
          SHAPEPAR8(1) = SIMPARLOC8(IPAR_SHAPE)
          SHAPEPAR8(2) = SIMPARLOC8(IPAR_SHAPE2)
      ELSE
         write(c1err,660) OPT
660      format('Invalid OPT=',I4 )
         CALL MADABORT("GET_FLUX_FITFUN", c1err, "")
      ENDIF


      LDMP = LDMPFUN(IFILT_OBS)  
     
      FLUX8 = 
     &       USRFUN ( NFIT_ITERATION
     &                ,ifilt_obs          ! (I) obs-frame filter
     &                ,Z8, T8obs          ! (I) redshift and epoch
     &                ,SHAPEPAR8          ! (I) Delta, stretch, x1 ...
     &                ,DISTPAR8           ! (I) MU or x0
     &                ,COLORPAR8          ! (I) AV or c
     &                ,RVHOST8            ! (I) RV
     &                ,MWEBV8             ! (I) MW extinction
     &                ,LDMP               ! (I) dump flag
     &                ,AVwarp8, KCOR8     ! (O)
     &                ,XTAV, XTMW         ! (O)
     &                ,MAGERR8            ! (O) return args
     &              )

      IF ( OPT .EQ. 6 ) then
        GET_FLUX_FITFUN = MAGERR8

      ELSE IF ( LREST_COSMO ) THEN

        magtmp8 = -2.5*DLOG10(FLUX8) + ZEROPOINT_FLUXCAL_DEFAULT 
     &            -(XTMW + KCOR8(1) + DLMAG8_REF(Z8) )

        if ( OPT .EQ. 3 ) magtmp8 = magtmp8 - XTAV

        ARG8 = -0.4 * ( MAGTMP8 - ZEROPOINT_FLUXCAL_DEFAULT)
        GET_FLUX_FITFUN = TEN8**ARG8

cc  xxxxxxx
cc        GET_FLUX_FITFUN = ADUSCALE * TEN8**(-0.4*MAGTMP8)
cc xxxxxxxxx

c -------------
c        print*,' XXXXX ------------------------------------- '
c        print*,' XXXXX ifilt_obs, Tobs = ', ifilt_obs, T8obs
c        print*,' XXXXX XTMW, KCOR = ', XTMW, KCOR8(1)
c        print*,' XXXXX Z, MU = ', Z8, DLMAG8_REF(Z8)
c        print*,' XXXXX FLUX8, MAGTMP8 = ', FLUX8, MAGTMP8
c -------------

      ELSE IF ( OPT .EQ. 60 ) then
        errfrac8        = 1.0 - TEN8**(-0.4*MAGERR8)
        GET_FLUX_FITFUN = FLUX8 * errfrac8
      ELSE IF ( OPT .EQ. 10 ) then
        GET_FLUX_FITFUN = KCOR8(1)  
      ELSE
        GET_FLUX_FITFUN = FLUX8 
      ENDIF 
 
      RETURN
      END     ! end of GET_FLUX_FITFUN 


C ================================================
+DECK,GET_RV8.
      DOUBLE PRECISION FUNCTION GET_RV8(FITPAR8)
c
c Sep 29, 2007
c Returns RV for fitter-function USRFUN
c
c Aug 1, 2009: RV8=1000 (instead of RV_MWDUST) if AV/RV=0
c
c ----------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.  
+CDE,SNFITCOM.   private fitter info
+CDE,SNLCINP.

      REAL*8  FITPAR8(IPAR_MAX)  ! (I) fit-params

c local var

      LOGICAL LDMP 
      REAL*8  RV8, AV8, AV8RV8  

c ------------ BEGIN ---------

      LDMP = .FALSE.

      GET_RV8 = RV_MWCOLORLAW

      IF ( INISTP_AVRV .NE. 0.0 ) THEN
         AV8RV8 = FITPAR8(IPAR_AVRV)   ! AV/RV ratio
         AV8    = FITPAR8(IPAR_AV) 
         if ( abs(AV8RV8) .GT. 1.0E-5 ) then
           RV8    = AV8 / AV8RV8
         else
           RV8    = 10.
         endif
      ELSE
         RV8  = FITPAR8(IPAR_RV) 
      ENDIF

      GET_RV8 = RV8
      
      RETURN
      END

C ==============================
+DECK,RSTFLTWGT.
      SUBROUTINE RESTFILT_WGT (
     &    LAMREST            ! (I) rest-frame wavelegth 
     &   ,ifilt_rest1        ! (I) index of nearest rest-filter
     &   ,ifilt_rest2        ! (I) index of 2nd nearest filter
     &   ,WGT1, WGT2         ! (O) return wgts (sum to 1)
     &      )

c Created Aug 26,2009 by R.Kessler
c
c Return rest-filter weights to allow a smooth transition
c across filters. At a transition wavelength (i.e., 3900 A
c between U & B), WGT1 = WGT2 = 0.5. If more than 
c "LAMREST_MODEL_SMOOTH" Anstroms away from transition
c wavelength, return WGT=1 and WGT=0
c
c These weights can then be used to smooth out the
c model mags and/or errors
c
      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.  
+CDE,SNFITCOM.   private fitter info
+CDE,SNLCINP.
+CDE,FILTCOM.

c subroutine args

      REAL*8  LAMREST, WGT1, WGT2
      INTEGER ifilt_rest1, ifilt_rest2

c local var

      REAL*8  
     &   LAMAVG(2)
     &  ,LAMBOUNDARY
     &  ,LAMDIST
     &  ,LAMDIST_MAX

c function
      REAL*8 SMOOTH_STEPFUN8

C -------------- BEGIN ------------

      WGT1 = 1.0 ! default output
      WGT2 = 0.0

      IF ( LAMREST_MODEL_SMOOTH .LE. 0.0 ) RETURN
      IF ( IFILT_REST1 .EQ. IFILT_REST2  ) RETURN

      LAMAVG(1) = FILTREST_LAMAVG(ifilt_rest1)
      LAMAVG(2) = FILTREST_LAMAVG(ifilt_rest2)

      IF ( LAMAVG(1) .GT. LAMAVG(2) ) THEN
        LAMBOUNDARY = FILTREST_LAMRANGE(1,ifilt_rest1)
      ELSE
        LAMBOUNDARY = FILTREST_LAMRANGE(2,ifilt_rest1)
      ENDIF

c get distance (Ansgrroms) from boundary
      LAMDIST = abs(LAMREST - LAMBOUNDARY)

c bail if too far from boundary
      IF ( LAMDIST .GT. LAMREST_MODEL_SMOOTH ) RETURN

c use SMMOOTH_STEPFUN function normalized to be 
c zero  at LAMBOUNDARY - LAMREST_MODEL_SMOTH, and
c one   at LAMBOUNDARY + LAMREST_MODEL_SMOTH

      LAMDIST_MAX = DBLE ( LAMREST_MODEL_SMOOTH )
      WGT1   = SMOOTH_STEPFUN8(LAMDIST, LAMDIST_MAX )
      WGT2   = 1.0 - WGT1

      RETURN
      END


C ===========================================
+DECK,DATA_MODEL_RATIO.
      REAL FUNCTION DATA_MODEL_RATIO(ifilt)

c 
c Return wgt average of data/model for point on lightcurve.
c This is used for adjusting initial "fluxnorms" for fit.
c Uses EP_XXX arrays, and assumes that they have been
c filled with a call to FCNSNLC with IFLAG=FCNFLAG_USER
c
c Aug 15, 2012: remove obsolet ISN arg.
c Jan 25, 2014: use new I4/R4EP_ALL arrays
c ---------------------

      IMPLICIT NONE
 
      INTEGER  ifilt   ! (I) sparse filter index

c local 

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER imjd, ifilt_obs, i, ep

      REAL RAT, ERR, RSUM, WSUM, w, TREST
      INTEGER NEPFIT

c functions
      LOGICAL MJDSELECT

c ------------- BEGIN ---------

      DATA_MODEL_RATIO = 1.0E-9

      ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
      if ( .NOT. USE_FILT(ifilt_obs) ) return

      RSUM = 0.0
      WSUM = 0.0
      NEPFIT = 0        

      DO 100 i = 1, NFITDATA + NFITDATA_REJECT

         ep   =   EPLIST_FIT(i)

c pick out epochs from only the input IFILT
         IF ( IFILT .NE. I4EP_ALL(ep,IEP_IFILT) ) goto 100

         IMJD =   I4EP_ALL(ep,IEP_IMJD)
         if ( .not. MJDSELECT(imjd,0) ) goto 100

c exclude early or late times to be safe
         TREST = R4EP_ALL(ep,JEP_TREST)
         if ( TREST .LT. -10. ) goto 100
         if ( TREST .GT.  40. ) goto 100

         RAT  = R4EP_ALL(ep,JEP_RATIO) ! data/fit ratio
         ERR  = R4EP_ALL(ep,JEP_RATIO_ERR)

         if ( RAT > 0.0 .and. ERR > 0.0 ) then
            w      = 1.0/ERR**2
            RSUM   = RSUM + W * RAT
            WSUM   = WSUM + W
            NEPFIT = NEPFIT + 1
         endif

 100  CONTINUE

      if ( WSUM .NE. 0.0 ) then
         DATA_MODEL_RATIO = RSUM / WSUM
      else
         DATA_MODEL_RATIO = 1.0
      endif

      RETURN
      END

C ===========================================
+DECK,RDFITNML.
      SUBROUTINE RDFITNML(IERR)
c
c 
c Read &FITINP namelist.
c
c HISTORY
c ---------------------
c
c Sep 30, 2090: Hard-wire DOCHI2_SIGMA = .TRUE.  for photoz fits
c
c Jul 20, 2011: on error call MADABORT with informative message
c               rather than returning IERR=-1.
c
c Jul 25, 2011: abort if OPT_SIMEFF != 0
c
c Aug 20, 2011: 
c  FITWIN_CHI2SIGMA is wide open by default instead of -10 to 50
c
c Aug 28, 2012: udpate defaults for OPT_XTMW_ERR and OPT_COVAR_FLUX
c Mar 17, 2018: INISTP_COLOR -> 0.03 (was 0.2)
c -------------------------------------
      IMPLICIT NONE

+CDE,SNFITPAR.   NULLVAL is here
+CDE,SNDATCOM. 
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNFITINP.

      INTEGER IERR ! (O) 0 => OK

c local var

      INTEGER IFILT, i
      REAL CUTINI(2), TMPCUT
      LOGICAL USE_AVPRIOR

      CHARACTER ctmp*4

C ------------------- BEGIN ---------------------

      CALL PRBANNER ( " READ &FITINP NAMELIST" )
      IERR = 0

      CUTINI(1) = -9.0E8
      CUTINI(2) = +9.0E8

      LTRACE = .FALSE.
      LPLOTCHI2 = .FALSE.
      IPAR_PLOTCHI2 = 0

c init namelist defaults

      FITMODEL_NAME       = ' '

      RESTLAMBDA_FITRANGE(1) =     0.0
      RESTLAMBDA_FITRANGE(2) = 25000.0
      UVLAM_EXTRAPFLUX       = -9.0

c set defgaults to no rejected epochs at 2nd iteration
      DELCHI2_REJECT   = 1.0E9
      FITWIN_TREST(1)  = -999.0
      FITWIN_TREST(2)  = +999.0
  
      FITWIN_TREST_FILTER = ' '

      FITWIN_MJD(1)    = 20000.0
      FITWIN_MJD(2)    = 80000.0

      PEAKMJD_SANITY(1) = 0.0   ! 0 => -20/+5 days from start/end of season
      PEAKMJD_SANITY(2) = 1.0E6

      SIGNOISE_REJECT  = -9.0 

      DO i = 1, 20
        CONTOUR_LIST(1,i) = 0
        CONTOUR_LIST(2,i) = 0
        CONTOUR_LIST(3,i) = 0
        CONTOUR_LIST(4,i) = 0
      ENDDO

      DO i = 1, 2
        FITWIN_ZPULL(i)      = CUTINI(i)
        FITWIN_ZPHOT(i)      = CUTINI(i)
        FITWIN_COLOR(i)      = CUTINI(i)        
        FITWIN_SHAPE(i)      = CUTINI(i)
        FITWIN_PROB(i)       = CUTINI(i)
        FITWIN_NOMARG_PROB(i)  = CUTINI(i)
        FITWIN_CHI2SIGMA(i)    = CUTINI(i)
        FITWIN_TREST(i)        = CUTINI(i)
        FITWIN_MJD(i)          = CUTINI(i)

        FITWIN_COV_OFFDIAG(i)  = CUTINI(i)

        if ( i .eq. 1 ) TMPCUT = 0.0
        if ( i .eq. 2 ) TMPCUT = sqrt(CUTINI(i)) ! so that COVCUT is ok
        FITWIN_PEAKMJD_ERR(i)  = TMPCUT  ! cut in sigma(fitPar)
        FITWIN_MB_ERR(i)       = TMPCUT
        FITWIN_SHAPE_ERR(i)    = TMPCUT
        FITWIN_COLOR_ERR(i)    = TMPCUT

        FITWIN_PEAKMJD_ERRz1(i)  = TMPCUT ! cut on sigma(fitPar)/(1+z)
        FITWIN_MB_ERRz1(i)       = TMPCUT
        FITWIN_SHAPE_ERRz1(i)    = TMPCUT
        FITWIN_COLOR_ERRz1(i)    = TMPCUT
      ENDDO

c hard-wire a few very loose cuts on SALT2-fitted errors
c to reject crazy fits
      FITWIN_COV_OFFDIAG(1)   = -8.0
      FITWIN_COV_OFFDIAG(2)   = +8.0
      FITWIN_MB_ERR(2)        = +1.0 

      SNMAGRMS_for_PHOTOZ = 0.12

      INISTP_PEAKMJD   = 2.0  
      INISTP_AV        = 0.2
      INISTP_COLOR     = 0.03   ! Mar 17 2018 (was 0.2)
      INISTP_RV        = 0.0
      INISTP_AVRV      = 0.0
      INISTP_SHAPE   = 0.3
      INISTP_SHAPE2  = 0.0
      INISTP_DLMAG     = 0.5
      INISTP_X0        = 1.0E-5
      INISTP_PHOTOZ    = 0.0

      INIVAL_PEAKMJD       = NULLVAL
      INIVAL_PEAKMJD_SHIFT = 999999.
      INIVAL_AV        = NULLVAL
      INIVAL_RV        = RV_MWCOLORLAW
      INIVAL_AVRV      = 0.1
      INIVAL_COLOR     = 0.01
      INIVAL_DLMAG     = NULLVAL
      INIVAL_X0        = NULLVAL
      INIVAL_SHAPE   = NULLVAL
      INIVAL_SHAPE2  = NULLVAL
      INIVAL_PHOTOZ    = NULLVAL
      INIVAL_SHIFT_ERRFRAC = 0.0
      FRACERRDIF_REPEATFIT = 1.0E9

c setup default grid w.r.t. peakmjd-estimate
      INIVAL_GRIDSEARCH_DPEAKMJD(1) = -4.0  ! min MJD - PEAKMJD_APPROX (days)
      INIVAL_GRIDSEARCH_DPEAKMJD(2) = +4.0  ! max 
      INIVAL_GRIDSEARCH_DPEAKMJD(3) = +2.0  ! bin size , days
      INIVAL_GRIDSEARCH_COLOR(1)   = 0.0
      INIVAL_GRIDSEARCH_COLOR(2)   = 0.0
      INIVAL_GRIDSEARCH_COLOR(3)   = 0.0
      

      USESIM_AV       = .FALSE.
      USESIM_COLOR    = .FALSE.
      USESIM_RV       = .FALSE.
      USESIM_SHAPE    = .FALSE.
      USESIM_LUMIPAR  = .FALSE.  ! legacy variable
      USESIM_PEAKMJD  = .FALSE.
      USESIM_DLMAG    = .FALSE.
      USESIM_REDSHIFT = .FALSE.
      USESIM_INIVAL   = .FALSE.

      LKCOR_AVWARP  = .TRUE.
      LKCOR_STRETCH = .FALSE.
      LFIXPAR_ALL   = .FALSE.
      LFIXPAR_ADJUST = .FALSE.

      DOCHI2_SIGMA = .FALSE.  ! May 8, 2009
      CHECK_CRAZYFITERR  = .TRUE.

      LDMP_PHOTOZ_DROPFILTER = .FALSE.
      DOFIT_PHOTOZ       = .FALSE.
      SKIP_PHOTOZ_INIT = .FALSE.
      LAMREST_MODEL_SMOOTH = -9.0

      OPT_PHOTOZ       = 0
      PHOTODZ_REJECT   = 0.05    ! initial W.A.G; users should test this
      PHOTODZ1Z_REJECT = -99.0   ! no cut
      PHOTOZ_BOUND(1)  = 1.0E-6
      PHOTOZ_BOUND(2)  = 1.4
      PHOTOZ_ITER1_LAMRANGE(1) =  4000.  ! default => skip UV region; 
      PHOTOZ_ITER1_LAMRANGE(2) = 26000.  ! note this is obs-frame !
 
      ISCALE_COURSEBIN_PHOTOZ = 1
      NEVAL_MCMC_PHOTOZ      =  0
      PARLIST_MCMC_PHOTOZ(1) =  float(NEVAL_MCMC_PHOTOZ)
      PARLIST_MCMC_PHOTOZ(2) =  20.0  ! NEVAL before reducing step size
      PARLIST_MCMC_PHOTOZ(3) =  0.33  ! initial STEP = range * par(3)
      PARLIST_MCMC_PHOTOZ(4) =  0.90  ! step reduction factor
      PARLIST_MCMC_PHOTOZ(5) =  1.00  ! dmu range on mu constraint

      MINOS_ERRMAX_BAD  = .TRUE.
      MINOS_ERR_DLMAG   = .FALSE.
      MINOS_ERR_REQALL0 = .FALSE.
      MINOS_ERR_REQALL1 = .FALSE.
      OPT_COVAR_LCFIT = 0   ! default: do not fix un-invertible COV(x0,x1,c)

      SIMEFF_FILE   =  ' '

      STRETCH_TEMPLATE_FILE = ' '
      SALT2_DICTFILE        = ' '
      SALT2alpha            = 0.14  ! -> JLA value, Dec 2014
      SALT2beta             = 3.20  ! -> JLA value
      OPT_SALT2FIT          = 0  ! 0 => nominal SALT2 defn

      ZSCALE_SIMEFF = 1.0

      TREST_PEAKRENORM(1) = 0.0  ! default is no peak renorm
      TREST_PEAKRENORM(2) = 0.0

c Set option for covariance matrix.
c -9 => use default for each model (Aug 28, 2012)
c  0 => use diagonal elements only
c  1 => use covariance matrix evaluated between iterations
c  2 => use covaraince matrix evaluated each fit trial (slower)
      OPT_COVAR      = -99 ! legacy variable
      OPT_COVAR_FLUX = -9  ! new variable name, Nov 9 2018

c option for covariance errors on Galactic-extinction
      OPT_XTMW_ERR      = -9 ! Sep 22: legacy variable off
      OPT_COVAR_MWXTERR =  1 ! Aug 28, 2012: default is ON

c extinction options (also see GET_SNXT8 in snana.car):
c  1 => use default extinction from CCM89 law
c  2 => use Saurabh's parametrized extinction from alphs,beta,zeta

      OPT_SNXT     = OPT_SNXT_CCM89

c set algorithm for picking rest-frame color
c   1 => use two closest rest-frame filters
c   5 => use closest filter, and then use color corresponding
c        to Saurabh's lookup (use this option for sync-tests only)

      OPT_NEARFILT   = OPT_FILTOBS  ! obsolete : Feb 3 2012

c set option for Kcor errors; use SJ option (=2) as default

      OPT_KCORERR = 2

c scale covariance matrix.
      SCALE_COVAR    = 1.0  ! default scale is 1 => nominal matrix

      FUDGE_COVAR    = 0.0  ! default is no fudge

      USE_MODEL_MAGERR = .TRUE.

      ADD_SALT2ERR_FROMz     = .FALSE.
      ENABLE_MAGSHIFT_SALT2  = .TRUE.
      ENABLE_WAVESHIFT_SALT2 = .TRUE.
      ALLOW_NEGFLUX_SALT2    = .TRUE.  ! default: allow UV Flam<0

c set default Landolt option OFF 
      OPT_LANDOLT = 0
      do i = 1, 10
        LANDOLT_COLOR_SHIFT(i) = 0.0
      enddo

      UCOR_BXB    = .FALSE.

c ---------------------------------
      NGRID_PDF      = 0 
      NSIGMA_PDF     = 4
      MAX_INTEGPDF   = 3

      PRIOR_AVEXP(1)   = 0.334   ! prior = exp(-AV/PRIOR_AVEXP)
      PRIOR_AVEXP(2)   = 1.0E9   ! prior = exp(-AV/PRIOR_AVEXP)
      PRIOR_AVWGT(1)   = 1.0     ! relative wgt of 1st expon
      PRIOR_AVWGT(2)   = 0.0     ! relative wgt of 2nd expon

      PRIOR_AVRES      = 0.0     ! smear AV prior by this resolution
      PRIOR_MJDSIG     = 20.0    ! sigma for gauss prior on PEAKMJD (days)
      PRIOR_ZERRSCALE  = 1000.0   ! default is no prior
      PRIOR_MUERRSCALE = 1000.0   ! default is no prior
      DOPRIOR_DLMAG    = .FALSE. 

      OPT_PRIOR      = 1
      OPT_PRIOR_AV   = 1
      OPT_PRIOR_SIMEFF = 0
      OPT_SIMEFF     = 0   ! obsolete ; abort if set to non-zero

      OPT_MNSTAT_COV = 1   ! 1-> repeat fit on MNSTAT_COV<3 (bad cov)

      SIMFIT_IDEAL_PRESCALE = 0  ! zero --> OFF

c init to wide open
      PRIOR_LUMIPAR_RANGE(1) = -9.0  ! legacy variable
      PRIOR_LUMIPAR_RANGE(2) = +9.0  ! idem
      PRIOR_LUMIPAR_SIGMA    =  0.1  ! idem

      PRIOR_SHAPE_RANGE(1) = -9.0  ! LUMIPAR -> SHAPE (Apr 2013)
      PRIOR_SHAPE_RANGE(2) = +9.0
      PRIOR_SHAPE_SIGMA    =  0.1

      PRIOR_COLOR_RANGE(1) = -9.0  ! LUMIPAR -> SHAPE (Apr 2013)
      PRIOR_COLOR_RANGE(2) = +9.0
      PRIOR_COLOR_SIGMA    =  0.01

c Aug 17 2015: from snlc_sim.defaults since this is no longer read
      PRIOR_DELTA_PROFILE(1) =  0.23  ! sigma(low)
      PRIOR_DELTA_PROFILE(2) =  0.48  ! sigma(upper)
      PRIOR_DELTA_PROFILE(3) = -0.24 ! bifurcate Gaussian peak
      PRIOR_DELTA_PROFILE(4) =  0.1  ! minimum prob (allows tails)

      DOFIT_FILT(0) = .FALSE.  ! protect against passing ifilt_obs=0

      FILTER_FITMAGDIF = ''

      FILTLIST_FITRESTMAG  = ''
      COLORFIX_FITRESTMAG  = 999.  ! crazy value -> use best-fit value
      LUMIFIX_FITRESTMAG   = 999.  ! crazy value -> use best-fit value
      SHAPEFIX_FITRESTMAG  = 999. 
      LAMEXTRAP_FITRESTMAG = 0.0 
      DLAMTOL_FITRESTMAG   = 0.0  ! Mar 28 2020

      FILTLIST_FIT    = ''
      FILTLIST_DMPFCN = ''
      FILTLIST_DMPFUN = ''
      FILTLAM_SHIFT   = ''
      TREST_DMPFUN(1) = -999.
      TREST_DMPFUN(2) = +999.
      SCALE_PLOTCHI2 = 1.0  ! scale range to plot chi2

      NEARFILT_IGNORE_REST = ''

      LDMPFCN(0)     = .FALSE.          
      DO ifilt    = 1, MXFILT_ALL
          DOFIT_FILT(ifilt)  = .FALSE.
          LDMPFCN(ifilt)     = .FALSE.          
          LDMPFUN(ifilt)     = .FALSE.      
          LDMPFCN_PLOTCHI2(ifilt)     = .FALSE.          
          LDMPFUN_PLOTCHI2(ifilt)     = .FALSE.          
          DOFUDGE_FITERR(ifilt)       = .FALSE.
      ENDDO

      USE_FUDGE_FITERR = .FALSE.
      FUDGE_FITERR_MAXITER   = 9
      FUDGE_FITERR_MAXFRAC   = 0.0
      FUDGE_FITERR_TREST(1)  = 999.
      FUDGE_FITERR_TREST(2)  = 999.
      FUDGE_FITERR_TREST(3)  = 999.
      FUDGE_FITERR_TREST(4)  = 999.
      FUDGE_FITERR_RESTLAM(1)  = 1000.
      FUDGE_FITERR_RESTLAM(2)  = 1000.
      FUDGE_FITERR_RESTLAM(3)  = 90000.
      FUDGE_FITERR_RESTLAM(4)  = 90000.
      FUDGE_FITERR_PASSBANDS = 'NULL'

      FUDGEALL_MAXFRAC       = 0.0 
      FUDGEALL_ITER1_MAXFRAC = 0.0

      FUDGE_MAGERR_MODEL = -9.0
      FUDGE_DATAERR_SCALE = 1.0
      FUDGE_MODELERR_SCALE = 1.0

      FITCOVAR_FILE = ''

      MAGLIM_VMAX = ''
      OPT_VMAX    = 0

c -----------------------

ccc      CALL READ_DEFAULT_PRIORS ! removed Aug 13 2015

c ---------------------
c read the 'snana' namelist file for the FITINP namelist

      OPEN (
     &    UNIT   = LUNNML
     &   ,file   = nmlfile
     &   ,status = 'OLD'
     &   ,ERR    = 900 
     &       )

      READ(LUNNML, NML = FITINP, ERR=901, END=902 )  
      CLOSE ( UNIT = LUNNML ) 

      print*,' ' 

      CALL FITNML_OVERRIDE(IERR)

c ------------
c check legacy nml variables.
      if ( PRIOR_LUMIPAR_RANGE(1) .NE.  -9.0  ) THEN
        PRIOR_SHAPE_RANGE(1) = PRIOR_LUMIPAR_RANGE(1) 
      endif
      if ( PRIOR_LUMIPAR_RANGE(2) .NE.  9.0  ) THEN
        PRIOR_SHAPE_RANGE(2) = PRIOR_LUMIPAR_RANGE(2) 
      endif

      if ( PRIOR_LUMIPAR_SIGMA .NE.  0.1  ) THEN
        PRIOR_SHAPE_SIGMA = PRIOR_LUMIPAR_SIGMA
      endif

      IF ( OPT_XTMW_ERR > -8 ) THEN
         OPT_COVAR_MWXTERR = OPT_XTMW_ERR   ! Sep 22, 2013
      ENDIF
      IF ( OPT_COVAR > -98 ) THEN
         OPT_COVAR_FLUX = OPT_COVAR   ! Nov 9 2018
      ENDIF

c ------------------
c check option to turn off all priors.
      IF ( OPT_PRIOR .LE. 0 ) THEN
        OPT_PRIOR_SIMEFF       =  0
        PRIOR_AVEXP(1)         = -1.0
        PRIOR_AVEXP(2)         = -1.0
        PRIOR_SHAPE_RANGE(1)   = -8.0
        PRIOR_SHAPE_RANGE(2)   = +8.0
        PRIOR_COLOR_RANGE(1)   = -8.0
        PRIOR_COLOR_RANGE(2)   = +8.0
        PRIOR_DELTA_PROFILE(4) =  1.0
      ENDIF

      IF ( OPT_SIMEFF .NE. 0 ) THEN
         C1ERR = '&FITINP namelist variable OPT_SIMEFF is obsolete'
         C2ERR = 'Remove OPT_SIMEFF and use SIMEFF_FILE'
         CALL MADABORT('RDFITNML', C1ERR, C2ERR)
      ENDIF
c -------------------------------------
c Convert FILTLIST_XXX strings into logical arrays

      CALL PARSE_NML_FILTLISTS

c ------------------
c make a few checks
      if ( SCALE_COVAR .LE. 0.0 ) then
         USE_MODEL_MAGERR = .FALSE.
      endif

      USE_AVPRIOR = (OPT_PRIOR_AV   .GT. 0) .and.
     &              (prior_avexp(1) .GT. 0.0 )

c turn off sim efficiency code if there is no AV prior.
      if ( .not.  USE_AVPRIOR ) then
         OPT_PRIOR_SIMEFF  = 0
      endif

c check PHOTOZ stuff.

c first, allow user to set integer option or logical flag.

      if ( OPT_PHOTOZ > 0 ) then
         DOFIT_PHOTOZ = .TRUE.
      endif
      if ( DOFIT_PHOTOZ .and. OPT_PHOTOZ .LE. 0 ) then
   ! use host-galaxy prior by default.
   ! But note PRIOR_ZERRSCALE=1000 by default
        ! xxx mark delete  OPT_PHOTOZ = 1
         OPT_PHOTOZ = IBSET(OPT_PHOTOZ,BIT_PHOTOZ_GAUSS) 
      endif

c Set non-zero step-size for PHOTOZ or DLMAG,
c depending on type of fit.

      if ( DOFIT_PHOTOZ ) THEN
         if ( INISTP_PHOTOZ < 1.0E-5 ) INISTP_PHOTOZ    = 0.05    
         DOCHI2_SIGMA     = .TRUE.    ! use proper chi2 when error varies
         INTERP_OPT       = INTERP_ZSMOOTH
         if ( LAMREST_MODEL_SMOOTH .LE. 0.0 ) then
           LAMREST_MODEL_SMOOTH = 200.  ! smooth model over this lambda range
         endif

         NEVAL_MCMC_PHOTOZ = int(PARLIST_MCMC_PHOTOZ(1))
         if ( NEVAL_MCMC_PHOTOZ > 0 )  ISCALE_COURSEBIN_PHOTOZ = 0
      endif

c dump namelist to std out

      IF ( .not. REDUCE_STDOUT_BATCH ) THEN
        WRITE ( 6 , NML = FITINP )
        CALL FLUSH(6)
      ENDIF

      RETURN

c ---------------------------------------------------
900   C1ERR = 'Could not open namelist file '
      CALL MADABORT('RDFITNML', C1ERR,  nmlfile)

901   C1ERR = 'could not read &FITINP namelist from '
      CALL MADABORT('RDFITNML', C1ERR,  nmlfile)

902   C1ERR = 'Could not find &FITINP namelist in'
      CALL MADABORT('RDFITNML', C1ERR,  nmlfile)

      RETURN
      END


C =================================
+DECK,PARSFILT.
      SUBROUTINE PARSE_NML_FILTLISTS
c
c Created Nov 24 by R.Kessler
c Prcoess namelist strings FILTLIST_XXX and NEARFILT_IGNORE_REST,
c and fill integer arrays.
c
c Check every character to allow spaces or no spaces
c betweeh filters: i.e, 'gri' and 'g r i' are both allowed.
c
c Apr 14, 2013:
c   Allow fitting peak-mags in extra filters. For example,
c   to fit ugriz and also compute peak mags in B & V,
c      FILTLIST_FIT   = 'ugriz+BV' 
c
c Apr 17 2017: check ABORT_ON_BADFILTER

c ---------------------

      IMPLICIT NONE

+CDE,SNFITPAR.
+CDE,SNDATCOM. 
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNFITINP.

      INTEGER 
     &   i, ifilt, ifiltdef, iplus, NF
     &  ,L1, L2, N

      CHARACTER FNAM*20, ctmp*4
      LOGICAL LDEF
  
c function
      INTEGER FILTINDX

C --------------- BEGIN -------------
      
      FNAM     = 'PARSE_NML_FILTLISTS'

c --------------------------------

      DO 100 i = 1, MXFILT_ALL

        ctmp = FILTLIST_FIT(i:i)
        if ( ctmp .NE. ' ' ) then
           ifiltdef = FILTINDX(ctmp)
           if ( ifiltDEF .LE.  0 ) then
             c1err = 'Invalid FILTLIST_FIT = ' // FILTLIST_FIT
             c2err = 'Check &FITINP namelist'
             CALL MADABORT(FNAM, c1err, c2err)
           endif
           DOFIT_FILT(ifiltdef) = .TRUE.

           ifilt = IFILTDEF_INVMAP_SURVEY(ifiltdef)

           LDEF = (ifilt .GT. 0 .and. ifilt .LE. NFILTDEF_SURVEY)
           if ( (.NOT. LDEF) .and. ABORT_ON_BADFILTER ) then
 
              write(c1err,662) ctmp(1:1)
662           format('Fit-filter ',A,' is not a survey filter.')

              L1 = INDEX ( FILTLIST_FIT, ' ' ) - 1
              L2 = INDEX (SURVEY_FILTERS, ' ' ) - 1
 
              c2err = 'FILTLIST_FIT = ' // FILTLIST_FIT(1:L1) //
     &           '  but SURVEY_FILTERS = ' // SURVEY_FILTERS(1:L2)
              CALL MADABORT(FNAM, c1err, c2err)      
           endif
        endif

c  skip DUMP options after 20 filters
        if ( i .GE. 20 ) GOTO 100

        ctmp = FILTLIST_DMPFCN(i:i)
        if ( ctmp .NE. ' ' ) then
           ifilt = FILTINDX(ctmp)
           if ( ifilt .LE.  0 ) then
             c1err = 'Invalid FILTLIST_DMPFCN = ' // FILTLIST_DMPFCN
             c2err = 'Check &FITINP namelist'
             CALL MADABORT(FNAM, c1err, c2err)
           endif
           if ( LPLOTCHI2 ) then
              ! either plot ...
              LDMPFCN_PLOTCHI2(ifilt) = .TRUE.
           else
              ! or stdout dump ...
              LDMPFCN(ifilt) = .TRUE.
              LDMPFCN(0)     = .TRUE.
           endif
        endif

        ctmp = FILTLIST_DMPFUN(i:i)
        if ( ctmp .NE. ' ' ) then
           ifilt = FILTINDX(ctmp)
           if ( ifilt .LE.  0 ) then
             c1err = 'Invalid FILTLIST_DMPFUN = ' // FILTLIST_DMPFUN
             c2err = 'Check &FITINP namelist'
             CALL MADABORT(FNAM, c1err, c2err)
           endif
           if ( LPLOTCHI2 ) then
              LDMPFUN_PLOTCHI2(ifilt) = .TRUE.
           else
              LDMPFUN(ifilt) = .TRUE.
           endif
        endif

        ctmp = NEARFILT_IGNORE_REST(i:i)
        if ( ctmp .NE. ' ' ) then
           ifilt = FILTINDX(ctmp)
           if ( ifilt .GT. 0 .and. ifilt .LT. MXFILT_ALL ) then      
             NFILTDEF_IGNORE_REST = NFILTDEF_IGNORE_REST + 1
             N = NFILTDEF_IGNORE_REST
             ifiltdef_ignore_rest(N) = ifilt
           endif
        endif

100   CONTINUE

      RETURN
      END

C ========================================
+DECK,FITNML_OVERRIDE.
      SUBROUTINE FITNML_OVERRIDE(IERR)
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNFITINP.
+CDE,SNLCINP.

      INTEGER IERR ! (O) 0 => OK

c local var
      CHARACTER ARG*(MXCHAR_ARG), ARGLIST(MXKEY_ARGS)*(MXCHAR_ARG)
      INTEGER i, LL, ilast, iuse

      LOGICAL MATCH_NMLKEY

C -------------- BEGIN --------------

      IERR = 0

      i = 2
      ilast = 2

      DO WHILE ( i .LE. NLINE_ARGS )

        CALL GETARG(i,ARG)
        LL = INDEX ( ARG, ' ' ) - 1

        if ( MATCH_NMLKEY('FITMODEL_NAME', 1,i,ARGLIST) ) then
            FITMODEL_NAME = ARGLIST(1)

        else if ( MATCH_NMLKEY('SALT2alpha', 1,i,ARGLIST) ) then
            READ(ARGLIST(1),*) SALT2alpha

        else if ( MATCH_NMLKEY('SALT2beta', 1,i,ARGLIST) ) then
            READ(ARGLIST(1),*) SALT2beta

        else if ( MATCH_NMLKEY('OPT_SALT2FIT', 1,i,ARGLIST) ) then
            READ(ARGLIST(1),*) OPT_SALT2FIT

        else if ( MATCH_NMLKEY('FILTLAM_SHIFT', 1,i,ARGLIST) ) then
            READ(ARGLIST(1),*) FILTLAM_SHIFT 

        else if ( MATCH_NMLKEY('SIMEFF_FILE', 1,i,ARGLIST) ) then
            READ(ARGLIST(1),*) SIMEFF_FILE

        else if ( MATCH_NMLKEY('TREST_PEAKRENORM', 2,i,ARGLIST) ) then
            READ(ARGLIST(1),*) TREST_PEAKRENORM(1)
            READ(ARGLIST(2),*) TREST_PEAKRENORM(2)

        else if ( MATCH_NMLKEY('DELCHI2_REJECT', 1,i,ARGLIST) ) then
            READ(ARGLIST(1),*) DELCHI2_REJECT

        else if ( MATCH_NMLKEY('SIGNOISE_REJECT', 1,i,ARGLIST) ) then
            READ(ARGLIST(1),*) SIGNOISE_REJECT

c --- keep legacy variables TREST_REJECT and MJD_REJECT

        else if ( MATCH_NMLKEY('TREST_REJECT', 2,i,ARGLIST) ) then
            READ(ARGLIST(1),*) TREST_REJECT(1)
            READ(ARGLIST(2),*) TREST_REJECT(2)

        else if ( MATCH_NMLKEY('MJD_REJECT', 2, i,ARGLIST) ) then
            READ(ARGLIST(1),*) MJD_REJECT(1)
            READ(ARGLIST(2),*) MJD_REJECT(2)

        else if (MATCH_NMLKEY('FITWIN_TREST_FILTER',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_TREST_FILTER

        else if ( MATCH_NMLKEY('FITWIN_TREST', 2, i, ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_TREST(1)
            READ(ARGLIST(2),*) FITWIN_TREST(2)

        else if ( MATCH_NMLKEY('FITWIN_MJD', 2, i, ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_MJD(1)
            READ(ARGLIST(2),*) FITWIN_MJD(2)

        else if ( MATCH_NMLKEY('ADD_SALT2ERR_FROMZ', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) ADD_SALT2ERR_FROMz

        else if ( MATCH_NMLKEY('ENABLE_MAGSHIFT_SALT2',
     &            1, i, ARGLIST)) then
            READ(ARGLIST(1),*) ENABLE_MAGSHIFT_SALT2
        else if ( MATCH_NMLKEY('ENABLE_WAVESHIFT_SALT2', 
     &            1, i, ARGLIST)) then
            READ(ARGLIST(1),*) ENABLE_WAVESHIFT_SALT2

        else if ( MATCH_NMLKEY('ALLOW_NEGFLUX_SALT2', 
     &            1, i, ARGLIST)) then
            READ(ARGLIST(1),*) ALLOW_NEGFLUX_SALT2

        else if ( MATCH_NMLKEY('USE_MODEL_MAGERR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USE_MODEL_MAGERR

        else if ( MATCH_NMLKEY('FUDGE_MAGERR_MODEL', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) FUDGE_MAGERR_MODEL

        else if ( MATCH_NMLKEY('FUDGE_DATAERR_SCALE', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) FUDGE_DATAERR_SCALE

        else if (MATCH_NMLKEY('FUDGE_MODELERR_SCALE',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) FUDGE_MODELERR_SCALE

        else if (MATCH_NMLKEY('FUDGE_FITERR_MAXFRAC',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) FUDGE_FITERR_MAXFRAC

        else if (MATCH_NMLKEY('FUDGE_FITERR_TREST', 4,i,ARGLIST)) then
            READ(ARGLIST(1),*) FUDGE_FITERR_TREST(1)
            READ(ARGLIST(2),*) FUDGE_FITERR_TREST(2)
            READ(ARGLIST(3),*) FUDGE_FITERR_TREST(3)

        else if (MATCH_NMLKEY('FUDGE_FITERR_RESTLAM', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FUDGE_FITERR_RESTLAM(1)
            READ(ARGLIST(2),*) FUDGE_FITERR_RESTLAM(2)

        else if(MATCH_NMLKEY('FUDGE_FITERR_PASSBANDS',1,i,ARGLIST)) then
            FUDGE_FITERR_PASSBANDS = ARGLIST(1)

        else if(MATCH_NMLKEY('FUDGEALL_MAXFRAC',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) FUDGEALL_MAXFRAC

        else if(MATCH_NMLKEY('FUDGEALL_ITER1_MAXFRAC',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) FUDGEALL_ITER1_MAXFRAC

        else if(MATCH_NMLKEY('MAX_INTEGPDF',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) MAX_INTEGPDF

        else if ( MATCH_NMLKEY('FITWIN_PROB', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_PROB(1)
            READ(ARGLIST(2),*) FITWIN_PROB(2)

        else if ( MATCH_NMLKEY('FITWIN_NOMARG_PROB',2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_NOMARG_PROB(1)
            READ(ARGLIST(2),*) FITWIN_NOMARG_PROB(1)

        else if ( MATCH_NMLKEY('FITWIN_CHI2SIGMA', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_CHI2SIGMA(1)
            READ(ARGLIST(2),*) FITWIN_CHI2SIGMA(2)

        else if ( MATCH_NMLKEY('FITWIN_TREST', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_TREST(1)
            READ(ARGLIST(2),*) FITWIN_TREST(2)

        else if ( MATCH_NMLKEY('FITWIN_MJD', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_MJD(1)
            READ(ARGLIST(2),*) FITWIN_MJD(2)

        else if ( MATCH_NMLKEY('FITWIN_ZPULL', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_ZPULL(1)
            READ(ARGLIST(2),*) FITWIN_ZPULL(2)

        else if ( MATCH_NMLKEY('FITWIN_ZPHOT', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_ZPHOT(1)
            READ(ARGLIST(2),*) FITWIN_ZPHOT(2)

        else if ( MATCH_NMLKEY('FITWIN_SHAPE', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_SHAPE(1)
            READ(ARGLIST(2),*) FITWIN_SHAPE(2)

        else if ( MATCH_NMLKEY('FITWIN_COLOR', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_COLOR(1)
            READ(ARGLIST(2),*) FITWIN_COLOR(2)

        else if ( MATCH_NMLKEY('FITWIN_COV_OFFDIAG',2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_COV_OFFDIAG(1)
            READ(ARGLIST(2),*) FITWIN_COV_OFFDIAG(2)

        else if ( MATCH_NMLKEY('FITWIN_PEAKMJD_ERR', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_PEAKMJD_ERR(1)
            READ(ARGLIST(2),*) FITWIN_PEAKMJD_ERR(2)

        else if ( MATCH_NMLKEY('FITWIN_MB_ERR', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_MB_ERR(1)
            READ(ARGLIST(2),*) FITWIN_MB_ERR(2)

        else if ( MATCH_NMLKEY('FITWIN_SHAPE_ERR', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_SHAPE_ERR(1)
            READ(ARGLIST(2),*) FITWIN_SHAPE_ERR(2)

        else if ( MATCH_NMLKEY('FITWIN_COLOR_ERR', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_COLOR_ERR(1)
            READ(ARGLIST(2),*) FITWIN_COLOR_ERR(2)

        else if (MATCH_NMLKEY('FITWIN_PEAKMJD_ERRz1',2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_PEAKMJD_ERRz1(1)
            READ(ARGLIST(2),*) FITWIN_PEAKMJD_ERRz1(2)

        else if (MATCH_NMLKEY('FITWIN_MB_ERRz1', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_MB_ERRz1(1)
            READ(ARGLIST(2),*) FITWIN_MB_ERRz1(2)

        else if (MATCH_NMLKEY('FITWIN_SHAPE_ERRz1', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_SHAPE_ERRz1(1)
            READ(ARGLIST(2),*) FITWIN_SHAPE_ERRz1(2)

        else if (MATCH_NMLKEY('FITWIN_COLOR_ERRz1', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) FITWIN_COLOR_ERRz1(1)
            READ(ARGLIST(2),*) FITWIN_COLOR_ERRz1(2)

        else if (MATCH_NMLKEY('PRIOR_ZERRSCALE', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_ZERRSCALE

        else if (MATCH_NMLKEY('PRIOR_MUERRSCALE', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_MUERRSCALE

        else if (MATCH_NMLKEY('OPT_MNSTAT_COV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_MNSTAT_COV

        else if (MATCH_NMLKEY('OPT_PRIOR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_PRIOR

        else if (MATCH_NMLKEY('OPT_PRIOR_AV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_PRIOR_AV

        else if (MATCH_NMLKEY('OPT_PHOTOZ', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_PHOTOZ

        else if (MATCH_NMLKEY('PHOTODZ_REJECT', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PHOTODZ_REJECT

        else if (MATCH_NMLKEY('PHOTODZ1Z_REJECT', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PHOTODZ1Z_REJECT

        else if (MATCH_NMLKEY('PHOTOZ_ITER1_LAMRANGE',2,i,ARGLIST)) then
            READ(ARGLIST(1),*) PHOTOZ_ITER1_LAMRANGE(1)
            READ(ARGLIST(2),*) PHOTOZ_ITER1_LAMRANGE(2)

        else if (MATCH_NMLKEY('PHOTOZ_BOUND', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) PHOTOZ_BOUND(1)
            READ(ARGLIST(2),*) PHOTOZ_BOUND(2)

        else if (MATCH_NMLKEY('ISCALE_COURSEBIN_PHOTOZ',
     &              1, i, ARGLIST) ) then
            READ(ARGLIST(1),*) ISCALE_COURSEBIN_PHOTOZ

        else if (MATCH_NMLKEY('PARLIST_MCMC_PHOTOZ',5,i,ARGLIST)) then
            READ(ARGLIST(1),*) PARLIST_MCMC_PHOTOZ(1)
            READ(ARGLIST(2),*) PARLIST_MCMC_PHOTOZ(2)
            READ(ARGLIST(3),*) PARLIST_MCMC_PHOTOZ(3)
            READ(ARGLIST(4),*) PARLIST_MCMC_PHOTOZ(4)
            READ(ARGLIST(5),*) PARLIST_MCMC_PHOTOZ(5)

        else if (MATCH_NMLKEY('PRIOR_MJDSIG', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_MJDSIG

        else if (MATCH_NMLKEY('PRIOR_AVEXP', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_AVEXP(1)
            READ(ARGLIST(2),*) PRIOR_AVEXP(2)

        else if (MATCH_NMLKEY('PRIOR_AVWGT', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_AVWGT(1)
            READ(ARGLIST(2),*) PRIOR_AVWGT(2)

        else if (MATCH_NMLKEY('PRIOR_AVRES', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_AVRES

c -------- legacy --------
        else if (MATCH_NMLKEY('PRIOR_LUMIPAR_RANGE', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_LUMIPAR_RANGE(1)
            READ(ARGLIST(2),*) PRIOR_LUMIPAR_RANGE(2)

        else if (MATCH_NMLKEY('PRIOR_LUMIPAR_SIGMA', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_LUMIPAR_SIGMA
c -------------------------

        else if (MATCH_NMLKEY('PRIOR_SHAPE_RANGE', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_SHAPE_RANGE(1)
            READ(ARGLIST(2),*) PRIOR_SHAPE_RANGE(2)

        else if (MATCH_NMLKEY('PRIOR_SHAPE_SIGMA', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_SHAPE_SIGMA

        else if (MATCH_NMLKEY('PRIOR_DELTA_PROFILE', 4,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_DELTA_PROFILE(1)
            READ(ARGLIST(2),*) PRIOR_DELTA_PROFILE(2)
            READ(ARGLIST(3),*) PRIOR_DELTA_PROFILE(3)
            READ(ARGLIST(4),*) PRIOR_DELTA_PROFILE(4)

        else if (MATCH_NMLKEY('PRIOR_COLOR_RANGE', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_COLOR_RANGE(1)
            READ(ARGLIST(2),*) PRIOR_COLOR_RANGE(2)

        else if (MATCH_NMLKEY('PRIOR_COLOR_SIGMA', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) PRIOR_COLOR_SIGMA

        else if (MATCH_NMLKEY('NGRID_PDF', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) NGRID_PDF

        else if (MATCH_NMLKEY('NSIGMA_PDF', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) NSIGMA_PDF

        else if (MATCH_NMLKEY('OPT_COVAR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_COVAR

        else if (MATCH_NMLKEY('OPT_COVAR_FLUX', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_COVAR_FLUX

        else if (MATCH_NMLKEY('OPT_COVAR_LCFIT', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_COVAR_LCFIT

        else if (MATCH_NMLKEY('OPT_COVAR_MWXTERR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_COVAR_MWXTERR

        else if (MATCH_NMLKEY('OPT_XTMW_ERR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_XTMW_ERR    ! legacy variable

        else if (MATCH_NMLKEY('SCALE_COVAR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) SCALE_COVAR

        else if (MATCH_NMLKEY('OPT_SNXT', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_SNXT

        else if (MATCH_NMLKEY('OPT_NEARFILT', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_NEARFILT

        else if (MATCH_NMLKEY('OPT_KCORERR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_KCORERR

        else if (MATCH_NMLKEY('ZSCALE_SIMEFF', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) ZSCALE_SIMEFF

        else if (MATCH_NMLKEY('LKCOR_AVWARP', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LKCOR_AVWARP

        else if (MATCH_NMLKEY('OPT_LANDOLT', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_LANDOLT

        else if (MATCH_NMLKEY('UCOR_BXB', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) UCOR_BXB

        else if (MATCH_NMLKEY('RESTLAMBDA_FITRANGE', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) RESTLAMBDA_FITRANGE(1)
            READ(ARGLIST(2),*) RESTLAMBDA_FITRANGE(2)

        else if (MATCH_NMLKEY('UVLAM_EXTRAPFLUX', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) UVLAM_EXTRAPFLUX

        else if(MATCH_NMLKEY('SIMFIT_IDEAL_PRESCALE',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) SIMFIT_IDEAL_PRESCALE

        else if(MATCH_NMLKEY('USESIM_COLOR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USESIM_COLOR

        else if(MATCH_NMLKEY('USESIM_AV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USESIM_AV

        else if(MATCH_NMLKEY('USESIM_RV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USESIM_RV

c ------------- legacy variable
        else if(MATCH_NMLKEY('USESIM_LUMIPAR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USESIM_LUMIPAR
c -------------
        else if(MATCH_NMLKEY('USESIM_SHAPE', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USESIM_SHAPE

        else if(MATCH_NMLKEY('USESIM_PEAKMJD', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USESIM_PEAKMJD

        else if(MATCH_NMLKEY('USESIM_DLMAG', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USESIM_DLMAG

        else if(MATCH_NMLKEY('INIVAL_RV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_RV

        else if(MATCH_NMLKEY('INIVAL_AVRV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_AVRV

        else if(MATCH_NMLKEY('INISTP_AVRV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_AVRV

        else if(MATCH_NMLKEY('INISTP_PEAKMJD', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_PEAKMJD

        else if(MATCH_NMLKEY('INIVAL_PEAKMJD', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_PEAKMJD

        else if(MATCH_NMLKEY('INIVAL_PEAKMJD_SHIFT',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_PEAKMJD_SHIFT

        else if(MATCH_NMLKEY('INISTP_SHAPE',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_SHAPE

        else if(MATCH_NMLKEY('INISTP_DLMAG',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_DLMAG

        else if(MATCH_NMLKEY('INISTP_X0',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_X0
c
        else if(MATCH_NMLKEY('INIVAL_GRIDSEARCH_DPEAKMJD', 
     &             3,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_GRIDSEARCH_DPEAKMJD(1)
            READ(ARGLIST(2),*) INIVAL_GRIDSEARCH_DPEAKMJD(2)
            READ(ARGLIST(3),*) INIVAL_GRIDSEARCH_DPEAKMJD(3)

        else if(MATCH_NMLKEY('USESIM_INIVAL', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) USESIM_INIVAL

        else if(MATCH_NMLKEY('INIVAL_GRIDSEARCH_COLOR',
     &            3,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_GRIDSEARCH_COLOR(1)
            READ(ARGLIST(2),*) INIVAL_GRIDSEARCH_COLOR(2)
            READ(ARGLIST(3),*) INIVAL_GRIDSEARCH_COLOR(3)
c
        else if(MATCH_NMLKEY('LANDOLT_COLOR_SHIFT',5,i,ARGLIST)) then
            READ(ARGLIST(1),*) LANDOLT_COLOR_SHIFT(1)  ! k0
            READ(ARGLIST(2),*) LANDOLT_COLOR_SHIFT(2)  ! k1
            READ(ARGLIST(3),*) LANDOLT_COLOR_SHIFT(3)  ! k2
            READ(ARGLIST(4),*) LANDOLT_COLOR_SHIFT(4)  ! k3
            READ(ARGLIST(5),*) LANDOLT_COLOR_SHIFT(5)  ! k4

        else if(MATCH_NMLKEY('CHECK_CRAZYFITERR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) CHECK_CRAZYFITERR

        else if(MATCH_NMLKEY('DOFIT_PHOTOZ', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) DOFIT_PHOTOZ

        else if(MATCH_NMLKEY('SKIP_PHOTOZ_INIT', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) SKIP_PHOTOZ_INIT

        else if(MATCH_NMLKEY('LDMP_PHOTOZ_DROPFILTER',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LDMP_PHOTOZ_DROPFILTER

        else if(MATCH_NMLKEY('DOCHI2_SIGMA', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) DOCHI2_SIGMA

        else if(MATCH_NMLKEY('LAMREST_MODEL_SMOOTH',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LAMREST_MODEL_SMOOTH

        else if(MATCH_NMLKEY('FILTER_FITMAGDIF',1,i,ARGLIST)) then
            FILTER_FITMAGDIF = ARGLIST(1)

        else if(MATCH_NMLKEY('FILTLIST_FITRESTMAG',1,i,ARGLIST)) then
            FILTLIST_FITRESTMAG = ARGLIST(1)

        else if(MATCH_NMLKEY('LUMIFIX_FITRESTMAG',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LUMIFIX_FITRESTMAG   ! legacy

        else if(MATCH_NMLKEY('SHAPEFIX_FITRESTMAG', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) SHAPEFIX_FITRESTMAG 

        else if(MATCH_NMLKEY('LAMEXTRAP_FITRESTMAG', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LAMEXTRAP_FITRESTMAG

        else if(MATCH_NMLKEY('DLAMTOL_FITRESTMAG', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) DLAMTOL_FITRESTMAG 

        else if(MATCH_NMLKEY('FILTLIST_FIT', 1,i,ARGLIST)) then
            FILTLIST_FIT = ARGLIST(1)

        else if(MATCH_NMLKEY('FILTLIST_DMPFCN', 1,i,ARGLIST)) then
            FILTLIST_DMPFCN = ARGLIST(1)

        else if(MATCH_NMLKEY('FILTLIST_DMPFUN', 1,i,ARGLIST)) then
            FILTLIST_DMPFUN = ARGLIST(1)

        else if(MATCH_NMLKEY('TREST_DMPFUN', 2,i,ARGLIST)) then
            READ(ARGLIST(1),*) TREST_DMPFUN(1) 
            READ(ARGLIST(2),*) TREST_DMPFUN(2) 

        else if(MATCH_NMLKEY('NEARFILT_IGNORE_REST',1,i,ARGLIST)) then
            NEARFILT_IGNORE_REST = ARGLIST(1)

        else if(MATCH_NMLKEY('LTRACE',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LTRACE

        else if(MATCH_NMLKEY('LFIXPAR_ALL',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LFIXPAR_ALL

        else if(MATCH_NMLKEY('LFIXPAR_ADJUST',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LFIXPAR_ADJUST

        else if(MATCH_NMLKEY('LPLOTCHI2',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) LPLOTCHI2

        else if(MATCH_NMLKEY('IPAR_PLOTCHI2',1,i,ARGLIST)) then
            READ(ARGLIST(1),*) IPAR_PLOTCHI2

        else if(MATCH_NMLKEY('MINOS_ERRMAX_BAD', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) MINOS_ERRMAX_BAD

        else if(MATCH_NMLKEY('INIVAL_SHAPE', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_SHAPE

        else if(MATCH_NMLKEY('INISTP_SHAPE', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_SHAPE

        else if(MATCH_NMLKEY('INIVAL_SHIFT_ERRFRAC', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_SHIFT_ERRFRAC

        else if(MATCH_NMLKEY('FRACERRDIF_REPEATFIT', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) FRACERRDIF_REPEATFIT

        else if(MATCH_NMLKEY('INIVAL_AV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_AV

        else if(MATCH_NMLKEY('INISTP_AV', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_AV

        else if(MATCH_NMLKEY('INIVAL_COLOR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_COLOR

        else if(MATCH_NMLKEY('INISTP_COLOR', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_COLOR

        else if(MATCH_NMLKEY('INIVAL_X0', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_X0

        else if(MATCH_NMLKEY('INIVAL_DLMAG', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_DLMAG

        else if(MATCH_NMLKEY('INIVAL_PHOTOZ', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INIVAL_PHOTOZ

        else if(MATCH_NMLKEY('INISTP_PHOTOZ', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) INISTP_PHOTOZ

c --- Vmax

        else if(MATCH_NMLKEY('MAGLIM_VMAX', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) MAGLIM_VMAX

        else if(MATCH_NMLKEY('OPT_VMAX', 1,i,ARGLIST)) then
            READ(ARGLIST(1),*) OPT_VMAX

         endif

c set logical flag for used LINE_ARGS
 
         IF ( i .GT. ilast ) THEN
           DO iuse = ilast, i
              USE_LINE_ARGS(iuse) = .TRUE.
           ENDDO
         ENDIF

         i = i + 1
         ilast = i
 
      ENDDO

      RETURN
      END


C ==========================================
+DECK,FINI_PARVAL.
      SUBROUTINE FITINI_PARVAL ( iter )
c
c Init INIVAL_ and INISTP arrays.
c
c Nov 29 2013:  fix USESIM_PEAKMJD by setting
c                  INIVAL(ipar) = INIVAL(ipar) - MJDOFF 
c               for ipar = IPAR_PEAKMJD.
c
c Dec 5 2013: remove ISN arg, and set SIMCHI2_CHEAT=0
c
c Aug 29 2017: check DOFIT_IDEAL
c
c Apr 13 2020: fix INISTP[VAL]_SHAPE logic for MLCS2k2 and SNOOPY
c Jun 04 2021: if USESIM_REDSHIFT, set z errors to 1.0E-4
c
c ----------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITIDEALCOM.

      INTEGER 
     &   iter  ! (I) fit iteration: 1,2, ... NFIT_ITERATION

c local var

      INTEGER  NPAR, ipar, ITER_LAST
      REAL*8   PEAKMJD, VALTMP, ERRTMP
      LOGICAL  FIRST_ITER, JG
    
c SALT2 stuff
      REAL*8 MU, MUMIN, MUMAX, x0, X0MIN, X0MAX, mb, S2a, S2b     

c functions
      REAL*8  SALT2x0calc, SALT2mBcalc  ! functions
      LOGICAL FIRST_ITERATION

C ---------- BEGIN -------------

      FIRST_ITER = FIRST_ITERATION(ITER) .and. (.not. LREPEAT_ITER)

      IF ( ITER .EQ. 1 ) THEN
         ITER_LAST = 1
      ELSE
         ITER_LAST = ITER - 1
      ENDIF

c init everything to BIDON value or to value of last iteration

      DO ipar = 1, NFITPAR_MN
        IF ( FIRST_ITER ) then
           INIVAL(ipar)       =  -9.0
           INISTP(ipar)       =   0.0
        ELSE 
           VALTMP = FITVAL(ipar,ITER_LAST)
           ERRTMP =  FITERR(ipar,ITER_LAST) 
           INIVAL(ipar) =  VALTMP + ERRTMP*INIVAL_SHIFT_ERRFRAC
           INISTP(ipar) =  ERRTMP
        ENDIF
      ENDDO


c always modify ITERation parameter
      ipar            = IPAR_ITER
      INIVAL(IPAR)    = DBLE(iter)
      INISTP(IPAR)    = 0.0

c --------------------------------
c special code to emulate Julien's SALT2 recipe
      JG = OPT_SALT2FIT .EQ. 4  ! emulate Julien/snfit (for debug)
      if ( JG .and. ITER > 1 ) then !
           INISTP(IPAR_SHAPE) = INISTP_SHAPE  ! restore
      endif

c check special fitting options
      CALL FITRESTMAG_PREP(ITER)
      CALL FITMAGDIF_PREP(ITER)
      CALL SIMFIT_IDEAL_PREP(ITER)

c continue below on 1st iteration only.
      IF ( .NOT. FIRST_ITER ) RETURN

      SIMCHI2_CHEAT  = 0.0

      ipar           = IPAR_ISN
      INIVAL(IPAR)   = DBLE(N_SNLC_FIT+1) ! changed from ISN, Dec 2013
      INISTP(IPAR)   = 0.0

      ipar            =  IPAR_AV
      INIVAL(IPAR)    =  0.1
      INISTP(IPAR)    =  INISTP_AV
      INIBND(1,IPAR)  =  -2.0
      INIBND(2,IPAR)  =  +6.0

      ipar            =  IPAR_RV
      if ( INISTP_AVRV .GT. 0.0 ) THEN
        INIVAL(IPAR)    =  INIVAL(IPAR_AV) / RV_MWCOLORLAW
        INISTP(IPAR)    =  INISTP_AVRV
        INIBND(1,IPAR)  =  -20.0
        INIBND(2,IPAR)  =   20.0
      ELSE
        INIVAL(IPAR)    =  INIVAL_RV
        INISTP(IPAR)    =  INISTP_RV
        INIBND(1,IPAR)  =  -20.0
        INIBND(2,IPAR)  =   20.0
      ENDIF

      ipar            =  IPAR_PEAKMJD
      PEAKMJD         =  SNLC_SEARCH_PEAKMJD    ! approx peak MJD
      INIVAL(IPAR)    =  PEAKMJD - MJDOFF
      INISTP(IPAR)    =  INISTP_PEAKMJD         ! initial step size, days

      INIBND(1,IPAR)  =  INIVAL(IPAR) - 100.0
      INIBND(2,IPAR)  =  INIVAL(IPAR) + 100.0

      IF ( DEBUG_FLAG == 30 ) THEN
         INIBND(1,IPAR)  =  INIVAL(IPAR) - 30.0
         INIBND(2,IPAR)  =  INIVAL(IPAR) + 30.0
      ENDIF
      FITVAL(IPAR,0)  =  INIVAL(IPAR) 

      ipar            =  IPAR_DLMAG
      INIVAL(IPAR)    =  SNLC_DLMAG
      INISTP(IPAR)    =  INISTP_DLMAG         ! initial step size, mag
      INIBND(1,IPAR)  =   10.0   ! 7/29/2008: changed from -10,80
      INIBND(2,IPAR)  =  +70.0

      if ( USESIM_REDSHIFT ) THEN
         SNLC_REDSHIFT = SIM_REDSHIFT_HELIO
         SNLC_ZHELIO   = SIM_REDSHIFT_HELIO
         SNLC_ZCMB     = SIM_REDSHIFT_CMB   ! Dec 15 2020

c  Jun 2021: set tiny z errors too
         SNLC_REDSHIFT_ERR = 1.0E-4
         SNLC_ZHELIO_ERR   = 1.0E-4
         SNLC_ZCMB_ERR     = 1.0E-4
      endif

      ipar            =  IPAR_zPHOT
      INISTP(IPAR)    =  INISTP_PHOTOZ         ! initial step size
      INIVAL(IPAR)    =  SNLC_REDSHIFT
      INIBND(1,IPAR)  =  -1.0
      INIBND(2,IPAR)  =  +4.0

c note that INIVAL(IPAR_SHAPE,IPAR_SHAPE2) depend
c on the model and are evaluated below.
      ipar            =  IPAR_SHAPE
      INISTP(IPAR)    =  INISTP_SHAPE      ! initial step size
      INIBND(1,IPAR)  =  -20.0
      INIBND(2,IPAR)  =  +20.0

c check for valid model and set model-dependent parameters

      IF (  FITMODEL_INDEX .EQ. MODEL_STRETCH 
     & .or. FITMODEL_INDEX .EQ. MODEL_STRETCH2 ) THEN

         INIVAL(IPAR_SHAPE)    =  1.0
cc         INISTP(IPAR_SHAPE)    =  0.1

         INIBND(1,IPAR_SHAPE)  =   0.0
         INIBND(2,IPAR_SHAPE)  =  +3.0

         IF (  FITMODEL_INDEX .EQ. MODEL_STRETCH2 ) THEN
            INIVAL(IPAR_SHAPE2)    =  1.0 
            INISTP(IPAR_SHAPE2)    =  0.1
            INIBND(1,IPAR_SHAPE2)  =  0.0
            INIBND(2,IPAR_SHAPE2)  = +3.0
         ENDIF

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_MLCS2k2 ) THEN

         INIVAL(IPAR_SHAPE)    =  -0.1
         INISTP(IPAR_SHAPE)    =   0.3

         INIVAL(IPAR_COLOR)    =  INIVAL_AV
         INISTP(IPAR_COLOR)    =  INISTP_AV

c Mar 24, 2012: set bound on AV and DELTA (for photoz fit)

         INIBND(1,IPAR_COLOR) = -3.0  ! AV
         INIBND(2,IPAR_COLOR) =  5.0

         INIBND(1,IPAR_SHAPE) = -1.0  ! DELTA
         INIBND(2,IPAR_SHAPE) = +3.0

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SNOOPY ) THEN

         if (INIVAL_SHAPE==NULLVAL) INIVAL(IPAR_SHAPE) = 1.1
         INISTP(IPAR_SHAPE)    =  INISTP_SHAPE
         INIVAL(IPAR_COLOR)    =  INIVAL_AV
         INISTP(IPAR_COLOR)    =  INISTP_AV

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN

         if (INIVAL_SHAPE==NULLVAL) INIVAL(IPAR_SHAPE) = 0.001
         INISTP(IPAR_SHAPE)   =  INISTP_SHAPE    ! initial step size 
         
         INIVAL(IPAR_COLOR)    =  INIVAL_COLOR
         INISTP(IPAR_COLOR)    =  INISTP_COLOR

c for SALT2, DLMAG is replaced by x0:

         if ( SNLC_DLMAG .GT. 0.0 ) THEN
             MU    = SNLC_DLMAG
         else
             MU  = 35.5555 ! anything to avoid NaN
         endif
         MUMIN = 20.0  
         MUMAX = 70.0

c note that X08min <-> MU8MAX and vice-versa
         S2a = 0.13  ! any non-zero of alpha to avoid abort
         S2b = 3.20  ! idem for betga

         X0    = SALT2x0calc( S2a, S2b, ZERO8, ZERO8, MU )
         X0MAX = SALT2x0calc( S2a, S2b, ZERO8, ZERO8, MUMIN )
         X0MIN = SALT2x0calc( S2a, S2b, ZERO8, ZERO8, MUMAX )

         MB = SALT2mBcalc( X0 )

         IF ( OPT_SALT2FIT .EQ. 0 .or. JG) THEN
           INIVAL(IPAR_X0)    = x0
           INISTP(IPAR_X0)    = x0 * 0.1

           INIBND(1,IPAR_X0)  = x0 * 0.01 
           INIBND(2,IPAR_X0)  = x0 * 100.0

           if ( JG .and. ITER .EQ. 1 ) then ! emulate Julien
              INISTP(IPAR_SHAPE) = 0.0   ! fix x1 on 1st iter 
           endif
       
         ELSE IF ( OPT_SALT2FIT .EQ. 1 ) THEN  ! fit x0
           INIVAL(IPAR_X0)    = log10(x0)
           INISTP(IPAR_X0)    = 0.1
           INIBND(1,IPAR_X0)  = log10(x0min)
           INIBND(2,IPAR_X0)  = log10(x0max)

         ELSE IF ( OPT_SALT2FIT .EQ. 2 ) THEN  ! fit delta-mu
           INIVAL(IPAR_X0)    =   0.001   ! MUDIF
           INISTP(IPAR_X0)    =   0.1
           INIBND(1,IPAR_X0)  = -10.0
           INIBND(2,IPAR_X0)  = +10.0
         ENDIF

c if user fixes DLMAG, then fix X0.

         IF ( INISTP_DLMAG .EQ. 0.0 ) then
           INISTP(IPAR_X0) = 0.0
         ENDIF

         INIVAL(IPAR_MB) = MB
         INISTP(IPAR_MB) = 0.0

c make sure that alpha & beta are defined for photoZ fit.

         IF ( DOFIT_PHOTOZ ) THEN
           if ( SALT2alpha .EQ. -9.0 .or. SALT2beta .EQ. -9.0 ) then
             c1err = 'SALT2alpha and/or SALT2beta not defined:'
             c2err = 'these must be defined for photoZ fit'
             CALL MADABORT("FITINI_PARVAL", c1err, c2err)       
           endif
         ENDIF

c set bounds on color and stretch
c Mar 24, 2012: reduce range from +-2
c Dec 5 2013: reduce max color frmo +2 to +1.
c Aug 30 2021: max color -> 2 to fit redder events

         INIBND(1,IPAR_COLOR) = -1.6  ! c
cc         INIBND(2,IPAR_COLOR) = +1.0 
         INIBND(2,IPAR_COLOR) = +2.0 

         INIBND(1,IPAR_SHAPE) = -5.0  ! x1
         INIBND(2,IPAR_SHAPE) = +5.0

      ELSE IF ( FITMODEL_INDEX .EQ. MODEL_SIMSED ) THEN

         INIVAL(IPAR_SHAPE)  =  0.0
         INISTP(IPAR_SHAPE)  =  0.0
         INIVAL(IPAR_COLOR)  =  0.0
         INISTP(IPAR_COLOR)  =  0.0

         INIVAL(IPAR_X0)    =   0.001   ! MUDIF
         INISTP(IPAR_X0)    =   0.1
         INIBND(1,IPAR_X0)  = -10.0
         INIBND(2,IPAR_X0)  = +10.0

c if user fixes DLMAG, then fix X0.
         IF ( INISTP_DLMAG .EQ. 0.0 ) then
           INISTP(IPAR_X0) = 0.0
         ENDIF

      ELSE
         write(c1err,660) FITMODEL_INDEX
660      format('Invalid FITMODEL_INDEX = ', i4 )
         CALL MADABORT("FITINI_PARVAL", c1err, "")
      ENDIF

c ------------------------

c check if user has specified any INITIAL values.
c To fix a parameter value, must also set INISTP_XXX = 0.0


      IF ( INIVAL_PEAKMJD .GT. 40000. )
     &     INIVAL_PEAKMJD = INIVAL_PEAKMJD - MJDOFF 

      IF ( INIVAL_PEAKMJD .GT. NULLVAL ) 
     &     INIVAL(IPAR_PEAKMJD) = INIVAL_PEAKMJD
      
c AV & COLOR are the same parameter index;
c so allow one or the other.

      IF ( INIVAL_AV .GT. NULLVAL ) THEN
          INIVAL(IPAR_AV) = INIVAL_AV
      ELSE IF ( INIVAL_COLOR .GT. NULLVAL ) THEN
          INIVAL(IPAR_COLOR) = INIVAL_COLOR
      ENDIF

      IF ( INIVAL_RV .GT. NULLVAL .and. INISTP_AVRV .EQ. 0.0 ) 
     &     INIVAL(IPAR_RV) = INIVAL_RV

      IF ( INIVAL_SHAPE .GT. NULLVAL ) 
     &     INIVAL(IPAR_SHAPE) = INIVAL_SHAPE
     
      IF ( INIVAL_DLMAG .GT. NULLVAL ) 
     &     INIVAL(IPAR_DLMAG) = INIVAL_DLMAG

      IF ( INIVAL_PHOTOZ .GT. NULLVAL ) 
     &     INIVAL(IPAR_zPHOT) = INIVAL_PHOTOZ

      IF ( INIVAL_X0 .GT. NULLVAL ) 
     &     INIVAL(IPAR_X0) = INIVAL_X0

c May 2022: check option to set all of the INIVAL to sim-values
c    Note that fit floats all params

      IF ( USESIM_INIVAL ) THEN
         if ( STDOUT_UPDATE ) then
	    print*,'   Set INIVAL = SIM value'
            call flush(6)
         endif
         INIVAL(IPAR_PEAKMJD)  = SIM_PEAKMJD
         INIVAL(IPAR_X0)       = SIM_SALT2X0
         INIVAL(IPAR_SHAPE)    = SIM_SHAPEPAR
         INIVAL(IPAR_COLOR)    = SIM_COLORPAR
         INIVAL(IPAR_zPHOT)    = SIM_REDSHIFT_HELIO
      ENDIF
c --------------------------------------------
c store SIMVAL and check option to use sim values
c in fit.

      IF ( LSIM_SNANA) THEN
         SIMVAL_STORE(IPAR_AV)    = SIM_COLORPAR
         SIMVAL_STORE(IPAR_RV)    = SIM_COLORLAW

         if ( INISTP_AVRV .GT. 0.0 ) then
           SIMVAL_STORE(IPAR_AVRV)  = SIM_COLORPAR/SIM_COLORLAW
         endif

         SIMVAL_STORE(IPAR_PEAKMJD) = SIM_PEAKMJD
         SIMVAL_STORE(IPAR_SHAPE)   = SIM_SHAPEPAR
         SIMVAL_STORE(IPAR_zPHOT)   = SIM_REDSHIFT_HELIO

         IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) then
            SIMVAL_STORE(IPAR_X0)   = SIM_SALT2x0
         ELSE
            SIMVAL_STORE(IPAR_DLMAG)   = SIM_DLMAG
         ENDIF

c now check if want to fix a parameter with the simulated value.

         do ipar = 1, IPAR_MAX
            if ( USESIM_FITPAR(ipar) ) then
               INIVAL(ipar) = SIMVAL_STORE(ipar)
               INISTP(ipar) = 0.0

               IF ( ipar .EQ. IPAR_PEAKMJD ) then
                  INIVAL(ipar) = INIVAL(ipar) - MJDOFF         ! Nov 2013
                  INIVAL(ipar) = INIVAL(ipar) + SHIFT_SETPKMJD ! May 2020
               ENDIF
            endif
         enddo
      ENDIF  ! end LSIM_SNANA

c set FITVAL on 1st interation since this array
c is used in the ADJUST & FITINI_XXXX routines.
c (exception for option that fixes parameters)

        do ipar = 1, IPAR_MAX
           FITVAL(ipar,iter) = INIVAL(ipar)
           FITERR(ipar,iter) = INISTP(ipar)
        enddo

      RETURN
      END   ! end of FITINI_PARVAL


C ==========================================
+DECK,FITINI_PHOTOZ.
      SUBROUTINE FITINI_PHOTOZ ( iter )
c
c Created Jul 11,2006 by R.Kessler
c Used only if DOFIT_PHOTOZ=T.
c Estimate initial PHOTOZ value and fill INIVAL(IPAR_zPHOT)
c
c * if there is a valid host, then INIVAL = Zhost
c
c * if no host and 1st iteration, loop over redshift in bins 
c   of 0.05 with AV=0 and LUMIPAR=0; find min CHI2.
c
c * if LREPEAT, set INIVAL = PHOTOZ from previous fit
c
c Mar 17 2018:
c  On last iteration, INIVAL += small shift to avoid crazy fit errors.
c
c Sep 25 2018:
c   INIVAL(ipar_zphot) = middle of PHOTOZ_BOUND range, not max 
c    [found by R.Hounsell]
c
c Jul 12 2019
c  + call PRINT_INIPAR_ZPHOT before after course minimization
c  + call INIPAR_PHOTOZ_COURSEGRID(..)
c
c Oct 10 2019: abort if USE_SNHOST_ZPHOT=T
c
c --------------------------------------------
      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITRESTCOM.
c+CDE,SNFITPAR.

      INTEGER 
     &   iter  ! (I) fit iteration: 1,2, ... NFIT_ITERATION

c local var

      INTEGER  IPAR, NZBIN, NCBIN, NSBIN
      LOGICAL  LZDONE, LAST_ITER, ISMODEL_SALT2
      REAL*8 ZHOST, ZPHOT_LAST, ZMIN, ZMAX, z, s, c, d
      LOGICAL LPRINT
      CHARACTER BANNER*60, CZTMP*20

c FCNSNLC args

      INTEGER IFLAG, q
      REAL*8 
     &    GRAD(MXFITPAR)
     &   ,CHI2GUESS, CHI2END, CHI2MIN, CHI2, INIVAL_SHIFT
     &   ,ZPHOT_Q(MXZPHOT_Q), ZPHOT_PROB(MXZPHOT_Q)
      CHARACTER FNAM*14
      REAL*8 GET_DIST8, USRFUN
      EXTERNAL USRFUN, init_zPDF_spline

C --------------- BEGIN -----------------

      LPRINT = STDOUT_UPDATE

      IF ( USE_SNHOST_ZPHOT  ) THEN
         c1err = '&SNLCINP input USE_SNHOST_ZPHOT=T'
         c2err = 'not allowed with photo-z fits'
         CALL MADABORT('FITINI_PHOTOZ', c1err, c2err)    
      ENDIF

      IF ( LFIXPAR_ALL  ) RETURN  
      IF ( LSIM_SNANA .and. USESIM_REDSHIFT ) RETURN

      PHOTOZ_ERR_SNFIT  = -9.0
      PHOTOZ_ERR_SNHOST = -9.0
      PHOTOZ_ERR_SNMAG  = -9.0
      PHOTOZ_ERR_ZPULL  = -9.0

c set global MINUIT bound each time since it may
c get over-written in FITINI_PARVAL

      ZMIN = PHOTOZ_BOUND(1)
      ZMAX = Zrange_KCOR(2) + 4.0 * Zbinsize_KCOR    
      ZMAX = min ( ZMAX, PHOTOZ_BOUND(2) )

c reset photoz step, unless this is a 2-band 'FITRESTMAG' fit (Nov 28, 2014)

      IPAR = IPAR_zPHOT
      if ( IFILTOBS_BRACKET(1) < 0 ) then
        INISTP(IPAR)  =  INISTP_PHOTOZ     ! initial step size
      endif

      INIBND(1,ipar)  =  ZMIN
      INIBND(2,ipar)  =  ZMAX


c Mar 27 2018:  
c  on last fit iteration, move INIVAL by a small amount;
c  empirically, this reduces pathological errors on fit par.
c  Pathological error seems to be linked to starting parameters
c  at the exact chi2-minimum, so moving away from the minimum
c  seems to be the solution.
      LAST_ITER     = (ITER           .EQ. NFIT_ITERATION )
      ISMODEL_SALT2 = (FITMODEL_INDEX .EQ. MODEL_SALT2)
      IF ( LAST_ITER .and. ISMODEL_SALT2 ) THEN
        DO ipar = 1, IPAR_MAX
           if ( FLOATPAR(ipar) ) then
              INIVAL_SHIFT = INISTP(IPAR)/5.0  ! 10% of initial step
              if ( ipar == IPAR_X0 ) INIVAL_SHIFT = INIVAL(IPAR)/50.
              INIVAL(IPAR) = INIVAL(IPAR) + INIVAL_SHIFT
           endif
        ENDDO
      ENDIF


c continue processing only on 1st fit iteration, 
      IF ( LREPEAT_ITER  ) RETURN
      IF ( ITER > 1      ) RETURN
      
      IF ( LPRINT) THEN
         write(BANNER,10) SNLC_CCID(1:ISNLC_LENCCID)
10       format('FITINI_PHOTOZ for CID=',A )
         CALL PRBANNER ( BANNER )
      endif

c --------------------------------------------

c set default KCOR look up range to extend beyond KCOR table
      Zrange_KCOR_LU(1) = Zrange_KCOR(1) 
      Zrange_KCOR_LU(2) = Zrange_KCOR(2) * 1.8

c ----------------------------------------
c set initial value and step size.

      Zhost     =  SNHOST_ZPHOT(1)
      LZDONE    = .FALSE.

      IF ( BTEST(OPT_PHOTOZ,BIT_BESTZ_GAUSS) ) THEN  ! Zspec prior
        INIVAL(ipar) = SNLC_REDSHIFT
        LZDONE       = .TRUE.
        CZTMP        = 'REDSHIFT_FINAL'

c Jan 2021: if user has not specified PRIOR_ZERRSCALE, then set it to 1
        if ( PRIOR_ZERRSCALE == 1000.0 )  PRIOR_ZERRSCALE = 1.0
        PHOTODZ_REJECT   = SNLC_REDSHIFT_ERR
        PHOTOZ_ITER1_LAMRANGE(1) =  2000. 

        goto 777        ! Jan 2021

      ELSE IF ( BTEST(OPT_PHOTOZ,BIT_PHOTOZ_GAUSS) ) THEN  ! Zhost prior (1)

        if ( DOFIT_PHOTOZ_HOST ) THEN
           INIVAL(ipar) = Zhost
           LZDONE       = .TRUE.
           CZTMP        = 'Zhost'
        else
           CZTMP        = 'AVG[PHOTOZ_BOUND]'
           INIVAL(IPAR) = (PHOTOZ_BOUND(2) + PHOTOZ_BOUND(1))/2.0 
           IF( SKIP_PHOTOZ_INIT ) GOTO 888
        endif
      
      ELSE IF ( BTEST(OPT_PHOTOZ,BIT_PHOTOZ_QUANTILES) ) THEN ! R. Chen Jun 2022 .xyz
c        Print *, 'xxx Start of quantiles code'
        if ( SNHOST_NZPHOT_Q .le. 0 ) THEN
            c1err = 'zPDF quantiles requested for photo-z fit'
            c2err = 'but there are no zPDF quantiles in the data.'
            CALL MADABORT("FITINI_PHOTOZ", c1err, c2err)
        endif
        do q = 1, SNHOST_NZPHOT_Q
            ZPHOT_PROB(q) = DBLE(SNHOST_ZPHOT_PERCENTILE(q))/100.
            ZPHOT_Q(q)          = DBLE(SNHOST_ZPHOT_Q(1,q))
c            Print *, ZPHOT_PROB(q)
c            Print *, ZPHOT_Q(q)
        enddo
c          Print *, 'xxx Calling init_zPDF_spline'
          CALL init_zPDF_spline(SNHOST_NZPHOT_Q,
     &                          ZPHOT_PROB, ZPHOT_Q)
c          Print *, 'xxx Spline initialized successfully' 
          INIVAL(ipar) = Zhost
          LZDONE       = .TRUE.
          CZTMP        = 'Zhost'
      ENDIF

c check cheat option (4/30/2012)
      IF ( DOFIT_PHOTOZ_CHEAT ) THEN  ! cheat option
        CZTMP        = 'Z(Cheat)'
        INIVAL(ipar) = SNLC_REDSHIFT
        LZDONE       = .TRUE.
      ENDIF


c -------------------------------------------------
c if we get here, then we have just the SN with no hostZ to lean on;
c search course grid to find min chi2.

      IFLAG   = FCNFLAG_USER  ! flag for FCNSNLC
      DOFIT_PHOTOZ_MCMC_ADJUST = 
     &     ( NEVAL_MCMC_PHOTOZ > 0 .and. (.not. LZDONE) )

c -----------------------------------------------------
c call FCNSNLC with INIVAL and IFLAG = FCNFLAG_USER (last-call) 
c to set EP_XXX arrays with initial conditions.
c This is needed to check initial data/model normalization.

c open up the x0 bound for the course grid search (Feb 4, 2014)
      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN
         INIBND(1,IPAR_X0) = 1.0E-15
         INIBND(2,IPAR_X0) = 10000.
      ENDIF

c Use initial guess to get starting CHI2GUESS
      z       = INIVAL(IPAR_zPHOT)
      s       = INIVAL(IPAR_SHAPE)
      c       = INIVAL(IPAR_COLOR)
      d       = GET_DIST8(Z,s,c,ONE8);   
      INIVAL(IPAR_DLMAG) = d        
      if ( DOFIT_PHOTOZ_MCMC_ADJUST ) then
         INIVAL(IPAR_SPARE) = 0.0
      else
         INIVAL(IPAR_SPARE) = 1.0
      endif
      CALL FCNSNLC(NFITPAR_MN,GRAD,CHI2GUESS,INIVAL,IFLAG,USRFUN)
      if(LPRINT) CALL PRINT_INIPAR_ZPHOT('guess',INIVAL,CHI2GUESS)

c - - - - - -
      if ( DOFIT_PHOTOZ_MCMC_ADJUST ) then
         CALL INIPAR_PHOTOZ_MCMC(CHI2GUESS)
      else
         CALL INIPAR_PHOTOZ_COURSEGRID(CHI2GUESS,LZDONE)
      endif

 444  CONTINUE

c update x0-bound for SALT2
      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN
         d = INIVAL(IPAR_DLMAG)
         INIBND(1,IPAR_X0) = 0.01  * d
         INIBND(2,IPAR_X0) = 100.  * d
      ENDIF

      CALL FCNSNLC(NFITPAR_MN,GRAD,CHI2,INIVAL,IFLAG,USRFUN)

777   CONTINUE
      if(LPRINT) CALL PRINT_INIPAR_ZPHOT('eval', INIVAL, chi2)

      CALL FLUSH(6)

888   CONTINUE

      REDSHIFT_FIT = INIVAL(IPAR_zPHOT) 

      RETURN
      END   ! end of FITINI_PHOTOZ

C =============================
+DECK,PRINT_INIPAR_ZPHOT.
      SUBROUTINE PRINT_INIPAR_ZPHOT(string,INIPAR_VAL,chi2)
c Created July 2012
c FITINI_PHOTOZ print utility to show
c     initial-[string]: zPhot,s,c,x0 = [values]

c local var

      IMPLICIT NONE
      CHARACTER STRING*(*)                 ! (I) descriptor
      REAL*8 INIPAR_VAL(*),     chi2   ! (I) values to print

+CDE,SNDATCOM.
+CDE,SNANAFIT. 
+CDE,SNFITCOM.

      REAL*8  z, s, c, x0, d
      INTEGER LZ, LS, LC, LD, LD2
      LOGICAL LEGACY
      CHARACTER PARNAME_D*20

C ----------- BEGIN --------      

      IF ( .not. STDOUT_UPDATE ) RETURN

      LEGACY  = (NEVAL_MCMC_PHOTOZ .EQ. 0)  ! legacy = course grid
      IF ( LEGACY ) THEN
         PARNAME_D = 'dScale'  ! course grid (legacy)
      ELSE
         PARNAME_D = 'dmu'   ! MCMC
      ENDIF

      LZ  = INDEX(PARNAME_STORE(IPAR_zPHOT),  ' ' ) - 1
      LS  = INDEX(PARNAME_STORE(IPAR_SHAPE),  ' ' ) - 1
      LC  = INDEX(PARNAME_STORE(IPAR_COLOR),  ' ' ) - 1
      LD  = INDEX(PARNAME_STORE(IPAR_DLMAG),  ' ' ) - 1
      LD2 = INDEX(PARNAME_D,                  ' ' ) - 1

      z       = INIPAR_VAL(IPAR_zPHOT)
      s       = INIPAR_VAL(IPAR_SHAPE)
      c       = INIPAR_VAL(IPAR_COLOR)
      x0      = INIPAR_VAL(IPAR_DLMAG)      
      d       = INIPAR_VAL(IPAR_SPARE) 

      write(6,43) STRING
     &     ,PARNAME_STORE(IPAR_zPHOT)(1:LZ)
     &     ,PARNAME_STORE(IPAR_SHAPE)(1:LS)
     &     ,PARNAME_STORE(IPAR_COLOR)(1:LC)
     &     ,PARNAME_STORE(IPAR_DLMAG)(1:LD)
     &     ,PARNAME_D(1:LD2)
     &     ,z, s, c, x0, d

 43   format(T5,'initial-',A, 2x, 
     &         5(A,1x),'= ', 3F6.3, 1x, G8.2, 1x, F6.3 )

      write(6,44) STRING, CHI2         
 44   format(T5,'initial-',A, 2x, 'CHI2 = ',G12.4 )
      
      CALL FLUSH(6)

      RETURN
      END

C ====================================
+DECK,INIPAR_PHOTOZ_COURSEGRID.
      SUBROUTINE INIPAR_PHOTOZ_COURSEGRID(CHI2INI,LZFIX)

c Created July 12 2019
c Estimate initial photo-z parameters using course grid.
c [Code moved from FITINI_PHOTOZ]

      IMPLICIT NONE

c subroutine arguments
      REAL*8  CHI2INI ! (I) initial chi2 from guess; try doing better
      LOGICAL LZFIX   ! (I) T=> fix redshift to INIVAL

c local args

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      REAL*8 Z_SAVE, ZMIN, ZMAX, ZBIN, z
      REAL*8 S_SAVE, SMIN, SMAX, SBIN, s
      REAL*8 C_SAVE, CMIN, CMAX, CBIN, c
      REAL*8 Fmodel_SCALE, Fmodel_SCALE_SAVE, d, d_SAVE
      REAL*8 GRAD(MXFITPAR), CHI2, CHI2MIN
      INTEGER NZBIN, NSBIN, NCBIN, iz, is, ic, IFLAG, ITER

      REAL*8 GET_DIST8, USRFUN
      EXTERNAL USRFUN

C ------------- BEGIN ------------

      ITER  = 1
      IFLAG = FCNFLAG_USER  ! to fill EP_XXX arrays in FCNSNLC

      IF ( ISCALE_COURSEBIN_PHOTOZ .LE. 0 ) THEN
         write(c1err,661) ISCALE_COURSEBIN_PHOTOZ
661      format('Invalid ISCALE_COURSEBIN_PHOTOZ = ', I6)
         c2err = 'Check  &FITINP namelist'
         CALL MADABORT("FITINI_PARVAL", c1err, c2err)    
      ENDIF


      CHI2MIN = CHI2INI
      Z_SAVE  = INIVAL(IPAR_zPHOT)
      D_SAVE  = INIVAL(IPAR_DLMAG)  ! mu or x0 (distance par)
      C_SAVE  = INIVAL(IPAR_COLOR)  ! AV or c
      S_SAVE  = INIVAL(IPAR_SHAPE)   ! stretch (x1, delta...)

c loop over redshift, color, stretch to estimate INIVAL
      
      IF ( LZFIX ) THEN
        ZMIN = Z_SAVE
        ZMAX = Z_SAVE       
      ELSE
        ZMIN  = INIBND(1,IPAR_zPHOT)
        ZMAX  = INIBND(2,IPAR_zPHOT)
      ENDIF
      NZBIN = ISCALE_COURSEBIN_PHOTOZ * int(25.*(ZMAX-ZMIN)) + 1
      ZBIN  = (ZMAX - ZMIN) / DBLE(NZBIN)

      CALL SETBINS_FITINI_PHOTOZ(IPAR_COLOR,   ITER, 
     &                 NCBIN,CBIN,CMIN,CMAX)  ! output
      CALL SETBINS_FITINI_PHOTOZ(IPAR_SHAPE, ITER, 
     &                 NSBIN,SBIN,SMIN,SMAX)  ! output

      IF ( STDOUT_UPDATE ) THEN
         print*,'    Course-grid minimization for initial values: '
         write(6,432) NZBIN, 'photoz', ZMIN, ZMAX, ZBIN
         write(6,432) NCBIN, 'color ', CMIN, CMAX, CBIN
         write(6,432) NSBIN, 'shape ', SMIN, SMAX, SBIN
         call flush(6)
 432     format(T10,I3, 2x, A,' bins from ', F8.3,' to ', F8.3,
     &        3x,'(binsize=',F7.3,')'  )
      ENDIF

      DO 55 iz  = 1, NZBIN
        z  = ZMIN + dble(iz-1)*ZBIN 
        INIVAL(IPAR_zPHOT) = Z

      DO 57 is = 1, NSBIN
        s = SMIN + dble(is-1) * SBIN
        INIVAL(IPAR_SHAPE) = s

      DO 59 ic  = 1, NCBIN
        c       = CMIN + dble(ic-1)*CBIN 
        INIVAL(IPAR_COLOR)  = c

        d       = GET_DIST8(Z,s,c,ONE8)
        INIVAL(IPAR_DLMAG)  = d

c call function to evaluate R4SN_XXX variables needed to 
c determine Fmodel_SCALE below.
        CALL FCNSNLC(NFITPAR_MN,GRAD,CHI2,INIVAL,IFLAG,USRFUN)

c now compute Fmodel_SCALE to minimize chi2 as a function of 
c x0 or MU. This is an approximation assuming that the error-squared 
c is constant, but it really depends slightly on the Fmodel_SCALE value.

        IF ( R4SN_FFSUM_CROSS > 0 .and. R4SN_FFSUM_MODEL > 0 ) then
           Fmodel_SCALE        = R4SN_FFSUM_CROSS/R4SN_FFSUM_MODEL
        ELSE
           Fmodel_SCALE        = 1.0  ! June 30 2013
        ENDIF

        d                   = GET_DIST8(Z,s,c,Fmodel_SCALE)
        INIVAL(IPAR_DLMAG)  = d
        CALL FCNSNLC(NFITPAR_MN,GRAD,CHI2,INIVAL,IFLAG,USRFUN)

c ------------
        if ( chi2 < -1300.  ) then
          write(6,667) z, PARNAME_STORE(IPAR_COLOR)(1:3), 
     &                 c,s,d,chi2, Fmodel_SCALE
667       format(' xxxx Z=',F5.3, 2x, A,'=',F6.3, 2x, 
     &           's=',F6.3, 2x, 'DIST=',G8.3, 2x, 'CHI2=',E10.3,
     &           2x, 'Fscale=',G8.3 )
          call flush(6)
cc          STOP ! xxxxxxxx
        endif
c -------
        if ( CHI2 .LT. CHI2MIN ) then
            chi2min = chi2
            Z_SAVE = INIVAL(IPAR_zPHOT)
            C_SAVE = INIVAL(IPAR_COLOR)
            S_SAVE = INIVAL(IPAR_SHAPE)
            D_SAVE = INIVAL(IPAR_DLMAG)
            Fmodel_SCALE_SAVE = Fmodel_SCALE
        endif

59    CONTINUE  ! color
57    CONTINUE  ! lumipar
55    CONTINUE  ! photoz

c load inital redshift and re-run FCNSNLC to update EP_FLUX_MODEL

      INIVAL(IPAR_zPHOT)   = Z_SAVE  ! save redshift
      INIVAL(IPAR_COLOR)   = C_SAVE  ! save color
      INIVAL(IPAR_DLMAG)   = D_SAVE  ! save distance
      INIVAL(IPAR_SHAPE)   = S_SAVE  ! save lumi/shape param
      INIVAL(IPAR_SPARE)   = Fmodel_SCALE_SAVE

      RETURN
      END     ! end INIPAR_PHOTOZ_COURSEGRID

         
C ====================================================
+DECK,INIPAR_PHOTOZ_MCMC.
      SUBROUTINE INIPAR_PHOTOZ_MCMC(CHI2INI)
c Created Jul 2019
c Estimate initial all 5 photo-z params using MCMC  method.
c The goal is to significantly reduce init time compared with
c the COURSEGRID method, and maybe even do a better job.
c Works only for SALT2 model.
c
c   !!! BEWARE: this is experimental !!!
c -------------------------------
      IMPLICIT NONE

c subroutine args
      REAL*8 CHI2INI  ! (I) chi2 from guess params; goal is to beat this

c local var

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER ISEED 
      PARAMETER ( ISEED = 12379 )

      INTEGER NEVAL_REDUCE_STEP
      REAL*8  FRACRANGE_STEPINI, FRAC_STEP_REDUCE, DMU_MAX

      INTEGER IFLAG, NTMP, itry, NPAR, i, IPAR, IPAR_LIST(MXFITPAR)
      REAL*8 CHI2min, DIF, AVG, STEP, VAL, ran
      REAL*8 z,s,c,t0,d, dmu, x0cosmo, x0
      REAL*8 CHI2, CHI2_LAST, ARG, PROB, VALMIN, VALMAX
      REAL*8 MCMC_STEPVAL(MXFITPAR), MCMC_TRYVAL(MXFITPAR)
      REAL*8 GRAD(MXFITPAR), BND_LOCAL(2,MXFITPAR)
      REAL*8 INIVAL_SAVE(MXFITPAR)
      LOGICAL MOVE
      LOGICAL LDMP / .FALSE. /
      CHARACTER PARNAME*20

c function
      REAL*8 GET_DIST8, USRFUN
      EXTERNAL USRFUN

C ------------ BEGIN ----------

      CALL SRAND(ISEED)
      IFLAG   = FCNFLAG_USER 
      CHI2MIN = CHI2INI
      NTMP    = 0

cc    NEVAL_MCMC_PHOTOZ = int(PARLIST_MCMC_PHOTOZ(1)) ! already done
      NEVAL_REDUCE_STEP = int(PARLIST_MCMC_PHOTOZ(2))
      FRACRANGE_STEPINI = PARLIST_MCMC_PHOTOZ(3)
      FRAC_STEP_REDUCE  = PARLIST_MCMC_PHOTOZ(4)
      DMU_MAX           = PARLIST_MCMC_PHOTOZ(5)

      IF ( STDOUT_UPDATE ) THEN
         write(6,30) 'Use MCMC minimization for initial values: '
 30      format(T7,A)  
         write(6,31) NEVAL_MCMC_PHOTOZ, FRAC_STEP_REDUCE,
     &               NEVAL_REDUCE_STEP
 31      format(T7,I3,' evals, STEP*=',F4.2,' every ',I3,' evals.')
         write(6,32) FRACRANGE_STEPINI
 32      format(T7,'Initial MCMC STEP = RANGE x ', F5.2 )
      ENDIF

      NPAR         = 5
      IPAR_LIST(1) = IPAR_ZPHOT
      IPAR_LIST(2) = IPAR_SHAPE
      IPAR_LIST(3) = IPAR_COLOR
      IPAR_LIST(4) = IPAR_PEAKMJD
      IPAR_LIST(5) = IPAR_DLMAG
      
      BND_LOCAL(1,IPAR_ZPHOT)   = INIBND(1,IPAR_ZPHOT)
      BND_LOCAL(2,IPAR_ZPHOT)   = INIBND(2,IPAR_ZPHOT)
      BND_LOCAL(1,IPAR_SHAPE)   = -3.0  ! x1 min
      BND_LOCAL(2,IPAR_SHAPE)   = +3.0  ! x1 max
      BND_LOCAL(1,IPAR_COLOR)   = -0.2  ! c min
      BND_LOCAL(2,IPAR_COLOR  ) =  0.4  ! c max
      BND_LOCAL(1,IPAR_PEAKMJD) = SNLC_SEARCH_PEAKMJD - 7.0
      BND_LOCAL(2,IPAR_PEAKMJD) = SNLC_SEARCH_PEAKMJD + 7.0
      BND_LOCAL(1,IPAR_DLMAG) = -DMU_MAX  ! MU shift w.r.t. cosmo constraint
      BND_LOCAL(2,IPAR_DLMAG) = +DMU_MAX

c for each param, get initial start value and step size
      DO i = 1, NPAR
         IPAR = IPAR_LIST(i)
         DIF  = (BND_LOCAL(2,IPAR) - BND_LOCAL(1,IPAR))
         AVG  = (BND_LOCAL(2,IPAR) + BND_LOCAL(1,IPAR))/2.0
         STEP = DIF * FRACRANGE_STEPINI
         MCMC_STEPVAL(IPAR) = STEP
         MCMC_TRYVAL(IPAR)  = AVG
         INIVAL(IPAR)       = AVG
         PARNAME            = PARNAME_STORE(IPAR)
         if ( IPAR == IPAR_DLMAG ) PARNAME = 'dmu' 

         if ( STDOUT_UPDATE ) then
            write(6,60) PARNAME, AVG, STEP
 60         format(T7,'Start ', A6,' value/step: ', F9.3,'/', F6.3 )
            call flush(6)
         endif
      ENDDO


      z = INIVAL(IPAR_ZPHOT); 
      s = INIVAL(IPAR_SHAPE); 
      c = INIVAL(IPAR_COLOR)
      INIVAL(IPAR_DLMAG) = GET_DIST8(z,s,c,ONE8)
      CALL FCNSNLC(NFITPAR_MN,GRAD,CHI2,INIVAL,IFLAG,USRFUN)
      CHI2_LAST = CHI2

c store initial chi2min in case we don't find better
      CHI2MIN = CHI2
      DO i = 1, NPAR
         IPAR = IPAR_LIST(i)
         INIVAL_SAVE(IPAR) = INIVAL(IPAR)
      ENDDO
      INIVAL_SAVE(IPAR_SPARE) = 0.0  ! dmu from cosmology constraint

c - - - - - - - - - - -

      DO 50 itry = 1, NEVAL_MCMC_PHOTOZ 

         DO 51 i = 1, NPAR
            IPAR   = IPAR_LIST(i)
            ran    = rand()-0.5    ! between -0.5 and +0.5
            STEP   = MCMC_STEPVAL(IPAR)
            VAL    = MCMC_TRYVAL(IPAR) + (STEP*ran)
            VALMIN = BND_LOCAL(1,IPAR)
            VALMAX = BND_LOCAL(2,IPAR)
            ! respect bounds
            if ( VAL < VALMIN ) VAL = VALMIN + STEP/20.0
            if ( VAL > VALMAX ) VAL = VALMAX - STEP/20.0
            INIVAL(IPAR) = VAL
            if ( IPAR == IPAR_DLMAG ) dmu = VAL
 51      CONTINUE

c treat x0/mu a bit different
         z       = INIVAL(IPAR_ZPHOT)
         s       = INIVAL(IPAR_SHAPE) 
         c       = INIVAL(IPAR_COLOR)
         t0      = INIVAL(IPAR_PEAKMJD)
         x0cosmo = GET_DIST8(z,s,c,ONE8)
         x0      = x0cosmo * 10**(-0.4*dmu)
         INIVAL(IPAR_DLMAG) = x0  ! overwrite dmu with x0

c call function to evaluate chi2 for this INIVAL trial
         CALL FCNSNLC(NFITPAR_MN,GRAD,CHI2,INIVAL,IFLAG,USRFUN)

         ARG  = -(CHI2-CHI2_LAST)/2.0
         PROB = EXP(ARG)
         IF ( PROB > 1.0 ) PROB = 1.0
         MOVE = .FALSE.
         if ( RAND() < PROB ) then
            MOVE = .TRUE.
            DO i = 1, NPAR
               IPAR = IPAR_LIST(i)            
               MCMC_TRYVAL(IPAR) = INIVAL(IPAR)
            ENDDO
         endif
         
         if ( CHI2 < CHI2MIN ) then
            CHI2MIN = CHI2
            DO i = 1, NPAR
               IPAR = IPAR_LIST(i)
               INIVAL_SAVE(IPAR) = INIVAL(IPAR)
            ENDDO
            INIVAL_SAVE(IPAR_SPARE) = dmu 
         endif

         NTMP = NTMP + 1
         if ( NTMP == NEVAL_REDUCE_STEP  ) then
c reduce step size, and move to current values with min chi2
            NTMP = 0
            DO i = 1, NPAR
               IPAR = IPAR_LIST(i)
               MCMC_STEPVAL(ipar) = MCMC_STEPVAL(ipar)*FRAC_STEP_REDUCE
               MCMC_TRYVAL(ipar)  = INIVAL_SAVE(ipar)
            ENDDO
         endif

            if ( LDMP ) then 
               print*,' xxx --------------------------------------- '
               write(6,665) z, s, c, t0
               write(6,666) itry, CHI2,CHI2_LAST, PROB, MOVE
               call flush(6)
 665           format('  xxx z, s, c, PKMJD = ', 3F7.3, F11.3 )
 666           format('  xxx itry=',I3, 2x, 'CHI2(cur,last)=',2F6.0, 2x, 
     &              'PROB=',F6.3, 2x, 'MOVE=',L2)
            endif

         CHI2_LAST = CHI2
 50   CONTINUE

c restore INIVAL_SAVE at mon chi2 to global INIVAL
      DO i = 1, NPAR
         IPAR = IPAR_LIST(i)
         INIVAL(IPAR) = INIVAL_SAVE(IPAR)      
      ENDDO
      INIVAL(IPAR_SPARE) = INIVAL_SAVE(IPAR_SPARE)

      RETURN
      END      ! INIPAR_PHOTOZ_MCMC

C ====================================================
+DECK,STBINZPH.
      SUBROUTINE SETBINS_FITINI_PHOTOZ(IPAR,ITER,
     &                                 NBIN,PARBIN,PARMIN,PARMAX)
c
c Created March 25, 2012 by R.Kessler
c
c Call by FITINI_PHOTOZ to set color (IPAR=IPAR_COLOR) or 
c stretch (IPAR=IPAR_SHAPE) bins. These bins are used
c to loop over a course grid to find an approx. global min.
c
c July 5 2019: min color bound -> -0.2 (was -0.3)
c
c ---------------------

      IMPLICIT NONE

c subroutine args.
      INTEGER IPAR                  ! (I) fit parameter index
      INTEGER ITER                  ! (I) fit-iteration to prepare
      INTEGER NBIN                  ! (O) Number of bins
      REAL*8  PARBIN,PARMIN,PARMAX  ! (O) binsize, min and max

c local args

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      LOGICAL DO_SALT2, DO_COLOR, DO_SHAPE
      REAL*8 PARLAST, DIF, BND_LOCAL(2)

C --------------- BEGIN ---------------

c define local bound to be tighter than INIBND since
c INIBND is larger than we need.

      DIF = INIBND(2,IPAR) - INIBND(1,IPAR)
      BND_LOCAL(1) = INIBND(1,IPAR) + 0.2*DIF
      BND_LOCAL(2) = INIBND(2,IPAR) - 0.2*DIF

c hard-code color range for SALT2 model (Dec 2014)
      DO_SALT2 = ( FITMODEL_INDEX .EQ. MODEL_SALT2 )
      DO_COLOR = ( IPAR == IPAR_COLOR ) 
      DO_SHAPE = ( IPAR == IPAR_SHAPE ) 

      IF ( DO_SALT2 .and. DO_COLOR ) THEN
        BND_LOCAL(1) = -0.2  ! -0.3 -> -0.2 (July 3 2019)
        BND_LOCAL(2) = +0.4
      ENDIF

c --------------------------------------------

      IF ( INISTP(IPAR) .EQ. 0.0 ) THEN ! fixed parameter
        NBIN    = 1
        PARMIN  = INIVAL(IPAR)
        PARMAX  = INIVAL(IPAR)
        PARBIN  = 0.0

      ELSE
        PARMIN  = BND_LOCAL(1)
        PARMAX  = BND_LOCAL(2)
        IF ( DO_COLOR ) THEN
           NBIN    = int(6.*(PARMAX-PARMIN) ) + 1     ! hard-wire
        ELSE
           NBIN    = 3  ! stretch/lumi bins
        ENDIF

        NBIN = NBIN * ISCALE_COURSEBIN_PHOTOZ

        PARBIN  = (PARMAX - PARMIN) / DBLE(NBIN)
      ENDIF


      RETURN
      END    ! end SETBINS_FITINI_PHOTOZ

C ==========================================
+DECK,FINI_ADJUST.
      SUBROUTINE FITINI_ADJUST ( iter )
c
c Re-Created April 6, 2009 by R.Kessler
c
c Compute data/model ratio and adjust either MU or x0
c so that initial model matches data better.
c This is much simpler than original version.
c
c Aug 30 2017: use function FIRST_ITERATION instead of test on ITER.
c              --> accomodate SIMFIT_IDEAL logic
c
c Mar 4 2020
c  + modify PKMJD sweep from -2, 2 in 1 day bins, to -4 to +4 in 2 day bins.
c  + remove CHI2TEST on 5*NEPOCH
c
c Aug 4 2021
c  + add optional color grid search with INIVAL_GRIDSEARCH_COLOR - D. Jones
c ----------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITIDEALCOM.

      INTEGER 
     &   iter  ! (I) fit iteration: 1,2, ... NFIT_ITERATION

c local var

      INTEGER 
     &   CID, IFILT, IFILT_OBS, NFILT, LTMP, i, ipar
     &  ,IPAR_ADJUST, NF, NZ, LCHAR, LCHAR2

      LOGICAL LPRINT
      LOGICAL LZFIT, FIRST_ITER, DO_PEAKMJD, DO_COLOR
      CHARACTER BANNER*60, CFILT*(MXFILT_ALL), cpar*20

      REAL
     &   RATIO_FLUX(MXFILT_ALL), RATIO_FLUX_AVG, rflux, CHI2, Xsig, ZTMP
     &  ,PEAKMJD_INI, PEAKMJD_SAVE
     &  ,DIFMJD_MIN, DIFMJD_MAX, DIFMJD_BIN, DIFMJD
     &  ,COLOR_INI, COLOR_SAVE, COLOR_MIN, COLOR_MAX, COLOR_BIN, COLOR
     &  ,PHOTOZ_INI, PHOTOZ_SAVE, PHOTOZ_STP
     &  ,INIVAL_START(IPAR_MAX), RTMP(MXFILT_ALL)

      REAL*8  T8, Z8

c FCNSNLC args
      INTEGER IFLAG
      REAL*8 GRAD(MXFITPAR), CHI8INI, CHI8END, CHI8MIN, CHI8, CHI8TEST

c functions
      REAL  DATA_MODEL_RATIO
      REAL*8  USRFUN
      EXTERNAL USRFUN
      LOGICAL  FIRST_ITERATION

C --------------- BEGIN -------------

      if ( DOFIT_PHOTOZ_MCMC_ADJUST ) RETURN

      if ( LTRACE ) CALL DMPTRACE("INSIDE FITINI_ADJUST: 0")

c process only 1st fit iteration

      FIRST_ITER = FIRST_ITERATION(ITER)

      IF ( .NOT. FIRST_ITER ) RETURN  
      IF ( LFIXPAR_ALL      ) RETURN  
      IF ( USESIM_INIVAL    ) RETURN ! May 2022

      if ( LTRACE ) CALL DMPTRACE("INSIDE FITINI_ADJUST: 1")

      LPRINT = STDOUT_UPDATE


c init everything to zero

      DO ifilt_obs = 1, MXFILT_ALL
         RATIO_FLUX(ifilt_obs)   = -9.0
      ENDDO


      cid   = SNLC_CID
      Z8    = REDSHIFT_FIT

      IFLAG = FCNFLAG_USER  ! to fill EP_XXX arrays in FCNSNLC

      IF ( LPRINT ) THEN
         LCHAR = ISNLC_LENCCID
         write(BANNER,10) cid, SNLC_CCID(1:LCHAR)
10       format('FITINI_ADJUST for CID=',I8, 3x, '(',A,')'   )
         CALL PRBANNER ( BANNER )
      endif

c save initial values before they are modified

      DO ipar = 1, IPAR_MAX
        INIVAL_START(ipar) = INIVAL(ipar)
      ENDDO
      
      if ( LTRACE ) CALL DMPTRACE("INSIDE FITINI_ADJUST: 2")

c -----------------------------------------------------
c call FCNSNLC with INIVAL and IFLAG = FCNFLAG_USER (last-call) 
c to set EP_XXX arrays with initial conditions.
c This is needed to check initial data/model normalization.

      CALL FCNSNLC(NFITPAR_MN,GRAD,CHI8INI,INIVAL,IFLAG,USRFUN)

      if ( LPRINT ) then
        write(6,56) 'BEFORE', chi8INI, NEPOCH_ALL(0)
      endif

      if ( LTRACE ) CALL DMPTRACE("INSIDE FITINI_ADJUST: 3")

c -----------------------------------------------------
c Now check PEAKMJD by testing 1/2-sigma steps

442   CONTINUE

      PEAKMJD_INI  = INIVAL(IPAR_PEAKMJD)
      PEAKMJD_SAVE = INIVAL(IPAR_PEAKMJD)
      DIFMJD_MIN   = INIVAL_GRIDSEARCH_DPEAKMJD(1)
      DIFMJD_MAX   = INIVAL_GRIDSEARCH_DPEAKMJD(2)
      DIFMJD_BIN   = INIVAL_GRIDSEARCH_DPEAKMJD(3)

c     D. Jones color grid search
      COLOR_INI  = INIVAL(IPAR_COLOR)
      COLOR_SAVE = INIVAL(IPAR_COLOR)
      COLOR_MIN   = INIVAL_GRIDSEARCH_COLOR(1)
      COLOR_MAX   = INIVAL_GRIDSEARCH_COLOR(2)
      COLOR_BIN   = INIVAL_GRIDSEARCH_COLOR(3)

      DO_PEAKMJD = (INISTP_PEAKMJD > 0.0 .and. DIFMJD_BIN > 0.0001)
      DO_COLOR   = (INISTP_COLOR   > 0.0 .and. COLOR_BIN  > 0.0001)

      IF ( .not. DO_COLOR ) THEN 
        COLOR_MIN = COLOR_INI
        COLOR_MAX = COLOR_INI
	COLOR_BIN = 999.0   ! avoid infinite loop if no color bins
      ENDIF

      if ( LTRACE ) CALL DMPTRACE("INSIDE FITINI_ADJUST: 4")

      if ( .not. DO_PEAKMJD ) GOTO 444
c xxx mark delet Aug 7 2021  IF ( INISTP_PEAKMJD .EQ. 0.0 ) GOTO 444

      CHI8MIN = CHI8INI
      COLOR   = COLOR_MIN

      DO 300 WHILE ( COLOR < COLOR_MAX+0.0001 ) 
        INIVAL(IPAR_COLOR) = COLOR
        DIFMJD = DIFMJD_MIN
      DO 400 WHILE ( DIFMJD < DIFMJD_MAX+0.001 ) 
        INIVAL(IPAR_PEAKMJD) = PEAKMJD_INI + DIFMJD

        CALL FCNSNLC(NFITPAR_MN,GRAD,CHI8,INIVAL,IFLAG,USRFUN)
        if ( CHI8 .LT. CHI8MIN ) then
            chi8min = chi8
            PEAKMJD_SAVE = INIVAL(IPAR_PEAKMJD)
            COLOR_SAVE = INIVAL(IPAR_COLOR)
        endif
        DIFMJD = DIFMJD + DIFMJD_BIN
400   CONTINUE
        COLOR = COLOR + COLOR_BIN
300   CONTINUE

      if ( LTRACE ) CALL DMPTRACE("INSIDE FITINI_ADJUST: 5")

c load inital PEAK MJD and re-run FCNSNLC to update EP_FLUX_MODEL

      IF ( CHI8MIN < CHI8INI ) THEN
       ! save new initial values at min chi2 on very course grid
        INIVAL(IPAR_PEAKMJD) = PEAKMJD_SAVE 
        INIVAL(IPAR_COLOR) = COLOR_SAVE
      ELSE
       ! restore original values
        INIVAL(IPAR_PEAKMJD) = PEAKMJD_INI
        PEAKMJD_SAVE         = PEAKMJD_INI
        INIVAL(IPAR_COLOR)   = COLOR_INI
        COLOR_SAVE           = COLOR_INI
      ENDIF

      CALL FCNSNLC(NFITPAR_MN,GRAD,CHI8,INIVAL,IFLAG,USRFUN)

      if ( LTRACE ) CALL DMPTRACE("INSIDE FITINI_ADJUST: 6")

c - - - - -
      if ( LPRINT ) then
         LCHAR  = INDEX(PARNAME_STORE(IPAR_PEAKMJD),' ') - 1
         LCHAR2 = INDEX(PARNAME_STORE(IPAR_COLOR),  ' ') - 1
	 IF ( DO_COLOR ) THEN
           write(6,42) 
     &         PARNAME_STORE(IPAR_PEAKMJD)(1:LCHAR),
     &         PARNAME_STORE(IPAR_COLOR)(1:LCHAR2),
     &         PEAKMJD_INI, COLOR_INI,
     &         INIVAL(IPAR_PEAKMJD), INIVAL(IPAR_COLOR), CHI8
	 ELSE
           write(6,41) PARNAME_STORE(IPAR_PEAKMJD)(1:LCHAR),
     &               PEAKMJD_INI, INIVAL(IPAR_PEAKMJD), CHI8
	 ENDIF

41       format(T10,'Adjust ',A,'=',F9.3, ' ==> ', F9.3,
     &             2x, '(CHI2=',F10.2,')'  )

42       format(T6,'Adjust ',A,'/',A, '=', 
     &        F9.3,'/',F6.3, ' ==> ', F9.3,'/',F6.3,
     &        2x, '(CHI2=',F10.2,')'  )

      endif

444   CONTINUE

c ----------------------------------------------------- 
c Now check Data vs. Model;
c The data/model flux ratio-average will serve as
c an estimator for peakmag(data)-peakmag(model).

      RATIO_FLUX_AVG = 0.0
      NFILT          = 0
      DO 105 ifilt = 1, NFILTDEF_SURVEY
        ifilt_obs  = IFILTDEF_MAP_SURVEY(ifilt)
        if ( USE_FILT(ifilt_obs) ) then
          Rflux                 = DATA_MODEL_RATIO(ifilt) 
          RATIO_FLUX(ifilt_obs) = Rflux
          RATIO_FLUX_AVG        = RATIO_FLUX_AVG + Rflux
          NFILT                 = NFILT + 1
        endif
105   CONTINUE

      IF ( NFILT .GT.0 ) THEN
         RATIO_FLUX_AVG = RATIO_FLUX_AVG / float(NFILT)
      ELSE
         RATIO_FLUX_AVG = 1.0
      ENDIF

      IPAR_ADJUST = 0

      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 .and. 
     &     INISTP_X0 > 0.0 ) THEN

         IPAR_ADJUST         = IPAR_X0

         if ( OPT_SALT2FIT .EQ. 0 ) then
           INIVAL(IPAR_ADJUST) = INIVAL(IPAR_ADJUST) 
     &                         * RATIO_FLUX_AVG

         else if ( OPT_SALT2FIT .EQ. 1 ) then
           INIVAL(IPAR_ADJUST) = INIVAL(IPAR_ADJUST) 
     &                         + LOG10(RATIO_FLUX_AVG)

         else if ( OPT_SALT2FIT .EQ. 2 ) then
           INIVAL(IPAR_ADJUST) = INIVAL(IPAR_ADJUST) 
     &                         - 2.5*LOG10(RATIO_FLUX_AVG)
         endif

      ELSE IF ( INISTP_DLMAG .GT. 0.0 ) THEN
         IPAR_ADJUST         = IPAR_DLMAG
         INIVAL(IPAR_ADJUST) = INIVAL(IPAR_ADJUST) 
     &                        -2.5*LOG10(RATIO_FLUX_AVG)
      ENDIF

c #########################################
 
      if ( LPRINT ) then
         
         NF = 0
         CFILT = ' '
         DO ifilt    = 1, NFILTDEF_SURVEY
           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
           if ( USE_FILT(ifilt_obs) ) then
             NF = NF + 1
             LCHAR = INDEX(CFILT,' ') - 1
             CFILT = CFILT(1:LCHAR) 
     &             // FILTDEF_STRING(ifilt_obs:ifilt_obs)
             RTMP(NF) = RATIO_FLUX(ifilt_obs)
          endif
         ENDDO

         write(6,51) CFILT(1:NF) // ' Data/Model flux-ratio'
         DO IFILT = 1,  NF
           write(6,52) RTMP(IFILT)
         ENDDO
         print*,' '

         if ( IPAR_ADJUST .GT. 0 ) then
           CPAR = PARNAME_STORE(IPAR_ADJUST)
           LTMP = INDEX(CPAR,' ') - 1
           write(6,54) 
     &        CPAR(1:LTMP)
     &       ,INIVAL_START(IPAR_ADJUST)
     &       ,INIVAL(IPAR_ADJUST)
        endif

51       format(T4, A, ' :', $ )
52       format(F7.3, $ )
54       format(T8,A,' = ', G10.3,' ==> ', G10.3 )


      ENDIF ! end of LDMP block

      if ( LTRACE ) CALL DMPTRACE("INSIDE FITINI_ADJUST: 8")


c -------------------------------------------
c check chi2 at end of adjustment

      CALL FCNSNLC(NFITPAR_MN,GRAD,CHI8END,INIVAL,IFLAG,USRFUN)
   
      if ( LPRINT ) then
        write(6,56) 'AFTER ', chi8end,  NEPOCH_ALL(0)
      endif

56    format(T4,'FCNSNLC(',A,' FITINI_ADJUST)    returns   CHI2=',
     &      F10.2,'/',I3)

c -----------------------------------------------
c if final chi2 is worse, then switch back to initial parameters
c and minimized PEAKMJD

      IF ( CHI8END .GT. CHI8INI ) THEN
        print*,' '
        print*,'  WARNING: ADJUSTED CHI2 is WORSE => '
        print*,'           SWITCH BACK TO ORIGINAL INIVAL '

        DO ipar = 1, IPAR_MAX
          INIVAL(ipar) = INIVAL_START(ipar) 
        ENDDO
        INIVAL(IPAR_PEAKMJD) = PEAKMJD_SAVE  ! save new PEAKMJD
      ENDIF

      CALL FLUSH(6)

      RETURN
      END  ! end FITINI_ADJUST

C ==========================
+DECK,FITINI_LIST_FILE.
      SUBROUTINE FITINI_LIST_FILE(iter)

C Created Apr 29 2022 by R.Kessler
c If &SNLCINP SNCID_LIST_FILE is set, check for previous SALT2 fit
c values to use as INIVAL when iter=1.

      IMPLICIT NONE

      INTEGER ITER ! (I) fit iteration

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,SNLCINP.

      INTEGER IPAR_LIST(20), NPAR, i, ipar 
      INTEGER ABORT_FLAG, LENV
      LOGICAL USE_FITPAR_LIST_FILE
      REAL*8  DVAL
      CHARACTER cVAR*40
      LOGICAL LDMP 

      REAL*8   MATCH_CIDLIST_PARVAL
      EXTERNAL MATCH_CIDLIST_PARVAL

C ----------- BEGIN ----------

      IF ( ITER > 1 .or. LREPEAT_ITER ) RETURN

      USE_FITPAR_LIST_FILE = BTEST(OPT_SNCID_LIST,1)
      IF ( .NOT. USE_FITPAR_LIST_FILE ) RETURN

c construct list of params to check in SNCID_LIST file

      NPAR = 0

      NPAR = NPAR + 1
      IPAR_LIST(NPAR) = IPAR_PEAKMJD
      NPAR = NPAR + 1
      IPAR_LIST(NPAR) = IPAR_X0
      NPAR = NPAR + 1
      IPAR_LIST(NPAR) = IPAR_SHAPE
      NPAR = NPAR + 1
      IPAR_LIST(NPAR) = IPAR_COLOR

      IF ( DOFIT_PHOTOZ ) THEN
        NPAR = NPAR + 1
        IPAR_LIST(NPAR) = IPAR_zPHOT
      ENDIF
      
      ABORT_FLAG = 0 ! do not abort on missing variable.

      LDMP = STDOUT_UPDATE 

      DO i = 1, NPAR
         IPAR = IPAR_LIST(i)
         LENV = INDEX(PARNAME_STORE(IPAR),' ') - 1
         cVAR = PARNAME_STORE(IPAR)(1:LENV) // char(0)
         if ( IPAR == IPAR_zPHOT ) cVAR = 'zHD' // char(0)

         DVAL = 
     &     MATCH_CIDLIST_PARVAL(INDEX_CID_MATCH, cVAR, ABORT_FLAG,40)
         if ( DVAL > -999.0 ) THEN
             INIVAL(IPAR) = DVAL
             if ( LDMP ) then
               write(6,44) PARNAME_STORE(IPAR), DVAL, SNLC_CCID
 44            format(T8, 'INIVAL ', A8,' -> ', G12.5, 
     &             ' from list file: CID=',A12)
             endif
         ENDIF

      ENDDO

      CALL FLUSH(6)

      RETURN
      END  ! end FITINI_LIST_FILE

C =====================================
+DECK,FITINI_TABLEVAR.
      SUBROUTINE FITINI_TABLEVAR

c -----------------------------------------------
c define extra "PLOTVAR" variables to plot along
c with fit values. These are all plotted as a
c function of ISN.
c
c Jul 21, 2009: fix index bug inside LSIM if-block;
c               increment NPLOTPAR at end of bloc, instead of at start.
c
c Sep 2, 2010: check NPLOTPAR array bound before filter loop
c Feb 13,2012: check NFILTDEF_FITRESTMAG
c
c Sep 29, 2012: call CWNT_DUPLICATE_FILTER(i)  to check for duplicate
c               filter for case-insensitive ntuple.
c
c Jun 24 2013: always ignore FILTER_REPLACE filters for plotting.
c
c Mar 5 2020: ad NPTFIT_REJECT (due to DELCHI2)
c
c -----------------

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FITRESTCOM.  Added Feb 2012
+CDE,TABLEVARCOM.

      CHARACTER cfilt_obs*2, cfilt_rst*1, cfilt*1
      INTEGER   ipar, ifilt, ifilt_obs, ifilt_rst, i
      INTEGER   NTMP, NFADD, IFILTDEF
      LOGICAL   REPLACE, DOFIT

c function
      LOGICAL  DUPLICATE_FILTER
C -------------- BEGIN -------------

c Oct 27, 2011: 
c get fixed number of filters to include in plots and ntuple,
c and create mapping between this fitted subset and
c the complete list of NFILTEDEF_SURVEY
c 

      NFILTOBS_TABLE = 0
      SURVEY_FILTERS_TABLE = ' '

      DO 624 ifilt = 1, NFILTDEF_SURVEY

           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt) 

           REPLACE  = (IFILTOBS_REPLACE(ifilt_obs) .NE. IFILT_OBS)   
           IF ( REPLACE ) GOTO 624  ! always ignore a replaced filter

           DOFIT   = DOFIT_FILT(ifilt_obs)

           if ( DOFIT ) then
               NFILTOBS_TABLE = NFILTOBS_TABLE + 1
               IFILTOBS_MAP_TABLE(NFILTOBS_TABLE) = ifilt_obs
               IFILT_MAP_TABLE(NFILTOBS_TABLE)    = ifilt

               SURVEY_FILTERS_TABLE =
     &           SURVEY_FILTERS_TABLE(1:NFILTOBS_TABLE-1) //
     &           FILTDEF_STRING(IFILT_OBS:IFILT_OBS)
           endif
624   CONTINUE

c - - - - - - - - - - - - - - - - - - - - -
c check filter-REMAP option (Feb 2017)
      IF ( NFILT_REMAP_TABLE > 0 ) THEN
        NFILTOBS_TABLE       = NFILT_REMAP_TABLE
        SURVEY_FILTERS_TABLE = FILTLIST_REMAP_TABLE 
        DO ifilt = 1, NFILT_REMAP_TABLE
           IFILTOBS_MAP_TABLE(ifilt) = IFILTLIST_REMAP_TABLE(ifilt)
        ENDDO
      ENDIF

c ----------------------
c define names of extra calculated parameters to plot; 
c these parnames are used only in HFFITRES

      NPLOTPAR = IPAR_MAX 

c make sure we don't exceed bound before filling arrays
      NTMP = NPLOTPAR + 7 * NFILTDEF_SURVEY
      if ( NTMP .GT. MXFITSTORE ) then
        write(c1err,662) 'Filter', NTMP
        write(c2err,663) MXFITSTORE
        CALL MADABORT ( "FITINI_TABLEVAR", c1err, c2err )
      endif


c add chi2 info for global fit.
      PARPTR_CHI2     =  NPLOTPAR  ! mark pointer-offset to global chi2 vars
 
      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'NDOF'
      PAROPT_STORE(NPLOTPAR)  = OPT_PARSTORE_TEXTTABLE 

      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'NPTFIT_REJECT'  ! Mar 2020

      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'FITCHI2'
      PAROPT_STORE(NPLOTPAR)  = OPT_PARSTORE_TEXTTABLE 

      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'PRIORCHI2'

      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'SIGCHI2'   ! used when DOCHI2_SIGMA=T

      IF ( LSIM_SNANA ) THEN
        NPLOTPAR        =  NPLOTPAR + 1
        PARNAME_STORE(NPLOTPAR) = 'SIMCHI2'     
      ENDIF

c --- now the fit-probs

      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'FITPROB_NOMARG' ! includes prior, before marg

      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'FITPROB'    ! includes prior, after marg
      PAROPT_STORE(NPLOTPAR)  = OPT_PARSTORE_TEXTTABLE 

      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'FITPROB_NOPRIOR'    ! excludes prior

c init everything, even for unused filters.

      DO 555 i = 1, NFILTOBS_TABLE  ! loop over observer-frame filters

        ifilt_obs  = IFILTOBS_MAP_TABLE(i)
        ifilt      = IFILT_MAP_TABLE(i)
        cfilt_obs  = FILTDEF_STRING(ifilt_obs:ifilt_obs)

c check for duplicate 'HBOOK' filters such as g,G or r,R ...
c perfectly allowed in snana, but ntuples cannot distinguish
c since they are case-insensitive.
        IF ( DUPLICATE_FILTER(i,SURVEY_FILTERS_TABLE) ) THEN
           cfilt_obs = cfilt_obs(1:1) // '2'  ! for ntuple distinction
        ENDIF

        NFADD = 0
        ipar = NPLOTPAR + i + NFADD*NFILTOBS_TABLE
        PARNAME_STORE(ipar) = 'm0obs_' // cfilt_obs

        NFADD = NFADD + 1
        ipar = NPLOTPAR + i + NFADD*NFILTOBS_TABLE
        PARNAME_STORE(ipar) = 'em0obs_' // cfilt_obs

        if ( NFILTOBS_TABLE .GT. 20 ) GOTO 555

        NFADD = NFADD + 1
        ipar = NPLOTPAR + i + NFADD*NFILTOBS_TABLE
        PARNAME_STORE(ipar) = 'PEAKFLUX_' // cfilt_obs

        NFADD = NFADD + 1
        ipar = NPLOTPAR + i + NFADD*NFILTOBS_TABLE
        PARNAME_STORE(ipar) = 'EPEAKFLUX_' // cfilt_obs

        NFADD = NFADD + 1
        ipar = NPLOTPAR + i + NFADD*NFILTOBS_TABLE
        PARNAME_STORE(ipar) = 'Nepoch_' // cfilt_obs
     
        NFADD = NFADD + 1
        ipar = NPLOTPAR + i + NFADD*NFILTOBS_TABLE
        PARNAME_STORE(ipar) = 'chi2_' // cfilt_obs

        NFADD = NFADD + 1
        ipar = NPLOTPAR + i + NFADD*NFILTOBS_TABLE
cc xxx mark delete         PARNAME_STORE(ipar) = 'prob_' // cfilt_obs
        PARNAME_STORE(ipar) = 'FITPROB_' // cfilt_obs

555   CONTINUE

      NPLOTPAR = NPLOTPAR + (NFADD+1) * NFILTOBS_TABLE


c plot peakMags in rest-frame.
c The number of rest-frame filters can be different
c than the number of observer-frame filters,
c so do NOT put this part into the 555 loop above.

      IF ( LREST_FITMODEL ) THEN
        DO ifilt     = 1, NFILTDEF_REST
         ifilt_rst = IFILTDEF_MAP_REST(ifilt)
         cfilt_rst = FILTDEF_STRING(ifilt_rst:ifilt_rst)
         NPLOTPAR        = NPLOTPAR + 1
         ipar            = NPLOTPAR
         PARNAME_STORE(ipar) = 'm0rst_' // cfilt_rst

c pointer to assoc NPLOTVAR with ifilt-rest
         PARPTR_IFILT_REST(ifilt_rst) = NPLOTPAR
        ENDDO
      ENDIF

c Feb 2012: Optional FITRESTMAGs
      PARPTR_FITRESTMAG  =  NPLOTPAR  ! mark pointer-offset 
      DO ifilt           = 1, NFILTDEF_FITRESTMAG
         IFILTDEF        = IFILTDEF_FITRESTMAG(ifilt)
         cfilt           = FILTDEF_STRING(ifiltdef:ifiltdef)

         NPLOTPAR        = NPLOTPAR + 1
         ipar            = NPLOTPAR
         PARNAME_STORE(ipar) = 'M0_' // cfilt
         PAROPT_STORE(ipar)  = OPT_PARSTORE_TEXTTABLE 

         NPLOTPAR        = NPLOTPAR + 1
         ipar            = NPLOTPAR
         PARNAME_STORE(ipar) = 'ERRM0_' // cfilt
         PAROPT_STORE(ipar)  = OPT_PARSTORE_TEXTTABLE 
      ENDDO

c Mar 2013: optional FITMAGDIF
      IF ( FILTER_FITMAGDIF .NE. '' ) THEN
         cfilt = FILTER_FITMAGDIF

         NPLOTPAR        = NPLOTPAR + 1
         ipar            = NPLOTPAR
         PARNAME_STORE(ipar) = 'MAGDIF_' // cfilt
         PAROPT_STORE(ipar)  = OPT_PARSTORE_TEXTTABLE 

         NPLOTPAR        = NPLOTPAR + 1
         ipar            = NPLOTPAR
         PARNAME_STORE(ipar) = 'ERRMAGDIF_' // cfilt
         PAROPT_STORE(ipar)  = OPT_PARSTORE_TEXTTABLE 

         NPLOTPAR        = NPLOTPAR + 1
         ipar            = NPLOTPAR
         PARNAME_STORE(ipar) = 'MAGDIF_FITPROB_' // cfilt

         NPLOTPAR        = NPLOTPAR + 1
         ipar            = NPLOTPAR
         PARNAME_STORE(ipar) = 'MAGDIF_FITPROB2_' // cfilt

      ENDIF

c April 2013: optional peak-mag(s) in other observer-frame filters
c             e.g.: FILTLIST_FIT = 'ugriz+BV' -> include B&V peak mags

c ---

      NPLOTPAR            =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'delZ'     

      NPLOTPAR            =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'delmu'     

c Dec 5, 2006: extra Z plots for PHOTOZ fits.

      NPLOTPAR        =  NPLOTPAR + 1
      PARNAME_STORE(NPLOTPAR) = 'delZph'     

      if ( NPLOTPAR .GT. MXFITSTORE ) then
        write(c1err,662) 'FINAL', NPLOTPAR
662     format(A, ' NPLOTPAR = ', I3 )
        write(c2err,663) MXFITSTORE
663     format('Exceeds MXFITSTORE = ', I4 )
        CALL MADABORT ( "FITINI_TABLEVAR", c1err, c2err )
      endif

      RETURN
      END

C =====================================
+DECK,FINI_PRKCOR.
      SUBROUTINE FITINI_PRKCOR()
      IMPLICIT NONE
c
c print info about K corrections
c

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.

c local var

      CHARACTER cfilt*1
      INTEGER   ifilt_rest1, ifilt_rest2, ifilt_obs, ifilt
      REAL Z, LAMDIF_MIN

c function
      INTEGER NEAREST_IFILT_REST

C -------------- BEGIN -------------


      z = REDSHIFT_FIT
      print*,' '
      DO 700 ifilt = 1, NFILTDEF_SURVEY  ! loop over observed filters

        ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
        if ( .NOT. USE_FILT(ifilt_obs) ) goto 700

        ifilt_rest1 = 
     &    NEAREST_IFILT_REST( OPT_FILTOBS, ifilt_obs, 1,Z, LAMDIF_MIN)
        ifilt_rest2 = 
     &    NEAREST_IFILT_REST( OPT_FILTOBS, ifilt_obs, 2,Z, LAMDIF_MIN)

        write(6,701)
     &    SNLC_CCID(1:ISNLC_LENCCID)
     &   ,filtdef_string(ifilt_obs:ifilt_obs)    
     &   ,filtdef_string(ifilt_rest1:ifilt_rest1) 
     &   ,filtdef_string(ifilt_obs:ifilt_obs)    
     &   ,filtdef_string(ifilt_rest1:ifilt_rest1) 
     &   ,filtdef_string(ifilt_rest2:ifilt_rest2) 
     &   ,OPT_FILTOBS

701      FORMAT(T5,'CID=',A, ' : ',
     &             A,'-band KCOR = K_', A,A, 
     &         ' ; AVwarp from ', A,'-', A, 3x,'(OPT=',I2,')' ) 

700   CONTINUE

      RETURN
      END


C =====================================
+DECK,FINI_COV.
      SUBROUTINE FITINI_COV(MSKOPT, ITER, FITPAR, IERR)

c ---------------------------
c init FITCOV arrays used in FCNSNLC and also used 
c to get covariance matrix.
c MSKOPT: bit 1 => print  info to stdout
c ITER = 1, 2, ... = fit iteration.
c
c
c Feb 2020: add OPT_COVAR_MWXT==2 option to include only DIAG part.
c May 2021: pass param lists to gencovar_SALT2
c 
c ----------------------------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER MSKOPT     ! (I) bit-mask of options
      INTEGER ITER       ! (I) fit iteration
      REAL*8  FITPAR(MXFITPAR) ! (I) fit parameters
      INTEGER IERR       ! (O) 0 => ok

c local var

      INTEGER 
     &   ifilt, ifilt_obs, ifilt_rest, ifilt1, ifilt2, ISTAT
     &  ,irow, icol, J1, N, ep, ep_row, ep_col
     &  ,IR(MXFIT_DATA), IFILT_COV(MXFIT_DATA)
     &  ,IFAIL, JFAIL, IFROW, IFCOL, LCCID, NONZERO
     &  ,FIRSTITER_USECOV
   
      REAL*8  
     &   COVTMP, RHO, Z, MWEBV, RHO_TMP, DET, ARG
     &  ,TOBS(MXFIT_DATA)
     &  ,TREST(MXFIT_DATA)
     &  ,COVMAG_ERR(MXFIT_DATA)
     &  ,SQMAGERR, SQFLUXERR, FF
     &  ,R1, R2, F1, F2, ERR1, ERR2, FUDGE_SQERR, ERRSCALE
     &  ,COV_MWXT, COV_MODEL, COV_DATA, COV_TMP
     &  ,PARLIST_SN(10), PARLIST_HOST(10)

      LOGICAL 
     &  LPRINT, USE_DIAG_ONLY, LTMP, LDIAG, FIRST_ITER, CHECK_COV
     & ,LMWXT

      character BANNER*60, ccid*(MXCHAR_CCID)

c functions
      INTEGER 
     &   gencovar_mlcs2k2
     &  ,gencovar_SALT2
     
      LOGICAL FIRST_ITERATION
      REAL*8 RHOFUDGE_MODEL, COVFUDGE_DATA

      EXTERNAL INVERTMATRIX

C ------------------- BEGIN ---------------

      IERR = 0   ! init output flag to OK

      FIRST_ITER = FIRST_ITERATION(ITER)

      LPRINT = BTEST(MSKOPT,0) .and. STDOUT_UPDATE

      CCID   = SNLC_CCID
      LCCID  = ISNLC_LENCCID

      IF ( LPRINT ) THEN
        write(BANNER,19) CCID(1:LCCID), iter
19      format('FITINI_COV: init fit arrays for CID=',A,' ITER=',I1)
        CALL PRBANNER(BANNER)
      ENDIF

c init

c -------------------------------
c  Fill R4EP_XXX and I4EP_XXX arrays.

      CALL LOAD_EPALL(ITER, FITPAR(IPAR_PEAKMJD) )

      NFITDATA_TOTAL = NFITDATA + NFITDATA_REJECT

c -------------------------------
c load some local arrays.

        DO N = 1, NFITDATA_TOTAL
           ep = EPLIST_FIT(N)

           ifilt_obs  = I4EP_ALL(ep,IEP_IFILT_OBS)
           ifilt_rest = I4EP_ALL(ep,IEP_IFILT_REST1)

           IF ( LREST_FITMODEL ) THEN
              IFILT_COV(N) = IFILTDEF_INVMAP_REST( IFILT_REST ) - 1
           ELSE 
              IFILT_COV(N) = IFILT_OBS
           ENDIF

           TREST(N)    = dble( R4EP_ALL(ep,JEP_TREST) )
           TOBS(N)     = dble( R4EP_ALL(ep,JEP_TOBS)  )

        ENDDO

c -------------------------------------------------
c set flag to use diagonal elements only if
c OPT_COVAR_FLUX <= 0 or if this is the 1st iteration

      CHECK_COV = (.NOT. FIRST_ITER)
      if ( OPT_SALT2FIT.EQ.4 ) CHECK_COV = ( ITER .EQ. 3 ) ! mimic Guy-code

      USE_FITCOV = .FALSE.
      IF ( CHECK_COV ) THEN
        if ( OPT_COVAR_FLUX     > 0    ) USE_FITCOV = .TRUE. ! model cov
        if ( OPT_COVAR_MWXTERR  > 0    ) USE_FITCOV = .TRUE. ! MWEBV cov
        if ( FUDGE_MAG_COVERR .NE. ' ' ) USE_FITCOV = .TRUE. ! data cov
      ENDIF
      USE_DIAG_ONLY = .NOT. USE_FITCOV

      IF ( LPRINT ) THEN
        write(6,21) NFITDATA,          'ACCEPTED'
        write(6,21) NFITDATA_REJECT,   'REJECTED'
21      format(T8,I3,2x, 'Filter-epochs ', A,' for fit.' )

        if ( USE_DIAG_ONLY ) then
           CALL  PRINT_ITERINFO(CCID,ITER,
     &           'Use DIAGONAL Covariance elements only.')
        else
           write(BANNER,5551) NFITDATA, NFITDATA
5551       format('Use full ',I4,' x ',I4,' Covariance matrix.')
           CALL  PRINT_ITERINFO(CCID,ITER, BANNER)
        endif

        IF ( .NOT. FIRST_ITER  ) THEN
          if ( OPT_COVAR_FLUX .GT. 0 ) THEN
             CALL  PRINT_ITERINFO(CCID,ITER,
     &             'Add covariance from fit-model')
          endif
          if ( OPT_COVAR_MWXTERR > 0 ) then
             CALL  PRINT_ITERINFO(CCID,ITER,
     &             'Add covariance from Galactic extinction')
          endif

          if ( FUDGE_MAG_COVERR .NE. ' ' ) then
             CALL  PRINT_ITERINFO(CCID,ITER,
     &             'Add covariance fudges from data.')
          endif
        ENDIF
 

      ENDIF

c 670   format(T8,'Use ',I3,' x ', I3,' Covariance computed ', A)

c --------------------------------------
      IF ( NFITDATA .LE. 0 ) THEN
        print*,' '
        print*,' FITINI_COV ERROR for CID = ', CCID(1:LCCID)
        print*,'   Nothing to fit ??? [NFITDATA=',NFITDATA,']'
        print*,'   Either remove this SN, or fix it. '
        print*,' '
        call flush(6)

        if ( ABORT_ON_NOEPOCHS ) then
           print*,'  To avoid abort, set   ABORT_ON_NOEPOCHS=F '
           print*,' ***** ABORT ***** '
           call flush(6)
           STOP
        else
           IERR = ERRFLAG_FITPREP_NOEPOCHS
           RETURN
        endif

      ENDIF


      IF ( NFITDATA .LT. int(CUTWIN_NEPOCH(1)) ) then
        print*,'   FITINI_COV WARNING for CID = ', CCID(1:LCCID),
     &      ' :   too few epochs to fit. '
        IERR = ERRFLAG_FITPREP_NEPOCH
        RETURN
      ENDIF

c =====================================================
c =====================================================
c =====================================================

c alway init covariance matrix to zero

      DO irow = 1, NFITDATA
      DO icol = 1, NFITDATA
         COVMAT2(irow,icol) = 0.0
         J1 = icol + (irow-1)*NFITDATA     ! 1-dim index for COVMAT1
         COVMAT1(J1) = 0.0
      ENDDO
      ENDDO

c ---------------------------------------------
      IF ( USE_DIAG_ONLY  ) RETURN
c ---------------------------------------------


c ----------------------------------------------------
c get COVMAT1 covariance matrix on 2nd iteration
c This linear array is converted below into a 2-dim array.
c This is the model-covariance only.

      IF ( OPT_COVAR_FLUX .GT. 0 ) THEN
        IF ( FITMODEL_INDEX .EQ. MODEL_MLCS2k2 ) THEN
          ISTAT = gencovar_mlcs2k2(NFITDATA, IFILT_COV, TREST, 
     &               COVMAT1 )  ! ==> returned

        ELSE if ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN

           Z        = REDSHIFT_FIT
           MWEBV    = SNLC_MWEBV
	   PARLIST_SN(1) = FITPAR(IPAR_x0   ) 
	   PARLIST_SN(2) = FITPAR(IPAR_SHAPE) 
	   PARLIST_SN(3) = FITPAR(IPAR_COLOR) 
	   PARLIST_HOST(1) = 0.0  ! cannot fit RV
	   PARLIST_HOST(2) = 0.0  ! cannot fit AV
	   PARLIST_HOST(3) = -9.0 ! cannot fit logMass

           ISTAT = gencovar_SALT2(NFITDATA, IFILT_COV, TOBS, Z
     &             ,PARLIST_SN, PARLIST_HOST  ! (I)
     &             ,MWEBV                     ! (I) MW extinction
     &             ,COVMAT1 )         ! <== returned array, MAGERR^2

        ELSE
          C1ERR = 'No covariance model for FITMODEL=' 
     &             // FITMODEL_VERSION(1:20)
          C2ERR = 'Set OPT_COVAR_FLUX = 0 for this model'
          CALL MADABORT('FITINI_COV', C1ERR, C2ERR)
        ENDIF
      ENDIF

c print rho-fudge formula by calling with args = 0
      LTMP = OPT_COVAR_FLUX .LE. 1  ! print comment for these OPT_COVAR_FLUX
      IF ( LTMP ) THEN
        RHO_TMP = RHOFUDGE_MODEL(0, 0, DBLE(0.0) )
      ENDIF

c -------------------------------------------------------------
c fill the 2d matrix, COVMAT2, and store diagonal errors.

       DO 301 irow = 1, NFITDATA
       DO 302 icol = 1, NFITDATA

         J1 = icol + (irow-1)*NFITDATA     ! 1-dim index for COVMAT1

c transfer to 2D array
         COVMAT2(irow,icol) = COVMAT1(J1)

c store diag errors in mag space
         if ( irow .EQ. icol ) then
            COVMAG_ERR(irow)  = dsqrt ( COVMAT1(J1) )
         endif

302    CONTINUE
301    CONTINUE

cc       CALL DMP_COVAR(iter)  ! for DEBUG only

       FUDGE_SQERR = FUDGE_MODELERR_SCALE**2

c now convert COVMAT2 model-magerr^2 to  model-fluxerr^2, 
c and add data errors. Note that COVMAT2 changes here.

c COVMAT1/COVMAT2 is the model-magerr covariance.
c Below convert to FLUXERR covariance and add the following
c  - XTMW covariance
c  - model-err cov
c  - data error covariance
c
c Also fill the 2d matrix, COVMAT2

       DO 311 irow = 1, NFITDATA
       DO 312 icol = 1, NFITDATA

          ep_row = EPLIST_FIT(irow)
          ep_col = EPLIST_FIT(icol)

          COV_MODEL = 0.0
          COV_MWXT  = 0.0
          COV_DATA  = 0.0 
          
          LDIAG = (IROW .EQ. ICOL)
         
c start with model covariance
          IF ( OPT_COVAR_FLUX .GT. 0 ) THEN
             SQMAGERR = COVMAG_ERR(irow) * COVMAG_ERR(icol)
             RHO_TMP  = COVMAT2(irow,icol) / SQMAGERR ! reduced cov.

c check user-option to  'fudge' rho
             RHO = RHOFUDGE_MODEL ( irow, icol, RHO_TMP )

c get the model covariance
             R1   = 1.0 - 10.0**(-0.4*COVMAG_ERR(irow)) ! frac err, sigF/F
             R2   = 1.0 - 10.0**(-0.4*COVMAG_ERR(icol)) ! frac err

             ERR1 = R1 * R4EP_ALL(ep_row,JEP_MODELFLUX) ! flux error 
             ERR2 = R2 * R4EP_ALL(ep_col,JEP_MODELFLUX) ! flux error
             COV_MODEL =  RHO * ERR1 * ERR2 * FUDGE_SQERR

          ELSE IF ( LDIAG ) THEN
c note that FUDGE_MODELERR_SCALE has already been 
c applied to R4EP_MODELFLUX_ERR
             ERR1 = R4EP_ALL(ep_row,JEP_MODELFLUX_ERR)
             COV_MODEL = ERR1 * ERR1
         ENDIF

c check option to turn off model error.
         IF ( FUDGE_MAGERR_MODEL .EQ. 0.0 ) COV_MODEL = 0.0
         
c check for XTMW covariance
         LMWXT = (OPT_COVAR_MWXTERR == 1) .or.        ! full COV
     &           (OPT_COVAR_MWXTERR == 2 .and. LDIAG) ! diag only 
         IF ( LMWXT ) THEN
            ERR1 = R4EP_ALL(ep_row,JEP_MWXT_FLUXERR)
            ERR2 = R4EP_ALL(ep_col,JEP_MWXT_FLUXERR)          
            COV_MWXT = ERR1 * ERR2
         ENDIF

c Now add diagonal error from data and user fudges. 
         if ( LDIAG ) then
            COV_DATA  = R4EP_ALL(ep_row,JEP_DATAFLUX_ERR)**2
     &                + R4EP_ALL(ep_row,JEP_FUDGEFLUX_ERR)**2
         endif

c add cov fudge-error for data (Feb 2015)
         COV_DATA = COV_DATA + COVFUDGE_DATA( irow, icol )

c redefine COVMAT2 in fluxerr space 
         COVMAT2(irow,icol) = COV_MODEL + COV_MWXT + COV_DATA

312    CONTINUE
311    CONTINUE       

cc       CALL DMP_COVAR(iter)  ! for DEBUG only DDDDDDDD

c invert COVMAT2 matrix.

       CALL INVERTMATRIX( MXFIT_DATA, NFITDATA, COVMAT2)

c !!! Now COVMAT2 is the inverted COV matrix !!!

c check for min value of inverted matrix

      COVMAT_MIN = +9999.
      COVMAT_MAX = -9999.
      NONZERO = 0

      DO irow = 1, NFITDATA
      DO icol = 1, NFITDATA
         COVTMP = COVMAT2(irow,icol)
         COVMAT_MIN = MIN ( COVMAT_MIN, COVTMP )
         COVMAT_MAX = MAX ( COVMAT_MAX, COVTMP )
         if ( COVTMP .NE. 0.0 ) NONZERO = NONZERO + 1
      ENDDO
      ENDDO


      if ( LPRINT ) then  
        write(BANNER,5555) NONZERO
5555    format('Inverted COVMAT with ',I6,' non-zero elements')
        CALL  PRINT_ITERINFO(CCID,ITER, BANNER(1:52) )
      endif

      CALL FLUSH(6)

      RETURN
      END      ! end of FITINI_COV

C =====================================
+DECK,LDFITARR.  
      SUBROUTINE LOAD_EPALL(ITER,PKMJD8)

c Created Sep 28, 2012
c
c Fill R4EP_ and I4EP_ arrays so that first NFITDATA elements
c are the ones to fit; the next NFITDATA_REJECT elements
c are rejected epochs. This sorting is done so that FCNSLNC
c can efficiently compute chi2,  and still be able to record
c rejected epochs [when LAST=T] for plotting.
c When IREJ=0, store epochs to fit;
c when IREJ=1, tack on rejected epochs.
c
c Feb 26 2015: load CHI2FLUX_SIM for simulation (LSIM_SNANA=T).
c
c -------------------------

      IMPLICIT NONE

      INTEGER ITER  ! (I) fit iteration
      REAL*8  PKMJD8

c local var

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER 
     &   IFILT, IFILT_OBS, IREJ, IMJD, ep, EPMIN, EPMAX
     &  ,IDTEL, N, OPT, IF1, IF2, ifit, ivar, REJECT, REJECT2

      INTEGER ITER_DMP / -1 /
      REAL 
     &   Z, Z1, TREST, MAXFRAC, LAMDIF_MIN, LAMREST
     &  ,FLUX_DATA, FLUXERR_STAT, FLUXERR_DATA, FLUX_SIM
     &  ,FLUX_MODEL, FLUXERR_MODEL, FLUXERR_TOT
     &  ,ERR_TRUE, ERR_CALC, ARG, TOBS, ERR_TMP
     &  ,SQDIF, SQERR

      REAL*8 FTMP8, MAGERR8, MJD8

      LOGICAL LTMP, LREJECT, LREJECT2

      character cfilt*1

c functions
      INTEGER NEAREST_IFILT_REST
      LOGICAL MJDSELECT
      REAL*4 GET_FUDGE_FITERR_MAXFRAC 

C ----------------- BEGIN ----------------

      N = 0
      NFITDATA        = 0
      NFITDATA_REJECT = 0

      DO ifilt = 0, MXFILT_OBS
         NEPOCH_ALL(ifilt)    = 0
         NEPOCH_FIT(ifilt)    = 0
         NEPOCH_REJECT(ifilt) = 0
      ENDDO
      NEPOCH_REJECT2 = 0

      Z = REDSHIFT_FIT
      Z1 = 1. + z

c -------------------------------
c save previous R4ALL values in R4_LAST array in case 
c previous iteration values are needed; e.g. FCNCHI2_SIGMA

      IF ( ITER > 1 ) THEN
         do ep = 1, MXFIT_DATA
            do ivar = 1, MXVAR_R4
               R4EP_LAST(ep,ivar) = R4EP_ALL(ep,ivar)
            enddo
         enddo
      ENDIF
      
c ---------------------------------
      
      DO 200 IREJ      = 0, 1  ! 0=keep, 1=reject

      DO 101 IMJD      = 1, ISNLC_NEWMJD_STORE

        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,IMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,IMJD)
        IDTEL = ISNLC_IDTEL(EPMIN)

      DO 102 ep = EPMIN, EPMAX

         MJD8   = SNLC8_MJD(ep) 
         IF ( PKMJD8 .GT. 20000.0 ) then
           TOBS  = SNGL(MJD8 - PKMJD8)
         ELSE
           TOBS  = SNGL(MJD8 - (PKMJD8+MJDOFF) )
         ENDIF
         TREST   = TOBS/z1

         IFILT_OBS = ISNLC_IFILT_OBS(ep)
         cfilt     = filtdef_string(ifilt_obs:ifilt_obs)

         lamrest = FILTOBS_LAMAVG(ifilt_obs) / Z1        

         if (  .NOT. USE_FILT(ifilt_obs)   ) goto 102

c find sparse index 'ifilt' that corresponds to IFILT_OBS
         ifilt = IFILTDEF_INVMAP_SURVEY(ifilt_obs)

         if ( ifilt .LE. 0 ) then
             write(c1err,660) ifilt_obs, cfilt
660          format('Could not find sparse index for IFILT_OBS= '
     &           ,I3, ' (',A,')'  )
             write(c2err,661) NFILTDEF_SURVEY, IFILTDEF_MAP_SURVEY
661          format('NFILTDEF_SURVEY=',I2,'  IFILTDEF_MAP_SURVEY=',10I3)
             CALL MADABORT("FITINI_COV", c1err, c2err )
         endif

         FLUX_DATA     = SNLC_FLUXCAL(ep)
         FLUXERR_STAT  = SNLC_FLUXCAL_ERRTOT(ep)
         FLUXERR_DATA  = SNLC_FLUXCAL_ERRTOT(ep)

c immediately skip epochs that fail cuts, or epochs whose
c flux-error is negative

        IF ( .not. MJDSELECT(imjd,0) ) GOTO 101
cc mark delete May 2016        if ( fluxerr_data .LE.  0.0  ) goto 102

c check if this epoch is rejected
        REJECT   = I4EP_ALL(ep,IEP_REJECT)
        REJECT2  = I4EP_ALL(ep,IEP_REJECT2)

        LREJECT  = (iter > 1  .and. REJECT  > 0)
        LREJECT2 = (iter > 1  .and. REJECT2 > 0)

c count rejected epochs within TREST window
        IF ( LREJECT2 .and. IREJ .EQ. 1 ) then
           NEPOCH_REJECT2 = NEPOCH_REJECT2 + 1
        ENDIF


        IF ( LREJECT .and. IREJ .EQ. 1 ) then
c count all rejected epochs
           NEPOCH_REJECT(ifilt) = NEPOCH_REJECT(ifilt) + 1         
           NEPOCH_REJECT(0)     = NEPOCH_REJECT(0)     + 1  
           NFITDATA_REJECT      = NFITDATA_REJECT + 1

        ELSE IF ( .NOT. LREJECT .and. IREJ .EQ. 0 ) THEN
c count epochs used for fitting
           NEPOCH_FIT(ifilt)    = NEPOCH_FIT(ifilt) + 1
           NEPOCH_FIT(0)        = NEPOCH_FIT(0)     + 1
           NFITDATA             = NFITDATA + 1
        ELSE
           GOTO 102
        ENDIF

c increment number of epochs (fit + rejected)

        NEPOCH_ALL(ifilt) = NEPOCH_ALL(ifilt) + 1
        NEPOCH_ALL(0)     = NEPOCH_ALL(0)     + 1

        N = N + 1 
    
        IF ( N > MXFIT_DATA ) THEN
           write(c1err,670) MXFIT_DATA
 670       format('Number of fitted data points exceeds MXFIT_DATA=',I4)
           c2err = 'Check MXFIT_DATA'
           CALL MADABORT("LOAD_EPALL", c1err, c2err )
        ENDIF

        EPLIST_FIT(N) = ep  ! allows FCN to quickly find useful epochs

        if ( ITER .EQ. ITER_DMP ) then
          write(6,454) N, ep, cfilt, MJD8
     &      ,MJD8 - SNLC_SEARCH_PEAKMJD, flux_data, fluxerr_data
454       format(I3,1x,'ep=',I3, 2x,A,2x,'MJD=',F7.2,2x,
     &        'Trest=',F6.2, 3x, 'Flux=',F6.1,'+-',F6.1 )
        endif

c get local flux and error from model (non-zero only if ITER > 1 )
        flux_model    = R4EP_ALL(ep,JEP_MODELFLUX)
        fluxerr_model = R4EP_ALL(ep,JEP_MODELFLUX_ERR)
        fluxerr_tot   = R4EP_ALL(ep,JEP_FLUX_ERRTOT)

c load FITCOV arrays      
        I4EP_ALL(ep,IEP_IFILT)       = IFILT
        I4EP_ALL(ep,IEP_IFILT_OBS)   = IFILT_OBS
        I4EP_ALL(ep,IEP_IMJD)        = IMJD
        I4EP_ALL(ep,IEP_IDTEL)       = ISNLC_IDTEL(ep)
	I4EP_ALL(ep,IEP_CCDNUM)      = ISNLC_CCDNUM(ep)
	I4EP_ALL(ep,IEP_IMGNUM)      = ISNLC_IMGNUM(ep)
        BANDEP_ALL(ep) = FILTDEF_STRING(IFILT_OBS:IFILT_OBS)

c Get nearest and 2nd nearest rest filter
c Also subtract index offsets
 
        IF ( LREST_FITMODEL ) THEN
          OPT = OPT_FILTOBS

          IF1 = NEAREST_IFILT_REST(OPT, ifilt_obs, 1, Z, LAMDIF_MIN) 
          IF2 = NEAREST_IFILT_REST(OPT, ifilt_obs, 2, Z, LAMDIF_MIN)
          
          I4EP_ALL(ep,IEP_IFILT_REST1) = IF1
          I4EP_ALL(ep,IEP_IFILT_REST2) = IF2

          ARG   = 0.4*(ZEROPOINT_FLUXCAL_DEFAULT - SIM_EPMAGREST(ep))
          R4EP_ALL(ep,JEP_SIM_FLUXREST) = 10.0**(ARG)
          R4EP_ALL(ep,JEP_SIM_MAGREST) = SIM_EPMAGREST(ep) 

        ENDIF

         R4EP_ALL(ep,JEP_SIM_FLUXCAL) = 0.0
         IF ( LSIM_MAGOBS .or. LSIM_SNANA ) THEN
            ARG   = 0.4*(ZEROPOINT_FLUXCAL_DEFAULT - SIM_EPMAGOBS(ep))
            FLUX_SIM = 10.0**(ARG)
            SQDIF    = (FLUX_SIM - FLUX_DATA)**2
            SQERR    = FLUXERR_DATA*FLUXERR_DATA

cc	    print*,' xxxx ', ep, FLUX_SIM
            R4EP_ALL(ep,JEP_SIM_FLUXCAL) = FLUX_SIM
            IF ( FLUXERR_DATA > 0 ) THEN
               R4EP_ALL(ep,JEP_SIM_DELCHI2) = SQDIF/SQERR
            ELSE
               R4EP_ALL(ep,JEP_SIM_DELCHI2) = -9.0
            ENDIF
         ENDIF

        R8EP_MJD(N)           = MJD8

        R4EP_ALL(ep,JEP_MJD)           = SNGL(MJD8)
        R4EP_ALL(ep,JEP_DATAFLUX)      = FLUX_DATA
        R4EP_ALL(ep,JEP_DATAFLUX_ERR)  =
     &           FLUXERR_DATA * FUDGE_DATAERR_SCALE 
        R4EP_ALL(ep,JEP_MODELFLUX)      = FLUX_MODEL
        R4EP_ALL(ep,JEP_MODELFLUX_ERR)  =
     &           FLUXERR_MODEL * FUDGE_MODELERR_SCALE       
        R4EP_ALL(ep,JEP_FLUX_ERRTOT)    = FLUXERR_TOT
        R4EP_ALL(ep,JEP_TOBS)           = TOBS
        R4EP_ALL(ep,JEP_TREST)          = TREST

c check for epochs to add fudged errors so that these
c points are ignored in the fit, but are included in
c all plots. 

        MAXFRAC = 
     &     GET_FUDGE_FITERR_MAXFRAC(ITER,ifilt_obs,TREST,LAMREST)

        ERR_TMP = MAXFRAC * SNLC_FLUXCALMAX(ifilt)  
        R4EP_ALL(ep,JEP_FUDGEFLUX_ERR)  = ERR_TMP
        R4EP_ALL(ep,JEP_FUDGE_MAXFRAC)  = MAXFRAC

c set error on MilkyWay Galactic extinction
         MAGERR8 = SNLC_MWXT_MAGERR(ifilt)
         FTMP8   = 1.0 - 10**(-0.4*MAGERR8)
         R4EP_ALL(ep,JEP_MWXT_MAGERR)  =  MAGERR8  
         R4EP_ALL(ep,JEP_MWXT_FLUXERR) =  FTMP8 * FLUX_MODEL 

         R4EP_ALL(ep,JEP_LAMREST)     = LAMREST
         R4EP_ALL(ep,JEP_PSF)         = SNLC_PSF_SIG1(ep)
         R4EP_ALL(ep,JEP_NEA)         = SNLC_PSF_NEA(ep) 
         R4EP_ALL(ep,JEP_SKYSIG)      = SNLC_SKYSIG(ep)
         R4EP_ALL(ep,JEP_SKYSIG_T)    = SNLC_SKYSIG_T(ep)
         R4EP_ALL(ep,JEP_ZP)          = SNLC_ZEROPT(ep)
         R4EP_ALL(ep,JEP_ZPERR)       = SNLC_ZEROPT_ERR(ep)
         R4EP_ALL(ep,JEP_GAIN)        = SNLC_GAIN(ep)
         R4EP_ALL(ep,JEP_XPIX)        = SNLC_XPIX(ep)
         R4EP_ALL(ep,JEP_YPIX)        = SNLC_YPIX(ep)
         R4EP_ALL(ep,JEP_AREAFRAC)    = SNLC_AREAFRAC(ep)
         R4EP_ALL(ep,JEP_SKYFLUXCAL)  = SNLC_SKYFLUXCAL(ep)
         R4EP_ALL(ep,JEP_SBFLUXCAL)   = SNHOST_SBFLUXCAL(ifilt)
         R4EP_ALL(ep,JEP_PHOTPROB)    = SNLC_PHOTPROB(ep)

         ERR_TRUE  = SNLC_FLUXCAL_ERRTOT(ep)  
         ERR_CALC  = SNLC_FLUXCAL_ERRCALC(ep)
	 ERR_TMP   = SNLC_FLUXCAL_ERRTEST(ep)

         R4EP_ALL(ep,JEP_ERRTEST) = ERR_TMP
         R4EP_ALL(ep,JEP_ERRCALC) = ERR_CALC

102   CONTINUE   ! end of EPMIN,EPMAX loop
101   CONTINUE   ! end of IMJD loop
200   CONTINUE   ! end of IREJ loop

      RETURN
      END      ! end of LOAD_EPALL

C ==========================================
+DECK,LDEPFIT.
      SUBROUTINE LOAD_EPFIT()

c Creatd Jan 25 2014
c Transfer R4EP_ALL -> sparse R4EP_FIT
c Transfer I4EP_ALL -> sparse I4EP_FIT

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER ifit, ivar, ep

C ------------- BEGIN ----------

c load sparse _FIT arrays

      DO 400 ifit = 1, NFITDATA + NFITDATA_REJECT
         ep = EPLIST_FIT(ifit)
         
         DO ivar = 1, MXVAR_R4
            R4EP_FIT(ifit,ivar) = R4EP_ALL(ep,ivar)
         ENDDO

         DO ivar = 1, MXVAR_I4
            I4EP_FIT(ifit,ivar) = I4EP_ALL(ep,ivar)
         ENDDO
         
         BANDEP_FIT(ifit) = BANDEP_ALL(ep)  ! July 2017

 400  CONTINUE

      RETURN
      END

C ================================
+DECK,PRITERINFO.
      SUBROUTINE PRINT_ITERINFO(CCID,ITER,COMMENT)

c print line as formated as
c  [CID](ITER=[ITER]):  [COMMENT]
c

c subroutine args
      CHARACTER CCID*(*)  ! SNID
      INTEGER   ITER
      CHARACTER COMMENT*(*)  ! comment to ptrin

c local args
      INTEGER LCCID
C -------------------- BEGIN ----------------

      LCCID = INDEX(CCID,' ') - 1
      write(6,20) CCID(1:LCCID),ITER,COMMENT
20    format(T5,A,'(ITER=',I1,'): ', A)

      RETURN
      END
C ================================
+DECK,GTMAXFRAC.
      REAL FUNCTION GET_FUDGE_FITERR_MAXFRAC (
     &           ITER        ! (I) fit-iteration
     &          ,ifilt_obs   ! (I) observer filter index
     &          ,TREST       ! (I) Trest (days)
     &          ,LAMREST     ! (I) rest-wavelength (Angstroms)
     &             )

c Created Jul 20 2011 by R.K
c Return MAXFRAC such that fudged error is MAXFRAC * PEAKFLUX
c Based on FUDGE_FITERR_XXX parameters.
c Evaluate MAXFRAC separeately from global FUDGEALL_XXX options  
c and also from FUDGE_FITERR_XXX options.
c Return maximum of these two MAXFRAC  values  so that we 
c essentially OR the two options.
c
c Feb 28 2020: 
c   FIRST_ITER now includes !LREPEAT_ITER. Restore old bug 
c   with RESTORE_DES3YR.
c
c -------------
      IMPLICIT NONE

c input args
      INTEGER ITER, IFILT_OBS  ! (I) fit-iter and filter index
      REAL    TREST, LAMREST   ! (I) rest epoch (days), rest-lambda(A)

c local args

+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

      REAL ALL_MAXFRAC, FITERR_MAXFRAC
      LOGICAL LT1, LT2, LAM1, LAM2, LFILT, LITER
      LOGICAL LT,  LAM, LFINAL, LTMP, FIRST_ITER

c functions
      LOGICAL FIRST_ITERATION  
c ------------------ BEGIN ----------------

      GET_FUDGE_FITERR_MAXFRAC = 0.0 
      IF ( .NOT. USE_FUDGE_FITERR ) RETURN

      FIRST_ITER = FIRST_ITERATION(ITER) 

      ALL_MAXFRAC         = 0.0
      FITERR_MAXFRAC      = 0.0

c check global options first

      LTMP = ( FUDGEALL_MAXFRAC > 0.000001 )
      IF ( LTMP ) THEN
         ALL_MAXFRAC =  FUDGEALL_MAXFRAC
      ENDIF

      LTMP = (FUDGEALL_ITER1_MAXFRAC > 1.0E-9 .and. FIRST_ITER )
      IF ( LTMP ) THEN
         ALL_MAXFRAC = FUDGEALL_ITER1_MAXFRAC
      ENDIF

c ---------
c check options that depend on TREST, LAMREST and filter

      LFILT = DOFUDGE_FITERR(ifilt_obs)
      LITER = ITER .LE. FUDGE_FITERR_MAXITER

      LT1 =   TREST .GE. FUDGE_FITERR_TREST(1)
     &  .and. TREST .LE. FUDGE_FITERR_TREST(2)
      LT2 =   TREST .GE. FUDGE_FITERR_TREST(3)
     &  .and. TREST .LE. FUDGE_FITERR_TREST(4)
      LT  = LT1  .or. LT2

      LAM1 =   LAMREST .GE. FUDGE_FITERR_RESTLAM(1)
     &   .and. LAMREST .LE. FUDGE_FITERR_RESTLAM(2)
      LAM2 =   LAMREST .GE. FUDGE_FITERR_RESTLAM(3)
     &   .and. LAMREST .LE. FUDGE_FITERR_RESTLAM(4)
      LAM = LAM1 .or. LAM2


      LFINAL = (LT .and. LAM  .and. LITER .and. LFILT)
      IF( LFINAL ) THEN
         FITERR_MAXFRAC =  FUDGE_FITERR_MAXFRAC
      ENDIF

      GET_FUDGE_FITERR_MAXFRAC =  MAX(ALL_MAXFRAC,FITERR_MAXFRAC)

      RETURN
      END

C ==========================================
+DECK,FINI_PRIOR.
      SUBROUTINE FITINI_PRIORS
c
c Initialize -2 * ln(prob) for prior on each fit variable.
c Fills PRIOR_CHI2GRID array so that chi2-contribution
c can be looked up via interpolation in CHI2_PRIOR function.
c
c Priors initialized for:
c  - AV     (exponential convoluted with Gaussian)
c  - MJD    (gaussian)
c  - photoZ (Gaussian -- added Dec 30, 2006)  
c
c Apr 25, 2009: pull LUMIPAR prior outside MLCS loop 
c               to work for all models.
c
c Jul 27, 2009: check OPT_PRIOR after FITINI_PKMJDPRIOR is called
c               If OPT_PRIOR=0, goto900 instead of return.
c
c Feb 02, 2013: replace HBOOK and HF1 with SNHIST_XXX utilities
c
c Apr 2 2018: call FITINI_FLATPRIOR for color
c
c Apr 7 2020: init AV prior for SNOOPY as well as MLCS2k2
c
c ------------------------

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER  ibin, ipar, NPRIOR

      REAL*8 tmp(2), prob, chi2, arg, xmin(2), xmax(2), xbin, x , wgt 

      LOGICAL LSTAT

c histogram args

      INTEGER NB(2), LL, NDIM, LCHIS, HOFF, hid
      CHARACTER chis*80

c function

      REAL*8 CHI2_PRIOR

C -------------- BEGIN ----------

c initalize all chi2-prior to zero.

      DO ibin = 1, NBIN_PRIOR
      DO ipar = 1, IPAR_MAX
          PRIOR_CHI2GRID(ibin,ipar) = 0.0
          PRIOR_PROBGRID(ibin,ipar) = 0.0
          PRIOR_GRID(ibin,ipar)     = 0.0
      ENDDO
      ENDDO

c initialize prior ranges to zero
 
      DO ipar = 1, IPAR_MAX
         USE_PRIOR(ipar) = .FALSE.
         PRIOR_RANGE(1,ipar) = 0.0
         PRIOR_RANGE(2,ipar) = 0.0
         PRIOR_BINSIZE(ipar) = 0.0

         FLATPRIOR_RANGE(1,IPAR) = -9.E9
         FLATPRIOR_RANGE(2,IPAR) = -9.E9

         FLATPRIOR_BINRANGE(1,IPAR) = +999999
         FLATPRIOR_BINRANGE(2,IPAR) = -999999

      ENDDO
      USE_PRIOR_AV = .FALSE.

      NPRIOR = 0

c Set peak-MJD PRIOR for all models, and even if OPT_PRIOR=0.
c This is mainly to protect against crazy MJD values,
c and it is not meant to bias the fit.

      CALL FITINI_PKMJDPRIOR(LSTAT)
      IF ( LSTAT ) THEN
        NPRIOR = NPRIOR + 1
        USE_PRIOR(ipar_PEAKMJD)  = .TRUE.
      ENDIF

c check OPT_PRIOR after MJD prior is set.

      IF ( OPT_PRIOR .EQ. 0  ) GOTO 900

c - - - - - - -  -
c Set PhotoZ PRIOR for SN-photoZ fit.
c
      IF ( DOFIT_PHOTOZ ) THEN
        CALL FITINI_ZPRIOR(LSTAT)
        IF ( LSTAT ) THEN
           NPRIOR = NPRIOR + 1
           USE_PRIOR(ipar_zPHOT)  = .TRUE.
        ENDIF

        CALL FITINI_MUPRIOR(LSTAT)
        IF ( LSTAT ) THEN
           NPRIOR = NPRIOR + 1
           USE_PRIOR(ipar_DLMAG)  = .TRUE.
        ENDIF

      ENDIF

c - - - - - -  -
c now turn on prior(s) specific to model

      IF ( FITMODEL_INDEX .EQ. MODEL_MLCS2k2 .or. 
     &     FITMODEL_INDEX .EQ. MODEL_SNOOPY ) THEN
        CALL FITINI_AVPRIOR(LSTAT)
        IF ( LSTAT ) THEN
           NPRIOR = NPRIOR + 1
           USE_PRIOR(ipar_AV) = .TRUE.  ! ambiguous for AV or SALT2c
           USE_PRIOR_AV       = .TRUE.  ! so set this AV-specific logical
        ENDIF

        ipar = IPAR_RV
        CALL FITINI_FLATPRIOR(IPAR,LSTAT)
        IF ( LSTAT ) THEN
           NPRIOR = NPRIOR + 1
           USE_PRIOR(IPAR)   = .TRUE.
        ENDIF

      ENDIF  ! end of MLCS-specific priors


      ipar = IPAR_SHAPE
      CALL FITINI_FLATPRIOR(IPAR,LSTAT)
      IF ( LSTAT ) THEN
         NPRIOR = NPRIOR + 1
         USE_PRIOR(IPAR)   = .TRUE.
      ENDIF

      ipar = IPAR_COLOR
      CALL FITINI_FLATPRIOR(IPAR,LSTAT)
      IF ( LSTAT ) THEN
         NPRIOR = NPRIOR + 1
         USE_PRIOR(IPAR)   = .TRUE.
      ENDIF


      IF ( NPRIOR .EQ. 0 ) THEN
        CALL PRBANNER("FITINI_PRIOR: NO PRIORS DEFINED" )   
      ENDIF    

c -----------------------------------------
c plot chi2 from prior in monitor plot
c use CHI2_PRIOR function

900   CONTINUE
      if ( .NOT. USE_TABLEFILE ) RETURN

      NDIM = 1  ; WGT = 1.0 ! 1D histos
      HOFF = 980
      DO 50 ipar = 1, IPAR_MAX

         if ( .not. USE_PRIOR(ipar) ) goto 50

59       format( A,' from ',A,'-prior vs. ', A )

c make plot with very fine binning to check interpolation
         xbin    = 0.2*PRIOR_BINSIZE(ipar)
         xmin(1) = PRIOR_RANGE(1,IPAR) - xbin/2.0
         xmax(1) = PRIOR_RANGE(2,IPAR) + xbin/2.0
         nb(1)   = int( (xmax(1) - xmin(1) + 0.1*xbin)/xbin )


         LL = INDEX ( PARNAME_STORE(ipar), ' ' ) - 1
         LCHIS = 25+2*LL

         hid = HOFF + ipar
         write(chis,59) 'prob', 
     &         PARNAME_STORE(ipar)(1:LL), PARNAME_STORE(ipar)(1:LL)
         chis = chis(1:LCHIS) // char(0)
         CALL SNHIST_INIT(NDIM, HID, CHIS, NB, xmin, xmax, 80)

         hid = HOFF + 10 + ipar
         write(chis,59) 'chi2', 
     &         PARNAME_STORE(ipar)(1:LL), PARNAME_STORE(ipar)(1:LL)
         chis = chis(1:LCHIS) // char(0)
         CALL SNHIST_INIT(NDIM, HID, CHIS, NB, xmin, xmax, 80)

      DO 51 ibin = 1, NB(1)
           tmp(1)  = PRIOR_RANGE(1,IPAR) + xbin * float(ibin-1) 
           chi2    = CHI2_PRIOR(ipar,tmp(1))
           arg     = min(40.0,chi2/2.0)
           prob    = dexp(-arg)
           
           HID = HOFF +  0 + ipar
           CALL SNHIST_FILL ( NDIM, HID, tmp, prob)

           HID = HOFF + 10 + ipar
           CALL SNHIST_FILL ( NDIM, HID, tmp, chi2 )

51    CONTINUE
50    CONTINUE


      RETURN 
      END    ! end of FITINI_PRIORS


C ==========================================
+DECK,FINI_ZPRIOR.
      SUBROUTINE FITINI_ZPRIOR(LSTAT)
c
c Created DEc 30, 2006 by R.Kessler
c
c Initialize photoZ prior using host photoZ.
c Fills PRIOR_CHI2GRID array with Gaussian with sigma=1.0
c so that chi2-contribution can be looked up via 
c interpolation in CHI2_PRIOR function.
c
c Prior chi2 =  [ (Z - Zhost) / scale*ERROR_Zhost ]^2 .
c
c where scale = PRIOR_ZERRSCALE scales the error.
c
c
c ------------------------

      IMPLICIT NONE

      LOGICAL  LSTAT  ! (O) T => prior is defined

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER IPAR, IZ

      REAL*8
     &   tmp, Zpull_BINSIZE, Zpull, XZ
     &  ,CHI2, PROB, SQSIG, SQDIF, GNORM

C -------------- BEGIN ---------------

      LSTAT    = .FALSE.
      IPAR     = IPAR_zPHOT  ! local variable

      if ( BTEST(OPT_PHOTOZ,BIT_PHOTOZ_GAUSS) ) then
         write(global_banner,21) PRIOR_ZERRSCALE
      else if ( BTEST(OPT_PHOTOZ,BIT_BESTZ_GAUSS) ) then
         write(global_banner,22) PRIOR_ZERRSCALE
      else if ( BTEST(OPT_PHOTOZ,BIT_PHOTOZ_QUANTILES) ) then
         write(global_banner,23) PRIOR_ZERRSCALE
      else
        write(c1err,662) OPT_PHOTOZ
662     format('Invalid OPT_PHOTOZ = ', I5 )
        c2err = "Check &FITINP namelist."
        CALL MADABORT ( "FITINI_ZPRIOR", c1err, c2err )
      endif

21    format('INIT Gaussian HOST-PHOTOZ PRIOR  with error-scale=',
     &         F7.2 )
22    format('INIT Gaussian SPEC-Z PRIOR with error-scale=',
     &         F7.2 )
23    format('INIT quantiles HOST-PHOTOZ PRIOR with error-scale=',
     &         F7.2 )

      CALL PRBANNER(global_banner(1:60))

      PRIOR_RANGE(1,IPAR) = -10.0  ! min Zpull for prior 
      PRIOR_RANGE(2,IPAR) = +10.0  ! max 

c set up binning used to store PHOTOZ prior on grid.

      tmp = PRIOR_RANGE(2,IPAR) - PRIOR_RANGE(1,IPAR)
      Zpull_binsize = tmp / float(NBIN_PRIOR)
      PRIOR_BINSIZE(ipar) = Zpull_binsize

      SQSIG = 1.0
      GNORM = 1.0/DSQRT(2.0 * PI * SQSIG)

      DO 50 IZ     = 1, NBIN_PRIOR  
            XZ     = float(IZ)  - 0.5
            Zpull  = PRIOR_RANGE(1,IPAR) + (Zpull_binsize * XZ)

            SQDIF = Zpull * Zpull
            CHI2  = SQDIF / SQSIG 
            PROB  = GNORM * EXP(-CHI2/2.0)

            PRIOR_GRID(IZ,ipar)     = Zpull
            PRIOR_CHI2GRID(IZ,IPAR) = CHI2
            PRIOR_PROBGRID(IZ,IPAR) = PROB
50    CONTINUE

      LSTAT = .TRUE.

      RETURN
      END  ! end of FITINI_ZPRIOR

C ==========================================
+DECK,FINI_MUPRIOR.
      SUBROUTINE FITINI_MUPRIOR(LSTAT)
c
c Created Aug 7, 2009 by R.Kessler
c
c Initialize DISTANCE-MODULUS prior,
c Fills PRIOR_CHI2GRID array with Gaussian with sigma=1.0
c so that chi2-contribution can be looked up via 
c interpolation in CHI2_PRIOR function.
c
c Prior chi2 =  [ (MU - MUREF) / scale*MUERR ]^2 .
c
c where scale = PRIOR_MUERRSCALE scales the error.
c
c WARNING: this should be used only for photoZ fits
c          to get a better estimate of redshift.
c          ==> do NOT use this for cosmology !!!
c
c ------------------------

      IMPLICIT NONE

      LOGICAL  LSTAT  ! (O) T => prior is defined

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER
     &   IPAR
     &  ,IMU

      REAL*8
     &   tmp
     &  ,pull_BINSIZE
     &  ,pull, MU
     &  ,CHI2, PROB
     &  ,SQSIG
     &  ,SQDIF
     &  ,GNORM

C -------------- BEGIN ---------------

      LSTAT    = .FALSE.
      DOPRIOR_DLMAG = ( PRIOR_MUERRSCALE .LT. 999.0 ) 
      IF ( .NOT. DOPRIOR_DLMAG ) RETURN

      IPAR     = IPAR_DLMAG  ! local variable

      write(global_banner,21) PRIOR_MUERRSCALE
21    format('INIT Gaussian DLMAG PRIOR with error-scale=',F6.2 )
      CALL PRBANNER(global_banner)
      print*,' '

      PRIOR_RANGE(1,IPAR) = -10.0  ! min DLMAG/DLMAGERR (not DLMAG)
      PRIOR_RANGE(2,IPAR) = +10.0  ! max 

c set up binning used to store DLMAG prior on grid.

      tmp = PRIOR_RANGE(2,IPAR) - PRIOR_RANGE(1,IPAR)
      pull_binsize = tmp / float(NBIN_PRIOR)
      PRIOR_BINSIZE(ipar) = pull_binsize

      SQSIG = 1.0
      GNORM = 1.0/DSQRT(2.0 * PI * SQSIG)

      DO 50 IMU   = 1, NBIN_PRIOR  
            MU    = float(IMU)  - 0.5
            pull  = PRIOR_RANGE(1,IPAR) + (pull_binsize * MU)

            SQDIF = pull * pull
            CHI2  = SQDIF / SQSIG 
            PROB  = GNORM * EXP(-CHI2/2.0)

            PRIOR_GRID(IMU,ipar)     = pull
            PRIOR_CHI2GRID(IMU,IPAR) = CHI2
            PRIOR_PROBGRID(IMU,IPAR) = PROB
50    CONTINUE

      LSTAT = .TRUE.

      RETURN
      END  ! end of FITINI_MUPRIOR

C ==========================================
+DECK,FINI_MJDPRIOR.
      SUBROUTINE FITINI_PKMJDPRIOR(LSTAT)
c
c Created Aug 21, 2006 by R.Kessler
c
c Initialize MJD prior.
c Fills PRIOR_CHI2GRID array so that chi2-contribution
c can be looked up via interpolation in CHI2_PRIOR function.
c
c Prior chi2 =  [ (MJD - INIMJD) / PRIOR_MJDSIG ]^2 .
c
c This is designed to protect against crazy MJD values that
c result in FLux(model) = 0 and reasonable chi2 ...
c The MJD prior will give a big chi2 when MJD wanders off.
c
c Note that MJD really mean PEAKMJD here.
c
c Jul 16, 2008: increase storage range to +-40 instead of +-20.
c
c
c Jul 16, 2008: when MJD is withing a few days of the edge,
c               CHI2 -> CHI2 * exp[(MJD-MJDedge)^2]
c               so that the CHI2 blows up much more quickly
c               resulting in a larger slope to extrapolate.
c               This suppresses crazy MJD values in the fit.
c               Note that both CHI2 and dCHI2/dMJD are continuous
c               with this function-change.
c
c Aug 7, 2009: reduce MJD window from +-40 to +-30 and similarly
c              reduce MJD for which exponential chi2 takes over.
c
c ------------------------

      IMPLICIT NONE

      LOGICAL LSTAT  ! (O) T => prior is defined OK

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER
     &   IPAR
     &  ,IMJD

      REAL*8
     &   tmp
     &  ,MJD_BINSIZE
     &  ,XMJD
     &  ,MJD
     &  ,CHI2, PROB
     &  ,SQSIG
     &  ,SQDIF
     &  ,GNORM
     &  ,DT

c parameters (relative to initial SEARCH_PEAKMJD)

      REAL 
     &   MINDEF_PKMJD1, MAXDEF_PKMJD1
     &  ,MINDEF_PKMJD2, MAXDEF_PKMJD2

      PARAMETER (
c udpated Aug 7, 2009 to handle SALT2
     &    MINDEF_PKMJD1 = -30.0   ! defined MJD-range for prior
     &   ,MAXDEF_PKMJD1 = +30.0
     &   ,MINDEF_PKMJD2 = -28.0   ! chi2 -> chi2*exp for MJD < this
     &   ,MAXDEF_PKMJD2 = +28.0   ! idem for MJD > this
     &     )

C -------------- BEGIN ---------------

      LSTAT    = .FALSE.
      IPAR     = IPAR_PEAKMJD  ! local variable

      write(global_banner,23) int(PRIOR_MJDSIG)
23    format('INIT PEAKMJD PRIOR = ', 1x , 
     &     'EXP[ -(PKMJD-PKMJD_INI)^2/', I4,'^2 ]' )

      CALL PRBANNER(global_banner(1:68))

      PRIOR_RANGE(1,IPAR) = MINDEF_PKMJD1  ! min MJD-MJD(peak) for prior 
      PRIOR_RANGE(2,IPAR) = MAXDEF_PKMJD1  ! max 

c set up binning used to store MJD prior on grid.

      tmp = PRIOR_RANGE(2,IPAR) - PRIOR_RANGE(1,IPAR)
      MJD_binsize = tmp / float(NBIN_PRIOR)
      PRIOR_BINSIZE(ipar) = MJD_binsize

      SQSIG = PRIOR_MJDSIG * PRIOR_MJDSIG 
      GNORM = 1.0/DSQRT(2.0 * PI * SQSIG)

      DO 50 IMJD   = 1, NBIN_PRIOR  
         XMJD   = float(IMJD) 
         MJD    = PRIOR_RANGE(1,IPAR) + (MJD_binsize * XMJD)

         SQDIF = MJD * MJD
         CHI2  = SQDIF / SQSIG 

         if ( MJD .LT. MINDEF_PKMJD2 ) then
            DT = ABS(MJD - MINDEF_PKMJD2)
         else if ( MJD .GT. MAXDEF_PKMJD2 ) then
            DT = ABS(MJD - MAXDEF_PKMJD2)
         else
            DT = 0.0
         endif

c flare the chi2 at the edges so that extrapolation
c has much larger slope. Note that CHI2 function and
c its derivative are still continuous at the MIN[MAX]DEF_PKMJD2
c boundary.

         CHI2  = CHI2 * EXP(DT*DT)
         PROB  = GNORM * EXP(-CHI2/2.0)
         PRIOR_GRID(IMJD,ipar)     = MJD 
         PRIOR_CHI2GRID(IMJD,IPAR) = CHI2
         PRIOR_PROBGRID(IMJD,IPAR) = PROB
50    CONTINUE

      LSTAT    = .TRUE.

      RETURN
      END

C ==========================================
+DECK,FLATPRIOR.
      SUBROUTINE FITINI_FLATPRIOR(IPAR,LSTAT)
c
c Created Aug 2,  2007 by R.Kessler
c
c Initialize prior that is flat over defined range,
c and then has guassian roll-off.
c Fills PRIOR_CHI2GRID array so that chi2-contribution
c can be looked up via interpolation in CHI2_PRIOR function.
c
c Works for DELTA, PHOTOZ and RV
c
c Dec 3, 2007: smooth out the delta prior
c
c Apr 25, 2009: use general PRIOR_LUMIPAR_RANGE[SIGMA],
c               and define DO_DELTA_PROFILE for mlcs-specific prior.
c
c Jul 18, 2009: change RV lower bound from 1 to 0.5
c               Fix AVRV prior-range depending on if AV prior
c               is flat, or forbids AV<0.
c
c Aug 17, 2009: set FLATPRIOR_RANGE and FLATPRIOR_BINRANGE to be
c               avoid discontinuity in CHI2_PRIOR.
c
c Apr 2 2018: check PRIOR_COLOR_RANGE
c
c Oct 21 2021: allow PRIOR_COLOR_RANGE to apply to SNooPy model
c 
c ------------------------

      IMPLICIT NONE

      INTEGER IPAR   ! (I) fitpar index to define prior
      LOGICAL LSTAT  ! (O) T => prior is defined OK

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER   IVAR, LL

      REAL*8
     &   RANGE(2)
     &  ,SIGMA
     &  ,tmp
     &  ,VAR_BINSIZE
     &  ,XVAR
     &  ,VAR
     &  ,CHI2, PROB, PROBMIN
     &  ,SQSIG
     &  ,SQDIF, DIF
     &  ,ARG
     &  ,PTMP, PMIN, SIGTMP, ARGTMP
     &  ,VAR0

      character comment_prior*60
      LOGICAL LLO, LHI, DO_DELTA_PROFILE, LFLAT
      LOGICAL IS_SALT2, IS_SHAPE, IS_COLOR, IS_zPHOT, IS_SNOOPY

C -------------- BEGIN ---------------

      LSTAT    = .FALSE.
      comment_prior = ' '
      LFLAT = .TRUE.  ! default is flat between Guass-rolls

      IS_SALT2 = ( FITMODEL_INDEX .EQ. MODEL_SALT2 )
      IS_SNOOPY = ( FITMODEL_INDEX .EQ. MODEL_SNOOPY )
      IS_COLOR = ( IPAR .EQ. IPAR_COLOR ) ! SALT2 c or AV
      IS_SHAPE = ( IPAR .EQ. IPAR_SHAPE )
      IS_zPHOT = ( IPAR .EQ. IPAR_zPHOT .and. DOFIT_PHOTOZ )

      DO_DELTA_PROFILE = IPAR .EQ. IPAR_SHAPE 
     &             .and. FITMODEL_INDEX .EQ. MODEL_MLCS2k2
     &             .and. PRIOR_DELTA_PROFILE(4) .LT. 1.0
  
      IF ( IS_SHAPE ) THEN
          RANGE(1) = PRIOR_SHAPE_RANGE(1)
          RANGE(2) = PRIOR_SHAPE_RANGE(2)
          SIGMA    = PRIOR_SHAPE_SIGMA

          if ( DO_DELTA_PROFILE ) then
            write(comment_prior,19) PRIOR_DELTA_PROFILE
19          format('DELTA-PRIOR SIG(-,+)=',2F5.2,
     &       ', peak=',F5.2,', minProb=',F4.2)
            LFLAT = .FALSE.
          endif

      ELSE IF ( IS_COLOR .and. (IS_SALT2 .or. IS_SNOOPY) ) THEN  ! Apr 2 2018
          RANGE(1) = PRIOR_COLOR_RANGE(1)
          RANGE(2) = PRIOR_COLOR_RANGE(2)
          SIGMA    = PRIOR_COLOR_SIGMA

      ELSE IF ( IPAR .EQ. IPAR_RV .and. INISTP_RV .NE. 0.0) THEN
          RANGE(1) = 0.5   ! hard-wire
          RANGE(2) = 5.0
          SIGMA    = 0.1

      ELSE IF ( IPAR .EQ. IPAR_AVRV .and. INISTP_AVRV .NE. 0.0) THEN

          if ( OPT_PRIOR_AV .GT. 0 ) then
            RANGE(1) = -4.0
            RANGE(2) = +4.0
            SIGMA    = 0.02
          else
            RANGE(1) = -3.0   ! flat AV prior => negative ratio  OK
            RANGE(2) = +4.0
            SIGMA    = 0.1
          endif
      ELSE IF ( IS_zPHOT ) THEN
          RANGE(1) = Zrange_KCOR_LU(1)
          RANGE(2) = Zrange_KCOR_LU(2)
          SIGMA    = 0.2
      ELSE
          RETURN
      ENDIF

c -------------------------------------
      LL = INDEX( PARNAME_STORE(ipar), ' ' ) - 1
      write(global_banner,23) PARNAME_STORE(ipar)(1:LL), RANGE, SIGMA
23    format('INIT ',A,' PRIOR: ',F5.2,' to ',F5.2, 
     &     '  Gauss roll sigma=',F5.2 )

      CALL PRBANNER(global_banner(1:68))
      print*,' '
      print*, '  ', comment_prior

c define range as defined range +- 10 sigmas.

      tmp = 10. * SIGMA

      PRIOR_RANGE(1,IPAR) = RANGE(1) - tmp
      PRIOR_RANGE(2,IPAR) = RANGE(2) + tmp

      IF ( LFLAT ) THEN
        FLATPRIOR_RANGE(1,IPAR) = RANGE(1)
        FLATPRIOR_RANGE(2,IPAR) = RANGE(2)
      ENDIF

c set up binning used to store prior on grid.

      tmp = PRIOR_RANGE(2,IPAR) - PRIOR_RANGE(1,IPAR)
      VAR_binsize = tmp / float(NBIN_PRIOR)
      PRIOR_BINSIZE(ipar) = VAR_binsize

      SQSIG   = SIGMA * SIGMA
      PROBMIN = DEXP(DBLE(-700.0))  ! ~ 10^{-305}

      DO 50 IVAR   = 1, NBIN_PRIOR  
         XVAR   = float(IVAR) 
         VAR    = PRIOR_RANGE(1,IPAR) + (VAR_binsize * XVAR)

         LLO = VAR .LT. RANGE(1)
         LHI = VAR .GT. RANGE(2)

         IF ( LLO ) THEN
           DIF   = VAR - RANGE(1)
           SQDIF = DIF * DIF
           ARG   = 0.5 * SQDIF / SQSIG
           PROB  = DEXP(-arg)
           CHI2  = -2.0 * DLOG(prob)
         ELSE IF ( LHI ) THEN
           DIF   = VAR - RANGE(2)
           SQDIF = DIF * DIF
           ARG   = 0.5 * SQDIF / SQSIG
           PROB  = DEXP(-arg)
           CHI2  = -2.0 * DLOG(prob)
         ELSE
           CHI2  = DBLE(0.0)
           PROB  = DBLE(1.0)

c keep track of min/max bin in FLATPRIOR range; 
c needed in CHI2_PRIOR to avoid discontinuity

           if ( LFLAT ) then
             FLATPRIOR_BINRANGE(1,IPAR) = 
     &         MIN ( IVAR, FLATPRIOR_BINRANGE(1,IPAR) )
             FLATPRIOR_BINRANGE(2,IPAR) = 
     &         MAX ( IVAR, FLATPRIOR_BINRANGE(2,IPAR) )
           endif

         ENDIF

c allow non-trivial priors to multiply flat prior

         IF ( DO_DELTA_PROFILE ) THEN
           VAR0 = PRIOR_DELTA_PROFILE(3)  ! bifurcate Gauss peak
           PMIN = PRIOR_DELTA_PROFILE(4)  ! min prob

           if ( VAR .GT. VAR0 ) then
             SIGTMP = PRIOR_DELTA_PROFILE(2) ! sig+ : dimmer SN
           else
             SIGTMP = PRIOR_DELTA_PROFILE(1) ! sig- : brighter SN
           endif
           ARGTMP = 0.5 * (VAR-VAR0)**2 / (SIGTMP*SIGTMP)

           PTMP = (1.0 - PMIN) * DEXP(-ARGTMP) + PMIN

           PROB = PROB * PTMP
           CHI2 = CHI2 - 2.0 * DLOG(PTMP)
         ENDIF

         PROB = MAX( PROB, PROBMIN )

         PRIOR_GRID(IVAR,ipar)     = VAR
         PRIOR_CHI2GRID(IVAR,IPAR) = CHI2
         PRIOR_PROBGRID(IVAR,IPAR) = PROB
50    CONTINUE

      LSTAT    = .TRUE.

      RETURN
      END


C ==========================================
+DECK,FINI_AVPRIOR.
      SUBROUTINE FITINI_AVPRIOR(LSTAT)
c
c Initialize AV prior.
c Fills PRIOR_CHI2GRID array so that chi2-contribution
c can be looked up via interpolation in CHI2_PRIOR function.
c
c Jul 27,2007: check option for ESSENCE/WV07 prior
c
c Jun 22, 2009: check OPT_PRIOR_AV for flat-prior option
c
c Apr 28, 2011: set C2ERR when PRIOR_AVRES < 0
c
c Sep 08, 2011: FLOAT() -> DBLE()
c               REAL*8 AVRES = DBLE(PRIOR_AVRES) 
c               to have consistent double precision usage.
c
c ------------------------

      IMPLICIT NONE

      LOGICAL LSTAT ! (O) T => prior is defined

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      INTEGER 
     &   IAV1
     &  ,IAV2
     &  ,IAVTMP
     &  ,IAV1_MIN, IAV1_MAX
     &  ,IAV2_MIN, IAV2_MAX
     &  ,iexp, NEXP
     &  ,LL(2)

      REAL*8
     &   tmp
     &  ,AV1_binsize
     &  ,AV2_binsize
     &  ,AV1, XAV1
     &  ,AV2, XAV2
     &  ,AVEXTRAP
     &  ,WAV, WRES
     &  ,AVRES
     &  ,GNORM
     &  ,prob, chi2
     &  ,tmpchi2
     &  ,probmin
     &  ,probmax
     &  ,chi2max
     &  ,chi2_1, chi2_2, chi2slope
     &  ,arg

      REAL*8  CHI2_PRIOR

      LOGICAL USER_EXPSUM

      CHARACTER CPRIOR(2)*28

C -------------- BEGIN ----------

      LSTAT       = .FALSE.
      NEXP        = 0
      USER_EXPSUM = .FALSE.

c determine how many exponentials used in prior.


c check for flat prior
      IF ( OPT_PRIOR_AV .EQ. 0 ) THEN
         CALL PRBANNER( 'FITINI_AVPRIOR: FLAT-NEG AV PRIOR.')
         PRIOR_AVRES    = 10.0
         PRIOR_AVWGT(1) = 75.0  ! adjusted so that probmax = 1
         NEXP           = 1
         LSTAT          = .TRUE.
         USER_EXPSUM    = .TRUE.
         GOTO 40
      ENDIF

c ------------

      DO iexp = 1, 2
        cprior(iexp) = ':'
        if ( PRIOR_AVEXP(iexp) .GT. 0.0 .and. 
     &       PRIOR_AVWGT(iexp) .GT. 0.0 ) THEN
                NEXP = NEXP + 1

           write(cprior(iexp),12) 
     &         PRIOR_AVWGT(iexp), PRIOR_AVEXP(iexp)
12         format( F5.2,'*EXP(-AV/',F5.3,'):' )
        endif

        LL(iexp) = INDEX ( CPRIOR(iexp), ':' ) - 1

      ENDDO

      IF ( NEXP .LE. 0 ) THEN
         CALL PRBANNER( 'FITINI_AVPRIOR: NO AV-PRIOR IS USED.' )
         RETURN
      ELSE
         write(global_banner,19) NEXP
19       format('FITINI_AVPRIOR: DEFINE AV PRIOR WITH ',
     &          I1,' EXPONENTIALS')
         CALL PRBANNER( global_banner )
         LSTAT    = .TRUE.
         USER_EXPSUM = .TRUE.
      ENDIF

c print prior formula to screen 

      write(6,23)  CPRIOR(1)(1:LL(1)), CPRIOR(2)(1:LL(2))
      write(6,24)  PRIOR_AVRES
23    format(T6,'AV-PRIOR FUNCTION  = ', A, ' + ' , A )
24    format(T6,'AV-SIGMA(SMEARING) = ', F6.3 )

      print*,' '

40    CONTINUE

      AVRES  = DBLE(PRIOR_AVRES)

      if ( PRIOR_AVRES .LE. 0.0 ) then
         write(c1err,660) PRIOR_AVRES
660      format('PRIOR_AVRES = ', F9.4, ' < 0 is INVALID.   ')
         c2err = 'PRIOR_AVRES must be positive. '
         CALL MADABORT("FITINI_AVPRIOR", c1err, c2err )
      endif


      PRIOR_RANGE(1,IPAR_AV) = -1.0  ! min AV for prior 
      PRIOR_RANGE(2,IPAR_AV) = +2.0  ! max AV for prior 

c set up binning used to store AV prior on grid.

      tmp = PRIOR_RANGE(2,IPAR_AV) - PRIOR_RANGE(1,IPAR_AV)
      AV1_binsize = tmp / DBLE(NBIN_PRIOR)
      PRIOR_BINSIZE(ipar_AV) = AV1_binsize
      IAV1_MIN = 1
      IAV1_MAX = NBIN_PRIOR

c setup binning for Gaussian smear: bin size = smaller of
c 1/10 of sigma or AV1_binsize.
c First AV2 bin has positive AV; last AV2 bin is 3-sigma
c past range.

      AV2_binsize = min(AV1_binsize, 0.1*AVRES)

      tmp         = PRIOR_RANGE(1,IPAR_AV)
      if ( tmp .LT. 0.0 ) then
        IAV2_MIN  = int( -tmp / AV2_binsize ) - 1
      else
        IAV2_MIN  = 1
      endif

      tmp = PRIOR_RANGE(2,IPAR_AV) - PRIOR_RANGE(1,IPAR_AV)
      IAV2_MAX    = int( (tmp + 3.0*AVRES)/AV2_binsize )

c now convolve exponential AV-prior with gaussian smear
c (to allow for negative AV)
c AV1 includes unphysical AV due to smearing;
c AV2 includes only physical AV

      GNORM   = AVRES * DSQRT( DBLE(2.0) * PI )
      PROBMIN = DEXP(DBLE(-700.0))  ! ~ 10^{-305}
      CHI2MAX = 0.0

      PROBMAX = 0.0

c start with loop over AV that includes negative values.

      DO 41 IAV1  = IAV1_MIN, IAV1_MAX
         XAV1     = DBLE(IAV1) 
         AV1      = PRIOR_RANGE(1,IPAR_AV) + AV1_binsize * xav1

         PRIOR_GRID(iav1,ipar_av) = AV1  ! store AV vs. grid index

c now loop over physical AV2 > 0, and go past defined range to
c accoount for smearing from beyond defined range.
          
          do 42 IAV2 = IAV2_MIN, IAV2_MAX
               XAV2  = DBLE(IAV2)
               AV2   = PRIOR_RANGE(1,IPAR_AV) + AV2_binsize * xav2

               if ( AV2 .LT. 0.0 ) goto 42

               IF ( USER_EXPSUM ) THEN
                 WAV = 0.0
                 DO iexp = 1, NEXP
                   ARG = AV2/PRIOR_AVEXP(iexp)
                   WAV = WAV + PRIOR_AVWGT(iexp) * DEXP(-arg)
                 ENDDO
               ENDIF

               if ( AVRES .GT. 1.0E-6 ) then
                  tmp   = (AV2 - AV1)/AVRES
                  WRES  = DEXP(-0.5*tmp*tmp) / GNORM
               else if ( dabs(AV2-AV1) .LT. 0.0001 ) then
                  WRES  = 1.0 / AV2_binsize
               else
                  WRES  = 0.0
               endif

               prob = WAV * WRES
               prob = MAX ( prob, probmin )

               probmax = max ( prob, probmax )

c large AVEXP is a flag to have no prior on AV
               if ( PRIOR_AVEXP(1) .GT. 100.0 ) prob = 0.0

               if ( prob .GT. 0.0 ) then

                  PRIOR_probgrid(iav1,ipar_av) = 
     &            PRIOR_probgrid(iav1,ipar_av) + prob * AV2_binsize

c update chi2 
                  prob    = PRIOR_probgrid(iav1,ipar_av)
                  tmpchi2 = -2.0 * dlog(prob)
                  PRIOR_chi2grid(iav1,ipar_av) = tmpchi2

               endif
42       continue  ! end of AV2 loop


41    CONTINUE   ! end of AV1 loop

c -----------------------------------------------------------
c Now check if chi2 > 1400 (at negative AV) which causes prob 
c to goto zero due to floating point overflow. 
c To avoid discontinuity in chi2, the chi2 is extrapolated 
c from a safe region.

c get chi2max from most neg AV in 1st bin

      chi2max = PRIOR_chi2grid(1,ipar_av)  

c look for first bin with chi2 < chi2max

      DO IAV1 = 2, NBIN_PRIOR
         chi2 = PRIOR_CHI2GRID(iav1,ipar_av)
         if ( chi2 .LT. 0.999*chi2max ) then
            IAVTMP = IAV1
            goto 444
         endif
      ENDDO

444   CONTINUE

c get slope from two neighbor chi2 points 

      AV1 =  PRIOR_GRID(iavtmp,  ipar_av)
      AV2 =  PRIOR_GRID(iavtmp+1,ipar_av)
      AVEXTRAP = AV1

      chi2_1 = PRIOR_chi2grid(iavtmp,  ipar_av)
      chi2_2 = PRIOR_chi2grid(iavtmp+1,ipar_av)

      chi2slope = (chi2_2 - chi2_1) / (AV2-AV1)

c Loop over AV bins again, and replace chi2 in overflow region
c with extrapolated chi2.

      DO IAV1 = 1, NBIN_PRIOR
         AV1 =  PRIOR_GRID(iav1,ipar_av)
         if ( AV1 .LT. AVEXTRAP ) then
           chi2 = chi2_1 + chi2slope * (AV1 - AVEXTRAP)
           PRIOR_CHI2GRID(iav1,ipar_av) = chi2
         endif
      ENDDO

      CALL FLUSH(6)

      RETURN 
      END  ! end of FITINI_AVPRIOR


C ==========================================
+DECK,CHI2_PRIOR.
      DOUBLE PRECISION FUNCTION CHI2_PRIOR(ipar, PARVAL)
c
c Return chi2 penality for prior.
c IPAR is the fitpar index;
c FITPAR is the value to look up the prior.
c
c Use CERNLIB's POLINT  for polynomial interpolation 
c with 3 nearest points in stored grid.
c
c Feb 24, 2007: use NGRID=3 if slope is nearly constant;
c               else use NGRID = 5 on rapidly changing parts.
c
c Jun 1, 2008 RK: fix bug to prevent bin=0 and divide-by-zero
c
c Aug 17, 2009: if PARVAL is in FLATPRIOR_RANGE region,
c               no need to interpolate. Also, do not allow
c               interp to use point in FLATPRIOR region,
c               otherwise we get a discontinuity.
c
c Sep 8, 2011: POLINT -> POLINT8 that uses REAL*8 args
c
c Apr 3 2018: NPINT=5 only for OPT_PRIOR_AV (not for SALT2c)
c             This fixes subtle numerical problem with new color-prior.
 
c ------------------------

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

c function args.

      INTEGER IPAR    ! (I) fitpar index
      REAL*8  PARVAL  ! (I) fitpar value to compute chi2

c local var

      INTEGER NPMAX, NBEDGE_LININTERP
      PARAMETER ( 
     &    NPMAX = 5           ! max  Ngrid points for interpolation
     &   ,NBEDGE_LININTERP =2 ! do lin-interp when this close to edge (bins)
     &       )   

      INTEGER 
     &   NPINT, NPHALF, ibin(NPMAX)
     &  ,ibcen, ibtmp, i

      REAL*8  
     &   dif, bin, parmin, parmax
     &  ,XTMP, XLO, XHI, XBIN
     &  ,dchi2_up, dchi2_dn
     &  ,arg, prob  ! debug args

      LOGICAL LTMP, LAV, LDMP

c define variables for polynomial interpolation

      REAL*8 XINT8(NPMAX), CHI2INT8(NPMAX), R8

C -------------- BEGIN --------------

      CHI2_PRIOR = 0.0  ! init

      if ( .NOT. USE_PRIOR(ipar) ) RETURN

c check trivial case of flat-prior region
      if ( PARVAL .GE. FLATPRIOR_RANGE(1,ipar) .and.
     &     PARVAL .LE. FLATPRIOR_RANGE(2,ipar) ) then
         CHI2_PRIOR = 0.0
         RETURN
      endif

c get bin for lookup
      bin   = PRIOR_binsize(ipar)

      parmin  = PRIOR_RANGE(1,ipar) + NBEDGE_LININTERP * bin
      parmax  = PRIOR_RANGE(2,ipar) - NBEDGE_LININTERP * bin

c near the edge (defined by parmin & parmax),  
c use linear interp to ensure that we get large chi2 when 
c [MINUIT] parameter values are way out there.
c With parabolic interp, the function can roll over at
c very large par-values and give a small (incorrect) chi2.

      IF ( PARVAL .LE. parmin ) then  ! linear interp near lo edge
          NPINT    = 2 
          ibcen    = NBEDGE_LININTERP
      ELSE IF ( PARVAL .GE. parmax ) then  ! linear interp near hi edge
          NPINT    = 2
          ibcen    = NBIN_PRIOR - NBEDGE_LININTERP

      ELSE      ! parabolic interp

         dif   = PARVAL - PRIOR_RANGE(1,ipar)     
         ibcen = int( (dif-bin + 1.0E-8 ) / bin ) + 1 ! central lookup bin

c avoid edges where linear interp is done.
         if ( ibcen .LE. NBEDGE_LININTERP ) then
           ibcen = NBEDGE_LININTERP + 1
         endif

         if ( ibcen .GE. NBIN_PRIOR - NBEDGE_LININTERP ) then
           ibcen = NBIN_PRIOR - NBEDGE_LININTERP - 1
         endif

c check if we are in FLAT-PRIOR region; if so, then move out so that
c we don't have two interp bins in the flat-prior region.
c Note that PARVAL must be outside FLAT-PRIOR region to get here,
c so this is just a check of the central interp bin.

         XTMP = PRIOR_GRID(ibcen,ipar)   

         IBTMP = FLATPRIOR_BINRANGE(1,IPAR)
         IF ( IBCEN .GE. IBTMP .and. IBCEN .LE. IBTMP+2 ) then
           IBCEN = IBCEN - 1  ! move out of flat-prior region
         ENDIF

         IBTMP = FLATPRIOR_BINRANGE(2,IPAR)
         IF ( IBCEN .LE. IBTMP .and. IBCEN .GE. IBTMP-2 ) then
           IBCEN = IBCEN + 1  ! move out of flat-prior region
         ENDIF

         if ( ibcen .LE. 0 ) then
 
            print*,' '
            print*,' ---------------------------------------- '
            print*,' XXXX PARMIN, PARMAX = ', PARMIN, PARMAX
            print*,' XXXX IBCEN    = ', IBCEN
            print*,' XXXX PARVAL   = ', PARVAL

            write(c1err,23) ibcen, DIF, PARNAME_STORE(ipar), parval
23          format('IBCEN=',I4,' for DIF=',F8.3,' and ',A,'=',F10.3)

            write(c2err,24) 
     &          PRIOR_RANGE(1,ipar),PRIOR_RANGE(2,ipar) 
     &         ,PRIOR_BINSIZE(ipar)
24          format('PRIOR_RANGE,BINSIZE=', 3F10.3 )

            CALL MADABORT ( "CHI2_PRIOR", c1err, c2err )            
         endif

c if upstream and downstream slopes are withing 5%, use 3 interp bins;
c else use 5 interp bins near rapidly changing regions.

         dchi2_up = PRIOR_CHI2GRID(ibcen,   ipar) 
     &            - PRIOR_CHI2GRID(ibcen-1, ipar) 
         dchi2_dn = PRIOR_CHI2GRID(ibcen+1, ipar) 
     &            - PRIOR_CHI2GRID(ibcen,   ipar) 

         if ( dchi2_dn .NE. 0.0)  then 
            dif = dchi2_up/dchi2_dn
         else
            dif = 1.0
         endif

         LTMP = dif.GT.0.0 .and. abs(dif-1.0) .GT. 0.05
         LAV  = (IPAR .EQ. IPAR_AV) .and. USE_PRIOR_AV
         if ( LTMP .and. LAV) then
            NPINT = NPMAX
         else
            NPINT = 3
         endif
       ENDIF

c -----------------------------

      NPHALF = (NPINT-1)/2

c load table for POLINT ... note 4-byte reals

      DO i = 1, NPMAX
        if ( i .LE. NPINT ) then
          ibin(i)     = ibcen - (NPHALF+1) + i
          XTMP        = PRIOR_GRID(ibin(i),ipar)      ! fitpar grid
          CHI2INT8(i) = PRIOR_CHI2GRID(ibin(i),ipar)  ! chi2 grid

c if GRID point is in a flat-prior region, pull it to the
c edge of the flat-prior region to avoid discontinuity
c Note that the chi2 need not change since it is the same
c in the flat-prior region.

          XBIN = 5. * PRIOR_BINSIZE(ipar)

          XLO  = FLATPRIOR_RANGE(1,ipar) 
          LTMP = (XTMP .GT. XLO) .and. (XTMP .LT. XLO+XBIN)
          IF ( LTMP ) XTMP = XLO

          XHI  = FLATPRIOR_RANGE(2,ipar) 
          LTMP = (XTMP .LT. XHI) .and. (XTMP .GT. XHI-XBIN)
          IF ( LTMP ) XTMP = XHI

          XINT8(i)    = XTMP
        else
          ibin(i)     = -9
          XINT8(i)    = 0.0
          CHI2INT8(i) = 0.0
        endif
      END DO

c call CERNLIB routine to interpolate ...
c R8 is returned.

      CALL POLINT8 ( CHI2INT8, XINT8, NPINT, PARVAL, R8 )
      CHI2_PRIOR = R8

+SELF,IF=PRIORBUG.
c xxxxxxxxxxxxxxxxxx
      if ( IPAR .EQ. IPAR_AV .and. 
     &     abs(abs(PARVAL) - 0.01) .LT. 1.0E-4 ) then

         arg   = min(40.0,chi2_prior/2.0)
         prob  = dexp(-arg)

         print*,' -------------------------------------- '
         write(6,666) PARVAL, chi2_prior, prob, NPINT, IBCEN
666      format(T2,' xxx AV=',F7.4, 2x, 'CHI2=', G12.5, 2x, 
     &       'PROB=',F12.5, 2x, 'NPINT,IBCEN=', I2,',', I5)

         print*,'      xxx PARVAL(interp) = ', 
     &          XINT8(1), XINT8(2), XINT8(3)
         print*,'      xxx chi2(interp)   = ', 
     &          CHI2INT8(1), CHI2INT8(2), CHI2INT8(3)
      endif
c xxxxxxxxxxxxxxxx
+SELF.

      LDMP = (IPAR .EQ. -IPAR_COLOR)
      if ( LDMP ) then
         print*,' XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX '
         print*,' XXX PARNAME      = ', PARNAME_STORE(ipar),'=',PARVAL
         print*,' XXX IBCEN        = ', IBCEN
         print*,' XXX IBIN(GRID)   = ', IBIN
         print*,' XXX dchi2(up,dn) = ', SNGL(dchi2_up), SNGL(dchi2_dn)
         print*,' XXX PAR(solve)   = ', SNGL(PARVAL),' NPINT=',NPINT
         print*,' XXX PAR(GRID)    = ', (SNGL(XINT8(i)),i=1,NPMAX)
         print*,' XXX CHI2(GRID)   = ', (SNGL(CHI2INT8(i)),i=1,NPMAX)
         print*,' XXX CHI2(fun)    = ', SNGL(CHI2_PRIOR)
         print*,' XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX '
      endif


      RETURN
      END

C =================================
+DECK,PRIOR_ZPULL.
      DOUBLE PRECISION FUNCTION PRIOR_ZPULL(ZSN)
c
c Created April 20, 2007 by R.Kessler
c
c Returns ZPULL = (Z - Zref) / err
c to be used in chi2-fit function.
c
c Note namelist option  
c  OPT_PHOTOZ=1  => always use host-galaxy photoZ
c  OPT_PHOTOZ=2  => use spectro Z when available.
c
c
c Jan 27 2018: 
c  + use DOFIT_PHOTOZ_HOST to determine LPULL
c
c Mar 02 2022: load global PRIOR_PHOTOZ[_ERR]
c
c ------------------------------------------------

      IMPLICIT NONE

      REAL*8  ZSN  ! (I) redshift in fit

c local

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,SNLCINP.

      REAL*8  zPRIOR_err, zPRIOR, sqerr, Zpull, Zdif, Zsig
      LOGICAL LPULL

C ------------ BEGIN -------------

      PRIOR_ZPULL = 0.0
      LPULL  = .FALSE.
  
      if ( BTEST(OPT_PHOTOZ,BIT_PHOTOZ_GAUSS) ) then  ! use host photo z
         zPRIOR     = SNHOST_ZPHOT(1)
         zPRIOR_err = SNHOST_ZPHOT_ERR(1)
         LPULL = zPRIOR_err .GT. 0.005 .and. DOFIT_PHOTOZ_HOST

      else if ( BTEST(OPT_PHOTOZ,BIT_BESTZ_GAUSS) ) then  ! use final redshift
         zPRIOR      = SNLC_REDSHIFT
         zPRIOR_err  = SNLC_REDSHIFT_ERR
         LPULL       = .TRUE.
      else
        write(c1err,662) OPT_PHOTOZ
662     format('Invalid OPT_PHOTOZ = ', I5 )
        c2err = 'Check &FITINP namelist.'
        CALL MADABORT ( "PRIOR_ZPULL", c1err, c2err )
      endif

c protect against error=0
      sqerr = zPRIOR_ERR*zPRIOR_ERR
      zPRIOR_ERR = SQRT(sqerr + 1.0E-10)

      if ( zPRIOR_ERR .LE. 1.0E-7 ) then
        write(c1err,666) zPRIOR_ERR, SNLC_CCID
666     format('zPRIOR_ERR=',G10.3,'  for CID=',A)
        c2err = 'Check REDSHIFT_FINAL' 
        CALL MADABORT ( "PRIOR_ZPULL", c1err, c2err ) 
      endif

      if ( LPULL ) then
         Zpull = (ZSN - zPRIOR )/ (zPRIOR_err*PRIOR_ZERRSCALE)
      else
         Zdif = ZSN - Zrange_KCOR(2) 
         Zsig = 0.2
         if ( Zdif > 0.0 ) then
            Zpull = Zdif / Zsig  ! prior if beyond Zrange_KCOR
         else
            Zpull = 0.0  ! no host => no prior
         endif
      endif
     
      PRIOR_ZPULL      =  Zpull  ! function return
      PRIOR_PHOTOZ     =  sngl(zPRIOR)       ! global
      PRIOR_PHOTOZ_ERR =  sngl(zPRIOR_ERR)   ! global

      RETURN
      END  ! end of PRIOR_ZPULL

C =================================
+DECK,PRIOR_MUPULL.
      DOUBLE PRECISION FUNCTION PRIOR_MUPULL(isn,ZSN,MUSN)
c
c Created Aug 7, 2009 by R.Kessler
c
c Returns MUPULL = (MU - MUref) / err^2
c to be used in chi2-fit function.
c
c ------------------------------------------------

      IMPLICIT NONE

      INTEGER isn   ! (I) SN index
      REAL*8  ZSN   ! (I) redshift
      REAL*8  MUSN  ! (I) distance modulus

c local

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,SNLCINP.

      REAL*8  
     &   muerr, mudif, muref, mu1, mu2
     &  ,W_SAVE, OMAT_SAVE

c functions
      REAL*8 DLMAG8_REF
C ------------ BEGIN -------------

      PRIOR_MUPULL = 0.0
      if ( .NOT. DOPRIOR_DLMAG ) RETURN

      muref = DLMAG8_REF(ZSN)
      
c Now get DLMAG with w shifted by its uncertainty
      W_SAVE    = W0_REF(1)
      W0_REF(1) = W0_REF(1) + W0_REF(2)
      mu1       = DLMAG8_REF(ZSN)
      W0_REF(1) = W_SAVE 

c now get DLMAG with OMAT shifted by its uncertainty
      OMAT_SAVE    = OMAT_REF(1)
      OMAT_REF(1)  = OMAT_REF(1) + OMAT_REF(2)
      mu2          = DLMAG8_REF(ZSN)
      OMAT_REF(1)  = OMAT_SAVE 

c now add mu-shifts in quadrature (ignore correlations)
c to get distance error.

      muerr = sqrt ( (mu1-muref)**2 + (mu2-muref)**2 )
      mudif = MUSN - muref

c inclucde user MUERRSCALE in evaluating the pull.

      PRIOR_MUPULL = mudif / (muerr * PRIOR_MUERRSCALE)

+SELF,IF=XXXDMP.
      print*,' ------------------------------------- '
      print*,' CID=', SNLC_CID, '    ZSN = ', ZSN
      print*,' MUREF, MUSN  = ', MUREF, MUSN
      print*,' MU(DIF,ERR)  = ', MUDIF, MUERR
      print*,' PRIOR_MUPULL = ', PRIOR_MUPULL
      call flush(6)
+SELF.

      RETURN
      END

C ==========================================
+DECK,INISIMEFF.
      SUBROUTINE INIT_PRIOR_SIMEFF
c
c Jul 25, 2011
c Initialize simulated efficiency for prior.
c [modified from MON_SIMEFF]
c Also make plots of simulated efficiency vs. Z and
c other variables.
c
c ------------------

      IMPLICIT NONE

c local var

+CDE,SNDATCOM.
+CDE,SNFITCOM.
+CDE,SIMEFFCM.
+CDE,SNANAFIT.

      INTEGER   L1, L2, ivar, ipar, NWD, MSKOPT
      CHARACTER 
     &   VARNAMES*200, NAME*(MXCHAR_FILEWORD)
     &  ,SIMEFF_FILE_LOC*(MXCHAR_FILENAME)

      LOGICAL USE_SIMEFF

c function
      INTEGER  INIT_SIMEFFMAP, STORE_PARSE_WORDS
      EXTERNAL INIT_SIMEFFMAP, STORE_PARSE_WORDS

C ------------------- BEGIN ---------------

      IF ( OPT_PRIOR    .EQ. 0 ) RETURN

      USE_SIMEFF = SIMEFF_FILE .NE. ' '

      IF ( USE_SIMEFF ) THEN
         OPT_PRIOR_SIMEFF = 1
         global_banner = 
     &      'INIT_PRIOR_SIMEFF: PRIOR multiplied by sim-efficiency'
      ELSE
         global_banner = 
     &      'INIT_PRIOR_SIMEFF: sim-efficiency NOT used for PRIOR.'
      ENDIF

      CALL PRBANNER( global_banner(1:60) )

      IF( .NOT. USE_SIMEFF ) RETURN

c ---------------------------------------------

      L1 = INDEX(SIMEFF_FILE,' ') - 1
      SIMEFF_FILE_LOC = SIMEFF_FILE(1:L1) // CHAR(0)
      NPAR_SIMEFF = INIT_SIMEFFMAP(SIMEFF_FILE_LOC, VARNAMES)

c translate VARNAMES string into variable names and fill 
c IPAR_SIMEFF array for faster lookups.

      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD = STORE_PARSE_WORDS(MSKOPT, VARNAMES//char(0), 200 )

      IF ( NPAR_SIMEFF .NE. NWD ) THEN
        write(c1err,601) NPAR_SIMEFF
        write(c2err,602) VARNAMES, NWD
601     format('INIT_SIMEFFMAP returned NVAR=',I2)
602     format('but VARNAMES=|', A30,'| has NWD=',I2 )
        CALL MADABORT('INIT_PRIOR_SIMEFF', C1ERR, C2ERR)
      ENDIF


      DO 200 ivar   = 1, NWD
         IPAR_SIMEFF(IVAR) = -9
         call get_PARSE_WORD_fortran(ivar, name, L1 )

c xxxxxxxx mark delete xxxxxxxxxxx
c         name      = fileword_list(ivar)
c         L1        = index(name,' ') - 1
c xxxxxxxxxxxxxxxxxxxxxxxxx

c check all of the fit parameter names
         DO 201 ipar = 1, IPAR_MAX  ! loop over fit-parameters
            L2 = INDEX(PARNAME_STORE(ipar),' ') -1 
            if ( L1 .NE. L2 ) goto 201
            if ( NAME(1:L1) .EQ. PARNAME_STORE(ipar)(1:L2) ) then
               IPAR_SIMEFF(IVAR) = IPAR 
               GOTO 200
            endif
201      CONTINUE

c check other variables that are not in the fit-par list

         IF ( NAME(1:1) .EQ. 'Z' ) THEN
             IPAR_SIMEFF(IVAR) = IPAR_SIMEFF_REDSHIFT
             GOTO 200
         ENDIF
         IF ( NAME(1:8) .EQ. 'REDSHIFT' ) THEN
             IPAR_SIMEFF(IVAR) = IPAR_SIMEFF_REDSHIFT 
             GOTO 200
         ENDIF
         IF ( NAME(1:5) .EQ. 'MWEBV' ) THEN
             IPAR_SIMEFF(IVAR) = IPAR_SIMEFF_MWEBV 
             GOTO 200
         ENDIF

         C1ERR = 'Uncrecognized SIMEFF map-var: ' // NAME(1:L1)
         C2ERR = 'Check SIMEFF map file.'
         CALL MADABORT('INIT_PRIOR_SIMEFF', C1ERR, C2ERR)
200   CONTINUE


      IF ( FITMODEL_INDEX == MODEL_MLCS2k2 .and. USE_TABLEFILE ) THEN
        CALL MON_SIMEFF()
      ENDIF

      RETURN
      END     ! end of INIT_PRIOR_SIMEFF


C ================================================
+DECK,FINI_XTPAR.
      SUBROUTINE FITINI_XTPAR(OPT)
c
c Nov 16, 2006
c
c Initalize host-gal extinction parameters based
c on namelist option OPT_SNXT
c
c Sep 15, 2008: print Extinction/AV for each filter.
c
      IMPLICIT NONE
cc +CDE,SNPAR.
+CDE,SNDATCOM.
+CDE,SNFITCOM.
+CDE,XTCOM.
+CDE,FILTCOM.

      INTEGER OPT  ! (I) option flag

c local var
      INTEGER ifilt, ifilt_Rest

c GET_SNXT8 args
      REAL*8  AV8, RV8, T8, XT8(MXFILT_ALL)

c functions
      INTEGER FILTINDX
      REAL*8  GET_SNXT8  

C -------------- BEGIN -------------

      CALL PRBANNER("FITINI_XTPAR: INIT HOST-GALAXY EXTINCTION")

      IF ( OPT .EQ. OPT_SNXT_CCM89 ) THEN

cc         print*,'  Will use exact CCM89 law with AV = XTMAG(5495 A)'
         CALL INIT_XTHOST(OPT)

      ELSE IF ( OPT .EQ. OPT_SNXT_SJPAR ) THEN

         print*,'  Will use approx XTMAG = ',
     &             'zeta(t) * [ alpha + beta/RV ] * AV '

         CALL RDXTPAR(FITMODEL_PATH)

      ELSE
         print*,' '
         print*,' FITINI_XTPAR ERROR: '
         print*,'   Unknown option OPT = ', OPT
         print*,'  ***** ABORT ***** '
         print*,' '
      ENDIF


      AV8 = 1.0
      T8  = 0.0 
      RV8 = INIVAL_RV

      write(6,20) RESTKCOR_FILTERS(1:NFILTDEF_REST)

      DO ifilt = 1, NFILTDEF_REST
         ifilt_rest = IFILTDEF_MAP_REST(ifilt)
         XT8(ifilt_rest) = GET_SNXT8(OPT, ifilt_rest, T8, AV8, RV8)
         write(6,21) XT8(ifilt_rest)
      ENDDO

      write(6,22) RV8

20    format(T5,'Peak XTMAG/AV(', A, ')=', $ )
21    format(F6.3, $)
22    format(' (RV=',F4.2,')' )

      RETURN
      END

C ===================================================
+DECK,FITANA_CUTS.
      SUBROUTINE FITANA_CUTS(isn, LCUTS )
c
c Apply quality cuts to fit results AFTER all fit-iterations
c have finished.
c Returns LCUTS = T if fit is acceptable.
c
c Cuts on:
c
c  * min Trest
c  * max Trest
c  * TGAPMAX & T0GAPMAX
c  * NEPOCH_FIT per filter
c  * valid LUMIPAR range
c  * all but 1 error is from MINOS
c  * DLMAG error is from MINOS
c  * ZPULL (for PHOTOZ fit only)  
c  * fit prob
c  * SNRMAX & SNRMAX2
c  * SIGMACHI2
c  * FitPar and covariances
c
c
c Sep 17 2016: cut on fitted covariances; see CUTWIN_FITCOV
c
c Mar 10 2017: cut on CUTWIN_FITERRz1
c
c Jan 4 2021: check OPT_SNCID_LIST option to accept everything.
c
c ------------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

c subroutine args

      INTEGER  isn     ! (I) sparse SN index 
      LOGICAL  LCUTS   ! (O) T => passes cuts

c local var

      INTEGER 
     &   cid, LCID, year, epoch, imjd
     &  ,ifilt, ifilt_obs, cutbit, ipar, ipar2
     &  ,ETYPE, MXERRBAD, NERRBAD, NERROK, ifitdata, NTLIST
    
      REAL 
     &   MJD, PEAKMJD, Tobs, Trest
     &  ,TMIN,TMAX, TGAPMAX, T0GAPMAX
     &  ,XN, xval, zpull, ERR_overz1, z1, TRESTCUT, TRESTCUT_EXTEND
     &  ,TLIST(MXEPOCH)

      LOGICAL LTMP, LTMP1, LTMP2, DOFIT_SPECZ, LVBOSE, LCOV

      CHARACTER 
     &   BANNER*60
     &  ,cfilt*1
     &  ,CCID*(MXCHAR_CCID)
     &  ,CLINE*72

c functions
      
      LOGICAL LCUTVAR

C ----------------- BEGIN ----------------

      LVBOSE = ( ISN .LE. NFIT_VERBOSE )  ! June 2013 - avoid HUGE log files

      CCID = SNLC_CCID
      LCID = ISNLC_LENCCID  ! INDEX(CCID,' ')

      write(BANNER,20) CCID(1:LCID)
20    format('FITANA_CUTS: APPLY FIT-CUTS TO SN ',A )
      CALL PRBANNER(BANNER)

      LCUTS = .TRUE.  ! init output argument

c Jan 4 2021
c check option to use SNCID list and skip cuts ... but always
c reject events that are pegged to the edge of the shape prior range
      if ( BTEST(OPT_SNCID_LIST,0) ) THEN
         xval = LCVAL_STORE(ipar_shape)
         if ( xval < PRIOR_SHAPE_RANGE(1) + 0.05 ) LCUTS = .FALSE.
         if ( xval > PRIOR_SHAPE_RANGE(2) - 0.05 ) LCUTS = .FALSE.
         RETURN
      endif

      DOFIT_SPECZ = .NOT. DOFIT_PHOTOZ

c ------------------------------------------------
c sanity check on PEAKMJD
   
      if ( PEAKMJD_SANITY(1) .EQ. 0.0 ) then
          PEAKMJD_SANITY(1) = CUTWIN_PEAKMJD(1) - 20.0 
          PEAKMJD_SANITY(2) = CUTWIN_PEAKMJD(2) + 20.0
      endif

      PEAKMJD   = LCVAL_STORE(IPAR_PEAKMJD) + MJDOFF

      LTMP =  ( PEAKMJD .GT. PEAKMJD_SANITY(1) )
     &  .and. ( PEAKMJD .LT. PEAKMJD_SANITY(2) )

      IF ( LTMP ) THEN
         write(CLINE,53000) 'PEAKMJD', PEAKMJD, 'PASSES'
      ELSE
         LCUTS = .FALSE.
         write(CLINE,53000) 'PEAKMJD', PEAKMJD, 'FAILED'
      ENDIF
      if ( LVBOSE ) print*,CLINE

53000   format(T10,A18,' = ', F10.3, 1x, A, ' CUT.' )

c ------------------------------------------------
c check Tobs[rest]_min,max using fit PEAKMJD instead
c of SEARCH_PEAKMJD. Use same "cutwin_Tobs[rest]*" parameters
c that snana uses.

c loop over epochs used in fit and make TLIST array

c apply Tobs cuts

      LTMP = LCUTVAR(Tobsmin_FIT, CUTBIT_Tobsmin, LVBOSE) 
      IF ( .NOT. LTMP ) LCUTS = .FALSE.

      LTMP = LCUTVAR(Tobsmax_FIT, CUTBIT_Tobsmax, LVBOSE) 
      IF ( .NOT. LTMP ) LCUTS = .FALSE.

c apply Trest cuts 

      LTMP = LCUTVAR(Trestmin_FIT, CUTBIT_Trestmin, LVBOSE) 
      IF ( .NOT. LTMP ) LCUTS = .FALSE.

      LTMP = LCUTVAR(Trestmax_FIT, CUTBIT_Trestmax, LVBOSE) 
      IF ( .NOT. LTMP ) LCUTS = .FALSE.

c apply GAP cuts 

      LTMP = LCUTVAR(TGAPMAX_FIT, CUTBIT_TGAPMAX, LVBOSE ) 
      IF ( .NOT. LTMP ) LCUTS = .FALSE.

      LTMP = LCUTVAR(T0GAPMAX_FIT, CUTBIT_T0GAPMAX, LVBOSE) 
      IF ( .NOT. LTMP ) LCUTS = .FALSE.

c -------------------------------------------------------
c Check that Trestmin/max are withing FITWIN_TREST,
c but allow slop of TRESTCUT_EXTEND.

c is this redundant with Trestmin[max]_FIT cuts above ??
c Feb 2014: skip this for photo-z fits.

      IF ( NFIT_ITERATION > 1 .and. (.not. DOFIT_PHOTOZ) ) THEN

        TRESTCUT_EXTEND = 3.0  ! extend from 2.0, Feb 2014

        xval     = Trestmin_FIT
        TrestCUT = FITWIN_TREST(1) - TRESTCUT_EXTEND
        LTMP     = ( xval .GE. Trestcut )

        if ( LTMP ) then
           write(CLINE,161) 'FITWIN_TREST(min)', xval, 'PASSES'
        else
           write(CLINE,161) 'FITWIN_TREST(min)', xval, 'FAILED'
           LCUTS = .FALSE.
        endif
        IF ( LVBOSE ) print*, CLINE

c - - - -
        xval     = Trestmax_FIT
        TrestCUT = FITWIN_TREST(2) + TRESTCUT_EXTEND
        LTMP     = ( xval .LE. Trestcut )     

        if ( LTMP ) then
           write(CLINE,161) 'FITWIN_TREST(max)', xval, 'PASSES'
        else
           write(CLINE,161) 'FITWIN_TREST(max)', xval, 'FAILED'
           LCUTS = .FALSE.
        endif
        IF ( LVBOSE ) print*, CLINE       

c - - - -
c  Dec 18 2017: add TRESTRANGE cut 
        xval     = TrestRange_FIT
        TrestCUT = CUTWIN_TRESTRANGE(1) 
        LTMP     = ( xval .GE. Trestcut )     

        if ( LTMP ) then
           write(CLINE,161) 'FITWIN_TRESTRANGE', xval, 'PASSES'
        else
           write(CLINE,161) 'FITWIN_TRESTRANGE', xval, 'FAILED'
           LCUTS = .FALSE.
        endif
        IF ( LVBOSE ) print*, CLINE  

      ENDIF

      CALL FLUSH(6)
c ---------------------------------
c cut on fit params

      DO 160 ipar = 1, IPAR_MAX
         if ( cutwin_fitpar(1,ipar) .LT. -9.0E7 ) goto 160
         if ( cutwin_fitpar(2,ipar) .GT. +9.0E7 ) goto 160

         xval = LCVAL_STORE(ipar)
         LTMP = xval .GE.  cutwin_fitpar(1,ipar) .and.
     &          xval .LE.  cutwin_fitpar(2,ipar) 

         if ( LTMP ) then
            write(CLINE,161) PARNAME_STORE(ipar), xval, 'PASSES'
         else
            write(CLINE,161) PARNAME_STORE(ipar), xval, 'FAILED'
            LCUTS = .FALSE.
         endif
         IF( LVBOSE ) print*,CLINE

160   CONTINUE

161      format(T10,A18,' = ', G10.3, 1x, A, ' CUT.' )
162      format(T10,A18,' = ', I4,    7x, A, ' CUT.' )
163      format(T10,A18, 14x, A, ' CUT.' )

c -------------------------------------------------------
c cut on fitted COVariances (Sep 2016)  

      LCOV = .TRUE.
      z1   = 1. + LCVAL_STORE(IPAR_zPHOT)

      DO 170 ipar  = 1, IPAR_MAX

c Mar 10 2017 check cut on sigma/(1+z)         
         ERR_overz1 = LCERR_STORE(ipar)/z1
         LTMP  = ERR_overz1 .GE. CUTWIN_FITERRz1(1,ipar) .and.
     &           ERR_overz1 .LE. CUTWIN_FITERRz1(2,ipar)
         if ( .not. LTMP ) LCOV=.FALSE.

      DO 172 ipar2 = 1, IPAR_MAX

         xval = FITERRMAT(ipar,ipar2)
         if ( abs(xval+9.0) < 1.0E-6 ) goto 172 ! not fitted

         LTMP = xval .GE.  cutwin_fitcov(1,ipar,ipar2) .and.
     &          xval .LE.  cutwin_fitcov(2,ipar,ipar2) 
         if ( .not. LTMP ) LCOV=.FALSE.

c xxxxxxxxx
c         write(6,177) ipar,ipar2, LTMP, FITERRMAT(ipar,ipar2),
c     &       cutwin_fitcov(1,ipar,ipar2), cutwin_fitcov(2,ipar,ipar2)
177      format(' xxx COVCUT(',i2,',',i2, ')=', L2, ' for COV=',G11.3,
     &          '  [CUTWIN=', G10.2, ' to ' , G10.2,']' )
c xxxxxxxxx

172   CONTINUE
170   CONTINUE

      IF ( LCOV ) THEN
        write(CLINE,163) 'FITCOV', 'PASSES'
      ELSE
        LCUTS = .FALSE.
        write(CLINE,163) 'FITCOV', 'FAILED'
      ENDIF
      IF( LVBOSE ) print*,CLINE

c -------------------------------------------------------
c cuts for PHOTOZ fits only: Zpull 

      IF ( DOFIT_PHOTOZ ) THEN

         zpull = PHOTOZ_ERR_ZPULL
         LTMP = zpull .GE. FITWIN_ZPULL(1) .and.
     &          zpull .LE. FITWIN_ZPULL(2) 

         if ( LTMP ) then
            write(CLINE,161) 'ZPULL', zpull, 'PASSES'
         else
            write(CLINE,161) 'ZPULL', zpull, 'FAILED'
            LCUTS = .FALSE.
         endif
         IF( LVBOSE ) print*,CLINE

      ENDIF
 
c -------------
c Cut on fit prob

      xval = LCPROBCHI2_STORE(1)
      LTMP = xval .GE.  fitwin_prob(1) .and.
     &       xval .LE.  fitwin_prob(2) 

      if ( LTMP ) then
         write(CLINE,161) 'FITPROB', xval, 'PASSES'
      else
         write(CLINE,161) 'FITPROB', xval, 'FAILED'         
         LCUTS = .FALSE.
      endif      
      IF( LVBOSE ) print*,CLINE

c Cut on sigma-chi2

      xval = FITCHI2_STORE(4)
      LTMP = xval .GE. FITWIN_CHI2SIGMA(1) .and.
     &       xval .LE. FITWIN_CHI2SIGMA(2) 


      IF ( DOCHI2_SIGMA .and. .NOT. LTMP ) THEN
         write(CLINE,161) 'CHI2(SIGMA)', xval, 'FAILED'
         LCUTS = .FALSE.
      ELSE
         write(CLINE,161) 'CHI2(SIGMA)', xval, 'PASSES'
      ENDIF
      IF( LVBOSE ) print*,CLINE
c -------------
c 7/13/2008 - cut on number of passbands passing SNR

      xval = float(NFILT_SNRMAX_FIT)
      LTMP = xval .GE. CUTWIN_NFILT_SNRMAX(1)

      if ( LTMP ) then
         write(CLINE,162) 'NFILT_SNRMAX', int(xval), 'PASSES'
      else
         write(CLINE,162) 'NFILT_SNRMAX', int(xval), 'FAILED'
         LCUTS = .FALSE.
      endif
      IF( LVBOSE ) print*,CLINE


c May 25, 2009 - cut on number of passbands passing 2nd SNR

      xval = float(NFILT_SNRMAX2_FIT)
      LTMP = xval .GE. CUTWIN_NFILT_SNRMAX2(1)

      if ( LTMP ) then
         write(CLINE,162) 'NFILT_SNRMAX2', int(xval), 'PASSES'
      else
         write(CLINE,162) 'NFILT_SNRMAX2', int(xval), 'FAILED'
         LCUTS = .FALSE.
      endif
      IF( LVBOSE ) print*,CLINE

c cut on Nfilt passing Trestmin & Trestmin

      xval = float(NFILT_TRESTMIN_FIT)
      LTMP = xval .GE. CUTWIN_NFILT_TRESTMIN(1)

      if ( LTMP ) then
         write(CLINE,162) 'NFILT_TRESTMIN', int(xval), 'PASSES'
      else
         write(CLINE,162) 'NFILT_TRESTMIN', int(xval), 'FAILED'
         LCUTS = .FALSE.
      endif
      IF( LVBOSE ) print*,CLINE

      xval = float(NFILT_TRESTMAX_FIT)
      LTMP = xval .GE. CUTWIN_NFILT_TRESTMAX(1)

      if ( LTMP ) then
         write(CLINE,162) 'NFILT_TRESTMAX', int(xval), 'PASSES'
      else
         write(CLINE,162) 'NFILT_TRESTMAX', int(xval), 'FAILED'
         LCUTS = .FALSE.
      endif
      IF( LVBOSE ) print*,CLINE

c -----------------------------------------------
c Allow only 1 of the errors to fail MINOS errors;
c 2 or more parabolic or BAD => skip

      MXERRBAD = 99   ! allow all bad errors 
      IF ( MINOS_ERR_REQALL1 ) THEN
         MXERRBAD = 1    ! allow up to 1 bad error
      ENDIF
      IF ( MINOS_ERR_REQALL0 ) THEN
         MXERRBAD = 0    ! allow 0 bad errors
      ENDIF

c count bad-errors => number of fitpars with invalid MINOS error
c (these errors are either parabolic or crazy-valued)

      NFITPAR(0) = (NFITPAR_MN - NFIXPAR) 
      NERROK     = NERRTYPE(ERRTYPE_MINOS) 
      NERRBAD    = NFITPAR(0) - NERROK

      IF ( NERRBAD .LE. MXERRBAD   ) THEN
         write(CLINE,165) 'PASSES'
      ELSE
         write(CLINE,165) 'FAILED'
         LCUTS = .FALSE.
      ENDIF
      IF( LVBOSE ) print*,CLINE

165   format(T12, 'MINOS ERROR EVALUATIONS   ', A, ' CUT. ' )

c ----------------------------------------------
c require that DLMAG has MINOS-error (if requested)

      IF ( MINOS_ERR_DLMAG ) THEN
         ETYPE = ERRTYPE_STORE(IPAR_DLMAG)

         if ( ETYPE .EQ. ERRTYPE_MINOS ) then
            write(CLINE,166) 'PASSES'
         else
            write(CLINE,166) 'FAILED'
            LCUTS = .FALSE.
         endif
         IF( LVBOSE ) print*,CLINE

166      format(T12, 'VALID MINOS ERR FOR DLMAG ', A, ' CUT. ' )
      ENDIF

c ===================

      IF ( LCUTS ) THEN
         write(6,801) CCID(1:LCID)
 801     format(T5,'CID ',A,'  PASSES FIT-CUTS ' ,/ )
      ELSE
         write(6,901) CCID(1:LCID)
 901     format(T5,'CID ',A,'  FAILED FIT-CUTS => SKIP ', / )
      ENDIF

      CALL FLUSH(6)

      RETURN
      END
C ===================================================
+DECK,FANA_STORE.
      SUBROUTINE FITANA_STORE()
c
c store info in  FITVAL_STORE and FITERR_STORE arrays.
c These arrays are used for generic plotting in HFFITRES.
c
c Jul 24, 2009: move fillig of hid=1 to PLOT_FITRES
c
c Aug 16, 2009: call GET_TRESTVAR to re-evaluate Trest-related variables.
c
c Aug 22, 2009: fix delmu calc to use Zspec for photoz fits & to use
c               DLMAG8_REF function
c
c Aug 25, 2009: fix DELMU for SALT2: convert x0 into MU
c Aug 12, 2010: use mB to compute MU for SALT2 
c                 (instead of 30-2.5log10(x0))
c
c Dec 02, 2011: fill SNRMAX_SORT_FIT to get sorted SNRMAX among fitted filters
c Feb 11, 2012: fill FITRESTMAG arrays
c
c Dec 21, 2012: fix NaN computing DELMU when REDSHIFT = -9
c
c Feb 20 2017: refactor using new calls to SET_FITANA_STORE;
c              accomodates SNTABLE_FILTER_REMAP option.
c
c --------------------------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FITRESTCOM. 
+CDE,TABLEVARCOM.

c local var

      INTEGER 
     &   IFILT, IFILT_OBS, IFILT_RST, ifitdata, iep, ipar, NPAR, i
     &  ,IERR, NTLIST,  NFILT, NFADD, isort
     &  ,FLIST(MXEPOCH)
     &  ,MODE, ORDER, NSORT, INDEX_SORT(MXFILT_OBS)  ! SORTZV args
     &  ,MASK_STORE_VAL, MASK_STORE_ERR, MASK_STORE_SUM

      REAL 
     &    TLIST(MXEPOCH), XEPOCH_FIT(MXFILT_ALL)
     &   ,Tobs, Trest, MJD, PEAKMJD, z1
     &   ,MAGVAL, MAGERR, PROB_MAGDIF(2)

      REAL*8 
     &   Z8, MU8REF, MU8FIT, MU8
     &  ,x08, x18, c8, S2a8, S2b8, mb8

      LOGICAL USE, LNON

c function
      REAL   LCPROBCHI2
      REAL*8 DLMAG8_REF, SALT2mBcalc

      EXTERNAL SORTFLOAT

C -------------------- BEGIN ---------------

      CALL FLUSH(6)

      NFITPAR(0) = (NFITPAR_MN - NFIXPAR) 

      DO ifilt           = 0, MXFILT_OBS
         if ( ifilt > 0 ) then
            NFITPAR(ifilt)  = 0
            XEPOCH_FIT(ifilt) = FLOAT( NEPOCH_FIT(ifilt) ) 
         endif
         NFITDOF(ifilt)  = NEPOCH_FIT(ifilt) 
     &                   - NFITPAR(ifilt)
         XNFITDOF(ifilt)   = float ( NFITDOF(ifilt) )
      END DO

c re-evaluate Trest-related variables

C set global redshift variable & local peakmjd
      REDSHIFT_FIT = LCVAL_STORE(IPAR_zPHOT)
      z1 = 1. + REDSHIFT_FIT

      PEAKMJD      = LCVAL_STORE(IPAR_PEAKMJD)

c loop over epochs used in fit: rejected epochs are excluded here. 
 
      NTLIST = 0 
      DO 100 ifitdata = 1, NFITDATA 
          iep       = EPLIST_FIT(ifitdata)
          MJD       = SNLC8_MJD(iep)
          Tobs      = MJD - (PEAKMJD + MJDOFF)
          Trest     = Tobs / z1
          NTLIST    = NTLIST + 1 
          TLIST(NTLIST) = Trest  
          FLIST(NTLIST) = I4EP_ALL(iep,IEP_IFILT_OBS)
100   CONTINUE 

      CALL GET_TRESTVAR (
     &        NTLIST, TLIST, FLIST              ! (I) Trest & IFILT arrays
     &       ,FITANA_CUTWIN_TREST               ! (I) user cutwin
     &       ,FITANA_CUTWIN_TRESTMIN            ! (I) idem 
     &       ,FITANA_CUTWIN_TRESTMAX            ! (I) idem
     &       ,FITANA_CUTWIN_TREST2              ! (I) idem
     &       ,NFILT                             ! (O) Nfilt 
     &       ,TRESTMIN_FIT, TRESTMAX_FIT        ! (O) Trestmin,max after fit
     &       ,NFILT_TRESTMIN_FIT                ! (O)
     &       ,NFILT_TRESTMAX_FIT                ! (O)
     &       ,NFILT_TREST2_FIT                  ! (O)
     &       ,TGAPMAX_FIT, T0GAPMAX_FIT )       ! (O) 

      TRESTRANGE_FIT = TRESTMAX_FIT - TRESTMIN_FIT
      TOBSMIN_FIT = TRESTMIN_FIT * z1
      TOBSMAX_FIT = TRESTMAX_FIT * z1

c -------------------------------------------------
c get peakmags in obs and rest frames.
c Make sure to get ALL of the rest-frame filters,
c even if there is no obs filter than maps on

      if ( LTRACE ) CALL DMPTRACE("CALLING PEAKMAG_CALC(OBS)")

      DO 551 IFILT = 1, NFILTDEF_SURVEY      
        ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
        USE  = USE_FILT(ifilt_obs)
        if ( USE ) then
           CALL PEAKMAG_CALC(ifilt_obs, 'OBS') 
        endif
551   CONTINUE


      IF ( LREST_FITMODEL ) THEN
         if ( LTRACE ) CALL DMPTRACE("CALLING PEAKMAG_CALC(REST)")
         DO 552 IFILT = 1, NFILTDEF_REST
           IFILT_RST  = IFILTDEF_MAP_REST(ifilt)
           CALL PEAKMAG_CALC(ifilt_rst, 'REST')
552     CONTINUE
      ENDIF


c compute number of fitted filters that pass global user-SNR cut
c This accounts for fudged errors so that deweighted passbands
c are not counted in NFILT_SNRMAX_FIT.

      NFILT_SNRMAX_FIT  = 0
      NFILT_SNRMAX2_FIT = 0
      DO ifilt = 1, NFILTDEF_SURVEY
        if ( R4BAND_SNRMAX_FIT(ifilt) > CUTWIN_SNRMAX(1) ) then
           NFILT_SNRMAX_FIT = NFILT_SNRMAX_FIT + 1
        endif
        if ( R4BAND_SNRMAX_FIT(ifilt) > CUTWIN_SNRMAX2(1) ) then
           NFILT_SNRMAX2_FIT = NFILT_SNRMAX2_FIT + 1
        endif
      ENDDO

c fill SNRMAX_SORT_FIT to get sorted SNRMAX for fitted bands.


      ORDER =  -1  ! -1, 0 descending,increasing order
      CALL SORTFLOAT( NFILTDEF_SURVEY, R4BAND_SNRMAX_FIT, ORDER, 
     &                 INDEX_SORT);


      DO isort  = 1, NFILTDEF_SURVEY
         ifilt  = INDEX_SORT(isort)
         SNRMAX_SORT_FIT(isort) = R4BAND_SNRMAX_FIT(ifilt)  ! for CWNT
         SNRMAX_FILT_FIT(ifilt) = R4BAND_SNRMAX_FIT(ifilt)  ! for CWNT
      ENDDO

c -----------------------------------------------
c store extra info in FITVAL_STORE array so that
c all gets plotted the same way as fit-parameters.

      if ( LTRACE ) CALL DMPTRACE("START 555 LOOP in FITANA_STORE")

      NPAR = PARPTR_CHI2

c store global fit parameters: Ndof, chi2 and prob(chi2)
c Note index here is NPAR instead of ipar

      NPAR = NPAR + 1  ! Ndof
      FITVAL_STORE(NPAR) = XNFITDOF(0)
      LCVAL_STORE(NPAR)  = XNFITDOF(0)

      NPAR = NPAR + 1  ! reject epochs withing Trest range (Mar 2020)
      FITVAL_STORE(NPAR) = FLOAT(NEPOCH_REJECT2)
      LCVAL_STORE(NPAR)  = FLOAT(NEPOCH_REJECT2)

      NPAR = NPAR + 1         ! chi2
      FITVAL_STORE(NPAR) = FITCHI2_STORE(1)
      LCVAL_STORE(NPAR)  = LCCHI2_STORE(1) ! Total chi2

      NPAR = NPAR + 1             ! prior-chi2
      FITVAL_STORE(NPAR) = FITCHI2_STORE(3)
      LCVAL_STORE(NPAR)  = LCCHI2_STORE(3)

      NPAR = NPAR + 1             ! sigma-chi2
      FITVAL_STORE(NPAR) = FITCHI2_STORE(4)
      LCVAL_STORE(NPAR)  = LCCHI2_STORE(4)

      IF ( LSIM_SNANA ) THEN
        NPAR = NPAR + 1             ! SIM chi2 (Dec 2013)
        FITVAL_STORE(NPAR) = SIMCHI2_CHEAT
        LCVAL_STORE(NPAR)  = SIMCHI2_CHEAT
      ENDIF

c now the fit-probs ...

      NPAR = NPAR + 1  ! prob(chi2) including prior, before marginal.
      FITVAL_STORE(NPAR) = FITPROBCHI2_STORE(1)
      LCVAL_STORE(NPAR)  = FITPROBCHI2_STORE(1) 

      NPAR = NPAR + 1  ! final prob(chi2) including prior, after marg.
      FITVAL_STORE(NPAR) = FITPROBCHI2_STORE(1) ! from fit, before marg
      LCVAL_STORE(NPAR)  = LCPROBCHI2_STORE(1)  ! after marg.

      NPAR = NPAR + 1  ! prob(chi2) excluding prior
      FITVAL_STORE(NPAR) = FITPROBCHI2_STORE(2)  
      LCVAL_STORE(NPAR)  = LCPROBCHI2_STORE(2)

c --------------------------------------

c set store-masks. first number refers to storing VAL or error.
c Second number is to take average(4) or sum(8) for REMAPed filters.
      MASK_STORE_VAL = 1 + 4   ! VAL,AVG
      MASK_STORE_ERR = 2 + 4   ! ERR,AVG
      MASK_STORE_SUM = 1 + 8   ! VAL,SUM

      DO 555 i = 1, NFILTOBS_TABLE

        ifilt_obs  = IFILTOBS_MAP_TABLE(i)
        ifilt      = IFILT_MAP_TABLE(i)

        if ( NFILT_REMAP_TABLE == 0 ) then
          if ( .not. USE_FILT(ifilt_obs) ) goto 555
          CALL FPKRAT(ifilt_obs)  ! flux/peakFlux in rest-frame
        endif

        NFADD = 0
        ipar = NPAR + NFADD*NFILTOBS_TABLE + i
        CALL SET_FITANA_STORE(ipar, MASK_STORE_VAL, ifilt,
     &                        PEAKMAG_OBS_MODEL)
        CALL SET_FITANA_STORE(ipar, MASK_STORE_ERR, ifilt,
     &                        PEAKMAG_OBS_MODEL_ERR)

        NFADD = NFADD + 1
        ipar = NPAR + NFADD*NFILTOBS_TABLE + i
        CALL SET_FITANA_STORE(ipar, MASK_STORE_VAL, ifilt,
     &                        PEAKMAG_OBS_MODEL_ERR)

        NFADD = NFADD + 1
        ipar = NPAR + NFADD*NFILTOBS_TABLE + i
        CALL SET_FITANA_STORE(ipar, MASK_STORE_VAL, ifilt,
     &                        PEAKFLUX_OBS_MODEL )
        CALL SET_FITANA_STORE(ipar, MASK_STORE_ERR, ifilt,
     &                        PEAKFLUX_OBS_MODEL_ERR )

        if ( NFILTOBS_TABLE .GT. 20 ) GOTO 555

        NFADD = NFADD + 1
        ipar = NPAR + NFADD*NFILTOBS_TABLE + i
        CALL SET_FITANA_STORE(ipar, MASK_STORE_VAL, ifilt,
     &                        PEAKFLUX_OBS_MODEL_ERR )

        NFADD = NFADD + 1
        ipar = NPAR + NFADD*NFILTOBS_TABLE + i
        CALL SET_FITANA_STORE(ipar, MASK_STORE_SUM, ifilt,
     &                        XEPOCH_FIT )

        NFADD = NFADD + 1
        ipar = NPAR + NFADD*NFILTOBS_TABLE + i
        CALL SET_FITANA_STORE(ipar, MASK_STORE_SUM, ifilt,
     &                        LC_FITCHI2 )  ! wrong for LCVAL ???

        NFADD = NFADD + 1
        ipar = NPAR + NFADD*NFILTOBS_TABLE + i
        CALL SET_FITANA_STORE(ipar, MASK_STORE_VAL, ifilt,
     &                        LC_FITPROB )  ! wrong for MARGPROB ???

555   CONTINUE

c now load rest-frame peakmags; use pointer to find IPAR.
c Note that number of rest-frame filters could be more
c than the number of obs-frame filters.

      IF ( LREST_FITMODEL ) THEN
        do ifilt    = 1, NFILTDEF_REST
          ifilt_rst = IFILTDEF_MAP_REST(ifilt)
          ipar      = PARPTR_IFILT_REST(ifilt_rst)
          FITVAL_STORE(ipar) = PEAKMAG_REST_MODEL(ifilt_rst)
          FITERR_STORE(ipar) = PEAKMAG_REST_MODEL_ERR(ifilt_rst)
          LCVAL_STORE(ipar)  = PEAKMAG_REST_MODEL(ifilt_rst)
          LCERR_STORE(ipar)  = PEAKMAG_REST_MODEL_ERR(ifilt_rst)
        enddo
      ENDIF

c Feb 2012: optional things to store for special fits
      NPAR = PARPTR_FITRESTMAG

      IPAROFF_FITRESTMAG    = NPAR
      DO ifilt    = 1, NFILTDEF_FITRESTMAG
         CALL GET_FITRESTMAG(ifilt, MAGVAL, MAGERR) ! return magdif and its err

         NPAR     = NPAR + 1
         FITVAL_STORE(Npar) = MAGVAL
         LCVAL_STORE(Npar)  = MAGVAL

         NPAR     = NPAR + 1
         FITVAL_STORE(Npar) = MAGERR
         LCVAL_STORE(Npar)  = MAGERR
      ENDDO


      IF ( FILTER_FITMAGDIF .NE. '' ) THEN

         CALL GET_FITMAGDIF(MAGVAL, MAGERR, PROB_MAGDIF) 

         NPAR   = NPAR + 1
         FITVAL_STORE(Npar) = MAGVAL 
         LCVAL_STORE(Npar)  = MAGVAL
         FITERR_STORE(Npar) = MAGERR
         LCERR_STORE(Npar)  = MAGERR

         NPAR   = NPAR + 1
         FITVAL_STORE(Npar) = MAGERR
         LCVAL_STORE(Npar)  = MAGERR

         NPAR   = NPAR + 1
         FITVAL_STORE(Npar) = PROB_MAGDIF(1)  ! FITPROB, 1 filter
         LCVAL_STORE(Npar)  = PROB_MAGDIF(1)  ! FITPROB, 1 filter

         NPAR   = NPAR + 1
         FITVAL_STORE(Npar) = PROB_MAGDIF(2) ! FITPROB, other filters
         LCVAL_STORE(Npar)  = PROB_MAGDIF(2) ! FITPROB, other filters
      ENDIF


      if ( LTRACE ) CALL DMPTRACE("FINISHED 555 LOOP in FITANA_STORE")

      
c store delZ = zfit - zspec
      NPAR = NPAR + 1 
        FITVAL_STORE(NPAR) = FITVAL_STORE(IPAR_zPHOT)
     &                     - SNLC_REDSHIFT
        FITERR_STORE(NPAR) = FITERR_STORE(IPAR_zPHOT)

        LCVAL_STORE(NPAR) = LCVAL_STORE(IPAR_zPHOT)
     &                    - SNLC_REDSHIFT
        LCERR_STORE(NPAR) = LCERR_STORE(IPAR_zPHOT)

c store DELMU = MU(fit) - MU(Zspec)
c If REDSHIFT < 0 (undefined) then use photoz

      NPAR = NPAR + 1          
        Z8  = FITVAL_STORE(IPAR_zPHOT)  ! Zspec or Zphot
        MU8REF = DLMAG8_REF(Z8)

        IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN      
           x08  = FITVAL_STORE(IPAR_X0) 
           mb8  = SALT2mbcalc(x08)
           x18  = FITVAL_STORE(IPAR_SHAPE)
           c8   = FITVAL_STORE(IPAR_COLOR)
           S2a8 = DBLE(SALT2alpha)
           S2b8 = DBLE(SALT2beta)

           MU8FIT = mb8 + S2a8*x18 - S2b8*c8 + 19.36
           MU8    = MU8FIT
        ELSE
           MU8FIT = FITVAL_STORE(IPAR_DLMAG) ! fitted MU
           MU8    = LCVAL_STORE(IPAR_DLMAG)  ! might be marginalized 
        ENDIF

        FITVAL_STORE(NPAR) = MU8FIT - MU8REF
        FITERR_STORE(NPAR) = FITERR_STORE(IPAR_DLMAG)

        LCVAL_STORE(NPAR) = MU8 - MU8REF
        LCERR_STORE(NPAR) = LCERR_STORE(IPAR_DLMAG)

c store delzph for photoz fits.
c Make sure to always increment NPAR.

      NPAR = NPAR + 1
      if ( DOFIT_PHOTOZ ) THEN  
        CALL PHOTOZ_STORE(NPAR)
      ENDIF
 
c store SALT2 mB in IPAR_MB index .. 
c do NOT increment NPAR here
      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN
        CALL SALT2_STORE()
      ENDIF


      IF ( NPAR .NE. NPLOTPAR ) THEN
        write(c1err,662) NPAR
662     format('Filled NPAR = ', I3, ' variables ' )

        write(c2err,663) NPLOTPAR
663     format('but expected NPLOTPAR = ', I4 )
        CALL MADABORT ( "FITANA_STORE", c1err, c2err )
      ENDIF 

      RETURN
      END        ! end of FITANA_STORE

C =============================
+DECK,SET_FITANA_STORE.
      SUBROUTINE  SET_FITANA_STORE(IPAR,MASK_STORE, IFILT, ARRAY)

c Created Feb 2017
c
c Copy element of ARRAY into either FITVAL_STORE or FITERR_STORE,
c which are used to fill the SNTABLE.
c
c For nominal jobs, load ARRAY(ifilt) into FITVAL[ERR]_STORE[IPAR].
c But for FILTER_REMAP_TABLE, then figure out which original 
c filters correspond to REMAPed IFILT.
c
      IMPLICIT NONE

c function inputs
      INTEGER 
     &   IPAR        ! index to store for FITVAL_STORE and FITERR_STORE   
     &  ,MASK_STORE  ! mask to store VAL or ERR array, and to take avg or sum
     &  ,IFILT       ! sparse IFILT or IFILTOBS, depending on OPT_IFILT
     
      REAL ARRAY(*) ! array to copy into storage

c local variables

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.

c +CDE,FITRESTCOM. 
c +CDE,TABLEVARCOM.

      LOGICAL LOADVAL, LOADERR, DO_AVG, DO_SUM
      REAL    VAL_STORE
      INTEGER IFILTOBS_ORIG, IFILTOBS_REMAP, IFILT_REMAP
      INTEGER IFILTOBS, IFILT_ORIG, IFILT_REMAP_TMP, NFILT_STORE

C ---------- BEGIN -------------

c parse MASK_STORE bits
      LOADVAL = BTEST(MASK_STORE,0)  ! 1
      LOADERR = BTEST(MASK_STORE,1)  ! 2
      DO_AVG  = BTEST(MASK_STORE,2)  ! 4 --> for REMAP filters only
      DO_SUM  = BTEST(MASK_STORE,3)  ! 8 --> for REMAP filters only

      IF ( NFILT_REMAP_TABLE == 0 ) THEN
         VAL_STORE = ARRAY(IFILT)
         GOTO 500
      ENDIF

c -----------------------------------------------------
c if we get here, then figure out the FILTER-REMAP

      IFILT_REMAP = IFILT  

c loop over original filters to see which one(s)
c were remapped onto IFILT_REMAP

      VAL_STORE = 0.0 ;  NFILT_STORE=0
      DO 100 ifilt_orig = 1, NFILTDEF_SURVEY

          IFILTOBS_ORIG = IFILTDEF_MAP_SURVEY(IFILT_ORIG)

          if ( .not. USE_FILT(ifiltobs_orig) ) goto 100

          CALL FILTER_REMAP_FETCH(IFILTOBS_ORIG,        ! (I)
     &              IFILTOBS_REMAP, IFILT_REMAP_TMP)    ! (O)

          IFILT_REMAP_TMP = IFILT_REMAP_TMP + 1 ! C -> fortran index
          IF ( IFILT_REMAP .EQ. IFILT_REMAP_TMP ) THEN
             VAL_STORE     = VAL_STORE + ARRAY(IFILT_ORIG)
             NFILT_STORE   = NFILT_STORE + 1

c xxxxxxxxxxxxxxxxxxx
c        write(6,66) IFILT_ORIG, IFILTOBS_ORIG, IFILTOBS_REMAP,
c     &             IFILT_REMAP_TMP, ARRAY(IFILT_ORIG)
c66      format(T2,'xxx IFILT_ORIG=',I2,2x,
c     &          'IFILTOBS[ORIG,REMAP]=',2I3,' IFILT_REMAP_TMP=',I2,
c     &          '  ARRAY=',F10.2 )
c xxxxxxxxxxxxxxxxxxx

          ENDIF
100   CONTINUE

      IF ( NFILT_STORE > 0 ) THEN
         IF ( DO_AVG ) THEN
           VAL_STORE = VAL_STORE / FLOAT(NFILT_STORE)
         ENDIF
      ELSE
         VAL_STORE = -9.0
      ENDIF

c ---------------
500   CONTINUE
      IF ( LOADVAL ) then
        FITVAL_STORE(IPAR) = VAL_STORE
        LCVAL_STORE(IPAR)  = VAL_STORE
      ELSE
        FITERR_STORE(IPAR) = VAL_STORE
        LCERR_STORE(IPAR)  = VAL_STORE
      ENDIF   

      RETURN
      END       ! end SET_FITANA_STORE

C ==================================
+DECK,FITERR_ADJUST.
      SUBROUTINE FITERR_ADJUST()
c
c  Created Apr 25, 2007 by R.Kessler
c
c  If MINOS returns rediculously tiny errors,
c  then set error to a reasonable artificial error.
c  This is needed for the marginalization to work
c  properly.
c
c  Feb 7, 2008: 
c    - set FITERR(IPAR) in addition to FITERR_MINUS[PLUS]
c
c    - if photoZ error is too big, trim errors
c      so that +-4 sigma does not give unphysical value
c
c Dec 16, 2011:
c   photoZ error must be at least 40% of color error.
c
c ------------------------

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,SNFITCOM.

c  local var

      REAL NSIGMA, EPLUS, EMINUS, Z1tmp, Z2tmp, RTMP, ZERR
      INTEGER IPAR, ITER
      LOGICAL LBAD

c ------------- BEGIN ------------

      ITER = NFIT_ITERATION

      IPAR = IPAR_AV
      LBAD = ERRTYPE(IPAR) .EQ. ERRTYPE_BAD 
      IF ( LBAD ) THEN
         EMINUS = 0.20
         EPLUS  = 0.20
         FITERR_MINUS(IPAR,ITER) = -EMINUS
         FITERR_PLUS(IPAR,ITER)  = +EPLUS
         FITERR_RATIO(IPAR,ITER) =  EPLUS / EMINUS
         FITERR(IPAR,ITER)       =  EPLUS
         print*,'  Reset BAD AV ERROR before MARG_DRIVER: CID=', 
     &             SNLC_CCID
      ENDIF


      IPAR = IPAR_zPHOT
      IF ( DOFIT_PHOTOZ ) THEN

c check for tiny error
         LBAD = ERRTYPE(IPAR) .EQ. ERRTYPE_BAD 
         IF ( LBAD ) THEN
           EMINUS = 0.01
           EPLUS  = 0.01
           FITERR_MINUS(IPAR,ITER) = -EMINUS
           FITERR_PLUS(IPAR,ITER)  = +EPLUS
           FITERR_RATIO(IPAR,ITER) =  EPLUS / EMINUS
           FITERR(IPAR,ITER)       =  EPLUS
           print*,'  Reset BAD PHOTOZ ERROR before MARG_DRIVER: CID=', 
     &               SNLC_CCID
         ENDIF

c check for too-big error that gives Z - 4\sigma_z < 0
         
         Z1tmp = FITVAL(ipar,ITER) 
     &         - NSIGMA_PDF * FITERR_MINUS(IPAR,ITER)
         Z2tmp = FITVAL(ipar,ITER) 
     &         + NSIGMA_PDF * FITERR_PLUS(IPAR,ITER)

         LBAD  = Z1tmp .LT. INIBND(1,IPAR)
         if ( NGRID_PDF .GT. 0 .and. LBAD ) then
           EMINUS = (FITVAL(ipar,ITER)-INIBND(1,IPAR))/NSIGMA_PDF
           EPLUS  = FITERR_PLUS(IPAR,ITER)
           FITERR_MINUS(IPAR,ITER) = -EMINUS
           FITERR_RATIO(IPAR,ITER) =  EPLUS / EMINUS
           FITERR(IPAR,ITER)       =  (EMINUS + EPLUS)/2.           
         endif

c Dec 2011: 
c check for too-tiny error. Should be at least .4 * color error
c or at least .02.

         ZERR = FITERR(IPAR,ITER)
         RTMP = ZERR/FITERR(IPAR_COLOR,ITER)
         if ( RTMP .LT. 0.4 ) then
             ZERR = 0.4 * FITERR(IPAR_COLOR,ITER)
         endif
ccc         IF ( ZERR .LT. 0.02 ) ZERR = 0.02
         FITERR(IPAR,ITER) = ZERR
  
      ENDIF

      RETURN
      END


C ======================================
+DECK,SALT2xx1.
      DOUBLE PRECISION FUNCTION SALT2xx1(ITER,x1)
c
c Created Jun  2011 by R.Kessler
c  [code moved from FCNSNLS]
c
c SALT2xx1 is the x1 value used in the SALT2  model-error 
c calculation. This value is either the same x1 value in 
c the fit (if DOCHI2_SIGMA=T) or it is fixed to the x1-value
c from the previous iteration.
c
c Aug 20, 2011
c If DOFIT_PHOTOZ is set, then DOCHI2_SIGMA is automatically set;
c in this case treat x1 as if DOCHI2_SIGMA was not set.
c
c Jul 2 2013: xx1 -> 0 (instead of 1.0) when ITER=1
c
c Aug 30 2017: use FIRST_ITERTION(ITER) instead of ITER=1 .
c              Needed for SIMFIT_IDEAL option.
c
c ---------------------
      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,SNANAFIT.
c +CDE,SNLCINP.
c +CDE,FILTCOM.


      INTEGER ITER  ! (I) fit iteration
      REAL*8  x1    ! (I) x1/stretch

c local variables
      REAL*8  xx1
      LOGICAL DOFIT_zFIX
      LOGICAL FIRST_ITERATION   ! function

c --------------- BEGIN -------------

      SALT2xx1 = -999.
      DOFIT_zFIX = (.NOT. DOFIT_PHOTOZ)

      IF ( FIRST_ITERATION(ITER)  ) then
        xx1 = 0.0    ! always fix xx1 on 1st iteration
      ELSE
         if ( DOCHI2_SIGMA .and. DOFIT_zFIX) then
             xx1 = x1
         else
             xx1 = FITVAL(IPAR_SHAPE,iter-1) ! from previous iteration
         endif
      ENDIF
    
      SALT2xx1 = xx1

      RETURN
      END    ! end SALT2xx1


C ======================================
+DECK,SALT2zz.
      DOUBLE PRECISION FUNCTION SALT2zz(ITER,z)
c
c Created Mar 2018
c
c Return redshift (zz) for SALT2 error calculation.
c Motivation is for photoz fit, fix zz = z(previous iteration),
c and use zz for SALT2 error calculation. 
c
c Mar 24 2020: fix logic using local DOFIT_zFIX; needed for FITRESTMAG.
c  
c ---------------------
      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,SNANAFIT.
c +CDE,SNLCINP.
c +CDE,FILTCOM.


      INTEGER ITER  ! (I) fit iteration
      REAL*8  z     ! (I) redshift

c local variables
      REAL*8  zz
      LOGICAL FIRST_ITER, DOFIT_zFIX
      LOGICAL FIRST_ITERATION   ! function

c --------------- BEGIN -------------

      SALT2zz = -999.
      DOFIT_zFIX = (.NOT. DOFIT_PHOTOZ)

c      FIRST_ITER = FIRST_ITERATION(ITER)  ! v10_76b and earlier
      FIRST_ITER = FIRST_ITERATION(ITER) .or. DOFIT_zFIX ! >= v10_76c

      IF ( FIRST_ITER ) then
        zz = z
      ELSE
         if ( DOCHI2_SIGMA .and. DOFIT_zFIX) then
             zz = z
         else
             zz = FITVAL(IPAR_ZPHOT,iter-1) ! from previous iteration
         endif
      ENDIF

      SALT2zz = zz

      RETURN
      END

C ========================================
+DECK,SALT2_STORE.
      SUBROUTINE SALT2_STORE()
c
c April 24, 2009 R.Kessler
c
c Compute mB* and its error, and store in parameter
c slot IPAR_MB.  Assumes same primary system for
c each survey/filter system.
c
c
c Nov 6, 2009:  mB -> mB - FILT_MAGPRIMARY(IFILT_BESS_B)
c               SALT2 mB* is now the same for Vega & BD17 primaries
c
c Jan 28, 2010: undo above after making more general fix in genmag_SALT2.
c
c Feb 09, 2010: set redshift to 10pc (see new SAVE_Z)
c
c Jul 27, 2010: z = ZAT10PC instead of 10.*Zat10pc.
c               No idea why there was a factor of 10 ... perhaps a debug ?
c
c Aug 11, 2010: huge simplification: just use SALT2mbcalc and get
c               rid of all the stuff for MODELMAB_CALC
c
c Sep 17 2016: load FITERRMAT
c Feb 16 2017: compute MBerr analytically (fix problem found by ChrisD)
c
c -----------------------------------------------------------

      IMPLICIT NONE

c subroutine args

c local var

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      REAL*8  mB, mbtmp, MBERR, x0, x0tmp, x0err

c functions
      REAL*8  SALT2mBcalc

c ----------- BEGIN ---------

      X0    = LCVAL_STORE(IPAR_X0)
      X0err = LCERR_STORE(IPAR_X0)

      MB    = SALT2mBcalc( X0 )
      MBERR = 2.5 * (X0err/X0)/log(10.0)  
c xxx      MBERR = 2.5 * (X0err/X0)/LOGTEN

c store mB and it error, and its COV


      LCVAL_STORE(IPAR_MB)  = mb
      LCERR_STORE(IPAR_MB)  = mberr
      FITERRMAT(IPAR_MB,IPAR_MB) = mberr*mberr  ! covariance

      RETURN
      END
 
C =====================================
+DECK,SETZFIT.
      SUBROUTINE SET_REDSHIFT_FIT(ITER)

c Created Aug 12, 2009 by R.Kessler
c
c Called from FITPAR_PREP to set initial REDSHIFT_FIT
c that is used to select filters & epochs.
c Most of the logic here is related to photoZ fits.
c
c ----------------------
 
      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER 
     &  iter  ! (I) fit iteration: 1,2, ... NFIT_ITERATION

      REAL Zhost

c ---------------- BEGIN ---------------

      REDSHIFT_FIT = SNLC_REDSHIFT  ! start with "best" Z

      PRIOR_PHOTOZ     = -9.0
      PRIOR_PHOTOZ_ERR = -9.0

c .xyz add option for using HOSTGAL_PHOTOZ ...

      DOFIT_PHOTOZ_HOST   =  .FALSE.
      DOFIT_PHOTOZ_noHOST =  .FALSE.
c -------------------------------
      IF ( DOFIT_PHOTOZ ) THEN

c check for host photoZ

        Zhost   =  SNHOST_ZPHOT(1)
        DOFIT_PHOTOZ_HOST = 
     &          Zhost .GT. 0.0 
     &    .and. PRIOR_ZERRSCALE .LT. 10.0

        DOFIT_PHOTOZ_noHOST = .NOT. DOFIT_PHOTOZ_HOST

c --------------------------------------------

         if ( ITER.EQ. 1 .and. DOFIT_PHOTOZ_HOST  )  then
           REDSHIFT_FIT = ZHOST
         endif

         if ( ITER.EQ. 1 .and. DOFIT_PHOTOZ_noHOST  )  then
c leave best Z  above ; note that initial photoZ gets modified
c in FITINI_PHOTOZ before the fit starts.
         endif

c use fitted photoZ (from 1st iteration) on 2nd iteration,
c or if 1st iteration is repeated.

         IF ( iter .GT. 1 .or. LREPEAT_ITER ) THEN
           REDSHIFT_FIT = LCVAL_STORE(IPAR_zPHOT)
         ENDIF

      ENDIF

c - - - - - - -  -

      if ( LSIM_SNANA .and. USESIM_REDSHIFT ) then
        REDSHIFT_FIT = SIM_REDSHIFT_HELIO
      endif

c xxxxxxxxxxxxxxxxxxxxx
c      write(6,61) iter, REDSHIFT_FIT, DOFIT_PHOTOZ_HOST
c61    format(' xxx iter=',I2,'  zFIT=',F8.4,'  DO_PHOTOZ_HOST=',L1)
c      call flush(6)
c xxxxxxxxxxxxxxxxxxxxx

      RETURN
      END   ! end SET_REDSHIFT_FIT

C ========================================
+DECK,PHZSTORE.
      SUBROUTINE PHOTOZ_STORE(NPAR)
c
c Store PHOTOZ-related variables
c
      IMPLICIT NONE

      INTEGER  NPAR   ! (I) storage index

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

c local var

      REAL 
     &   zfit,  zfiterr
     &  ,zhost, zhosterr
     &  ,zmagerr
     &  ,zdif, zerr, zpull, Z1
     &  ,TCOR

      INTEGER NFTMIN, NFTMAX

      REAL*8  MU8(2), Z8(2), DZ8, DZDMU, MUREF

      character CZPRIOR*6

c functions

      REAL*8  DLMAG8_REF

C ------------ BEGIN -----------

      if ( LTRACE ) CALL DMPTRACE("BEGIN PHOTOZ_STORE" )

c extract fit photoZ and determine total error.

      zfit    = LCVAL_STORE(IPAR_zPHOT) 
      zfiterr = LCERR_STORE(IPAR_zPHOT) 
         
      if ( BTEST(OPT_PHOTOZ,BIT_PHOTOZ_GAUSS) ) then 
        zhost    =  SNHOST_ZPHOT(1)
        zhosterr =  SNHOST_ZPHOT_ERR(1)
        czprior  = 'SNGAL'   ! for screen dump comment

      else if ( BTEST(OPT_PHOTOZ,BIT_BESTZ_GAUSS) ) then
        zhost    = SNLC_REDSHIFT     ! for testing only
        zhosterr = SNLC_REDSHIFT_ERR
        czprior  = 'SPECZ'   ! for screen dump comment
      endif

c scale the error by user-scale:
      zhosterr = zhosterr * PRIOR_ZERRSCALE
      if ( zhost < 0.0 .or. Zhosterr < 0.0 .or. 
     &     DOFIT_PHOTOZ_noHOST) then
         zhost    = zfit
         zhosterr = 0.0
      endif

c ---------------------
c Compute photoZ-error from intrinsic MAG-dispersion.

      DZ8   = 0.01
      Z8(1) = dble(Zfit)
      Z8(2) = Z8(1) + dZ8

      MU8(1) = DLMAG8_REF(Z8(1))
      MU8(2) = DLMAG8_REF(Z8(2))
      MUREF  = MU8(1)

      DZDMU = ( Z8(2) - Z8(1) ) / ( MU8(1) - MU8(2) )  ! local derivative

      zmagerr = SNMAGRMS_for_PHOTOZ * abs(DZDMU)

c -------
      zdif  = zfit - zhost
      zerr  = sqrt ( zfiterr**2 + zhosterr**2 + zmagerr**2)
      zerr  = max(zerr,0.00001)  ! avoid Zpull divide-by-zero
      zpull = zdif / zerr
 
      LCVAL_STORE(Npar) = zdif
      LCERR_STORE(Npar) = zerr
      ISTORE_ZPULL          = NPAR    ! store this index for later

c store errors in common block

      PHOTOZ_ERR_SNFIT  = zfiterr
      PHOTOZ_ERR_SNHOST = zhosterr
      PHOTOZ_ERR_SNMAG  = zmagerr
      PHOTOZ_ERR_ZPULL  = zpull

c ----------------------------------------------
c print PHOTOZ info

      IF ( STDOUT_UPDATE ) THEN
        write(6,20) SNLC_CID, ZFIT
     &   , PHOTOZ_ERR_SNFIT
     &   , PHOTOZ_ERR_SNMAG

        write(6,30) SNLC_CID, CZPRIOR, ZHOST
     &   , PHOTOZ_ERR_SNHOST
     &   , PHOTOZ_ERR_ZPULL
      ENDIF

20    format(T8,'CID',I8,' PHOTOZ(SNFIT) = ', F6.4
     &         , ' +- ',F5.4,'(stat)'
     &         , ' +- ',F5.4,'(snmag)'  )

30    format(T8,'CID',I8,' ZPRIOR(',A,') = ', F6.4
     &         , ' +- ',F5.4, 5x,'ZPULL=',F6.2 )

      if ( LTRACE ) CALL DMPTRACE("END PHOTOZ_STORE")

c -----------
c for photoZ fit, MU is fixed to initial photoZ.
c Here we change the 'fixed' DLMAG parameter to correspond
c to the final (fitted) photoZ. This is just for internal
c consistency and it does not affect the fit or analysis
c in any way.

      IF ( DOFIT_PHOTOZ .and. INISTP_DLMAG .EQ. 0.0 ) THEN 
         LCVAL_STORE(IPAR_DLMAG) = MUREF
      ENDIF

      RETURN
      END

C ===================================================
+DECK,FANA_SUMMARY.
      SUBROUTINE FITANA_SUMMARY ( isn )
c
c print summary of fit vs. filter.
c
c
c Apr 26, 2007: print marginalized chi2
c
c Mar 12, 2008: write SIMEFF(z,AV,DELTA) at end.
c
c Jul 14, 2008: define IFMINsp & IFMAXsp, and fix 
c               ifilt-ranges for some write statements.
c
c Dec 15, 2008: print correct EP_XTMW instead of SNLC_XTINCMAG_MW ;
c               latter is for SDSS galaxy and is usually zero;
c               EP_XTMW is for SN.
c
c Feb 16, 2009: 'quantity' printouts account for non-sequential filters
c Apr 24, 2009: write mB +- mBerr for SALT2 model
c
c May 8, 2009: CCHI2(3) -> CCHI2(4) to include CHI2 from ln(sigma)
c
c Jul 17, 2009: add RV8 to call to SNLC_SIMEFF
c
c Jul 25, 2011: replace SNLC_SIMEFF() with SNLC_FIT_SIMEFF()
c
c Jun 27, 2013: bail when ISN > 1000
c
c --------------------------------------------------

      IMPLICIT NONE

      INTEGER isn ! (I)  sn index

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
c +CDE,SNLCINP.
+CDE,SNFITCOM.
+CDE,FILTCOM.

c local var 

      REAL 
     &   TCOR
     &  ,RTMP(MXFILT_ALL,10)

      INTEGER 
     &   ifilt, kk, i, ipar
     &  ,ifilt_obs
     &  ,NFILT, NFTMP
     &  ,IERR
     &  ,ITMP(MXFILT_ALL,10)
     &  ,NTMP

      CHARACTER 
     &   BANNER*60
     &  ,CCID*(MXCHAR_CCID)
     &  ,CCHI2(4)*8
     &  ,CFILT(MXFILT_ALL)*1

      REAL*8  EFF8, LCVAL8(MXFITPAR)

      DATA  CCHI2 / 'TOTAL' , 'DATA', 'PRIOR', 'SIGMA' /
      
c function
      REAL*8 SNLC_FIT_SIMEFF

C ------------------- BEGIN -----------------

      IF ( ISN > NFIT_VERBOSE ) RETURN  ! Jun 2013: avoid HUGE log files.

      CCID = SNLC_CCID
      KK   = ISNLC_LENCCID

      write(BANNER,20) CCID(1:KK)
20    format('LC FIT SUMMARY for CID=', A )

      CALL PRBANNER ( BANNER )

c create sparse arrays for printing results-vs-filter on one line.

      NFILT = 0
      DO 444 ifilt   = 1, NFILTDEF_SURVEY
        IFILT_OBS    = IFILTDEF_MAP_SURVEY(ifilt)
 
        if ( .NOT. USE_FILT(ifilt_obs) ) goto 444

        NFILT = NFILT + 1 
        CFILT(Nfilt)  = filtdef_string(ifilt_obs:ifilt_obs)
        ITMP(Nfilt,1) = NEPOCH_ALL(ifilt)
        ITMP(Nfilt,2) = NEPOCH_REJECT(ifilt)
        ITMP(Nfilt,3) = NFITDOF(ifilt)

        RTMP(Nfilt,1) = LC_MARGCHI2(ifilt)
        RTMP(Nfilt,2) = LC_MARGPROB(ifilt)
        RTMP(Nfilt,3) = PEAKMAG_OBS_MODEL(ifilt)
        RTMP(Nfilt,4) = PEAKMAG_OBS_MODEL_ERR(ifilt)
        RTMP(Nfilt,5) = SNLC_MWXT_MAG(ifilt)
        RTMP(Nfilt,6) = SNLC_MWXT_MAGERR(ifilt)

444   CONTINUE

c print no more than 6 filters to avoid a messsy output
      NFTMP = MIN(NFILT,6) 

      write(6,700) 'Quantity', (CFILT(ifilt), ifilt = 1, NFTMP )
      write(6,799)
      write(6,706) 'NEPOCH',  (ITMP(ifilt,1),ifilt=1, NFTMP)
      write(6,706) 'NREJECT', (ITMP(ifilt,2),ifilt=1, NFTMP)
      write(6,706) 'NDOF',    (ITMP(ifilt,3),ifilt=1, NFTMP)

      write(6,725) 'CHI2',    (RTMP(ifilt,1), ifilt=1,NFTMP) 
      write(6,725) 'PROB',    (RTMP(ifilt,2), ifilt=1,NFTMP) 
      write(6,725) 'PeakMag', (RTMP(ifilt,3), ifilt=1,NFTMP) 
      write(6,725) 'PeakErr', (RTMP(ifilt,4), ifilt=1,NFTMP) 
      write(6,725) 'XTMW',    (RTMP(ifilt,5), ifilt=1,NFTMP) 
      write(6,725) 'XTMWerr', (RTMP(ifilt,6), ifilt=1,NFTMP) 

700   format(T2, A,  6(10x,A)  )
706   format(T2, A8, 6(I11)   )
725   format(T2, A8, 6(F11.2) )
799   format(T2, 80('-') )

      write(6,799)

      if ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) then
        write(6,21) 
     &     CCID(1:KK)
     &    ,LCVAL_STORE(IPAR_MB)
     &    ,LCERR_STORE(IPAR_MB)
21      format(T4,'SALT2 mB(',A,') = ', F8.3, ' +- ', F6.3 )
      endif

c write Trest fit range relative to PEAKMJD(fit)

      write(6,770) CCID(1:KK), R4SN_Tearly, R4SN_Tlate, 'FIT'
      write(6,771) CCID(1:KK), R4SN_MJDmin, R4SN_MJDmax


c write Trest fit range relative to exact SIM_PEAKMJD

      IF ( LSIM_SNANA ) THEN
         TCOR = FITVAL_STORE(IPAR_PEAKMJD) - (SIM_PEAKMJD-MJDOFF)
         write(6,770) CCID(1:KK), 
     &          R4SN_Tearly+TCOR, R4SN_Tlate+TCOR, 'SIM'         
      ENDIF

770   format(T4, 'Trest FIT RANGE(',A,'): ', F7.2,' to ', F7.2,
     &    3x,'(relative to ',A,'-PEAKMJD)' )

771   format(T4, 'MJD   FIT RANGE(',A,'): ', F7.1,' to ', F7.1 )

c write  rest-frame peakmags

      IF ( LREST_FITMODEL ) THEN

        write(6,777) 'REST-PEAKMAGS',
     &    RESTKCOR_FILTERS(1:NFILTDEF_REST)
        
        do i = 1, NFILTDEF_REST 
          write(6,778) 
     &    PEAKMAG_REST_MODEL(IFILTDEF_MAP_REST(i))
        enddo
        print*,' '

        write(6,777) 'REST-PEAKERRS',
     &    RESTKCOR_FILTERS(1:NFILTDEF_REST)
        do i = 1, NFILTDEF_REST 
           write(6,778) 
     &     PEAKMAG_REST_MODEL_ERR(IFILTDEF_MAP_REST(i))
        enddo
        print*,' '

      ENDIF

777   format(T4, A, '(',A,') : ',  $)
778   format(F6.2, $ )

c -----------------------------------
c print chi2 and prob for 1:TOTAL,  2:DATA,  3:PRIOR,   4:SIGMA

      print*,' '

      NTMP = 3
      IF ( DOCHI2_SIGMA ) NTMP=4
      DO i = 1, NTMP
         write(6,781) 'FIT MINIMUM ', CCID(1:KK)
     &    ,CCHI2(i)
     &    ,FITCHI2_STORE(i), NDOF_STORE(i)
     &    ,FITPROBCHI2_STORE(i)
      ENDDO

      IF ( NGRID_PDF .GT. 0 ) THEN
        DO i = 1, NTMP
         write(6,781) 'MARGINALIZATION', CCID(1:KK)
     &    ,CCHI2(i)
     &    ,LCCHI2_STORE(i), NDOF_STORE(i)
     &    ,LCPROBCHI2_STORE(i)
        ENDDO
      ENDIF

781   format(T4,A,'(',A,') returns ',A6,2x,
     &   'CHI2/dof=',G10.3,'/',I3,  3x, 'PROB=',F7.5)


c write simulated efficiency if used in prior.
      IF ( OPT_PRIOR_SIMEFF .GT. 0 ) THEN
        do ipar = 1, IPAR_MAX 
          LCVAL8(ipar) = DBLE( LCVAL_STORE(ipar) )
        enddo
        EFF8 = SNLC_FIT_SIMEFF(isn, LCVAL8 )
        write(6,801) EFF8
801     format(T4,'SIMEFF(Best Fit) = ', F5.3)
      ENDIF

      print*,' '

      CALL FLUSH(6)

      RETURN 
      END  ! end of FNANA_SUMMARY

C ========================================
+DECK,LCPROBCHI2.
      REAL FUNCTION LCPROBCHI2(ifilt)
      IMPLICIT  NONE
      INTEGER   IFILT  ! (I) filter index

c Mar 2011: protect againt chi2 < 0.

c local 

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      REAL    probtmp, chi2
      INTEGER Ndof

      REAL*8  CHI8

c function
      REAL*8 PROB_CHI2NDOF

C ----------------- BEGIN -----------------

      LCPROBCHI2 = 0.0

      chi2     = LC_FITCHI2(ifilt)
      Ndof     = NFITDOF(ifilt)

      if ( Ndof .LE. 0 ) then
        write(6,20) Ndof, ifilt
20      format(T10,'LCPROBCHI2 WARNING: Ndof=',I2,' for ifilt=',I2 )
        return
      endif


      CHI8     = DBLE(CHI2)
      probtmp  = SNGL( PROB_CHI2NDOF(CHI8,NDOF) )

      probtmp  = max ( probtmp, 1.2E-10 )

      LCPROBCHI2 = probtmp

      RETURN
      END

C ====================================
+DECK,FPKRAT.
      SUBROUTINE FPKRAT(ifilt_obs)

c Created May 15, 2008 by R.Kessler
c
c Fill EP_FPKRAT[ERR] = flux/peakFlux in rest frame.
c Loop over all epochs & filters inside here.
c
c Mar 06, 2009: 
c   Correct peakFlux for average data/model ratio so that 
c   peakFlux is not way off if the model is off.
c   See new namelist varaible TREST_PEAKKRENORM
c   Fills new array FPKRAW to keep track of raw
c   (uncorrected) Flux/peakFlux ratio.
c   
c   Pass 'ifilt_obs' arg and process only this filter
c
c Mar 3, 2010: apply K-correction only if kcor != NULLVALL;
c              ==> give something reasonable for SALT2
c
c Mar 5, 2010: fix aweful bug, argument of PEAKFLUX_OBS_MODEL
c              is IFILT_OBS instead of IFILT. Previous code worked
c              by accident for SDSS, but not for any other survey.
c
c Dec 14, 2011: avoid divide-by-zero for Fraterr calc
c
c Nov 10 2015: move divide-by-zero protection; see Flux_model
c
c --------------------

      IMPLICIT NONE

c subroutine args.

      INTEGER  IFILT_OBS    ! (I) obs filter to process
c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNFITCOM.
+CDE,FILTCOM. 

      INTEGER IMJD, ifilt, ifilto, ifiltr, iep, ifitdata

      REAL 
     &   kcor, flux, flux_err, Flux_model, Flux_model_err
     &  ,Frat, Fraterr, arg, FPKRAW(MXEPOCH)
     &  ,z1, Trest, MJD, PEAKMJD
     &  ,Tnear, Terr, ratio, ratio_err, sum_ratio, wsum_ratio
     &  ,wgt, sq1, sq2, PEAK_MODEL_RENORM

      LOGICAL LRENORM, USE_RENORM, LDMP, LKCOR

      CHARACTER cfilt*1

C ---------------- BEGIN ------------

      LDMP = .FALSE.  ! debug-dump flag
      USE_RENORM = .FALSE.

      cfilt   = filtdef_string(ifilt_obs:ifilt_obs)
      z1      = 1. + REDSHIFT_FIT
      PEAKMJD = LCVAL_STORE(IPAR_PEAKMJD) + MJDOFF 

        SUM_RATIO   = 0. 
        WSUM_RATIO  = 0.
        Tnear       = 99999.  ! epoch closest to peak

      DO 50 ifitdata = 1, NFITDATA

         iep        = EPLIST_FIT(ifitdata)

         ifilto     = I4EP_ALL(iep,IEP_IFILT_OBS)
         if ( ifilto .NE. IFILT_OBS ) goto 50

         MJD        = R8EP_MJD(ifitdata)
         Trest      = (MJD - PEAKMJD) / z1
         ifilt      = I4EP_ALL(iep,IEP_IFILT)

         Flux           = R4EP_ALL(iep,JEP_DATAFLUX)
         Flux_err       = R4EP_ALL(iep,JEP_DATAFLUX_ERR)
         Flux_model     = R4EP_ALL(iep,JEP_MODELFLUX)
         Flux_model_err = R4EP_ALL(iep,JEP_MODELFLUX_ERR)
         kcor           = R4EP_ALL(iep,JEP_KCOR)
      
c Compute FPKRAT: 
         Frat = Flux / PEAKFLUX_OBS_MODEL(ifilt)  ! obs-frame

c now K-correct from obs-frame back to rest-frame
         LKCOR = abs(kcor-NULLVAL) > 1.0 
         IF ( LREST_FITMODEL .and. LKCOR ) then
           arg     = 0.4 * (kcor - PEAK_KCOR_MODEL(ifilt))
           Frat    = Frat * TEN8**(arg)
         ENDIF
 
c include data and model error for error on FPKRAT:
         if ( FLux > 0.0 .or.  flux_model > 0.0 ) then
           SQ1 = (flux_err/Flux)**2
           SQ2 = (flux_model_err/flux_model)**2
           Fraterr = Frat * sqrt(SQ1+SQ2)
         ELSE
           Fraterr = -9.0
         ENDIF

         FPKRAW(iep)                 = Frat
         R4EP_ALL(iep,JEP_FPKRAT)    = Frat
         R4EP_ALL(iep,JEP_FPKRATERR) = Fraterr

c 3/06/2009: 
c check if this epoch is used to re-normalize
c the peak from the model.

         LRENORM  = Trest .GE. TREST_PEAKRENORM(1) .and.
     &              Trest .LE. TREST_PEAKRENORM(2) .and.
     &              Flux_model > 0.0   ! Nov 10 2015 - avoid divide-by-0

         IF ( LRENORM ) THEN
           USE_RENORM = .TRUE.
           ratio       = Flux/Flux_model
           ratio_err   = Flux_err/Flux_model

c Amplify error away from peak;
c error scale is 1 at peak, and 3 at 8 days away from peak.

           ratio_err   = ratio_err * sqrt(abs(Trest)+1.)

c compute weight at this epoch
           wgt         = 1. / (ratio_err**2)

c now add additional weight based on 
c proximity to peak
           wgt = wgt + .01/(abs(Trest) + 1.0)

           WSUM_RATIO  = WSUM_RATIO  + wgt
           SUM_RATIO   = SUM_RATIO   + wgt * ratio

           if ( LDMP ) then
              write(6,660) cfilt, ratio, ratio_err, Trest
660           format(' xxxx ',A,'-Data/Model ratio = ',
     &             F6.3,' +- ', F6.3,'  at Trest=',F5.1,' days ' )
           endif

           if ( abs(Trest) .LT. abs(Tnear) ) then
              Tnear = Trest
           endif
         ENDIF

50    CONTINUE

      
c --------
c Check if model peakFlux gets renormalized

      IF ( USE_RENORM .and. WSUM_RATIO > 0.0 ) THEN
        
        PEAK_MODEL_RENORM = (SUM_RATIO/WSUM_RATIO)

        PEAKFLUX_OBS_MODEL_COR(ifilt) = PEAK_MODEL_RENORM

        write(6,71) SNLC_CCID, PEAK_MODEL_RENORM, cfilt
71      format(T5,'Model peakFlux(SN ', A8, ') adjusted by ',
     &          F6.3,' for FPKRAT-', A )

c adjust all of the FPKRAT values.

        DO 70 ifitdata = 1, NFITDATA

           iep     = EPLIST_FIT(ifitdata)

           ifilto  = I4EP_ALL(iep,IEP_IFILT_OBS)
           if ( ifilto .NE. IFILT_OBS ) goto 70

           R4EP_ALL(iep,JEP_FPKRAT) = 
     &          FPKRAW(iep) / PEAK_MODEL_RENORM

           R4EP_ALL(iep,JEP_FPKRATERR) = 
     &          R4EP_ALL(iep,JEP_FPKRATERR) / PEAK_MODEL_RENORM
 70     CONTINUE        
      ENDIF

      RETURN
      END

C ======================================
+DECK,MODELMAG_CALC.
      SUBROUTINE MODELMAG_CALC ( 
     &    IFILT          ! (I) absolute filter index
     &   ,CFRAME         ! (I) 'REST'  or 'REST2' or 'OBS'
     &   ,MJD            ! (I) MJD to evaluate
     &   ,FLUX, FLUXERR  ! (O) Flux and error 
     &   ,MAG,  MAGERR   ! (O) mag and its error
     &   ,KCOR           ! (O) K-correction (if used)
     &       )

c -----------------------
c
c Created Jan 2008 by R.Kessler
c Calculate Lightcurve parmaters at MJD using best fit model.
c Returns FLUX, MAG and KCOR
c
c [modified from PEAKMAG_CALC]
c
c
c Mar 24, 2008: add 'REST2' option to get rest-mag
c               from cosmology instead of from model.
c
c April 6, 2008: add new return arguments FLUXERR and MAGERR,
c                which are computed using full covariance matrix.
c
c Dec 18, 2011: for photoZ fit, return if min or max filter-lambda
c               is outside model-wavelength range => avoids abort.
c              
c ----------------------------------------------
      IMPLICIT NONE

      INTEGER 
     &   ifilt  ! (I) IFILT_OBS or IFILT_REST (depends on CFRAME)

      CHARACTER CFRAME*(*)  ! (I) 'REST' or 'OBS' or 'REST2'

      REAL*8 
     &   MJD
     &  ,FLUX, FLUXERR
     &  ,MAG,  MAGERR
     &  ,KCOR 


c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.cars
+CDE,SNFITCOM.
+CDE,FILTCOM. 

      REAL*8  
     &   TREF, MAGOFF, TOBS, MAGOFF_REST
     &  ,SQSIG_FLUX, PKMJD, LAMMIN, LAMMAX, Z1, Z

      INTEGER OPT, OPT_KCOR, ipar1, ipar2, i, NLAM, LL
      LOGICAL LOBS, LREST, LDMP

      CHARACTER CFILT1, CFRAME_LOC*8

c functions
      REAL*8  GET_FLUX_FITFUN, COVFLUXFUN

C ----------------- BEGIN --------------

c init output args
      MAG     =  99.
      MAGERR  = -9.0
      FLUX    = -9.0
      FLUXERR = -9.0

      cfilt1     = filtdef_string(ifilt:ifilt)

      CFRAME_LOC = CFRAME

      LOBS  = .FALSE.
      LREST = .FALSE.

      PKMJD = LCVAL_STORE(IPAR_PEAKMJD) + MJDOFF
      TOBS  =  MJD - PKMJD

      IF ( PARNAME_STORE(IPAR_DLMAG) .EQ. 'DLMAG' ) THEN
         MAGOFF_REST = -PEAKMAG_AT_10pc
      ELSE
         MAGOFF_REST = 0.0
      ENDIF

      IF ( CFRAME_LOC(1:3) .EQ. 'OBS' ) THEN
          LOBS   = .TRUE.
          OPT    = 0
          MAGOFF = 0.0
          TREF   = TOBS

      ELSE IF ( CFRAME_LOC(1:5) .EQ. 'REST2' ) THEN
          LOBS   = .TRUE.
          OPT    = 3  ! 2=> includes AV; 3 => subtract XTAV
          MAGOFF = MAGOFF_REST
          TREF   =  TOBS 

      ELSE IF ( CFRAME_LOC(1:4) .EQ. 'REST' ) THEN
          LREST  = .TRUE.
          OPT    = 1
          MAGOFF = MAGOFF_REST
          TREF   = TOBS / ( 1. + REDSHIFT_FIT )
      ELSE
         c1err = 'Unknown CFRAME = ' // CFRAME
         write(c2err,660) SNLC_CCID, IFILT
660      format('CID=',A8, 4x, 'IFILT=', I2 )         
         CALL MADABORT("MODELMAG_CALC", c1err, c2err )
      ENDIF

      LDMP =  ( LREST .and. IFILT .EQ. -IFILT_BESS_B ) 
c ---------------------
c get the flux

      Flux  =  GET_FLUX_FITFUN ( ifilt, TREF, OPT )

      SQSIG_FLUX = 
     &   COVFLUXFUN(OPT, ifilt, ifilt, TREF, TREF, LDMP )

c -------
c      print*,' OLD/NEW= ', SNGL(SQSIG_FLUX/U12),
c     &   '  COV=',U12, '  at TREF=',sngl(TREF),'  ifilt=',ifilt
c ------

      if ( SQSIG_FLUX < 0.0 ) then
         write(c1err,661) CFILT1, SQSIG_FLUX, SNLC_CCID
661      format('SQSIG_FLUX(',A,')=', G10.4,' for CID=',A )
         c2err = ' '
         print*,' MODELMAG_CALC WARNING: ', c1err(1:50)
cc         CALL MADABORT("MODELMAG_CALC", c1err, c2err )
      endif

      Fluxerr = sqrt ( abs(SQSIG_FLUX) ) 


c convert flux to MAG.

      if ( Flux .GT. 1.0E-20 ) then
        mag    = -2.5 * LOG10(Flux) + MAGOFF + ZEROPOINT_FLUXCAL_DEFAULT
        magerr =  2.5 * LOG10(1.0 + Fluxerr/Flux)
      else
        mag    = 99.
        magerr = 9.
      endif

c get the K-correction
      if ( LOBS .and. LKCOR_AVWARP ) THEN
        OPT_KCOR = 10
        KCOR  = GET_FLUX_FITFUN (  ifilt, TREF, OPT_KCOR )
      else
        KCOR = 0.0
      endif

c+SELF,IF=XXXDBG.
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
      if ( LDMP ) THEN
         print*,' xxx Peak FLUX = ', SNGL(Flux/1.0E18), 
     &       ' +- ', SNGL(fluxerr/1.0E18)
         print*,' xxx Peak MAG = ', mag,' +- ' , magerr
         print*,' xxx ---------------------------- '
         call flush(6)          ! xxxxxx
      ENDIF
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c+SELF.

      RETURN
      END   ! end of MODELMAG_CALC

C ======================================
+DECK,PKMAG_CALC.
      SUBROUTINE PEAKMAG_CALC ( IFILTDEF, CFRAME )
c
c Created Jan, 2008
c Just calls MODELMAG_CALC with PKMJD = PEAKMJD
c
c Feb 20 2017: convert input IFILTDEF to sparse index IFILT,
c              and fill arrays with sparse IFILT.
c
c ----------------------------------------------
      IMPLICIT NONE

      INTEGER 
     &   ifiltdef  ! (I) IFILT_OBS or IFILT_REST (depends on CFRAME)

      CHARACTER CFRAME*(*)  ! (I) 'REST' or 'OBS'

c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNFITCOM.
+CDE,FILTCOM. 

      INTEGER IFILT
      REAL*8 PKMJD, FLUX, FLUXERR, MAG, MAGERR, KCOR

C ----------------- BEGIN --------------

      PKMJD = LCVAL_STORE(IPAR_PEAKMJD) + MJDOFF
      
      CALL MODELMAG_CALC(IFILTDEF,CFRAME, PKMJD,   ! (I) inputs
     &     FLUX, FLUXERR, MAG, MAGERR, KCOR)    ! (O) return args

      if ( CFRAME(1:3) .EQ. 'OBS' ) THEN
        IFILT = IFILTDEF_INVMAP_SURVEY(ifiltdef) ! get sparse index

        PEAKMAG_OBS_MODEL(ifilt)     = MAG
        PEAKMAG_OBS_MODEL_ERR(ifilt) = MAGERR

        PEAKFLUX_OBS_MODEL(ifilt)     = FLUX
        PEAKFLUX_OBS_MODEL_ERR(ifilt) = FLUXERR

        PEAK_KCOR_MODEL(ifiltdef)        = KCOR
      ELSE
        PEAKMAG_REST_MODEL(ifiltdef)     = MAG
        PEAKMAG_REST_MODEL_ERR(ifiltdef) = MAGERR
      ENDIF

      RETURN
      END

C =====================================
+DECK,COVFLUXFUN.
      REAL*8 FUNCTION COVFLUXFUN(OPT, ifilt1,ifilt2, T1,T2,LDMP )

c
c Created April 6, 2008 by R.Kessler
c
c Get the model-Flux covariance between any two epochs/filters
c using full fitpar covariance, FITERRMAT(ipar1,ipar2)
c  ( see eq. 32.24 in PDG statistics section)
c 
c COVFLUXFUN = U12,
c
c                           dF1   dF2
c U12       = \sum_{k,l}  ------ ------ * FITERRMAT(k,l)
c                         dPAR_k dPAR_l
c
c  where PAR_k = fit-parameter with index 'k'.
c  and F1,F2 are fluxes at days with index 1,2.
c
c If ifilt1=ifilt2 and T1=T2,  then U12 = square of model
c uncertainty at this epoch.
c
c Mar 26 2014: add new LDMP argument
c
c -------------------------------

      IMPLICIT NONE

c subroutine args:

      INTEGER
     &   OPT     ! (I) option for GET_FLUX_FITFUN
     &  ,IFILT1  ! (I) ifilt_obs or ifilt_rest (depends on OPT) 
     &  ,IFILT2  ! (I) idem for other epoch
  
      REAL*8  T1, T2  ! (I) epoch (days) to get covariance
  
      LOGICAL LDMP  ! (I) dump flag.

c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNFITCOM.
+CDE,FILTCOM. 

      INTEGER 
     &   ipar_k, ipar_l

      REAL*8 
     &   FLUX1, FLUX2
     &  ,FTMP1, FTMP2
     &  ,SAVEVAL_k, SAVEVAL_l
     &  ,ERRPAR_k,  ERRPAR_l
     &  ,dF1dVAL_k, dF2dVAL_l, FF
     &  ,V_kl, U12

c functions
      REAL*8  GET_FLUX_FITFUN

C -------------- BEGIN -------------

      COVFLUXFUN = 0.0
      U12 = 0.0   ! init output

c get reference fluxes to computer deriviates below.
     
      Flux1   =  GET_FLUX_FITFUN ( ifilt1, T1, OPT )
      Flux2   =  GET_FLUX_FITFUN ( ifilt2, T2, OPT )

      DO 301 ipar_k = 1, NFITPAR_MN
         if ( .NOT. FLOATPAR(ipar_k) ) goto 301
      DO 302 ipar_l = 1, NFITPAR_MN
         if ( .NOT. FLOATPAR(ipar_l) ) goto 302

         SAVEVAL_k = LCVAL_STORE(ipar_k)
         SAVEVAL_l = LCVAL_STORE(ipar_l)

         ERRPAR_k  = LCERR_STORE(ipar_k)
         ERRPAR_l  = LCERR_STORE(ipar_l)

c change fitpar values by +1 sigma and re-evaluate Flux.

         LCVAL_STORE(ipar_k) = 
     &   LCVAL_STORE(ipar_k) + ERRPAR_k
         Ftmp1   =  GET_FLUX_FITFUN ( ifilt1, T1, OPT )
         LCVAL_STORE(ipar_k) = SAVEVAL_k

c repeat for 2nd fitpar ...
         LCVAL_STORE(ipar_l) = 
     &   LCVAL_STORE(ipar_l) + ERRPAR_l
         Ftmp2   =  GET_FLUX_FITFUN ( ifilt2, T2, OPT )
         LCVAL_STORE(ipar_l) = SAVEVAL_l

c make sure that errors are non-zero before dividing.

         c2err = ' '
         if ( ERRPAR_k .EQ. 0.0 ) then
           write(c1err,662) PARNAME_STORE(ipar_k)
           CALL MADABORT("COVFLUXFUN", c1err, c2err )
         endif
         if ( ERRPAR_l .EQ. 0.0 ) then
           write(c1err,662) PARNAME_STORE(ipar_l)
           CALL MADABORT("COVFLUXFUN", c1err, c2err )
         endif
662      format('Cannot compute FLUXERR with ERR(',A,') = 0' )

c evaluate partial deriviates for flux
         dF1dVAL_k = (Ftmp1 - Flux1) / ERRPAR_k
         dF2dVAL_l = (Ftmp2 - Flux2) / ERRPAR_l

         FF   = dF1dVAL_k * dF2dVAL_l 
         V_kl = FITERRMAT(ipar_k,ipar_l)
         U12  = U12 + FF * V_kl

         if ( LDMP .and. FF .NE. 0.0 ) then
            print*,' xxx COVFLUXFUN DUMP for ', 
     &          parname_store(ipar_k)(1:10), 
     &          parname_store(ipar_l)(1:10)
            print*,' xxx   FF, V_kl, U12 ', 
     &           sngl(FF/1.0E35), sngl(V_kl), sngl(U12/1.0E35)
            print*,' xxx   dF1,dF2 = ', 
     &          sngl(dF1dVAL_k/1.0E18), sngl(dF2dVAL_l/1.0E18)
            print*,' xxx   ERR1,ERR2 = ', 
     &          sngl(ERRPAR_k), sngl(ERRPAR_l)
            call flush(6)
         endif

302   CONTINUE
301   CONTINUE

      COVFLUXFUN = U12

      RETURN
      END

C ======================================
+DECK,COVFUDGE.
      DOUBLE PRECISION FUNCTION COVFUDGE_DATA( irow, icol )
c
c Created Feb 23 2015 by R.Kessler
c Compute fudged data-covariance from &SNLCINP  namelist
c input FUDGE_MAG_COVERR.
c
      IMPLICIT NONE

      INTEGER irow, icol   ! (I) matrix location

c local var

+CDE,SNDATCOM. 
+CDE,SNFITCOM.

      REAL*8 COV, R1, R2, ERR1, ERR2, F1, F2
      INTEGER IFILT1, IFILT2

C -------------- BEGIN --------------

      COVFUDGE_DATA = 0.0 
      if ( FUDGE_MAG_COVERR .EQ. ' ' ) RETURN  ! no fudge requested

      ifilt1  = I4EP_ALL(irow,IEP_IFILT_OBS)
      ifilt2  = I4EP_ALL(icol,IEP_IFILT_OBS)           

      if ( ifilt1 .NE. ifilt2 ) RETURN  ! no cov for different filters.

      R1   = FUDGE_MAG_COVERR_FILT(ifilt1)  ! mag error
      R1   = 1.0 - 10.0**(-0.4*R1)          ! exact sigF/F
      R2   = R1
      F1   = R4EP_ALL(irow,JEP_DATAFLUX)    ! flux
      F2   = R4EP_ALL(icol,JEP_DATAFLUX)
      ERR1 = F1 * R1                       ! error on flux
      ERR2 = F2 * R2

      COVFUDGE_DATA  = (ERR1 * ERR2)

      RETURN
      END   ! end of COVFUDGE_DATA


C =====================================
+DECK,RHOFUDGE.
      DOUBLE PRECISION FUNCTION RHOFUDGE_MODEL( irow, icol, RHO )

c Created Sep 20, 2006 
c
c Return fudged correlation coefficients for systematic studies
c on model errors.
c Fudge only non-zero elements using FUDGE_COVAR as explained below.
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SNFITCOM.

      INTEGER irow, icol   ! (I) matrix location
      REAL*8  RHO          ! (I) un-fudged rho = COV[1,2]/sig1*sig2
      LOGICAL LPRINT       ! (I) print comment
c local var
   
      REAL*8 RHOSGN, RHOABS, RHOTMP
      LOGICAL LDMP  ! print fudge formula if TRUE
     
C --------- BEGIN ---------

      RHOFUDGE_MODEL = RHO  ! default is no fudge

c check option to print fudge-formual

      LDMP = ( irow .LE. 0 .and. irow .LE. 0 )
      IF ( LDMP ) THEN

cc         CALL PRBANNER("RHOFUDGE: FUDGE RHO = COV[i,j]/sig_i*sig_j")

         IF ( FUDGE_COVAR .EQ. 0.0 ) THEN
cc            print*,'      No fudge for RHO '
         ELSE IF ( FUDGE_COVAR .LT. 0.0 ) THEN
            write(6,21) abs(FUDGE_COVAR)
21          format(T10,'FUDGE non-zero |RHO| -> ', 
     &                 '|RHO| x [ 1 - ',F5.2,' ]' )
         ELSE IF ( FUDGE_COVAR .GT. 0.0 ) THEN
            write(6,22) FUDGE_COVAR
22          format(T10,'FUDGE non-zero |RHO| -> ',
     &                   '|RHO| + [ 1 - |RHO| ] x ',F5.2 )
         ENDIF
         RETURN
      ENDIF

c ------------------------------------
c do NOT fudge ...

      if ( irow  .EQ. icol ) return  ! skip diagonal elements
      if ( RHO   .EQ. 0.0  ) return  ! elements already = 0

c bail if fudge is not requested
      if ( FUDGE_COVAR .EQ. 0.0  ) return
      
c ------------------------
444   CONTINUE

      RHOABS = ABS(RHO)
      RHOSGN = RHO / ABS(RHO)

c as FUDGE_COVAR spans -1 to 1, |RHO| spans 0 to 1
c Positive FUDGE_COVAR increases |RHO| up to 1.0 ;
c Negative FUDGE_COVAR decreases |RHO| down to zero.

      IF ( FUDGE_COVAR .LT. 0.0 ) THEN
         RHOTMP = RHOABS * (1.0 + FUDGE_COVAR)
      ELSE IF ( FUDGE_COVAR .GT. 0.0 ) THEN
         RHOTMP = RHOABS + (1.0 - RHOABS) * FUDGE_COVAR
      ENDIF

      RHOFUDGE_MODEL = RHOTMP * RHOSGN

c  make sure that |RHOFUDGE| < 1 to avoid singular matrix.
      
      IF ( RHOFUDGE_MODEL .GE.  1.00000 ) THEN
          RHOFUDGE_MODEL =  +1.0 - 1.0E-08
      ENDIF

      IF ( RHOFUDGE_MODEL .LE. -1.00000 ) THEN
         RHOFUDGE_MODEL =  -1.0 + 1.0E-08
      ENDIF

      RETURN
      END   ! end of RHOFUDGE_MODEL

C ==================================================
+DECK,VMAX_INI.
      SUBROUTINE VMAX_INI

c Created Jun 2013 by R.Kessler
c
c Initialization for 1/Vmax method.
c Parse user inputs  MAGLIM_VMAX and OPT_VMAX
c

      IMPLICIT NONE

+CDE,SNDATCOM.  from snana.car
+CDE,SNFITINP.
+CDE,FILTCOM.
+CDE,VMAXCOM.

c +CDE,SNLCINP.
c +CDE,SNANAFIT.
c +CDE,SNFITCOM.
c +CDE,FILTCOM.

      INTEGER IFILT, IFILT_OBS, NFTMP, IFLIST(MXFILT_OBS)
      REAL    MAGLIM,  MAGLIST(MXFILT_OBS)
      CHARACTER FNAM*12, CFILT*2

C ------------- BEGIN -------------

      NFILT_VMAX = 0
      IF ( MAGLIM_VMAX .EQ. ' ' ) RETURN

      FNAM = "VMAX_INI"
      CALL PRBANNER('VMAX_INI: Initialize Zmax for 1/Vmax method')

      IF ( BTEST(OPT_VMAX,OPTBIT_MAG) )  THEN
        write(6,42) 'Compute best-fit MAG at epoch of peak brightness.'
      ELSE
        write(6,42) 'Compute best-fit MAG at epoch of max flux.'
      ENDIF

      IF ( BTEST(OPT_VMAX,OPTBIT_ZMAX) )  THEN
        write(6,42) 'Compute Zmax at epoch of peak brightness.'
      ELSE
        write(6,42) 'Compute Zmax at epoch of max flux.'
      ENDIF

      IF ( BTEST(OPT_VMAX,OPTBIT_VERBOSE) )  THEN
         write(6,42) 'Verbose mode ON.'
      ENDIF

 42   format(T8,'VMAX: ', A)

      CALL FLUSH(6)

c ---------------------------------
c translate user string MAGLIM_VMAX

      CALL PARSE_FILTSTRING(1, MAGLIM_VMAX,          ! inputs
     &    NFILT_VMAX, IFLIST, MAGLIST )  ! return args

      IF ( NFILT_VMAX > MXFILT_VMAX ) THEN
         write(c1err,671) NFILT_VMAX, MXFILT_VMAX
 671     format('NFILT_VMAX = ', I2,' exceeds bound of MXFILT_VMAX=',I2)
         c2err = 'Reduce NFILT_VMAX or increase MXFILT_VMAX.'
         CALL MADABORT(FNAM, c1err, c2err )
      ENDIF
      
      FILTLIST_VMAX = ''

      DO 20 IFILT = 1, NFILT_VMAX

         IFILTOBS_LIST_VMAX(IFILT) = IFLIST(IFILT)
         MAGLIM_LIST_VMAX(IFILT)   = MAGLIST(IFILT)

         IFILT_OBS = IFILTOBS_LIST_VMAX(ifilt)
         MAGLIM    = MAGLIM_LIST_VMAX(ifilt)
         CFILT     = FILTDEF_STRING(IFILT_OBS:IFILT_OBS)
         write(6,21) CFILT, MAGLIM, IFILT_OBS
 21      format(T12,'MAGLIM(',A1,') = ', F5.2, 3x,'(IFILTOBS=',I3,')' )

         NFTMP = INDEX(FILTLIST_VMAX,' ') - 1
         FILTLIST_VMAX = FILTLIST_VMAX(1:NFTMP) // CFILT(1:1)
 20   CONTINUE

      CALL FLUSH(6)

      RETURN
      END      ! end of VMAX_INI

C ==================================================
+DECK,DMPVMAX.
      SUBROUTINE DMPVMAX(CCID,CFILT,NITER,ZMAX,MAGDIF,MAG)

C utility to dump one line for VERBOSE option
      IMPLICIT NONE

      CHARACTER CCID*(*) 
      CHARACTER CFILT*(*)   ! (I)
      INTEGER NITER         ! (I)
      REAL*8  ZMAX, MAGDIF,MAG  ! (I)

c locals
      REAL*8  MMAG
      INTEGER LCCID

C ---------- BEGIN ----------

      LCCID = INDEX(CCID,' ') - 1
      MMAG  = 1000. * MAGDIF

      write(6,505) CCID(1:LCCID),CFILT, NITER, zmax, MMAG, MAG
 505  format(T5,A,'-',A, ' :  Zmax(ITER=',I2,')=', F6.4,3x,
     &     'MAGDIF=',F7.2,' mmag', 2x,'MAG=',F7.3 )
      CALL FLUSH(6)

      RETURN
      END

C ==================================================
+DECK,VMAX_ANA.
      SUBROUTINE VMAX_ANA(IFILT_VMAX)

c Created Jun 2013 by R.Kessler
c
c Compute Zmax/Vmax for 1/Vmax method.
c
c Jun 28 2013:
c  Fix bug setting x0 = LCVAL_STORE(IPAR_DLMAG)  in iterative loop.
c
      IMPLICIT NONE

      INTEGER IFILT_VMAX  ! (I) sparse filter index for VMAX calc


+CDE,SNDATCOM.   from snana.car
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,VMAXCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

c +CDE,SNLCINP.

      INTEGER JOBS, JFIT
      PARAMETER ( JOBS=1, JFIT=2 )

      INTEGER  IFITDATA, IFILT, IFILT_OBS, IMJD, j, ep
      INTEGER  NITER, OPTWGT, NEP

      CHARACTER CFILT*1
      LOGICAL LVBOSE

      REAL*8
     &   PEAKMJD, MJD, FLUXCAL(2), MAGTMP(2), Tobs, Trest
     &  ,FLUXCAL_atmax(2), Trest_atmax(2), mag_atmax(2)
     &  ,FLUXCAL_TMP, FLUXCAL_ERR, MAG_ERR, KCOR
     &  ,MAGDIF, MAG, MAGLIM, zmax, Vmax, COSPAR(10)
     &  ,z_save, d_save, shape, color, d0, d

c function
      REAL*8 GET_DIST8, DVDZ_INTEGRAL

C ------------- BEGIN -------------

c init all global output to crazy values.
      MAG_LIST_VMAX(ifilt_Vmax)   =  99.
      TREST_LIST_VMAX(ifilt_Vmax) =  99.
      Z_LIST_VMAX(ifilt_Vmax)     = -99.
      VOL_LIST_VMAX(ifilt_Vmax)   = -99.
      NEP_LIST_VMAX(ifilt_Vmax)   =  0

      IF ( NFILT_VMAX .EQ. 0 ) RETURN

      LVBOSE = BTEST(OPT_VMAX,OPTBIT_VERBOSE) 

c strip off a few globals into local variables
      IFILT_OBS = IFILTOBS_LIST_VMAX(ifilt_Vmax)
      MAGLIM    = MAGLIM_LIST_VMAX(ifilt_Vmax) 
      PEAKMJD   = LCVAL_STORE(IPAR_PEAKMJD)
      CFILT     = FILTDEF_STRING(IFILT_OBS:IFILT_OBS)

c find brightest epoch, both observed and best-fit.
      DO j = 1, 2  
         FLUXCAL_atmax(j) = -9.9E+8  ! must be negative for logic below
         Trest_atmax(j)   =  99.
         mag_atmax(j)     =  99.
      ENDDO
      NEP     = 0

      DO 200 ifitdata = 1, NFITDATA

         ep = EPLIST_FIT(ifitdata)

         if ( ifilt_obs .NE. I4EP_ALL(ep,IEP_IFILT_OBS) ) GOTO 200

c         ifilt     = I4EP_IFILT(ifitdata)  ! sparse fit index, not Vmax 
c         imjd      = I4EP_IMJD(ifitdata)

         MJD     = R4EP_ALL(ep,JEP_MJD)
         Tobs    = MJD - PEAKMJD
         Trest   = Tobs / (1. + SNLC_REDSHIFT)

c extract observed flux and mag just in case;
c we should not need this.
          FLUXCAL(JOBS)      = R4EP_ALL(ep,JEP_DATAFLUX)
          MAGTMP(JOBS)       = R4EP_ALL(ep,JEP_DATAMAG)

c idem for best-fit flux and mag; use this
          FLUXCAL(JFIT)      = R4EP_ALL(ep,JEP_MODELFLUX)
          MAGTMP(JFIT)       = R4EP_ALL(ep,JEP_MODELMAG)
  
c keep track of max FLUXCALs
          DO j = 1, 2
             if ( FLUXCAL(j) > FLUXCAL_atmax(j) ) then
                FLUXCAL_atmax(j) = FLUXCAL(j)
                mag_atmax(j)     = MAGTMP(j)
                Trest_atmax(j)   = Trest
             endif
          ENDDO

          NEP = NEP + 1

200   CONTINUE   ! ifitdata

   
c --- load common block variables -------

      NEP_LIST_VMAX(ifilt_Vmax) = NEP

      IF ( BTEST(OPT_VMAX,OPTBIT_MAG) ) THEN
        MAG_LIST_VMAX(ifilt_Vmax)   = PEAKMAG_OBS_MODEL(IFILT_Vmax)
        TREST_LIST_VMAX(ifilt_Vmax) = 0.0
      ELSE
        MAG_LIST_VMAX(ifilt_Vmax)   = MAG_atmax(JFIT)
        TREST_LIST_VMAX(ifilt_Vmax) = Trest_atmax(JFIT)
      ENDIF

      
c bail if we have an undefined MAG to work with
      if ( abs(MAG_LIST_VMAX(ifilt_Vmax)) > 98.0 ) RETURN
      
      Trest    = TREST_LIST_VMAX(ifilt_Vmax) 
      Tobs     = TREST*(1.0 + SNLC_REDSHIFT)
      MJD      = MJDOFF + PEAKMJD + Tobs
       
c save fit quantities that need to be changed to find zmax
      z_save = LCVAL_STORE(IPAR_zPHOT)
      d_save = LCVAL_STORE(IPAR_DLMAG)  ! DLMAG or x0

c need color and shape parameter for distance(zmax) calc.
      SHAPE = LCVAL_STORE(IPAR_SHAPE) 
      COLOR = LCVAL_STORE(IPAR_COLOR) 

      NITER  = 0
      zmax   = SNLC_REDSHIFT  ! initial guess is current redshift
      d0     = GET_DIST8(zmax,SHAPE,COLOR,ONE8)  ! reference x0/mu

c first MAG-DIF for iterative loop
      MAG    = MAG_LIST_VMAX(ifilt_Vmax)
      MAGDIF = MAGLIM - MAG

      IF ( LVBOSE  ) THEN
         print*,' '
         print*,' ########## 1/Vmax DUMP ############# '
         
         print*,'    MAG   = ', MAG_LIST_VMAX(ifilt_Vmax),
     &           '      MAGLIM,MAGDIF=', sngl(MAGLIM), sngl(MAGDIF)
         print*,'    Trest = ', TREST_LIST_VMAX(ifilt_Vmax)
         print*,'    d,c,s = ', sngl(d_save), sngl(color), sngl(shape)

         CALL DMPVMAX(SNLC_CCID,CFILT,NITER,ZMAX,MAGDIF,MAG)
      ENDIF
c ----------------------------------------
      DO 300 WHILE ( abs(MAGDIF) > MAGDIF_CONVERGE ) 

c modify zmax and distance before re-computing model mag at zmax;
c for each iteration,  
c (zmax/z)^2  = FLux(z)/FLUXLIM = 10**[0.4*(MAGLIM - mag(z))]
         zmax = zmax * 10.0**(0.2*(MAGDIF))
         d    = GET_DIST8(zmax,SHAPE,COLOR,ONE8) ! compute dist: x0 or mu
         
         LCVAL_STORE(IPAR_zPHOT) = zmax

         IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN
            LCVAL_STORE(IPAR_DLMAG)  = d_save * d/d0  ! scale x0
         ELSE
            LCVAL_STORE(IPAR_DLMAG)  = d_save + (d0-d) ! MU-dif -> UNTESTED!
         ENDIF

         CALL MODELMAG_CALC(IFILT_OBS, 'OBS', MJD,
     &        FLUXCAL_TMP, FLUXCAL_ERR, MAG, MAG_ERR, KCOR)

         MAGDIF = MAGLIM - MAG
         NITER  = NITER + 1

         IF ( LVBOSE  ) THEN
            CALL DMPVMAX(SNLC_CCID,CFILT,NITER,ZMAX,MAGDIF,MAG)
cc            print*,'          x0 = ' , LCVAL_STORE(IPAR_DLMAG)
         ENDIF

         if ( NITER > 20 ) THEN            
            print*,' ' 
            print*,' xxx ------------------------- '
            print*,' xxx IFILT_OBS,VMAX = ', IFILT_OBS, IFILT_VMAX
            print*,' xxx MAG_atmax  = ', MAG_atmax
            print*,' xxx MJD, Tobs  = ', MJD, Tobs
            print*,' xxx PEAKMAG    = ', PEAKMAG_OBS_MODEL(IFILT_VMAX)
            print*,' xxx PEAKMJD    = ', PEAKMJD
            print*,' xxx NEPOCH     = ', NEP
            print*,' xxx zmax, mag = ', sngl(zmax), sngl(mag), NITER
            call flush(6)

            write(c1err,661) NITER
 661        format('Too many zmax iterations: NITER = ',I3 )
            c2err = 'for CID = ' // SNLC_CCID
            CALL MADABORT("VMAX_ANA", c1err, c2err )
         endif

 300  CONTINUE

c ------------------------------
c compute volume out to zmax

c xxxxxxxxxxx mark delete Oct 16 2020 xxxx
c      H0     = H0_REF(1) * 1.0E6 * Parsec  ! km/s/Mpc
c      OM     = OMAT_REF(1)
c      OL     = OLAM_REF(1)
c      w0     = W0_REF(1)
c xxxxxxxxx end mark xxxxxx

      OPTWGT    = 0  ! do NOT weight by redshift
      COSPAR(1) = H0_REF(1)
      COSPAR(2) = OMAT_REF(1)
      COSPAR(3) = OLAM_REF(1)
      COSPAR(4) = W0_REF(1)
      COSPAR(5) = 0.0        ! wa
      Vmax   = 4.0 * PI * DVDZ_INTEGRAL(OPTWGT, zmax, COSPAR )

c -----------
c store results in globals
      Z_LIST_VMAX(ifilt_Vmax)     = zmax
      VOL_LIST_VMAX(ifilt_Vmax)   = Vmax
     
c restore LCVAL_STORE values
      LCVAL_STORE(IPAR_zPHOT) = z_save
      LCVAL_STORE(IPAR_DLMAG)  = d_save

      RETURN
      END        ! end of VMAX_ANA


C ================================================
+DECK,MAGDIFINI.
      SUBROUTINE FITMAGDIF_INI
c
c Created Mar 2013
c Prepare fits for 1-filter only, all other filters,
c and all filters.

      IMPLICIT NONE

+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,MAGDIFCOM.

      LOGICAL    L0, L1, L2, LX
      INTEGER    
     &   iter, IFLAG, NFILT, NFILT_ALL
     &  ,IFILTDEF, IFILT, NFIT_PER_SN

      CHARACTER  FILTLIST*(MXFILT_ALL), CFILT*2, CTMP*28

c function
      INTEGER FILTINDX

C ------------------ BEGIN -----------

      IF ( FILTER_FITMAGDIF .EQ. '' ) RETURN
      
      global_banner = 'FITMAGDIF_INI: prepare 2 fit methods for mag-' 
     &            // FILTER_FITMAGDIF

      CALL PRBANNER ( GLOBAL_BANNER(1:60) )

      NFIT_PER_SN = 3
      CALL SNLCPAK_NFIT_PER_SN(NFIT_PER_SN)   ! see sntools_output.c 

c get filter index (absolute and sparse) for test filter.
      IFILTDEF  = FILTINDX(FILTER_FITMAGDIF)
      IFILT     = IFILTDEF_INVMAP_SURVEY(IFILTDEF)
      IFILTOBS_FITMAGDIF = IFILTDEF
      IFILT_FITMAGDIF    = IFILT

      IF ( IFILT < 0 ) THEN
        c1err = 'Invalid FILTER_FITMAGDIF = ' // FILTER_FITMAGDIF
        c2err = 'Must use valid SURVEY filter: ' // 
     &       SURVEY_FILTERS(1:NFILTDEF_SURVEY)
        CALL MADABORT('FITMAGDIF_INI', c1err, c2err)
      ENDIF
      
c --------      
      NFIT_ITERATION_ALLFILT = NFIT_ITERATION
      NFIT_ITERATION  = 
     &    NFIT_ITERATION_ALLFILT   ! nominal, fix t0,c,shape
     &  + 2*NFIT_ITER_FITMAGDIF    ! special fits
     &  + 1                        ! nominal again

      NFILT_ALL = INDEX(FILTLIST_FIT,' ') - 1
      DO 100 iter = 1, NFIT_ITERATION

            IFLAG    = -9
            NFILT    = -9
            FILTLIST = '???'
            CTMP = ' '

        L0 =     ( iter .LE. NFIT_ITERATION_ALLFILT ) 
     &     .or.  ( iter .EQ. NFIT_ITERATION ) 

        L1 = (iter .GT. NFIT_ITERATION_ALLFILT) .and.
     &       (iter .LE. NFIT_ITERATION_ALLFILT + NFIT_ITER_FITMAGDIF)

        IF ( L0 ) then
           IFLAG    = IFLAG_FITMAGDIF_NOMINAL
           NFILT    = NFILT_ALL
           FILTLIST = FILTLIST_FIT
        ELSE IF ( L1 ) THEN
           IFLAG    = IFLAG_FITMAGDIF_1FILT
           NFILT    = 1
           FILTLIST = FILTER_FITMAGDIF
        ELSE
           IFLAG    = IFLAG_FITMAGDIF_XFILT
           NFILT    = NFILT_ALL
           FILTLIST = FILTLIST_FIT
           CTMP = '(' // FILTER_FITMAGDIF(1:1)//'-band deweighted)'
        ENDIF


        write(6,20) iter, NFILT, FILTLIST(1:NFILT), ctmp
 20     format(T10,'ITER=',I1,' -> NFILT = ', I2, 2x, A, 3x, A)
        CALL FLUSH(6)

         IFLAG_FITMAGDIF(iter) = IFLAG
         NFILT_FITMAGDIF(iter) = NFILT
         FILTLIST_FITMAGDIF(iter) = FILTLIST
 100  CONTINUE

      RETURN
      END   ! end of FITMAGDIF_INI

C =====================================
+DECK,MAGDIFPREP.
      SUBROUTINE FITMAGDIF_PREP(ITER)

c March, 2013
c Called before fit-iteration ITER to prepare fit-iteration ITER
c for fitting either FILTER_FITMAGDIF or all filters except this one.
c
c -----------------------

      IMPLICIT NONE

c subroutine args

      INTEGER ITER ! (I) SN index and fit iteration

c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,MAGDIFCOM.

      LOGICAL LMATCH, USE
      INTEGER ipar, ifilt, ifiltdef, iflag, LL
      CHARACTER CFILTDEF*2

C -------------- BEGIN -----------

c check global flag
      IF ( FILTER_FITMAGDIF .EQ. '' ) RETURN

c bail on the nominal ALLFILT interations
      IF ( ITER .LE. NFIT_ITERATION_ALLFILT ) RETURN

c =============================================
c store ALLFILT results just before doing first 2-band fit

      IF ( ITER .EQ. NFIT_ITERATION_ALLFILT + 1 ) THEN

c store original USE_FILT(IFILT) and FITPAR to keep track of which
c filters can be used.
         ALLFILTLIST_FIT   = FILTLIST_FIT_USE 
         NOBS_ALLFILT      = NFILT_OBS_USEFIT 
         DO IFILTDEF = 1, MXFILT_ALL
           USE_ALLFILT(IFILTDEF) = USE_FILT(IFILTDEF)
         ENDDO

         DO ipar = 1, MXFITPAR
            FITVAL_ALLFILT(ipar) = FITVAL(ipar,ITER-1)
            FITERR_ALLFILT(ipar) = FITERR(ipar,ITER-1)
         ENDDO

c  init final results to dummy values.
    
         FITMAG_1FILT    = 99.
         FITMAG_XFILT    = 99.
         FITMAGERR_1FILT = 99.
         FITMAGERR_XFILT = 99.
         FITMAGDIF       = 99.
         FITERRDIF       = -9.0
         FITPROB_1FILT   = -9.0
         FITPROB_XFILT   = -9.0
      ENDIF


c make sure that test filter is on the list; otherwise bail out.

      IF ( .not. USE_ALLFILT(IFILTOBS_FITMAGDIF)  ) RETURN

c reset global list of filters to fit.
      FILTLIST_FIT_USE = ''
      NFILT_OBS_USEFIT = 0

c always restore INIVAL and INISTP

      DO ipar = 1, MXFITPAR
         INIVAL(ipar)  = FITVAL_ALLFILT(ipar) 
         INISTP(ipar)  = FITERR_ALLFILT(ipar) 
      ENDDO

c always restore FUDGE_FITERR params.

      FUDGE_FITERR_PASSBANDS = 'NULL'
      FUDGE_FITERR_MAXFRAC   = 0.0 

c -----------------
c if done with all test fits, do nominal fit again so that
c analysis variables correspond to nominal fit.

      IF ( ITER .EQ. NFIT_ITERATION ) THEN

         FILTLIST_FIT_USE = ALLFILTLIST_FIT
         NFILT_OBS_USEFIT = NOBS_ALLFILT

         DO IFILTDEF = 1, MXFILT_ALL
           USE_FILT(IFILTDEF) = USE_ALLFILT(IFILTDEF)
         ENDDO 

         CALL INIT_FUDGE_FITERR
         RETURN   ! bail out on last ALLFIT iteration
      ENDIF

      IFLAG = IFLAG_FITMAGDIF(iter)
      NFILT_OBS_USEFIT = 0


c fix all params except for the overall scale/distance parameter
      INISTP(IPAR_SHAPE)     = 0.0    ! fix stretch/lumipar parameter
      INISTP(IPAR_PEAKMJD)   = 0.0    ! fix time of peak

      IF ( IFLAG .EQ. IFLAG_FITMAGDIF_1FILT ) THEN
         INISTP(IPAR_COLOR)     = 0.0    ! fix color param
      ELSE
         INISTP(IPAR_COLOR)     = 0.2
      ENDIF

c use FUDGE_FITER_XXX parameters to de-wieght test filter
c to effectively exclude it.
      IF ( IFLAG .EQ. IFLAG_FITMAGDIF_XFILT ) THEN
         FUDGE_FITERR_PASSBANDS   = FILTER_FITMAGDIF
         FUDGE_FITERR_MAXFRAC     =  999.0
         FUDGE_FITERR_TREST(1)    =  -30.0
         FUDGE_FITERR_TREST(2)    = +200.0
         FUDGE_FITERR_RESTLAM(1)  =  200.0
         FUDGE_FITERR_RESTLAM(2)  = 30000.
      ENDIF


      DO 200 IFILTDEF = 1, MXFILT_ALL
        USE_FILT(IFILTDEF) = .FALSE.
        USE   = .FALSE.
        CFILTDEF = FILTDEF_STRING(IFILTDEF:IFILTDEF)

        LMATCH = IFILTDEF .EQ. IFILTOBS_FITMAGDIF

        IF ( IFLAG .EQ. IFLAG_FITMAGDIF_1FILT ) THEN
          IF ( LMATCH )  USE = .TRUE.
        ELSE
          USE = .TRUE.
        ENDIF
    
        IF ( USE .and. USE_ALLFILT(IFILTDEF) ) THEN
          NFILT_OBS_USEFIT   = NFILT_OBS_USEFIT + 1
          USE_FILT(IFILTDEF) = .TRUE.

          LL = NFILT_OBS_USEFIT - 1
          FILTLIST_FIT_USE = FILTLIST_FIT_USE(1:LL) //
     &          CFILTDEF(1:1)
        ENDIF

 200  CONTINUE

      write(6,40) SNLC_CCID(1:ISNLC_LENCCID),
     &     ITER, FILTLIST_FIT_USE(1:NFILT_OBS_USEFIT)
 40   format(T5,'FITMAGDIF_PREP(CID=',A,' ITER=',I1,') -> fit  ', A)
      call flush(6)

      CALL INIT_FUDGE_FITERR

      RETURN
      END     ! end of FITMAGDIF_PREP


C =====================================
+DECK,MAGDIFCALC.
      SUBROUTINE FITMAGDIF_CALC(ITER)

c Computations for stored quantities.
c May 8 2013: compute and store FITPROB_1FILT & FITPROB_XFILT
c Feb 20 2017: load PEAKMAG_OBS_MODEL array using sparse IFILT
c
      IMPLICIT NONE

c subroutine args

      INTEGER ITER ! (I) SN index and fit iteration

c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,MAGDIFCOM.

      LOGICAL DO_MAGDIF, DO_LCPLOT
      INTEGER IFLAG, IFILTOBS, LCID, NFUNPLOT, NDOF, IFILT
      REAL    ERR1, ERR2, FITPROB
      REAL*8  CHI8, PROB8

      CHARACTER CCID*40

c function
      REAL*8  PROB_CHI2NDOF
      LOGICAL DOPLOT_SNLC

C ------------ BEGIN -------------

c check global flag
      IF ( FILTER_FITMAGDIF .EQ. '' ) RETURN

c bail on the nominal ALLFILT interations
      IF ( ITER .LE. NFIT_ITERATION_ALLFILT ) RETURN
      IF ( ITER .EQ. NFIT_ITERATION         ) RETURN

c bail if test filter is not part of fit.
      IF ( .not. USE_ALLFILT(IFILTOBS_FITMAGDIF)  ) RETURN

c strip off useful info
      IFLAG    = IFLAG_FITMAGDIF(ITER)
      IFILTOBS = IFILTOBS_FITMAGDIF
      IFILT    = IFILTDEF_INVMAP_SURVEY(IFILTOBS) ! sparse index

c store peakMag 

      CALL PEAKMAG_CALC(IFILTOBS, 'OBS') 
      
c compute fit prob for each iteration (May 2013)
      NDOF     = NEPOCH_FIT(0) - NFITPAR(0)
      CHI8     = DBLE( FCN_FITCHI2(0) )
      PROB8    = PROB_CHI2NDOF(CHI8, NDOF)

      IF ( IFLAG .EQ. IFLAG_FITMAGDIF_1FILT ) THEN
c fit only this 1 filter.
         FITMAG_1FILT    = PEAKMAG_OBS_MODEL(IFILT)
         FITMAGERR_1FILT = PEAKMAG_OBS_MODEL_ERR(IFILT)
         FITPROB_1FILT   = SNGL(PROB8)
      ELSE IF ( IFLAG .EQ. IFLAG_FITMAGDIF_XFILT ) THEN
c  with filter Xcluded.
         FITMAG_XFILT    = PEAKMAG_OBS_MODEL(IFILT)
         FITMAGERR_XFILT = PEAKMAG_OBS_MODEL_ERR(IFILT)
         FITPROB_XFILT   = SNGL(PROB8)
      ENDIF

c ----
      DO_LCPLOT = ( ITER < NFIT_ITERATION  ) .and.
     &            ( DOPLOT_SNLC() )

      IF ( DO_LCPLOT ) THEN
         IF ( IFLAG .EQ. IFLAG_FITMAGDIF_1FILT ) THEN         
            NFUNPLOT = 3
            CALL SNLCPAK_NFIT(NFUNPLOT)  ! store NFIT
         ENDIF

         LCID = ISNLC_LENCCID
         CCID = SNLC_CCID(1:LCID) // char(0)
         CALL MAKEDIR_OUTPUT(CCID,SNLC_CID,LCID)
         CALL FITANA_STORE()
         CALL SNLCPLOT()   
         CALL CDTOPDIR_OUTPUT()  ! back to topdir
      ENDIF

c after both fits, compute mag difference & error.

      DO_MAGDIF = ITER .EQ. NFIT_ITERATION-1

      IF ( DO_MAGDIF ) THEN

         FITMAGDIF = FITMAG_XFILT - FITMAG_1FILT ! predicted - measured

         ERR1 = FITMAGERR_1FILT
         ERR2 = FITMAGERR_XFILT
         FITERRDIF = sqrt(ERR1**2 + ERR2**2)

c print one-line summary.

         write(6,50) SNLC_CCID(1:ISNLC_LENCCID),
     &          FILTER_FITMAGDIF(1:1), FITMAGDIF, FITERRDIF
 50      format(T5,'FITMAGDIF(CCID=',A,') : ', A,'(pred-meas) = ', 
     &         F6.3, ' +- ', F6.3,' mag ')

      ENDIF

      RETURN
      END    ! FITMAGDIF_CALC

C ========================================
+DECK,GTMAGDIF.
      SUBROUTINE GET_FITMAGDIF(MAGDIF, MAGERR, FITPROB )

c Created Mar 2013.
c Return final results via subroutine args.
c May 8 2013: add FITPROB(2) to output
c
      IMPLICIT NONE
      REAL MAGDIF, MAGERR  ! (O)
      REAL FITPROB(2)      ! (O) fit prob for 1 filter, other filters

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,MAGDIFCOM.

C ---------- BEGIN ---------

      MAGDIF = 77.   ! different than initialized value of 99
      MAGERR = -7.0
      FITPROB(1) = -9.0
      FITPROB(2) = -9.0

      IF ( FILTER_FITMAGDIF .NE. '' ) THEN
         MAGDIF = FITMAGDIF
         MAGERR = FITERRDIF

         FITPROB(1) = FITPROB_1FILT
         FITPROB(2) = FITPROB_XFILT
      ENDIF

      RETURN
      END


C ================================================
+DECK,SIMFIT_IDEAL_INI.
      SUBROUTINE SIMFIT_IDEAL_INI()

c Created Aug 29 2017
c 
c One-time init for IDEAL FIT with FLUX=TRUEFLUX (sims only)
c Do nothing except print message.
c
      IMPLICIT NONE

+CDE,SNDATCOM.  from snana.car
+CDE,SNFITCOM.
+CDE,FITIDEALCOM.
+CDE,SNLCINP.

c+CDE,SNANAFIT.

C ---------- BEGIN --------------

      DOFIT_IDEAL = .FALSE. 
      NFIT_ITERATION_ORIG = NFIT_ITERATION

      IF ( .NOT. LSIM_SNANA ) SIMFIT_IDEAL_PRESCALE = 0
      IF ( SIMFIT_IDEAL_PRESCALE == 0 ) RETURN

      global_banner = 
     &    'SIMFIT_IDEAL_INI: include IDEAL fit with TRYEFLUX'
      CALL PRBANNER ( GLOBAL_BANNER(1:60) )
      print*,'   SIMFIT IDEAL PRESCALE = ', SIMFIT_IDEAL_PRESCALE

      RETURN
      END  ! end SIMFIT_IDEAL_INI

C ===============================================
+DECK,SIMFIT_IDEAL_PREP.
      SUBROUTINE SIMFIT_IDEAL_PREP(ITER)

c Created Aug 29 2017
c Called for each event before fit; prepare to add IDEAL fit.
c
c ITER=0 --> before fitting begings
c ITER>0 --> before fit iteration ITER

      IMPLICIT NONE

+CDE,SNDATCOM.  from snana.car
+CDE,SNFITCOM.
+CDE,SNLCINP.
+CDE,FITIDEALCOM.
+CDE,SNANAFIT.

      INTEGER ITER ! (I) fit iteration

c local var
      INTEGER EP, EPMIN, EPMAX, IMJD, IFILT_OBS
      REAL*8  PS, MAGOFF, SCALE
      LOGICAL REJECT_PRESCALE  ! function

C ----------------- BEGIN ---------------

      IF ( SIMFIT_IDEAL_PRESCALE == 0 ) RETURN

c check pre-scale on ITER=0 (before fitting begins)

      IF ( ITER .EQ. 0 ) THEN

c check debug flag to NOT change fluxes, but still run the
c fit twice to see if we get the same results.
        IF ( SIMFIT_IDEAL_PRESCALE .EQ. SIMFIT_IDEAL_DEBUG ) THEN
           DOFIT_IDEAL = .TRUE.
           NFIT_ITERATION = NFIT_ITERATION_ORIG * 2
           RETURN
        ENDIF

        PS = DBLE(SIMFIT_IDEAL_PRESCALE)
        IF ( REJECT_PRESCALE(NCALL_SNANA_DRIVER,PS) ) THEN
           DOFIT_IDEAL = .FALSE.
           NFIT_ITERATION = NFIT_ITERATION_ORIG
        ELSE
           DOFIT_IDEAL = .TRUE.
           NFIT_ITERATION = NFIT_ITERATION_ORIG * 2
           CALL SET_IDEAL_FLUXCAL(+1)  ! set FLUXCAL = TRUEFLUX
        ENDIF

        RETURN
      ENDIF

c check to restore nominal FLUXCAL for normal fit with Poisson fluctuations
      IF ( ITER .EQ. NFIT_ITERATION_ORIG+1 ) THEN
        IF ( SIMFIT_IDEAL_PRESCALE .NE. SIMFIT_IDEAL_DEBUG ) THEN
          CALL SET_IDEAL_FLUXCAL(-1)  ! restore SNLC_FLUXCAL
        ENDIF
        CALL LOAD_EPALL(ITER, FITVAL(IPAR_PEAKMJD,ITER) )
      ENDIF

cc      print*,' xxx IDEAL_PREP for NCAL=', NCALL_SNANA_DRIVER

      RETURN
      END    ! SIMFIT_IDEAL_PREP

C =======================================
+DECK,SET_IDEAL_FLUXCAL.
      SUBROUTINE SET_IDEAL_FLUXCAL(OPT)

C Created Aug 30 2017
C OPT > 0 --> set SNLC_FLUXCAL = TRUEFLUX
C OPT < 0 --> restore original FLUXCAL
c
c Jan 28 2018:  set USESIM_PEAKMJD = T/F
c
      IMPLICIT NONE

      INTEGER OPT

+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,SNANAFIT.
+CDE,FITIDEALCOM.

      INTEGER IMJD, EPMIN, EPMAX, EP, IFILT_OBS
      REAL FSCALE

C -------------- BEGIN -------------

      IF ( OPT > 0 ) THEN

c   FLUXCAL -> TRUEFLUX
        DO 101 IMJD  = 1, ISNLC_NEWMJD_STORE
          EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,IMJD)
          EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,IMJD)
        DO 102 ep = EPMIN, EPMAX

           SAVE_FLUXCAL(ep) = SNLC_FLUXCAL(ep)

c re-apply mag-system offset 
           IFILT_OBS  = ISNLC_IFILT_OBS(ep)
           Fscale     = FLUXSCALE_ZP_FILT(ifilt_obs)
           SNLC_FLUXCAL(ep) = SIM_EPFLUXCAL(ep) * FSCALE ! true flux

102     CONTINUE
101     CONTINUE

c save measured MWEBV, then MWEBV-> TRUE MWEBV
        SAVE_MWEBV     = SNLC_MWEBV
        SAVE_MWEBV_ERR = SNLC_MWEBV_ERR
        SNLC_MWEBV     = SIM_MWEBV
        SNLC_MWEBV_ERR = 0.0 
        CALL MWEBV_FLUXCOR()

        USESIM_PEAKMJD              = .TRUE.  ! Jan 28 2018
        USESIM_FITPAR(IPAR_PEAKMJD) = .TRUE.

      ELSE
c        restore original MWEBV & FLUXCAL
     
          DO 201 IMJD      = 1, ISNLC_NEWMJD_STORE
            EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,IMJD)
            EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,IMJD)
          DO 202 ep = EPMIN, EPMAX
             SNLC_FLUXCAL(ep) = SAVE_FLUXCAL(ep)
202       CONTINUE
201       CONTINUE     

          SNLC_MWEBV      = SAVE_MWEBV
          SNLC_MWEBV_ERR  = SAVE_MWEBV_ERR
          CALL MWEBV_FLUXCOR()

          USESIM_PEAKMJD              = .FALSE.  ! Jan 28 2018
          USESIM_FITPAR(IPAR_PEAKMJD) = .FALSE.
      ENDIF

      RETURN
      END     ! end SET_IDEAL_FLUXCAL

C ================================================
+DECK,SIMFIT_IDEAL_CALC.
      SUBROUTINE SIMFIT_IDEAL_CALC(ITER)

C Created Aug 29 2017
C Process IDEAL fit after each fit ITER.
C Jan 28 2018: compute mB from x0
c
      IMPLICIT NONE

      INTEGER ITER ! (I) fit iteration that just completed

c local var

+CDE,SNDATCOM. 
+CDE,SNFITCOM.
+CDE,SNANAFIT.
+CDE,FITIDEALCOM.
c+CDE,SNLCINP.

      INTEGER IPAR
      REAL*8  x0, mB, SALT2MBCALC

C -------------- BEGIN ---------------
     
      IF ( SIMFIT_IDEAL_PRESCALE == 0 ) RETURN
      
      IF ( ITER .EQ. 1) THEN
        DO ipar = 1, NFITPAR_MN
           FITPAR_IDEAL(ipar) = 999.
        ENDDO
      ENDIF

c check when to store results of IDEAL fit
      IF ( DOFIT_IDEAL .and. ITER .EQ. NFIT_ITERATION_ORIG) THEN
        DO ipar = 1, NFITPAR_MN
           FITPAR_IDEAL(ipar) = FITVAL(IPAR,ITER)
        ENDDO 

c compute mB from x0 (Jan 28 2018)
        x0 = DBLE ( FITPAR_IDEAL(IPAR_x0) )
        mB = SALT2MBCALC(x0)
        FITPAR_IDEAL(IPAR_MB) = SNGL(mB)
      ENDIF

      RETURN
      END   !  SIMFIT_IDEAL_CALC

C ================================================
+DECK,FITRESTMAG_INI.
      SUBROUTINE FITRESTMAG_INI

c Created Feb 10, 2012
c
c One-time init.
c if FITLTER_RESTMAG is set, then add this filter
c to suryey-filter list and re-init kcor file to 
c include this filter. Called only once.
c
c --------

      IMPLICIT NONE

+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FITRESTCOM.

      INTEGER 
     &   NFILT, NTMP, IERR, IFILT, IFILTDEF
     &  ,i, ITER, LL, NPLOT_PER_SN

      CHARACTER CFILT*2

c function
      INTEGER FILTINDX

C ----------------- BEGIN -----------

      IFILTOBS_BRACKET(1) = -999  ! flag that it's NOT a 2-band fit
      IFILTOBS_BRACKET(2) = -999

      NFILTDEF_FITRESTMAG = 0
      IF ( FILTLIST_FITRESTMAG .EQ. '' ) RETURN

      NFILTDEF_FITRESTMAG = INDEX(FILTLIST_FITRESTMAG,' ') - 1
      NFILT = NFILTDEF_FITRESTMAG

      global_banner = 'FITRESTMAG_INI: prepare rest-mag for  ' 
     &            // FILTLIST_FITRESTMAG(1:NFILT)

      CALL PRBANNER ( GLOBAL_BANNER(1:60) )

c -------------
c init number of LC plots per SN to prepare SNLCPAK utility
      NPLOT_PER_SN = NFILTDEF_FITRESTMAG + 1    ! each filter, and total
      CALL SNLCPAK_NFIT_PER_SN(NPLOT_PER_SN)   ! see sntools_output.c 

c ------------

      NFILTDEF_SURVEY_ORIG    = NFILTDEF_SURVEY

      DO 100 i = 1, NFILT
         CFILT                  = FILTLIST_FITRESTMAG(i:i)
         IFILTDEF_FITRESTMAG(i) = FILTINDX(CFILT)
         IFILTDEF               = IFILTDEF_FITRESTMAG(i)

c add FILTLIST_FITRESTMAG to list of SURVEY_FILTERS

c skip this filter if it is already defined as a survey filter.
         IFILT     = IFILTDEF_INVMAP_SURVEY(IFILTDEF)
         IF ( IFILT .GT. 0 ) THEN
           write(6,20) CFILT
20         format(T8,A1,'-filter already defined -> skip')
           GOTO 100
         ELSE
           write(6,21) CFILT, IFILTDEF
21         format(T8,'Add ',A1,'-filter to SURVEY_FILTERS list',2x,
     &          '(IFILTDEF=',I2,')'  )
         ENDIF
         CALL FLUSH(6)

        NTMP            = NFILTDEF_SURVEY
        SURVEY_FILTERS  = SURVEY_FILTERS(1:NTMP) // CFILT(1:1)
        NFILTDEF_SURVEY = NFILTDEF_SURVEY + 1

        IFILTDEF_INVMAP_SURVEY(IFILTDEF)     = NFILTDEF_SURVEY
        IFILTDEF_MAP_SURVEY(NFILTDEF_SURVEY) = IFILTDEF

100   CONTINUE


c -------- adjust NFIT_ITERATION ----------------

c add NFIT_ITERATION for each new filter
      NFIT_ITERATION_ALLFILT = NFIT_ITERATION
      NFIT_ITERATION      = 
     &       NFIT_ITERATION_ALLFILT        ! nominal fit, all bands
     &     + NFIT_ITER_FITRESTMAG*NFILT    ! 2-band fits
     &     + 1                             ! nominal again
     &     + 1                             ! nominal again (Dec 11 2014)


      IF ( NFIT_ITERATION .GT. MXITER ) THEN
        write(c1err,661) NFIT_ITERATION
661     format('NFIT_ITERATION = ', I2,' exceeds bound.')
        write(c2err,662) MXITER
662     format('MXITER = ', I2)
        CALL MADABORT("FITRESTMAG_INI", c1err, c2err )
      ENDIF

      write(6,40) NFIT_ITERATION_ALLFILT, NFIT_ITERATION
40    format(T8,'NFIT_ITERATION = ',I2, ' -> ', I2 )

c load IFILTDEF_ITER_FITRESTMAG array to store which filter
c to process for each fit-iteration

      ITER     = NFIT_ITERATION_ALLFILT
      DO ifilt = 1, NFILT
      DO i     = 1, NFIT_ITER_FITRESTMAG
         CFILT     = FILTLIST_FITRESTMAG(ifilt:ifilt)
         IFILTDEF  = IFILTDEF_FITRESTMAG(ifilt)
         ITER      = ITER + 1
         IFILTDEF_ITER_FITRESTMAG(ITER) = IFILTDEF
         IFILTSP_ITER_FITRESTMAG(ITER)  = IFILT
         write(6,42) ITER, CFILT
42       format(T12,'Fit-iteration ', I2,' -> ', A )

         ITERLAST_FITRESTMAG(ifilt) = ITER
      ENDDO
      ENDDO

c avoid annoying aborts
      ABORT_ON_NOEPOCHS = .FALSE.  ! Mar 20, 2012

c -------------------------
c print misc info

c check for legacy variable
      if ( LUMIFIX_FITRESTMAG < 998.0 ) THEN
        SHAPEFIX_FITRESTMAG = LUMIFIX_FITRESTMAG
      endif
      if ( SHAPEFIX_FITRESTMAG .LT. 900.0 ) then
         write(6,51) 'SHAPEFIX',  SHAPEFIX_FITRESTMAG
      endif
      if ( COLORFIX_FITRESTMAG .LT. 900.0 ) then
         write(6,51) 'COLORFIX', COLORFIX_FITRESTMAG
      endif

51       format(T8,'Evaluate RestMags for ',A,' = ' , F9.3)

      write(6,54) LAMEXTRAP_FITRESTMAG
 54   format(T8,'Allow rest-wavelength extrapolation of +- ', 
     &          F5.0,' A ')

      write(6,55) DLAMTOL_FITRESTMAG
 55   format(T8,'Include obs bands within ', F5.0,
     &          ' A of closest bands.')

      write(6,58)       NFILTDEF_SURVEY_ORIG, NFILTDEF_SURVEY
 58   format(T8,'NFILTDEF_SURVEY = ',I3,' -> ', I3)

c -------------------------------------------------
c re-read KCOR file to include FILTLIST_FITRESTMAG
c (user must make sure that FILTLIST_FITRESTMAG is in the kcor file)

      CALL RDKCOR(KCOR_FILE,IERR)

      CALL CDTOPDIR_OUTPUT  ! back to topdir

c check that added filter(s) are all in the KCOR file.
c Abort if any filter is missing.

      DO 200 i = 1, NFILT
         CFILT          = FILTLIST_FITRESTMAG(i:i)
         IFILTDEF       = IFILTDEF_FITRESTMAG(i)
         IF ( .NOT. LFILTDEF_OBS(ifiltdef)  ) THEN
           c1err = 'FILTLIST_FITRESTMAG = ' // cfilt // 
     &            ' is not in kcor file.'
           c2err = 'Check ' // KCOR_FILE
           CALL MADABORT("FITRESTMAG_INI", c1err, c2err )
         ENDIF
200   CONTINUE

c set flag so that SURVEY_FILTERS are NOT re-read
c if another version header is read.
      FREEZE_SURVEY_FILTERS = .TRUE.
      
      RETURN
      END

C =====================================
+DECK,FITRESTMAG_PREP.
      SUBROUTINE FITRESTMAG_PREP(ITER)

c Feb 12, 2012
c Called before fit-iteration ITER to prepare fit-iteration ITER
c for fitting FILTLIST_FITRESTMAG. Do nothing for first 1/2 of iterations
c to get t0 and stretch. For 2nd half of iterations keep only
c the two observer bands that bracket FILTLIST_FITRESTMAG.
c 
c
c Apr 24 2014:
c  Re-do SNRMAX logic; apply cut to mask filters before calling
c  BRACKET_IFILT_OBS() function, rather than applying SNRMAX cut
c  to the filters found by BRACKET_IFILT_OBS.  New logic is more
c  efficient. Should fix problem at z ~ 0.4 in which g&r are 
c  BRACKET filters but then g fails SNRMAX cut; now it will find
c  r&i instead.
c
c Dec 3 2014: for photo-z fit, set Z=ZPHOT instead of SNLC_REDSHIFT.
c
c Mar 26 2020
c  Refactor to use new BRACKET_FILTERLIST with DLAM_TOL so that 
c  more than 2 bands can be included if some bands have very 
c  similar central wavelengths. 
c
c -----------------------

      IMPLICIT NONE

c subroutine args

      INTEGER ITER ! (I) SN index and fit iteration

c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FITRESTCOM.

      INTEGER  
     &   i, IFILT, IFILTDEF, IFILT_TMP, IF1, IF2
     &  ,J, JKEEP, LL, NBRA, NTRY, itry, ITERLAST, IPAR
     &  ,IFILTDEF_MAP_SAVE(MXFILT_OBS)

      REAL LAMAVG, LAMREST(3), LAMTMP, Z, DLAM_TOL
      REAL SNRMAX, SNRMAX1, SNRMAX2
      CHARACTER CFILTOBS_LIST*(MXFILT_OBS), CTMP*4, CFILTDEF*2

      LOGICAL L_BRACKET, L_MATCH, L_USE, L_SNR, L_KEEP
      LOGICAL SKIPTEST, LSNR, LSNR1, LSNR2

c function
      INTEGER BRACKET_FILTERLIST, BRACKET_IFILT_OLD

c -------------------- BEGIN ----------------

      IF ( ITER .EQ. 1 ) NLCPLOT_FITRESTMAG = 0  ! reset plot-counter

c default flag is NOT 2-band fit; 
c setting IFILTOBS_BRACKET below --> 2-band fit
      IFILTOBS_BRACKET(1) = -999
      IFILTOBS_BRACKET(2) = -999

c check global flag
      IF ( NFILTDEF_FITRESTMAG .LE. 0 ) RETURN

c bail on the nominal ALLFILT interations
      IF ( ITER .LE. NFIT_ITERATION_ALLFILT ) RETURN

c =============================================
c store ALLFILT results just before doing first 2-band fit

      IF ( ITER .EQ. NFIT_ITERATION_ALLFILT + 1 ) THEN

         DO i = 1, NFILTDEF_FITRESTMAG
            FITRESTMAG(i)     = 999.
            FITRESTMAG_ERR(i) = 999.
         ENDDO 

c store original USE_FILT(IFILT) and FITPAR to keep track of which
c filters can be used.
         ALLFILTLIST_FIT   = FILTLIST_FIT_USE 
         NOBS_ALLFILT      = NFILT_OBS_USEFIT 
         DO IFILT = 1, MXFILT_ALL
           USE_ALLFILT(IFILT) = USE_FILT(IFILT)
         ENDDO

         DO ipar = 1, MXFITPAR
             FITVAL_ALLFILT(ipar) = FITVAL(ipar,ITER-1)
             FITERR_ALLFILT(ipar) = FITERR(ipar,ITER-1)
         ENDDO

      ENDIF

c -------------------------------------------
c reset global list of filters to fit.
      FILTLIST_FIT_USE = ''
      NFILT_OBS_USEFIT = 0

c always restore INIVAL and INISTP
c Note that 1st IPAR_ITER param is not restored.

      DO ipar = 1, MXFITPAR  
         IF ( ipar .NE. IPAR_ITER ) then
           INIVAL(ipar)  = FITVAL_ALLFILT(ipar) 
           INISTP(ipar)  = FITERR_ALLFILT(ipar) 
         ENDIF
      ENDDO

c -----------------------------------------------------------
c if done with all 2-band fits, do nominal fit again so that
c analysis variables correspond to nominal fit rather than
c to the last 2-band fit.

      ITERLAST = ITERLAST_FITRESTMAG(NFILTDEF_FITRESTMAG)
      IF ( ITER .GT. ITERLAST ) THEN

         FILTLIST_FIT_USE = ALLFILTLIST_FIT
         NFILT_OBS_USEFIT = NOBS_ALLFILT

         DO IFILT = 1, MXFILT_ALL
           USE_FILT(IFILT) = USE_ALLFILT(IFILT)
         ENDDO 

         RETURN   ! bail out on last ALLFIT iteration
      ENDIF

c set tolerance for including bands close in wavelength
      DLAM_TOL = DLAMTOL_FITRESTMAG

c =========================================

c strip off filter to process for this fit-iteration
      IFILTDEF = IFILTDEF_ITER_FITRESTMAG(ITER)
      CFILTDEF = FILTDEF_STRING(IFILTDEF:IFILTDEF)
      if ( IFILTDEF .LE. 0 .OR. IFILTDEF .GT. MXFILT_ALL ) then
         write(C1ERR,161) ITER,IFILTDEF
161      format('Invalid IFILTDEF_ITER_FITRESTMAG(ITER=',I2,') = ', I4)
         C2ERR = 'Check FILTLIST_FITRESTMAG in &FITINP'
         CALL MADABORT('FITRESTMAG_PREP', C1ERR, C2ERR)
      endif


c for remainder of the iterations (i.e., 2-band fits)
c  - float only color and distance/x0 (i.e,, fix PKMJD and LUMIPAR)
c  - keep only observer bands that bracket FILTLIST_FITRESTMAG
c  - fix redshift (for photo-z fits)

      INISTP(IPAR_SHAPE)     = 0.0  ! fix stretch/lumipar parameter
      INISTP(IPAR_PEAKMJD)   = 0.0  ! fix time of peak     

      IF ( DOFIT_PHOTOZ ) THEN
         ipar = IPAR_zPHOT
         INISTP(ipar) = 0.0 
         Z    =  FITVAL_ALLFILT(ipar) 
      ELSE
         Z  = SNLC_REDSHIFT
      ENDIF

c set list of LAMREST to try.
      LAMAVG        = FILTOBS_LAMAVG(ifiltdef)
      LAMREST(1)    = LAMAVG
      LAMREST(2)    = LAMAVG + LAMEXTRAP_FITRESTMAG
      LAMREST(3)    = LAMAVG - LAMEXTRAP_FITRESTMAG
      IF ( LAMEXTRAP_FITRESTMAG .GT. 0.1 ) THEN
         NTRY = 3
      ELSE
         NTRY = 1
      ENDIF

c ---------------------------------------------------
c Find obs-filters that bracket FILTLIST_FITRESTMAG
c Before searching for two nearest bands,  EXCLUDE filter if
c   * it's a FITRESTMAG filter (so it does not find itself)
c   * it fails SNRMAX cut  e.g., if g&r are the closest two bands
c     but g fails SNRMAX cut, the BRACKET function will return
c     ri instead.
c
c Note that loop is over ALL filters, not just FITRESTMAG filters.
c

      DO ifilt = 1, NFILTDEF_SURVEY

         IFILTDEF_MAP_SAVE(ifilt) = IFILTDEF_MAP_SURVEY(ifilt) 
         IFILTDEF                 = IFILTDEF_MAP_SURVEY(ifilt)  !absolute indx
         if ( ifilt .GT. NFILTDEF_SURVEY_ORIG ) then
            IFILTDEF_MAP_SURVEY(ifilt) = -999
         endif

         ! apply SNRMAX cut only if SNRMAX is defined
         SNRMAX   = SNLC_SNRMAX_FILT(ifilt)
         SKIPTEST = .not. LFILTDEF_SNRMAX(IFILTDEF)
         LSNR     = SKIPTEST .or. (SNRMAX .GE. CUTWIN_SNRMAX2(1) )

         if ( .NOT. LSNR ) then
            IFILTDEF_MAP_SURVEY(ifilt) = -999
         endif
      ENDDO  ! end ifilt loop over all filters

c -----------------------

      L_BRACKET = .FALSE.
      DO 440 itry = 1, NTRY

c Sep 2013: beware that BRACKET_IFILT_OBS() checks all filters 
c selected by snana, not just the ones in FILTLIST_FIT.
c Use EPCUT_SNRMIN to reject extra filters.

         LAMTMP = LAMREST(itry)

c new default, Mar 28 2020
          NBRA = BRACKET_FILTERLIST(LAMTMP, DLAM_TOL, Z, 
     &            IFILTOBS_BRACKET) ! <== returned

         IF1 = IFILTOBS_BRACKET(1)  ! closest band, low wavelen
         IF2 = IFILTOBS_BRACKET(2)  ! closest band, high wavelen

+SELF,IF=XYZDEL.
         print*, ' xxx ------------------------------------------ '
         print*, ' xxx NBRA, itry = ', NBRA, itry
         print*, ' xxx LAMREST =', LAMREST(itry),'   z=',Z
         print*, ' xxx --> IF1,IF2 = ', IF1, IF2
         print*, ' xxx --> BAND1,2 = ', 
     &         FILTDEF_STRING(IF1:IF1), FILTDEF_STRING(IF2:IF2)
         call flush(6)
+SELF.

         IF ( IF1 .LE. 0 ) GOTO 440
         IF ( IF2 .LE. 0 ) GOTO 440

c check if IFILTOBS_BRACKET(1:2) are valid
         L_USE = USE_ALLFILT(IF1) .and. USE_ALLFILT(IF2)
c xxx mark del L_BRACKET = (NBRA .EQ. 2) .and. L_USE
         L_BRACKET = (NBRA >= 2) .and. L_USE

         if ( L_BRACKET ) goto 444
440   CONTINUE  ! end itry

c --------------------
444   CONTINUE

c ------------------
c reset filter map

      DO ifilt = 1, NFILTDEF_SURVEY
         IFILTDEF_MAP_SURVEY(ifilt) = IFILTDEF_MAP_SAVE(ifilt)
      ENDDO

      IF ( .NOT. L_BRACKET ) GOTO 455


c print message for which filter to fit, or to skip.
455   CONTINUE

      IF ( L_BRACKET ) THEN
         do i = 1, NBRA
            IFILTDEF = IFILTOBS_BRACKET(i) 
            CFILTOBS_LIST(i:i) =  FILTDEF_STRING(IFILTDEF:IFILTDEF)
         enddo
         CTMP     = 'Fit ' 
      ELSE
         CTMP     = 'Skip' 
         CFILTOBS_LIST =  '??'
      ENDIF

      LL = ISNLC_LENCCID
      write(6,20) CTMP, CFILTDEF,
     &     SNLC_CCID(1:LL), CFILTOBS_LIST(1:NBRA)
20    format(T5, A,' RestMag-',A,'  for  CID = ',A, 
     &               3x, 'ObsFilt = ',A,A) 
      CALL FLUSH(6)


c Turn off filters that do not bracket FILTLIST_FITRESTMAG.
c If either of the BRACKET filters is not defined then
c turn off ALL filters so that nothing passes.


      DO 200 ifilt   = 1, NFILTDEF_SURVEY

         L_KEEP      = .FALSE.
         L_USE       = .FALSE.

         IFILT_TMP   = IFILTDEF_MAP_SURVEY(ifilt)
         L_USE       = USE_ALLFILT(IFILT_TMP)
         
      DO 202 j       = 1, NBRA  ! xxx 2 -> NBRA
           L_MATCH   = IFILT_TMP .EQ. IFILTOBS_BRACKET(J)            
           IF ( L_BRACKET .and. L_MATCH .AND. L_USE ) THEN
               L_KEEP  = .TRUE.
               JKEEP = J
           ENDIF
 202  CONTINUE  ! J

         if ( L_KEEP ) then
            LL = INDEX ( FILTLIST_FIT_USE, ' ' ) - 1
            FILTLIST_FIT_USE = FILTLIST_FIT_USE(1:LL) // 
     &            cfiltobs_list(jkeep:jkeep)
            NFILT_OBS_USEFIT = NFILT_OBS_USEFIT + 1
            USE_FILT(IFILT_TMP) = .TRUE.
         else
            USE_FILT(IFILT_TMP) = .FALSE.
         endif

 200  CONTINUE  ! ifilt

c --------------------
c sanity check

      IF ( L_BRACKET .and. NFILT_OBS_USEFIT < 2 ) THEN
         write(c1err,601)  NFILT_OBS_USEFIT 
601      format('L_BRACKET=T  but  NFILT_OBS_USEFIT = ',I2)
         write(c2err,602) SNLC_CCID, ITER, CFILTDEF
602      format('CID=',A8, 2x, 'ITER=',I1,' -> RestFilt=',A1)
         CALL MADABORT('FITRESTMAG_PREP', C1ERR, C2ERR)
      ENDIF

+SELF,IF=XXXDBG.
      print*,' xxx -------------------------------------------- '
      print*,' xxx LAMREST, Z =', LAMREST, Z
      print*,' xxx BRACKET-IFILTOBS = '
     &      ,IFILTOBS,' -> ', CFILT(1), CFILT(2)
      print*,' xxx LOK = ', LOK
      CALL FLUSH(6)
+SELF.

      RETURN
      END    ! end of FITRESTMAG_PREP(ITER)


C ========================================
+DECK,BRACKET_IFILT_OLD.
      INTEGER FUNCTION BRACKET_IFILT_OLD ( 
     &          LAMREST, Z, IFILTOBS_BRACKET )

c !!!!!!!!!!!!!!!!!!!
c !!!! Mar 25 2020: SLATED TO BECOME OBSOLETE !!!!
c !!!!!!!!!!!!!!!!!!!
c -----------------------------------------
c Feb 12, 2012
c Return IFILTOBS_BRACKET(2) (filter indices) that brackets
c LAMREST in the rest-frame. In the loop over SURVEY filters, 
c IFILT_OBS = -999 is a flag to ignore this filter.
c
c Return number of bracket-filters found; 2 => success.
c
c ------------------------------------------

      IMPLICIT NONE

c subroutine args.

      REAL LAMREST   ! (I) rest-frame lambda to match
      REAL Z         ! (I) redshift
      INTEGER 
     &  IFILTOBS_BRACKET(2) ! (O) IFILTOBS that brackets LAMREST

c local var
+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IFILT, IFILTOBS, JLOHI, NFILT
      REAL Z1, LAMZ, LAMDIF, LAMDIFMIN(2)

C ------------- BEGIN ------------

      Z1 = 1.0 + z

      LAMDIFMIN(1) = 99999999.
      LAMDIFMIN(2) = 99999999.

      IFILTOBS_BRACKET(1) = -9 
      IFILTOBS_BRACKET(2) = -9

      DO 100 ifilt = 1, NFILTDEF_SURVEY

         if ( .not. EXIST_FILT(ifilt) ) goto 100

         ifiltobs = IFILTDEF_MAP_SURVEY(ifilt)
         if ( ifiltobs .EQ. -999 ) goto 100
         
         LAMZ   = FILTOBS_LAMAVG(ifiltobs)/Z1
         LAMDIF = ABS(LAMZ-LAMREST)

         IF ( LAMZ .LE. LAMREST ) THEN
            JLOHI = 1
         ELSE
            JLOHI = 2
         ENDIF

         if ( LAMDIF .LT. LAMDIFMIN(JLOHI) ) then
             LAMDIFMIN(JLOHI)        = LAMDIF
             IFILTOBS_BRACKET(JLOHI) = IFILTOBS
         endif

100   CONTINUE

c set function value

      NFILT = 0
      IF ( IFILTOBS_BRACKET(1) .GT. 0 ) NFILT = NFILT + 1
      IF ( IFILTOBS_BRACKET(2) .GT. 0 ) NFILT = NFILT + 1

      BRACKET_IFILT_OLD = NFILT

      RETURN
      END   

C ========================================
+DECK,BRACKET_FILTERLIST.
      INTEGER FUNCTION BRACKET_FILTERLIST ( 
     &          LAMREST, DLAM_TOL, Z, IFILTOBS_BRACKET )

c -----------------------------------------
c Mar 25 2020
c Return IFILTOBS_BRACKET (indices) of obs-filters that bracket
c LAMREST in the rest-frame. 
c In the loop over SURVEY filters, IFILT_OBS = -999 is a flag
c (externally set) to ignore this filter.
c
c This function originally returned just 2 bands: one below and
c one above the target LAMREST. Now it has been refactored to
c return all filters within DLAM_TOL of closest filters.
c
c Original motivatoin is to work for LOWZ in which each band 
c is broken into several bands covering different time periods.
c 
c
c Inputs:
c   LAMREST   : rest-frame wavelength to bracket
c   DLAM_TOL  : combine obs filters withing this tolerance
c   Z         : redshift
c  
c Output:
c   IFILTOBS_BRACKET(1) : closest band with LAM/z1 < LAMREST
c   IFILTOBS_BRACKET(2) : closest band with LAM/z1 > LAMREST
c   IFILTOBS_BRACKET(3) : optional additional band within DLAM_TOL
c   IFILTOBS_BRACKET(4) : optional additional band within DLAM_TOL
c   etc ...
c
c Function returns number of bands in IFILTOBS_BRACKET list.
c If only low or high bands are found, function returns 1.
c Function returnig 2 or larger is flag for success.
c Example, if filters a,b,c all have LAM/z1 < LAMREST, then
c function returns 1. But if there is also filter d with 
c LAM/z1>LAMREST, then function returns 4.
c
c ------------------------------------------

      IMPLICIT NONE

c subroutine args.

      REAL LAMREST   ! (I) rest-frame lambda to match
      REAL DLAM_TOL  ! (I) tolerance to accept multiple bracket filters
      REAL Z         ! (I) redshift

      INTEGER 
     &  IFILTOBS_BRACKET(*) ! (O) IFILTOBS that brackets LAMREST

c local var
+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IFILT, NFILT, IFILTOBS, IFILTOBS_LO, IFILTOBS_HI, JLOHI
      REAL    Z1, LAMZ, LAMZ_LO, LAMZ_HI, LAMDIF, LAMDIFMIN(2)
      CHARACTER  CFILT*2

C ------------- BEGIN ------------

      Z1 = 1.0 + z

      LAMDIFMIN(1) = 99999999.
      LAMDIFMIN(2) = 99999999.

      DO 100 ifilt = 1, NFILTDEF_SURVEY

         if ( .not. EXIST_FILT(ifilt) ) goto 100
         ifiltobs = IFILTDEF_MAP_SURVEY(ifilt)
         if ( ifiltobs .EQ. -999 ) goto 100

         CFILT  = FILTDEF_STRING(IFILTOBS:IFILTOBS)         
         LAMZ   = FILTOBS_LAMAVG(ifiltobs)/Z1
         LAMDIF = ABS(LAMZ-LAMREST)

         IF ( LAMZ .LE. LAMREST ) THEN
            JLOHI = 1
         ELSE
            JLOHI = 2
         ENDIF

         if ( LAMDIF .LT. LAMDIFMIN(JLOHI) ) then
             LAMDIFMIN(JLOHI)        = LAMDIF
             IFILTOBS_BRACKET(JLOHI) = IFILTOBS
         endif

100   CONTINUE

c set function value

      NFILT = 0
      IFILTOBS_LO = IFILTOBS_BRACKET(1)
      IFILTOBS_HI = IFILTOBS_BRACKET(2)
      IF ( IFILTOBS_LO > 0 ) NFILT = NFILT + 1
      IF ( IFILTOBS_HI > 0 ) NFILT = NFILT + 1
      BRACKET_FILTERLIST = NFILT

      IF ( NFILT < 2       ) RETURN
      IF ( DLAM_TOL < 0.01 ) RETURN

cc      IF ( DLAM_TOL < 1.0E9 ) RETURN ! xxx REMOVE

      LAMZ_LO = FILTOBS_LAMAVG(IFILTOBS_LO)/Z1
      LAMZ_HI = FILTOBS_LAMAVG(IFILTOBS_HI)/Z1

c if we get here, check for more bands with DLAM_TOL ...

      DO 200 ifilt = 1, NFILTDEF_SURVEY

         if ( .not. EXIST_FILT(ifilt) ) goto 200
         ifiltobs = IFILTDEF_MAP_SURVEY(ifilt)
         if ( ifiltobs .EQ. -999 ) goto 200

c skip already defined bracket filters
         if ( ifiltobs == IFILTOBS_LO ) goto 200
         if ( ifiltobs == IFILTOBS_HI ) goto 200

         LAMZ   = FILTOBS_LAMAVG(IFILTOBS)/Z1

c start with lower-wavelength filter
         LAMDIF = ABS(LAMZ-LAMZ_LO)
         if ( LAMZ < LAMZ_LO .and. LAMDIF < DLAM_TOL ) then
            NFILT = NFILT + 1 ; IFILTOBS_BRACKET(NFILT) = ifiltobs
         endif

c higher-wavelength filter
         LAMDIF = ABS(LAMZ-LAMZ_HI)
         if ( LAMZ > LAMZ_HI .and. LAMDIF < DLAM_TOL ) then
            NFILT = NFILT + 1 ; IFILTOBS_BRACKET(NFILT) = ifiltobs
         endif

 200  CONTINUE

      BRACKET_FILTERLIST = NFILT

      RETURN
      END

C =====================================
+DECK,FITRESTCALC.
      SUBROUTINE FITRESTMAG_CALC(ITER)
c
c Feb 2012:
c If ITER corresponds to the last iteration for a rest-filter,
c compute and fill global FITRESTMAG and FITRESTMAG_IERR
c
c Sep 19 2013: call SNLCPAK to show each single-band fit
c
c Dec 11, 2014: return if ITER > ITERLAST_2BAND to allow more
c                than 1 fit after the 2-band fits.
c ----------------------------------

      IMPLICIT NONE

c subroutine args

      INTEGER ITER ! (I) SN index and fit iteration

c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FITRESTCOM.

      INTEGER 
     &   IFILTDEF, IFILT, NFUNPLOT, ITERLAST_2BAND
     &  ,LCHAR_CCID, LCHAR_SHAPE, LCHAR_COLOR

      REAL*8  
     &   SHAPE_FIT, COLOR_FIT, Z, x0, x0err, x0ref
     &  ,SHAPE, COLOR, MAGCOR

      CHARACTER CFILT*2, CCID*(MXCHAR_CCID)

c function
      REAL*8  GET_DIST8
      LOGICAL DOPLOT_SNLC

C ----------- BEGIN -----------

      IF ( NFILTDEF_FITRESTMAG .LE. 0       ) RETURN
      IF ( ITER .LE. NFIT_ITERATION_ALLFILT ) RETURN
ccc mark for deletion      IF ( ITER .EQ. NFIT_ITERATION  ) RETURN

      ITERLAST_2BAND = ITERLAST_FITRESTMAG(NFILTDEF_FITRESTMAG)
      IF ( ITER > ITERLAST_2BAND ) RETURN

c get absolute filter index of rest-frame filter
      IFILTDEF = IFILTDEF_ITER_FITRESTMAG(ITER) 
      IFILT    = IFILTSP_ITER_FITRESTMAG(ITER)

c ---------------------------------------
c sanity check on filter indices

      IF (     IFILTDEF .LE. 0  
     &   .or.  IFILTDEF .GT. MXFILT_ALL 
     &   .or.  IFILT    .LE. 0
     &   .or.  IFILT    .GT. MXFILT_FITRESTMAG
     &     ) THEN
         write(c1err,611) IFILTDEF, IFILT
611        format('Invalid  IFILTDEF=', I5, 3x,'IFILT=',I3)
         write(c2err,612) SNLC_CCID, ITER
612        format('for CID=', A8, 3x, 'and ITER=' ,I2)
         CALL MADABORT('FITRESTMAG_CALC', C1ERR, C2ERR)
      ENDIF
c ---------------------------------------

c proceed with calc only on last iteration for this filter.
      IF ( ITER .NE. ITERLAST_FITRESTMAG(ifilt) ) RETURN

c save fitted SHAPEPAR in case we use a fixed SHAPEPAR for restMag
      SHAPE_FIT  = LCVAL_STORE(IPAR_SHAPE)
      COLOR_FIT  = LCVAL_STORE(IPAR_COLOR)

c set LCVAL_STORE to get rest-frame mag

      IF ( SHAPEFIX_FITRESTMAG .LT. 990.0 ) THEN
        LCVAL_STORE(IPAR_SHAPE) = SHAPEFIX_FITRESTMAG
      ENDIF
      IF ( COLORFIX_FITRESTMAG .LT. 990.0 ) THEN
        LCVAL_STORE(IPAR_COLOR) = COLORFIX_FITRESTMAG
      ENDIF

c store fit-info in local variables (before they get restored!)
      CFILT   = FILTDEF_STRING(IFILTDEF:IFILTDEF)
      SHAPE   = DBLE( LCVAL_STORE(IPAR_SHAPE) )
      COLOR   = DBLE( LCVAL_STORE(IPAR_COLOR)   )

c put this filter on the 'EVAL' list
      CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,ifiltdef), ifiltdef )

c compute peakmag
      CALL PEAKMAG_CALC(ifiltdef, 'REST') 

c restore nominal values 
      LCVAL_STORE(IPAR_SHAPE)   = SHAPE_FIT
      LCVAL_STORE(IPAR_COLOR)   = COLOR_FIT

c PEAKMAG_REST was evaluated for the best-fit model assuming 
c DLMAG=0 or x0=1. But we need the standardization part of x0.
c WARNING: Below is hard-wired for SALT2 ... need to fix for mlcs/snoopy.

      Z      = DBLE(REDSHIFT_FIT)
      x0     = LCVAL_STORE(IPAR_DLMAG)     ! from fit with SHAPE floated
      x0err  = LCERR_STORE(IPAR_DLMAG)     ! idem
      x0ref  = GET_DIST8(Z,SHAPE_FIT,COLOR_FIT,ONE8)
      MAGCOR = -2.5*log10(x0/x0ref)
cc      print*,' xxx MAGCOR = ', MAGCOR,'  for CID=', SNLC_CCID

c save fitted rest mag and error
      FITRESTMAG(IFILT)     = PEAKMAG_REST_MODEL(ifiltdef)
     &                      + MAGCOR

c      FITRESTMAG_ERR(IFILT) = PEAKMAG_REST_MODEL_ERR(ifiltdef)
      FITRESTMAG_ERR(IFILT) = 1.0857*x0err/x0     ! Mar 30 2014

c ------------------------
c print one-line summary.

      LCHAR_CCID  = ISNLC_LENCCID
      LCHAR_SHAPE = INDEX(PARNAME_STORE(IPAR_SHAPE),' ') - 1
      LCHAR_COLOR = INDEX(PARNAME_STORE(IPAR_COLOR),  ' ') - 1

      write(6,20) 
     &    CFILT(1:1)
     &   ,SNLC_CCID(1:LCHAR_CCID)
     &   ,FITRESTMAG(IFILT), FITRESTMAG_ERR(IFILT)
     &   ,PARNAME_STORE(IPAR_SHAPE)(1:LCHAR_SHAPE),  SHAPE
     &   ,PARNAME_STORE(IPAR_COLOR)(1:LCHAR_COLOR),  COLOR

20    format(T5,'FitRestMag-',A,'(',A,') = ', F8.3,' +- ' , F6.3,
     &   3x, '(',A,'=',F6.3,  2x,  A,'=',F6.3, ')'   )


c -----------------------------------------------------
c for SALT2, get K-corrected FLUX_REST (Jan 2014)

      IF ( FITMODEL_INDEX .EQ. MODEL_SALT2 ) THEN
         CALL SALT2_FLUXREST(IFILTDEF,SHAPE,COLOR)
      ENDIF

c --------------------------
c check option for single-band plot (Sep 2013)
      
      IF ( DOPLOT_SNLC() ) THEN

         NLCPLOT_FITRESTMAG = NLCPLOT_FITRESTMAG + 1
         IF ( NLCPLOT_FITRESTMAG .EQ. 1 ) THEN
c problem: if next fit fails we have already committed
c          to NFUNPLOT plots ???
            NFUNPLOT = NFILTDEF_FITRESTMAG + 1 
            CALL SNLCPAK_NFIT(NFUNPLOT)  ! store NFIT
         ENDIF

         CCID = SNLC_CCID(1:LCHAR_CCID) // char(0)
         CALL MAKEDIR_OUTPUT(CCID, SNLC_CID, LCHAR_CCID)
         CALL FITANA_STORE()
         CALL SNLCPLOT()   
         CALL CDTOPDIR_OUTPUT()  ! back to topdir
      ENDIF

      RETURN
      END   ! FITRESTMAG_CALC


C ========================================
+DECK,S2FLREST.
      SUBROUTINE SALT2_FLUXREST(IFILTREST,SHAPE,COLOR)
c ---------------------
c
c Created Jan 2014 by R.Kessler
c
c For each epoch, compute K-correction and load EP_FLUX_REST array.
c
c Dec 31, 2014:   fill I4EP_ALL(ep,IEP_IFILT_REST1) 
c
c ---------------------

      IMPLICIT NONE

c subroutine args
      INTEGER IFILTREST      ! (I) absolute value of rest-frame filter
      REAL*8  SHAPE, COLOR   ! (I) 

c local args

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,FITRESTCOM.

      INTEGER 
     &   IF1, IF2, IFILTOBS, IFILT, IMJD
     &   ,MSKSALT2, NEP, EP, EPMIN, EPMAX

      REAL*8  
     &   z1, ZSN, LAMREST, LAMDIF1, LAMDIF2, LAMDIF
     &  ,x0, x1, xx1, c, MWEBV, PKMJD
     &  ,TOBS, Trest, MAGOBS_MODEL, MAGREST_MODEL, MAGERR
     &  ,KCOR, MAGOBS, MAGREST, FLUX_REST, ARG
     &  ,RV, AV,  PARLIST_SN(10), PARLIST_HOST(10)

      LOGICAL LDMP 
C ----------------- BEGIN -----------------
C
C determine which of the IFILTOBS_BRACKET is closest to IFILTDEF(rest)
C Note that the rest-frame filter is defined as an obs-filter.

      LDMP = .FALSE.

      Z1      = 1.0 + REDSHIFT_FIT
      LAMREST = FILTOBS_LAMAVG(ifiltrest)
      IF1     = IFILTOBS_BRACKET(1)
      IF2     = IFILTOBS_BRACKET(2)
      LAMDIF1 = ABS(FILTOBS_LAMAVG(IF1)/z1 - LAMREST)
      LAMDIF2 = ABS(FILTOBS_LAMAVG(IF2)/z1 - LAMREST)
      MWEBV   = SNLC_MWEBV

      IF (LAMDIF1 < LAMDIF2 ) THEN
        IFILTOBS = IF1 ; LAMDIF = LAMDIF1
      ELSE
        IFILTOBS = IF2 ; LAMDIF = LAMDIF2
      ENDIF

      IF ( LDMP ) THEN
        print*,' xxxxx ------------------------------------- '
        write(6,60) SNLC_CCID, IFILTREST, IFILTOBS, LAMDIF
 60     format(' xxxxx CID=', A6, 2x,'IFILT[REST,OBS]=',2I3, 3x,
     &          'LAMDIF=',F5.0 )
      ENDIF

      MSKSALT2 = 0   ! -> return mag
      x0       = 1.0
      x1       = SHAPE
      xx1      = SHAPE
      c        = COLOR
      NEP      = 1
      PKMJD    = LCVAL_STORE(IPAR_PEAKMJD) + MJDOFF
      RV=0.0 ;   AV=0.0

      PARLIST_SN(1) = x0
      PARLIST_SN(2) = x1
      PARLIST_SN(3) = xx1
      PARLIST_SN(4) = c

      PARLIST_HOST(1) = RV
      PARLIST_HOST(2) = AV
      PARLIST_HOST(3) = -9.0 ! logmass

      DO 101 IMJD      = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,IMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,IMJD)

      DO 102 ep = EPMIN, EPMAX

         IF ( IFILTOBS .NE.  ISNLC_IFILT_OBS(ep) ) GOTO 102
      
         ifilt = IFILTDEF_INVMAP_SURVEY(ifiltobs)

c start with obs-frame
         TOBS    = SNLC8_MJD(ep) - PKMJD 
         Trest   = TOBS/z1

         ZSN     = REDSHIFT_FIT
         CALL genmag_salt2( MSKSALT2, IFILTOBS,
     &        PARLIST_SN, PARLIST_HOST, MWEBV, ZSN,ZSN,  NEP, Tobs,
     &        MAGOBS_MODEL, MAGERR )     ! return arg

c now the rest-frame
         ZSN     = 1.0E-6
         CALL genmag_salt2( MSKSALT2, IFILTREST, 
     &        PARLIST_SN, PARLIST_HOST, MWEBV, ZSN,ZSN, NEP, Trest,
     &        MAGREST_MODEL, MAGERR )     ! return arg

         KCOR    = MAGREST_MODEL - MAGOBS_MODEL
         MAGOBS  = R4EP_ALL(ep,JEP_DATAMAG)

         IF ( MAGOBS > 0 ) THEN
           MAGREST    = MAGOBS + KCOR - SNLC_DLMAG
           ARG        = 0.4*(ZEROPOINT_FLUXCAL_DEFAULT - MAGREST)
           FLUX_REST  = 10.0**(ARG)
           R4EP_ALL(ep,JEP_DATAFLUX_REST) = FLUX_REST
           I4EP_ALL(ep,IEP_IFILT_REST1)   = IFILTREST
         ELSE
           MAGREST   = -999
           FLUX_REST = -999
         ENDIF

         IF ( LDMP ) THEN
           write(6,61) Trest, MAGOBS, MAGREST
 61        format(' xxxx Trest=',F6.1, 2x, 'MAG[OBS,REST]=',2G12.5 )
           call flush(6)
         ENDIF

 102  CONTINUE  ! ep
 101  CONTINUE  ! IMJD

      RETURN
      END

C ========================================
+DECK,GTFITRST.
      SUBROUTINE GET_FITRESTMAG(IFILT, MAGREST, MAGERR)

C created Mar 2013.
C Return fitted rest-mag and error for this sparse IFILT.
C
      IMPLICIT NONE
      INTEGER  IFILT            ! (I) sparse filter index
      REAL     MAGREST, MAGERR  ! (O)

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.
+CDE,FITRESTCOM.
C ----------- BEGIN ----------
      MAGREST = FITRESTMAG(ifilt)
      MAGERR  = FITRESTMAG_ERR(ifilt)
      RETURN
      END


C =======================================
+DECK,LFITFUN_FILT.
      LOGICAL FUNCTION LFITFUN_FILT(ifilt_obs,ZTEST)
c
c Return T if this filter should be included in fit.
c
c ZTEST > 0 => make z-dependent tests
c ZTEST < 0 => skip z-dependent tests
c 
c
c May 20, 2008: use sparse 'ifilt' index for EXIST_FILT
c May 04, 2009: test RESTLAMBDA_MODEL
c Aug 07, 2009: add ZTEST arg to separate z-dependent & z-independent tests;
c               Needed for PHOTOZ fits
c
c Aug 12, 2009: test PHOTOZ_DROPFILTER for photoz fits only
c
c Nov 26, 2012: RESTLAMBDA_MODEL -> RESTLAMBDA_USEFIT
c
c Jul 19, 2013: 
c   modify logic for no epocs; see NOEPOCH and ISSURVEY
c   Note that NONSURVEY_FILTERS are kept if redshift is valid
c   to allow getting fitted model for NONSURVEY_FILTERS.
c
c ---------------------

      IMPLICIT NONE

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.

      INTEGER 
     &  ifilt_obs  ! (I) observer filter index

      REAL*8 ZTEST

c local

      INTEGER IFILT_REST, IFILT, OPT
      REAL*8 oneplusZ, LAMZ
      REAL*4 Z4, LMIN4

      LOGICAL DOTEST_Z
      LOGICAL DOTEST_NONZ, ISSURVEY, NOEPOCHS

c function
      INTEGER NEAREST_IFILT_REST

C --------------- BEGIN ----------------

      LFITFUN_FILT = .FALSE.

c did user request this filter.
      if ( .NOT. DOFIT_FILT(ifilt_obs) ) RETURN

c are there any epochs with this filter.
      ifilt = IFILTDEF_INVMAP_SURVEY(ifilt_obs)
      ISSURVEY = .NOT. LFILTDEF_NONSURVEY(ifilt_obs) 
      NOEPOCHS = .NOT. EXIST_FILT(ifilt) 
      if ( ISSURVEY .and. NOEPOCHS ) RETURN

      IF ( DOFIT_PHOTOZ ) THEN
        if ( PHOTOZ_DROPFILTER(ifilt_obs)) RETURN ! drop this filter
      ENDIF

c -----------------------------------

      IF ( ZTEST .GT. 0.0 ) THEN

c does this observer filter transform to a valid 
c rest-frame lambda range

        oneplusZ  = 1.0 + ZTEST
        LAMZ  = FILTOBS_LAMAVG(ifilt_obs) / oneplusZ

        IF ( LAMZ .LT. RESTLAMBDA_USEFIT(1) ) RETURN
        IF ( LAMZ .GT. RESTLAMBDA_USEFIT(2) ) RETURN

c does this observer filter transform to a valid rest-frame filter

        IF ( LREST_FITMODEL ) THEN
          Z4  = SNGL(ZTEST) 
          OPT = OPT_FILTOBS
          ifilt_rest = NEAREST_IFILT_REST(OPT,ifilt_obs,1,Z4,LMIN4)
          if ( ifilt_rest .LE. 0. ) RETURN
        ENDIF
      ENDIF


c all is OK.

      LFITFUN_FILT = .TRUE.

      RETURN
      END

C =======================================
+DECK,LNDLT_PREP.
      SUBROUTINE LANDOLT_PREP
c
c Created Feb 10, 2012
c
c Init stuff related to OPT_LANDOLT.
c Pulled out of FITPAR_PREP.
c
c May 2012: if BX is defined in the KCOR file but is not
c           a SURVEY_FILTER, then define X here as a SURVEY_FILTER.
c           This part was moved from RDKCOR.
c
c ------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER ISTAT, IFILT, i
      CHARACTER CTMP*8
      LOGICAL   FORCE, LBX

c function
      INTEGER  LANDOLT_INI
      EXTERNAL LANDOLT_INI

C -------------- BEGIN -------------------------

c check for Marriner's "LANDOLT" option
c OPT_LANDOLT bits (lsb=0):
c   bit0 : Landolt => Bessell in rest-frame (BD17)
c   bit1 : Bessell => Landolt in obs-frame  (BD17)
c   bit2 : idem but in Vega system

         USE_LANDOLT_REST = .FALSE.
         USE_LANDOLT_OBS  = .FALSE.


      IF ( UCOR_BXB .and. OPT_LANDOLT .EQ. 0 ) THEN
         USE_LANDOLT_REST = .TRUE.  ! color terms =0; but U -> U+BX-B
         istat = landolt_ini( OPT_LANDOLT, 
     &       FILTREST_MAG_PRIMARY(IFILT_BESS_U), LANDOLT_COLOR_SHIFT )

         CALL LANDOLT_SNMAG_CHECK(0, 0.0, 0.0)  ! Trest, AV
      ENDIF  ! end of OPT_LANDOLT option

c ----------------------------------------------
      IF ( OPT_LANDOLT .EQ. 0 ) RETURN
c ----------------------------------------------

      USE_LANDOLT_REST = BTEST(OPT_LANDOLT,0)  ! mask = 1
      USE_LANDOLT_OBS  = BTEST(OPT_LANDOLT,1)  ! mask = 2
      FORCE            = BTEST(OPT_LANDOLT,6)  ! mask = 64 -> FORCE use in SIM 

      IF ( LSIM_SNANA .and. .NOT. FORCE ) THEN
          write(c1err,670) OPT_LANDOLT
670       format('OPT_LANDOLT=',I3,' is invalid for SIM.')
          c2err = 'Must set OPT_LANDOLT = 0 in &FITINP '
          CALL MADABORT("LANDOLT_PREP", c1err, c2err )
      ENDIF

c -----------------------------------------------
c if BX filter is not a survey filter, 
c then add it to the SURVEY_FILTERS list and call RDKCOR again.

      LBX = IFILTDEF_INVMAP_SURVEY(ifilt_BESS_BX) .GT. 0   
      IF ( USE_LANDOLT_OBS .and. .NOT. LBX ) THEN
         NFILTDEF_SURVEY = NFILTDEF_SURVEY + 1
         i = NFILTDEF_SURVEY 
         IFILTDEF_MAP_SURVEY(i) = IFILT_BESS_BX
         IFILTDEF_INVMAP_SURVEY(ifilt_BESS_BX) = i
         CALL RDKCOR(KCOR_FILE,ISTAT)

         CALL CDTOPDIR_OUTPUT  ! back to topdir (to be safe)

      ENDIF

c -----------------------------------
c make sure that BX filters is defined
      C2err = 
     &   'Either set OPT_LANDOLT=0 or add BX filter to KCOR file.'

      IF ( USE_LANDOLT_OBS ) THEN
        IFILT = IFILTDEF_INVMAP_SURVEY(ifilt_BESS_BX)
        IF ( .NOT. EXIST_BXFILT_OBS .or. IFILT .LE. 0 ) THEN
          write(c1err,677) OPT_LANDOLT, 'OBS'
          CALL MADABORT("LANDOLT_PREP", c1err, c2err )
        ENDIF 
      ENDIF
      IF ( USE_LANDOLT_REST ) THEN
         IFILT = IFILTDEF_INVMAP_REST(ifilt_BESS_BX)
         IF ( .not. EXIST_BXFILT_REST .or. IFILT .LE. 0) THEN
            write(c1err,677) OPT_LANDOLT, 'REST'
            CALL MADABORT("LANDOLT_PREP", c1err, c2err )
         ENDIF 
      ENDIF

677      format('Cannot implement OPT_LANDOLT=',I3,
     &      ' without ', A,'-frame BX filter.')


       istat = landolt_ini( OPT_LANDOLT, 
     &      FILTREST_MAG_PRIMARY(IFILT_BESS_U), LANDOLT_COLOR_SHIFT )


c check for VEGA or BD17 as reference;
c make crude sanity check on FILT_MAGPRIMARY to avoid 
c mixing the wrong things.

      if ( BTEST(OPT_LANDOLT,2) ) then
         ctmp = 'VEGA'                    
      else
         ctmp = 'BD17'
      endif

      if ( USE_LANDOLT_REST ) then
           print*,'   Transform rest-Landolt => rest-Bessell', 
     &             '  (', ctmp,')'
           call flush(6)
      endif

      if ( USE_LANDOLT_OBS ) then
           print*,'   Transform obs-Bessell => obs-Landolt ',
     &             '  (', ctmp,')'
           call flush(6)
      endif

      if ( USE_LANDOLT_REST ) then
        CALL LANDOLT_SNMAG_CHECK(0, 0.0, 0.0)  ! Trest, AV
      endif
      CALL LANDOLT_SNMAG_CHECK(1, 0.0, 0.0)
      CALL LANDOLT_SNMAG_CHECK(2, 0.0, 0.0)

      RETURN
      END
 
C =======================================
+DECK,LANDOLT_CHECK.
      SUBROUTINE LANDOLT_SNMAG_CHECK(OPT,Trest,AVwarp)
c
c Compute SN mags at t=0 for Bessell and Landolt;
c compare with external calculations.
c
c -----------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNFITCOM.
+CDE,FILTCOM.

      INTEGER OPT             ! () 0=>SN, 1=Vega, 2=BD17
      REAL    Trest, AVwarp   ! (I) test params

c local var

      INTEGER ifilt, OPT_CONVERT, istat

      REAL*8 
     &   T8, Z8, AV8
     &  ,MAG8_BESS(MXFILT_ALL)     ! reported Bessell mags
     &  ,MAG8_SYNBESS(MXFILT_ALL)  ! synthetic Bessell
     &  ,MAG8_LAND(MXFILT_ALL)     
     &  ,MAG8_INVERT(MXFILT_ALL)
     &  ,MAG8_BX, MAG8_B

      character cflt*1

      REAL BD17_MAG_LANDOLT(MXFILT_ALL) 
      REAL VEGA_MAG_LANDOLT(MXFILT_ALL)

c functions
      REAL*8 GET_MAGLC8
      INTEGER LANDOLT_CONVERT

C --------------- BEGIN ---------------

      DO ifilt = 1, MXFILT_ALL
        MAG8_SYNBESS(ifilt) = -9.0
        MAG8_BESS(ifilt)    = -9.0
        MAG8_LAND(ifilt)    = -9.0
        MAG8_INVERT(ifilt)  = -9.0
      ENDDO

c hard-wire primary mags from John Marriner.

      BD17_MAG_LANDOLT(IFILT_BESS_U) = 9.724
      BD17_MAG_LANDOLT(IFILT_BESS_B) = 9.907
      BD17_MAG_LANDOLT(IFILT_BESS_V) = 9.464
      BD17_MAG_LANDOLT(IFILT_BESS_R) = 9.166
      BD17_MAG_LANDOLT(IFILT_BESS_I) = 8.846
      BD17_MAG_LANDOLT(IFILT_BESS_BX) = 9.907

      VEGA_MAG_LANDOLT(IFILT_BESS_U) = 0.011
      VEGA_MAG_LANDOLT(IFILT_BESS_B) = 0.015
      VEGA_MAG_LANDOLT(IFILT_BESS_V) = 0.017
      VEGA_MAG_LANDOLT(IFILT_BESS_R) = 0.024
      VEGA_MAG_LANDOLT(IFILT_BESS_I) = 0.020
      VEGA_MAG_LANDOLT(IFILT_BESS_BX) = 0.015

      print*,' '

      if ( OPT .EQ. 0 ) then
        print*,'  Check SN mags at Trest=',Trest,'  AVwarp=',AVwarp
        T8  = DBLE(Trest)
        AV8 = DBLE(AVwarp)
        Z8  = Zat10pc
        DO ifilt = IFILT_BESS_U, IFILT_BESS_BX
          MAG8_SYNBESS(ifilt) = GET_MAGLC8(ifilt,T8,Z8,AV8) 
     &                        - PEAKMAG_AT_10pc
        ENDDO
      ELSE IF ( OPT .EQ. 1 ) then
        print*,'  Check VEGA mags. ' 
        DO ifilt = IFILT_BESS_U, IFILT_BESS_BX
          MAG8_LAND(ifilt) = VEGA_MAG_LANDOLT(ifilt)
        ENDDO 
        MAG8_LAND(IFILT_BESS_BX) = 
     &  MAG8_LAND(IFILT_BESS_BX) - MAG8_LAND(IFILT_BESS_B) 
        GOTO 400
      ELSE IF ( OPT .EQ. 2 ) then
        print*,'  Check BD17 mags. ' 
        DO ifilt = IFILT_BESS_U, IFILT_BESS_BX
          MAG8_LAND(ifilt) = BD17_MAG_LANDOLT(ifilt)
        ENDDO
        MAG8_LAND(IFILT_BESS_BX) = 
     &  MAG8_LAND(IFILT_BESS_BX) - MAG8_LAND(IFILT_BESS_B) 
        GOTO 400
      ELSE
        print*,' '
        print*,' LANDOLT_SNMAG_CHECK: UKNOWN OPT = ', OPT
        print*,' ***** ABORT ***** '
        STOP
      ENDIF


      OPT_CONVERT = +1      
      istat = Landolt_convert(opt_convert
     &          ,MAG8_SYNBESS(IFILT_BESS_U)  ! input  UBVRI,X
     &          ,MAG8_LAND(IFILT_BESS_U)     ! output UBVRI
     &           )

c now invert to get back Bessell from Landolt.

      MAG8_BX = GET_MAGLC8(ifilt_BESS_BX,T8,Z8,AV8)
      MAG8_B  = GET_MAGLC8(ifilt_BESS_B, T8,Z8,AV8)
      MAG8_LAND(IFILT_BESS_BX) = MAG8_BX - MAG8_B

400   CONTINUE

      OPT_CONVERT = -1      
      istat = Landolt_convert(opt_convert
     &          ,MAG8_LAND(IFILT_BESS_U)    ! input   land  UBVRI, BX-B
     &          ,MAG8_INVERT(IFILT_BESS_U)  ! output  synth UBVRI,X
     &           ) 

c convert synthetic mags into reported BESS mags.
      DO ifilt = IFILT_BESS_U, IFILT_BESS_BX
         MAG8_BESS(ifilt) = MAG8_INVERT(ifilt)
      ENDDO
      MAG8_BESS(ifilt_BESS_U) = MAG8_INVERT(ifilt_BESS_U)
     &                        - MAG8_INVERT(ifilt_BESS_BX)
     &                        + MAG8_INVERT(ifilt_BESS_B)

c --------

      print*,' '
      print*,'      synth      reported   syn-Bessell   Landolt->     '
      print*,'      Bessell    Bessell    -> Landolt    syn-Bessell   '
      print*,' ----------------------------------------------------- '

      DO ifilt = IFILT_BESS_U, IFILT_BESS_I
        cflt = FILTDEF_STRING(ifilt:ifilt)
        write(6,20)  cflt
     &    ,MAG8_SYNBESS(ifilt) 
     &    ,MAG8_BESS(ifilt)
     &    ,MAG8_LAND(ifilt)
     &    ,MAG8_INVERT(ifilt)

20      format(T3,A, 2x,4(F9.4,3x) )

      ENDDO

      print*,' ----------------------------------------------------- '
      CALL FLUSH(6) 

      RETURN
      END

C ====================================
+DECK,SETFILTOBS.
      SUBROUTINE SET_IFILT_OBS(LPRINT)
c
c Sets up appropriate observer-filter ranges before fit begins
c so that USRFUN need not compute filter ranges during each
c call.
c
c Set the following FILTCOM varaibles for this SN:
c   IFILT_OBS_EVAL_MASK(ifilt_obs)  => mask of obs filters to evaluate
c  
c  Example: U-band needs to evaluate obs U,B,V,BX
c   => IFILT_OBS_EVAL_MASK(IFILT_BESS_U) = bits 6,7,8,11 
c
c
c Apr 22 2022: pass LPRINT logical flag as input argument
c --------------------------------------

      IMPLICIT NONE

      LOGICAL  LPRINT  ! (I)

+CDE,SNDATCOM.  from snana.car
c +CDE,SNANAFIT.  from snana.car
+CDE,SNFITCOM.
+CDE,FILTCOM.

      INTEGER 
     &   ifilt, ifilt2
     &  ,ifilt_obs, ifilt2_obs
     &  ,LL, NFUSE

      INTEGER*8 MSKTMP8(2)

      LOGICAL LBESS_OBS, LTMP, MULTIFILT, USE
      character cfilt*2, cfilt2*2

c functions
      LOGICAL FILTBTEST

C -------------- BEGIN --------------

      LL = ISNLC_LENCCID 

      DO ifilt = 1, MXFILT_ALL
        IFILT_OBS_EVAL_MASK(1,ifilt) = 0
        IFILT_OBS_EVAL_MASK(2,ifilt) = 0
      ENDDO

c check if any of the OBS filters are in the Bessell90 system
      LBESS_OBS = .FALSE.
      DO ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)          
         if ( ifilt_obs .GE. IFILT_BESS_U .and. 
     &        ifilt_obs .LE. IFILT_BESS_I ) LBESS_OBS = .TRUE.
      ENDDO

c set default mask to evaluate only observer filter
c (ie.. no color transformations).

      MULTIFILT = .FALSE.

      DO ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)          
         USE = USE_FILT(ifilt_obs) .or. LFILTDEF_NONSURVEY(ifilt_obs)
         if ( USE ) then
            CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,ifilt_obs),
     &                   ifilt_obs)
        endif
      ENDDO

c -----------------------------------------------------
c check option to correct U with BX-B
c Note that UCOR is used automatically with OPT_LANDOLT;
c this is to allow UCOR_BXB without the LANDOLT option

      IF ( UCOR_BXB .and. LBESS_OBS ) THEN

         MULTIFILT = .TRUE.

         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_U),
     &                IFILT_BESS_U)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_U),
     &                IFILT_BESS_B)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_U),
     &                IFILT_BESS_BX)

      ENDIF

c -----------------------------------------------------
c check options that involve color transformations.

      IF ( USE_LANDOLT_OBS .and. LBESS_OBS ) THEN

         MULTIFILT = .TRUE.

c --- U
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_U),
     &                IFILT_BESS_U)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_U),
     &                IFILT_BESS_B)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_U),
     &                IFILT_BESS_V)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_U),
     &                IFILT_BESS_BX)

c --- B

         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_B),
     &                IFILT_BESS_B)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_B),
     &                IFILT_BESS_V)

c --- V
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_V),
     &                IFILT_BESS_B)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_V),
     &                IFILT_BESS_V)

c --- R
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_R),
     &                IFILT_BESS_B)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_R),
     &                IFILT_BESS_V)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_R),
     &                IFILT_BESS_R)

c --- I
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_I),
     &                IFILT_BESS_B)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_I),
     &                IFILT_BESS_V)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_I),
     &                IFILT_BESS_R)
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_I),
     &                IFILT_BESS_I)

c --- BX
         CALL FILTBSET(IFILT_OBS_EVAL_MASK(1,IFILT_BESS_BX),
     &                IFILT_BESS_BX)

      ENDIF

c ----------
c write list of filters to fit
c  
      NFUSE = INDEX(FILTLIST_FIT_USE,' ') - 1

      IF ( LPRINT ) THEN
        write(6,44) SNLC_CCID(1:LL), FILTLIST_FIT_USE(1:NFUSE)
44      format(T5,'CID ',A,' : FIT OBSERVER FILTERS ', A )
      ENDIF
c ----------------------------------------
c  print obs filters for each filter when mutliple filters
c  are needed per band, such as for the Landolt correction
      
      LTMP = (N_SNLC_FITCUTS .LT. 20) .and. MULTIFILT

      IF ( LTMP ) THEN
        if ( LPRINT ) print*,' '

        DO 29 ifilt = 1, NFILTDEF_SURVEY

         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt) 
         USE = USE_FILT(ifilt_obs)
         if ( .NOT. USE ) goto 29

         cfilt  = filtdef_string(ifilt_obs:ifilt_obs)
         MSKTMP8(1) = IFILT_OBS_EVAL_MASK(1,ifilt_obs) 
         MSKTMP8(2) = IFILT_OBS_EVAL_MASK(2,ifilt_obs) 

         write(6,20) SNLC_CCID(1:LL), cfilt
20       format(T10,'SN ',A,': OBSERVER-',A1,' => evaluate obs ', $)
          
         DO ifilt2 = 1, NFILTDEF_SURVEY
            ifilt2_obs = IFILTDEF_MAP_SURVEY(ifilt2)
            cfilt2 = filtdef_string(ifilt2_obs:ifilt2_obs)
            LTMP = FILTBTEST(MSKTMP8,ifilt2_obs)
            if ( LTMP .and. LPRINT ) write(6,21) cfilt2(1:1)
21          format(A1, $)
         ENDDO
	 if ( LPRINT ) print*, '  (ifilt=', ifilt, ')'

29      CONTINUE ! end of IFILT loop

      ENDIF    ! end of LTMP if-block

      RETURN
      END     ! end SET_IFILT_OBS


C ===================================
+DECK,INIFUDGE.
      SUBROUTINE INIT_FUDGE_FITERR
c
c Created Jul 18, 2008
c (code moved from FITPAR_INI)
c
c Feb 19 2010: abort if MAXFRAC>0, but TREST-range or LAM-range 
c              is zero.
c
c Mar 1 2017: do NOT return after FUDGEALL_MAXFRAC -->
c             allow mixing with other options.
c ---------------------------------

      IMPLICIT NONE      

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNFITCOM.

      INTEGER LL, ifilt, ifilt_obs

      character ctmp*4

      INTEGER FILTINDX

C ------------- BEGIN ------------

      USE_FUDGE_FITERR = .FALSE.

      IF ( FUDGE_MAGERR_MODEL .GE. 0.0 ) THEN
         write(6,16) FUDGE_MAGERR_MODEL
16       format(T5,'FIT-MODEL FUDGE WARNING: ', 
     &       ' ALL MODEL-MAG ERRORS -> ', F6.3,' mag ' )
      ENDIF

      IF ( FUDGEALL_MAXFRAC .GT. 0.0 ) THEN
        write(6,179) FUDGEALL_MAXFRAC
179     format(T5,'FIT-ERROR fudge = ', F6.2,' * max(Flux)', 3x,
     &    'for all epochs and fit-iterations.' )
       USE_FUDGE_FITERR = .TRUE.
c xxx mark delete Mar 1 2017       RETURN
      ENDIF

      IF ( FUDGEALL_ITER1_MAXFRAC .GT. 0.0 ) THEN
         write(6,79) FUDGEALL_ITER1_MAXFRAC, 1
         USE_FUDGE_FITERR = .TRUE.
      ENDIF

      IF ( FUDGE_FITERR_PASSBANDS .EQ. 'NULL' ) RETURN
      IF ( FUDGE_FITERR_MAXFRAC   .EQ. 0.     ) RETURN

      USE_FUDGE_FITERR = .TRUE.

      LL = INDEX ( FUDGE_FITERR_PASSBANDS, ' ' ) -  1

      DO ifilt     = 1, LL
         ctmp      = FUDGE_FITERR_PASSBANDS(ifilt:ifilt)
         ifilt_obs = FILTINDX(ctmp)
         DOFUDGE_FITERR(ifilt_obs) = .TRUE.

         write(6,77) ctmp(1:1), 
     &         FUDGE_FITERR_TREST(1), FUDGE_FITERR_TREST(2)

77       format(T5,'Fudge ',A,'-band FIT-ERRORS for ',
     &          F6.1, ' < Trest < ', F6.1,' days ' )

         if ( FUDGE_FITERR_TREST(3) .LT. 900. ) then
             write(6,77) ctmp(1:1), 
     &         FUDGE_FITERR_TREST(3), FUDGE_FITERR_TREST(4)
         endif

         write(6,78) int(FUDGE_FITERR_RESTLAM(1))
     &              ,int(FUDGE_FITERR_RESTLAM(2))

         if( FUDGE_FITERR_RESTLAM(3) .LT. 80000. ) then
           write(6,78)  int(FUDGE_FITERR_RESTLAM(3))
     &                 ,int(FUDGE_FITERR_RESTLAM(4))
         endif

78       format(T30,'and ', I5,' < RESTLAM < ', I5,' Angstroms')

      ENDDO

      write(6,79) FUDGE_FITERR_MAXFRAC, FUDGE_FITERR_MAXITER
79    format(T5,'FIT-ERROR fudge = ', F6.2,' * max(Flux)', 3x,
     &    'for ITER <=',I2   )
      print*,'  '


c ----------------------------------------------------
c sanity checks to prevent setting bad FUDGEs

      write(c1err,661) FUDGE_FITERR_MAXFRAC
661   format('FUDGE_FITERR_MAXFRAC = ',F8.2)

      IF ( FUDGE_FITERR_TREST(1) .GE. FUDGE_FITERR_TREST(2) ) then
         c2err = 'but  FUDGE_FITERR_TREST  is not set.'
         CALL MADABORT("INIT_FUDGE_FITERR", c1err, c2err)        
      ENDIF
      IF ( FUDGE_FITERR_RESTLAM(1).GE.FUDGE_FITERR_RESTLAM(2)) then
         c2err = 'but  FUDGE_FITERR_RESTLAM  is not set.'
         CALL MADABORT("INIT_FUDGE_FITERR", c1err, c2err)        
      ENDIF

      RETURN
      END

C ==========================================
+DECK,DMP_DICTFILE.
      SUBROUTINE DMP_DICTFILE(IFLAG)
c
c Created Apr 13, 2009 by R.Kessler
c
c Write SALT2 results to "dictFile" ...
c the particular format needed by their
c "hubblefit" program. Note that SNANA does
c NOT use this DICTFILE for anything;
c this is just a convenience option to
c use the original SALT2 hubblefit with
c the output of snlc_fit.exe
c
c IFLAG = 0 => open file; write header
c IFLAG > 0 => update with next SN

c ------------------

      IMPLICIT NONE      
+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNFITCOM.


      INTEGER IFLAG ! (I) 0-> open file; 1-> write

c local

      INTEGER LTMP,  ivar

      INTEGER NVAR_DICTFILE
      PARAMETER ( NVAR_DICTFILE =  17 )
      REAL*8  XVAR(NVAR_DICTFILE)

C ----------- BEGIN ----------

      IF ( FITMODEL_INDEX .NE. MODEL_SALT2 ) RETURN

      IF ( IFLAG .EQ. 0 ) THEN

c init dictFile and  write header

        OPEN(UNIT= LUNSALT2, FILE = SALT2_DICTFILE, 
     &         STATUS='UNKNOWN', ERR=92)

        write(6,90) SALT2_DICTFILE(1:LTMP)
90      format(T5,'Open SALT2 DICT-FILE : ', A)
        print*,' '

c write mandatory header
        write(LUNSALT2,20) 'z',  1,'redshift'
        write(LUNSALT2,20) 'X0', 2,'10^[-0.4*(mu + alpha*x1 - beta*c)]'
        write(LUNSALT2,20) 'X0e',3,'error on x_0'
        write(LUNSALT2,20) 'X1', 4,'stretch/luminosity parameter'
        write(LUNSALT2,20) 'X1e',5,'error on x_1'
        write(LUNSALT2,20) 'X2', 6,'bidon'
        write(LUNSALT2,20) 'X2e',7,'bidon'
        write(LUNSALT2,20) 'X3', 8,'color'
        write(LUNSALT2,20) 'X3e',9,'error on color'
        write(LUNSALT2,20) 'msb',10,'reference B-mag'
        write(LUNSALT2,20) 'msbe',11,'error on above'

        write(LUNSALT2,20) 'X0X1_c', 12, 'x_0/x_1 Correlation'
        write(LUNSALT2,20) 'X0X2_c', 13, 'bidon'
        write(LUNSALT2,20) 'X0X3_c', 14, 'x_0/color Correlation'
        write(LUNSALT2,20) 'X1X2_c', 15, 'bidon'
        write(LUNSALT2,20) 'X1X3_c', 16, 'x_1/color Correlation'
        write(LUNSALT2,20) 'X2X3_c', 17, 'bidon'
        write(LUNSALT2,20) 'end'

20      format('#', A, T9,': (', I2.2,') ', A)

        RETURN
  
      ENDIF  ! end if IFLAG=0 


c --------------

      ivar = 0

      IVAR = IVAR + 1
      XVAR(ivar) = SNLC_ZCMB

c x0
      IVAR = IVAR + 1
      XVAR(ivar) = LCVAL_STORE(IPAR_X0)
      IVAR = IVAR + 1
      XVAR(ivar) = LCERR_STORE(IPAR_X0)

c x1
      IVAR = IVAR + 1
      XVAR(ivar) = LCVAL_STORE(IPAR_SHAPE)
      IVAR = IVAR + 1
      XVAR(ivar) = LCERR_STORE(IPAR_SHAPE)

c x2
      IVAR = IVAR + 1
      XVAR(ivar) = 0.0
      IVAR = IVAR + 1
      XVAR(ivar) = 0.0

c x3 = color
      IVAR = IVAR + 1
      XVAR(ivar) = LCVAL_STORE(IPAR_COLOR)
      IVAR = IVAR + 1
      XVAR(ivar) = LCERR_STORE(IPAR_COLOR)

c mB*
      IVAR = IVAR + 1
      XVAR(ivar) = LCVAL_STORE(IPAR_MB)
      IVAR = IVAR + 1
      XVAR(ivar) = LCERR_STORE(IPAR_MB)

c now the covariances ...

c #X0X1_c :   
      IVAR = IVAR + 1
      XVAR(ivar) = FITERRMAT(IPAR_X0,IPAR_SHAPE)

c #X0X2_c :  bidon
      IVAR = IVAR + 1
      XVAR(ivar) = 0.0

c #X0X3_c :  x0-color cov
      IVAR = IVAR + 1
      XVAR(ivar) = FITERRMAT(IPAR_X0,IPAR_COLOR)

c #X1X2_c :   bidon
      IVAR = IVAR + 1
      XVAR(ivar) = 0.0

c #X1X3_c :   x1-color cov
      IVAR = IVAR + 1
      XVAR(ivar) = FITERRMAT(IPAR_SHAPE,IPAR_COLOR)

c #X2X3_c : bidon
      IVAR = IVAR + 1
      XVAR(ivar) = 0.0

c -----------------------

c  write XVAR 
      DO ivar = 1, NVAR_DICTFILE
        write(LUNSALT2, '(G14.6,$)' ) XVAR(ivar)
      END DO
      write(LUNSALT2, '(A)') ' '
      CALL FLUSH(LUNSALT2)

      GOTO 888

c ---------------------
92    CONTINUE 
      c1err = 'Could not open SALT2_DICTFILE: '
      c2err = SALT2_DICTFILE
      CALL MADABORT("DMP_DICTFILE", c1err, c2err)

888   CONTINUE
      RETURN
      END


C =======================================
+DECK,DMP_COVAR.
      SUBROUTINE DMP_COVAR(iter)
c
c Created Jun 2, 2011 by R.Kessler
c 
c Dump non-zero elements of COVMAT2 matrix
c before it is  inverted.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER iter  ! (I) fit-iteration to prepare
c local variables

      INTEGER NDMP, IROW, ICOL, IFILT_ROW, IFILT_COL
      INTEGER ep_row, ep_col
      REAL*8  COVTMP8

      character cfilt_row*2, cfilt_col*2

C ---------------- BEGIN ------------

       print*,' --------------------------------------- '
       print*,' COVMAT DUMP for CID=', SNLC_CCID,
     &      '   FIT-ITER=', ITER

       NDMP = 0

       DO 301 irow = 1, NFITDATA
       DO 302 icol = 1, NFITDATA
         
         COVTMP8     = COVMAT2(irow,icol)
         if ( COVTMP8 .EQ. 0.0 ) GOTO 302

         ep_row = EPLIST_FIT(irow)
         ep_col = EPLIST_FIT(icol)

         NDMP = NDMP + 1
         IFILT_ROW   = I4EP_ALL(ep_row,IEP_IFILT_OBS)
         IFILT_COL   = I4EP_ALL(ep_col,IEP_IFILT_OBS)
         cfilt_row   = FILTDEF_STRING(ifilt_row:ifilt_row)
         cfilt_col   = FILTDEF_STRING(ifilt_col:ifilt_col)

         write(6,660) 
     &      R4EP_ALL(ep_row,JEP_TREST), cfilt_row, 
     &      R4EP_ALL(ep_col,JEP_TREST), cfilt_col, 
     &      COVTMP8,
     &      R8EP_MJD(irow), R8EP_MJD(icol)
660      format(T3,'COVMAT[ ', F6.2, '(', A1, ')'  , 
     &          F6.2, '(', A1, ') ] = ', F15.6 ,
     &          4x,'MJD=', F9.3,','F9.3 
     &     )

302    CONTINUE
301    CONTINUE

      write(6,661) NFITDATA,  NFITDATA, NFITDATA*NFITDATA
661   format(T3,'COVMAT FULL-SIZE: ', I4,' x ', I4, ' = ', I8)

      write(6,662) NDMP
662   format(T3,'COVMAT Number of non-zero elements: ', I8)

      RETURN
      END

C ========================================
+DECK,DMPSNMJD.
      SUBROUTINE DMP_SNMJD_INTERP(IFLAG,OPTMJD)
c
c For specified MJDs, write MAG(obs & rest) , FLUX & KCOR
c to special dump file. List has been read from 
c SNMJD_LIST_FILE. Output file has same name as input,
c but with .OUT extension.
c
c March 24, 2008:
c       Add OPTMJD (see below)
c
c May 28, 2008: fix dumb bug so that PEAKMJD dump happens only once.
c
c May 18, 2012: use new GET_INTERP_MJDLIST utility
c Aug 15, 2012: protect printing info for undefined IFILT_OBS.
c
c Jul 31 2015: write fitres [column] format to make it easier to parse.
c
c Nov 19 2019: remove NVAR key
c Dec 04 2019: remove obsolete IFILTOBS_RST to avoid negative index
c
c ------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.
+CDE,INTERPCM.

c IFLAG = 0 => open output file
c IFLAG > 0 => update file with SN if MJD is specified
c IFLAG < 0 => close file.

      INTEGER 
     &   IFLAG      ! (I) SN sparse index
     &  ,OPTMJD     ! (I) 0=>use PEAKMJD, 1=> use MJD from file.
 
c local args

      INTEGER 
     &   LTMP, imjd, NMJD, ipar, NVAR_OUT
     &  ,CID, CID_TMP
     &  ,IFILT, IFILT_OBS, IFILT_RST

      REAL*8  
     &   MJD8, MJD8_LAST, MJD8LIST(MXINTERP)
     &  ,FLUX8, FLUX8ERR
     &  ,MAG8, MAG8ERR, KCOR8
     
      REAL 
     &    TOBS, TREST, PKMJD
     &   ,FLUXOBS_INTERP(MXFILT_ALL)
     &   ,FLUXERROBS_INTERP(MXFILT_ALL)
     &   ,MAGOBS_INTERP(MXFILT_ALL)
     &   ,MAGERROBS_INTERP(MXFILT_ALL)
     &   ,KCOR_INTERP(MXFILT_ALL)
     &   ,MAGRST_INTERP(MXFILT_ALL)  ! model mags
     &   ,MAGERRRST_INTERP(MXFILT_ALL)  ! model mags
     &   ,MAGRST2_INTERP(MXFILT_ALL) ! training mags
     &   ,MAGERRRST2_INTERP(MXFILT_ALL) ! training mags
     &   ,VAL, ERR

      CHARACTER CCID*(MXCHAR_CCID), BAND*2

      LOGICAL LDMP, LSKIP, ADDFLAG

      PARAMETER ( NVAR_OUT=9 )

C ------------ BEGIN -----------

c negative IFLAG => end of program
      IF ( IFLAG < 0 ) THEN
        CLOSE ( UNIT = LUNINTERP  )
        RETURN
      ENDIF

      PKMJD = LCVAL_STORE(IPAR_PEAKMJD) + MJDOFF

c open output file.
      IF ( IFLAG .EQ. 0 ) THEN

        GLOBAL_BANNER = "OPEN TEXT-FILE TO DUMP INTERPOLATED MAGS"
        CALL PRBANNER (GLOBAL_BANNER )

        LTMP = INDEX ( SNMJD_LIST_FILE, ' ' ) - 1       

        if ( SNMJD_OUT_FILE .EQ. ' ' ) then
          SNMJD_OUT_FILE = SNMJD_LIST_FILE(1:LTMP) // '.OUT'
        endif
        
        LTMP = INDEX ( SNMJD_OUT_FILE, ' ' ) - 1       
        OPEN(UNIT= LUNINTERP, FILE=SNMJD_OUT_FILE,
     &         STATUS='UNKNOWN', ERR=92)

        write(6,90) SNMJD_OUT_FILE(1:LTMP)
90      format(T5,'Open MAG-interp file : ', A)
        print*,' '

        WRITE(LUNINTERP,40) 'Interpolation Results at MJD_INTERP'
cc xxx mark delete         WRITE(LUNINTERP,401) NVAR_OUT
cc xxx 401     FORMAT('NVAR: ', I2)
        WRITE(LUNINTERP,402)
402     FORMAT('VARNAMES: CID BAND MJD_INTERP MAG MAGERR '
     &                   'FLUX FLUXERR TOBS TREST' )
         
        RETURN

      ENDIF  ! end of IFLAG = 0 block

c ----------------------------------
c search MJD(s) for this SN:

      CCID = SNLC_CCID
      CALL GET_INTERP_MJDLIST(CCID, NMJD, MJD8LIST, ADDFLAG)     
      
      MJD8_LAST = -9.0

      DO 200 imjd = 1, NMJD

        IF ( OPTMJD .EQ. 1 ) THEN
           MJD8 = MJD8LIST(imjd)
        ELSE
           MJD8 = PKMJD
        endif

c avoid repeating an MJD ... mainly to avoid multiple PEAKMJD entries.
        IF ( MJD8 .EQ. MJD8_LAST ) GOTO 200


c get observer mags,flux,kcor at this MJD

        DO IFILT = 1, NFILTDEF_SURVEY      
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)

          if ( USE_FILT(ifilt_obs) ) then

             CALL MODELMAG_CALC(ifilt_obs, 'OBS', MJD8, 
     &           FLUX8, FLUX8ERR, MAG8, MAG8ERR, KCOR8 ) ! return args

             FLUXOBS_INTERP(ifilt_obs)    = FLUX8
             FLUXERROBS_INTERP(ifilt_obs) = FLUX8ERR
             MAGOBS_INTERP(ifilt_obs)     = MAG8
             MAGERROBS_INTERP(ifilt_obs)  = MAG8ERR
             KCOR_INTERP(ifilt_obs)       = KCOR8

          endif
        ENDDO
c -------------------------
c write results to output file.

        TOBS = MJD8 - PKMJD
        TREST = TOBS / ( 1.0 + REDSHIFT_FIT )

        if ( MJD8 < 1.0 ) GOTO 4000

        write(LUNINTERP,40) ' '
40      format('# ', A)
        DO 1400 IFILT = 1, NFILTDEF_SURVEY      
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          BAND      = FILTDEF_STRING(ifilt_obs:ifilt_obs)
          if ( .not. USE_FILT(ifilt_obs) ) GOTO 1400


           write(LUNINTERP,405) 
     &       CCID(1:ISNLC_LENCCID),
     &       BAND, MJD8,
     &       MAGOBS_INTERP(ifilt_obs),  MAGERROBS_INTERP(ifilt_obs),
     &       FLUXOBS_INTERP(ifilt_obs), FLUXERROBS_INTERP(ifilt_obs),
     &       TOBS, TREST
       
405        format('INTERP: ', 
     &          A, 1x, A1, 1x, F9.3,   ! CCID, BAND, MJD8
     &          2x, 2F7.3,               ! MAG MAGERR
     &          2x, 2G10.4,              ! FLUX FLUXERR
     &          2F7.2                    ! TOBS TREST
     &             )

1400    CONTINUE

        MJD8_LAST = MJD8

200   CONTINUE  ! end of main SNMJD loop

      IF( OPTMJD > 0 ) GOTO 6000

c --------------------

4000  CONTINUE

c Write out the fit parameters
c Make sure to write out PEAKMJD even if it's fixed.

      LTMP = INDEX(FITMODEL_VERSION,' ') - 1
      write(LUNINTERP,410) 
     &    FITMODEL_VERSION(1:LTMP), CCID(1:ISNLC_LENCCID)
410   format(/,T4,A,' FIT-PARAMETERS for ',A, ': ' )

      DO 400 ipar = 1, NFITPAR_MN

         LDMP = FLOATPAR(ipar) 
     &     .or. IPAR.EQ. IPAR_PEAKMJD
     &     .or. IPAR.EQ. IPAR_zPHOT

         if ( .not. LDMP ) goto 400

         VAL = FITVAL_STORE(ipar) 
         ERR = FITERR_STORE(ipar) 
 
         if ( IPAR .EQ. IPAR_PEAKMJD ) VAL = VAL + MJDOFF

         LTMP = INDEX ( PARNAME_STORE(ipar), ' ' ) - 1
         write(LUNINTERP,420) PARNAME_STORE(ipar)(1:LTMP), VAL, ERR

420      format(T10,A,'= ', T20, G12.3, ' +- ', G10.3 )

400   CONTINUE
      write(LUNINTERP,40) 
     &  '========================================================='
c ---------------------------

6000  CONTINUE
      CALL FLUSH(LUNINTERP)
      RETURN

c ----------------------------------
92    CONTINUE 
      c1err = 'Could not open MAG-INTERP output file '
      c2err = SNMJD_OUT_FILE
      CALL MADABORT("DMP_SNMJD_INTERP", c1err, c2err)

      RETURN
      END


C ===============================
+DECK,PREPTUP.
      SUBROUTINE PREP_FITRES_TABLEVAR()

c Created Sep 2012 by R.Kessler
c Prepare some FITRES table variables.
c
c Apr 29, 2013: fill CWNT_COV
c May 14 2014: overhaual using keep, TABLEVARCOM.
c
c
      IMPLICIT NONE

c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,TABLEVARCOM.
+CDE,SNLCINP.
c+CDE,CWNTCOM.

      INTEGER 
     &   i, i2, ifilt, ifilt_obs, ifilt_obs2
     &  ,iep, ipar, ipar1, ipar2, ICOV, ITER

      character 
     &   cfilt1*2, cfilt2*2
     &  ,cfilt1_lower*2, cfilt2_lower*2

      LOGICAL LF2, NONSURVEY
      REAL RHO, COV

      REAL*8 PKMJD8, XTMW

C --------------- BEGIN -------------

      ITER    = NFIT_ITERATION
      PKMJD8  = FITVAL(IPAR_PEAKMJD,ITER) 
      CALL LOAD_EPALL(ITER,PKMJD8)

c ----------------------------------
c load MINUIT reduced correlation matrix into linear array

      do ipar = 1, MXCOV_TBL
         TBL_COV(ipar)    = -999.
         TBL_REDCOV(ipar) = -999.
      enddo

      DO 100 ICOV = 1, NCOV_TBL

         IPAR1 = IPAR_TBL_COV(1,ICOV) 
         IPAR2 = IPAR_TBL_COV(2,ICOV)

         if ( NGRID_PDF .LE. 0 ) then
            RHO = FITCORMAT(ipar1,ipar2)
            COV = FITERRMAT(ipar1,ipar2)
         else
            RHO = PDFCORMAT(ipar1,ipar2)
            COV = PDFERRMAT(ipar1,ipar2)
         endif

         TBL_COV(ICOV)    = COV
         TBL_REDCOV(ICOV) = RHO

 100  CONTINUE 


c fill SNRMAX and XTMW arrays with only fitted bands.

      DO ifilt     = 1, NFILTDEF_SURVEY
         TBL_XTMW(ifilt)   = -999.
         TBL_SNRMAX(ifilt) = -999. 
      ENDDO

      DO 200 i     = 1, NFILTOBS_TABLE
         ifilt_obs = IFILTOBS_MAP_TABLE(i)
         ifilt     = IFILT_MAP_TABLE(i)
         
         if ( use_filt(ifilt_obs) ) then    
            iep   = I4BAND_EP_NEARPEAK(ifilt_obs)
 
            NONSURVEY = LFILTDEF_NONSURVEY(ifilt_obs)
            if ( NONSURVEY ) iep = 1 ! avoid -9999 index

c           print*,' xxx iep,ifilt, ifiltobs = ', iep, ifilt, ifilt_obs

            if ( iep > 0 ) then
               XTMW          = R4EP_ALL(iep,JEP_MWXT)  ! mag
               TBL_XTMW(i)   = 10**(-0.4*XTMW)         ! flux-frac
               TBL_SNRMAX(i) = R4BAND_SNRMAX_FIT(ifilt)
            endif
         endif      
200   CONTINUE

      RETURN
      END    ! end of PREP_FITRES_TABLEVAR


C ========================================
+DECK,TEST_TRANSFORM.
      SUBROUTINE TEST_TRANSFORM(Z4)
c
c Test rest->observer frame transformation.
c For well-defined filter set, this transformation
c is simply a K-correction on a warped spectrum.
c For John's color transformation, it's a little more
c complicated.
c

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.


      REAL*4  Z4  ! (I) redshift

c  local args

      REAL*4  LMIN4

      INTEGER 
     &   ifilt_obs
     &  ,ifilt_rest1
     &  ,ifilt_rest2
     &  ,OPT

      REAL*8  
     &   T8, Z8, FLux8, MAG8
     &  ,DELTA8(2), AV8, MWEBV8, DLMAG8
     &  ,AVwarp8, KCOR8(2), XTAV, XTMW,MAGERR8, RVMW8
   
      LOGICAL LDMP / .FALSE. /

c functions
      REAL*8 USRFUN
      INTEGER NEAREST_IFILT_REST

c -------------- BEGIN ------------

      CALL PRBANNER("TEST REST -> OBSERVER TRANSFORMATION")

      Z8     = DBLE(Z4)

      T8        = ZERO8
      DELTA8(1) = ZERO8
      DELTA8(2) = ZERO8
      AV8       = INIVAL_AV
      MWEBV8    = ZERO8
      RVMW8     = DBLE(RV_MWCOLORLAW)
      DLMAG8    = ZERO8
      

      print*,' Z=',Z4,'  Trest=',sngl(T8),'   AV=',sngl(AV8)
      print*,' MWE(B-V)=', sngl(MWEBV8), '   DLMAG=',sngl(DLMAG8)

      print*,' IFILTDEF_MAP_SURVEY = ', IFILTDEF_MAP_SURVEY

c      write(6,18) MAG_REST_TEST
c18    format(T3,'REST UBVRI mags: ', 5F8.4 )

      print*,' ' 

      DO ifilt_obs = 1,10

         OPT = OPT_FILTOBS
         ifilt_rest1 = NEAREST_IFILT_REST(opt,ifilt_obs,1,Z4,LMIN4)
         ifilt_rest2 = NEAREST_IFILT_REST(opt,ifilt_obs,2,Z4,LMIN4)

         FLUX8 = 
     &     USRFUN ( NFIT_ITERATION, ifilt_obs, Z8, T8
     &             ,DELTA8, DLMAG8, AV8, RVMW8, MWEBV8, LDMP
     &             ,AVwarp8, KCOR8, XTAV, XTMW, MAGERR8 )    ! (O) 

ccc         MAG8 = -2.5*DLOG10(FLUX8/ADUSCALE)
         MAG8 = -2.5*DLOG10(FLUX8) + ZEROPOINT_FLUXCAL_DEFAULT

         write(6,20) 
     &     filtdef_string(ifilt_obs:ifilt_obs), MAG8
     &    ,filtdef_string(ifilt_rest1:ifilt_rest1)
     &    ,filtdef_string(ifilt_rest2:ifilt_rest2)
     &    ,AVwarp8, KCOR8(1)

 20      format(T5,'obsMag(',A,')=',F8.4, 3x,
     &             'AVwarp(',A,'-',A,')=', F7.3 , 3x,
     &             'Kcor=',F7.3
     &         )

      ENDDO

c -------------------------------

      RETURN
      END

C ===========================
+DECK,SNLCPLOT.
      SUBROUTINE SNLCPLOT()

c ---------------------------------------------
c Created Feb 2013 by R.Kessler
c 
c Pack light curve & best-fit function for snlc_fit.exe.
c Also pack optional info such as marginalized distributions.
c
c Jul 19, 2013: add MJD list to SNLCPAK_DATA
c Jan 25, 2014: use new I4EP_FIT and R4EP_FIT arrays.
c Dec 10, 2017: fix to work with SNTABLE_FILTER_REMAP
c Jan 23, 2020: pack KCOR and AVWARP for rest-frame model
c ---------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.    public snana.car
+CDE,SNFITCOM.    fitter info
+CDE,SNLCINP. 
+CDE,FILTCOM.
+CDE,FITRESTCOM.

      INTEGER MXEP_SNLCPAK   !  includes all filters
      PARAMETER ( MXEP_SNLCPAK = 10*MXEPOCH )

      CHARACTER  CCID*(MXCHAR_CCID)

      REAL*8
     &   VMJD(MXEP_SNLCPAK)
     &  ,VTOBS(MXEP_SNLCPAK)
     &  ,VFLUXOBS(MXEP_SNLCPAK)
     &  ,VFLUXOBS_ERR(MXEP_SNLCPAK)
     &  ,VFLUXREST(MXEP_SNLCPAK)  ! K-corrected rest-frame flux
     &  ,VKCOR(MXEP_SNLCPAK)
     &  ,VAVWARP(MXEP_SNLCPAK)
     &  ,VSIMFLUXREST(MXEP_SNLCPAK)  
     &  ,VSIMFLUXOBS(MXEP_SNLCPAK)   ! May 20 2016
     &  ,VZERO(MXEP_SNLCPAK)         ! zeros for true simFlux error
     &  ,VCHI2(MXEP_SNLCPAK)
     &  ,VREJECT(MXEP_SNLCPAK)
     &  ,VDUMERR(MXEP_SNLCPAK)  ! all zeros
     &  ,VBAND_NDOF(MXFILT_OBS)
     &  ,VBAND_CHI2(MXFILT_OBS)
     &  ,VBAND_PKFLUX(MXFILT_OBS)
     &  ,VBAND_PKFLUX_ERR(MXFILT_OBS)
     &  ,VBAND_PKMJD(MXFILT_OBS)
     &  ,VBAND_PKMJD_ERR(MXFILT_OBS)
c
     &  ,FLUX, COR, FPEAK, FPERR, PKMJD
     &  ,TMIN, TMAX, TBIN, xi, TOBS

      INTEGER
     &   LENCCID, NOBS, i, ifilt, ifilt_obs, NFILT, NBT, indxR4
     &  ,NFILTARG, IFILTARG, IFILTARG_MAP_SURVEY(MXFILT_ALL), NDOF
     &  ,IFILTOBS_REMAP, IFILT_REMAP_TMP
     &  ,VFILTOBS(MXEP_SNLCPAK) 
     &  ,VFILTREST(MXEP_SNLCPAK) 
      
      LOGICAL DO_RESTFLUX

c functions
      REAL*8 GET_FLUX_FITFUN
      LOGICAL DOPLOT_SNLC 

C -------------------- BEGIN ---------------

c check if plot should be made
      IF ( .NOT. DOPLOT_SNLC() ) RETURN

      LENCCID = ISNLC_LENCCID
      CCID = SNLC_CCID(1:LENCCID) // char(0)
      NFILT = NFILTDEF_SURVEY

      write(6,10) SNLC_CCID(1:LENCCID)
 10   format(T10,'SNLCPAK: pack CID = ',A,' for plotting.')
      call flush(6)

      DO_RESTFLUX = ( LREST_FITMODEL .or. NFILTDEF_FITRESTMAG > 0 )

c generate text strings
      CALL SNLCPAK_DISPLAYTEXT_FIT()

c -------------------------------------------
c load data flux, reject flags, chi2 ...

      DO IFILT = 1, MXFILT_OBS
          VBAND_NDOF(IFILT)   = 0.0
          VBAND_CHI2(IFILT)   = 0.0
          VBAND_PKMJD(IFILT)  = 0.0
          VBAND_PKFLUX(IFILT) = 0.0
      ENDDO
      
      DO 100 IFILT = 1, NFILT
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)

         IFILTARG  = IFILT
         NFILTARG  = NFILT
         IFILTARG_MAP_SURVEY(IFILTARG) = IFILT_OBS

         IF ( NFILT_REMAP_TABLE > 0 ) THEN
           CALL FILTER_REMAP_FETCH(IFILT_OBS,   ! (I)
     &               IFILTOBS_REMAP, IFILTARG)    ! (O)
           IFILTARG = IFILTARG + 1   ! C -> fortran
           NFILTARG = NFILT_REMAP_TABLE
           IFILTARG_MAP_SURVEY(IFILTARG) = IFILTOBS_REMAP
         ENDIF

         NDOF = int( XNFITDOF(IFILT) )
         IF ( NDOF == 0 ) GOTO 100  ! needed for REMAP filters

c  load each filter with the same PEAK-MJD value
         PKMJD                     = LCVAL_STORE(IPAR_PEAKMJD)
         VBAND_PKMJD(IFILTARG)     = PKMJD
         VBAND_PKMJD_ERR(IFILTARG) = LCERR_STORE(IPAR_PEAKMJD)
         VBAND_NDOF(IFILTARG)      = XNFITDOF(IFILT)     ! Ndof
         VBAND_CHI2(IFILTARG)      = LC_FITCHI2(IFILT)   ! chi2 per filter

c peak flux
         cor   =  PEAKFLUX_OBS_MODEL_COR(ifilt)
         Fpeak =  PEAKFLUX_OBS_MODEL(ifilt) * cor
         Fperr =  PEAKFLUX_OBS_MODEL_ERR(ifilt) * cor
         VBAND_PKFLUX(IFILTARG)     = Fpeak
         VBAND_PKFLUX_ERR(IFILTARG) = Fperr      
 100  CONTINUE


c - - - - - - - - - - - 

      NOBS = 0
      DO 101 i   = 1, NFITDATA + NFITDATA_REJECT
       
         NOBS = NOBS + 1

         IF ( NOBS .GT. MXEP_SNLCPAK ) THEN
            write(C1ERR,661) NOBS, MXEP_SNLCPAK
 661        format('NOBS=',I5,' exceeds bound of MXEP_SNLCMAX=',I5)
            c2err = 'Increase bound for data array.'
            CALL MADABORT('SNLCPLOT(SNFIT)', C1ERR, C2ERR)
         ENDIF

         IFILT_OBS       = I4EP_FIT(i,IEP_IFILT_OBS)
         VFILTOBS(NOBS)  = IFILT_OBS

c Dec 10 2017: check for filter-remap option 
         IF ( NFILT_REMAP_TABLE > 0 ) THEN
           CALL FILTER_REMAP_FETCH(IFILT_OBS,            ! (I)
     &               IFILTOBS_REMAP, IFILT_REMAP_TMP)    ! (O)
            VFILTOBS(NOBS)  = IFILTOBS_REMAP 
         ENDIF

         VMJD(NOBS)         = R4EP_FIT(i,JEP_MJD) + MJDOFF
         VTOBS(NOBS)        = R4EP_FIT(i,JEP_TOBS)
         VFLUXOBS(NOBS)     = R4EP_FIT(i,JEP_DATAFLUX)
         VFLUXOBS_ERR(NOBS) = R4EP_FIT(i,JEP_DATAFLUX_ERR)
         VREJECT(NOBS)      = I4EP_FIT(i,IEP_REJECT)
         VCHI2(NOBS)        = R4EP_FIT(i,JEP_DELCHI2)
         VSIMFLUXOBS(NOBS)  = R4EP_FIT(i,JEP_SIM_FLUXCAL)  ! May 20 2016
         VZERO(NOBS)        = 0.0 

         IF ( DO_RESTFLUX ) THEN
           VFILTREST(NOBS)    = I4EP_FIT(i,IEP_IFILT_REST1)
           VFLUXREST(NOBS)    = R4EP_FIT(i,JEP_DATAFLUX_REST)
           VKCOR(NOBS)        = R4EP_FIT(i,JEP_KCOR)
           VAVWARP(NOBS)      = R4EP_FIT(i,JEP_AVWARP)
           VSIMFLUXREST(NOBS) = R4EP_FIT(i,JEP_SIM_FLUXREST)
         ENDIF
 101  CONTINUE

      CALL SNLCPAK_DATA(CCID, NOBS, VMJD,VTOBS, VFLUXOBS, VFLUXOBS_ERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_FLUXDATA, LENCCID)

c store REJECT flags
      CALL SNLCPAK_DATA(CCID, NOBS, VMJD,VTOBS, VREJECT, VDUMERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_REJECT, LENCCID)

c store data-FITFUN chi2 
      CALL SNLCPAK_DATA(CCID, NOBS, VMJD,VTOBS, VCHI2, VDUMERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_CHI2, LENCCID)

      IF ( LSIM_SNANA .or. LSIM_MAGOBS ) THEN
c      pack generated SIM fluxes (May 20 2016)
        CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, 
     &     VSIMFLUXOBS, VZERO,   ! VZERO = zero error for each true flux 
     &     VFILTOBS, SNLCPAK_EPFLAG_FLUXSIM, LENCCID)
      ENDIF

c Jan 2014: store rest-frame filter and flux (mlcs,snoopy ...) 
c Jan 2020: add KCOR and AVwarp

      IF ( DO_RESTFLUX ) THEN
        CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VFLUXREST, VDUMERR, 
     &     VFILTREST, SNLCPAK_EPFLAG_FLUXREST, LENCCID)

        CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VKCOR, VDUMERR, 
     &     VFILTREST, SNLCPAK_EPFLAG_KCOR, LENCCID)

        CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VAVWARP, VDUMERR, 
     &     VFILTREST, SNLCPAK_EPFLAG_AVWARP, LENCCID)

        if ( LSIM_SNANA ) then
           CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, 
     &       VSIMFLUXREST, VDUMERR, VFILTREST, 
     &       SNLCPAK_EPFLAG_SIMFLUXREST, LENCCID)
        endif
      ENDIF

c store filter-dependent quantities.

      VMJD(1)  = -9999.
      VTOBS(1) = -9999.0  ! dummy for unused TOBS arg
      CALL SNLCPAK_DATA(CCID, NFILTARG, VMJD, VTOBS, 
     &     VBAND_NDOF, VDUMERR, 
     &     IFILTARG_MAP_SURVEY, SNLCPAK_BANDFLAG_NDOF, LENCCID)

      CALL SNLCPAK_DATA(CCID, NFILTARG, VMJD, VTOBS, 
     &     VBAND_CHI2, VDUMERR, 
     &     IFILTARG_MAP_SURVEY, SNLCPAK_BANDFLAG_CHI2, LENCCID)

      CALL SNLCPAK_DATA(CCID, NFILTARG, VMJD, VTOBS,
     &   VBAND_PKFLUX,VBAND_PKFLUX_ERR, 
     &   IFILTARG_MAP_SURVEY, SNLCPAK_BANDFLAG_PKFLUX, LENCCID)

      CALL SNLCPAK_DATA(CCID, NFILTARG, VMJD, VTOBS, 
     &   VBAND_PKMJD,VBAND_PKMJD_ERR, 
     &   IFILTARG_MAP_SURVEY, SNLCPAK_BANDFLAG_PKMJD, LENCCID)  

c ---------------------------------------
c load best-fit model

      NOBS = 0
      TMIN = -60.0
      TMAX = 140.0
      TBIN = DTOBS_MODEL_PLOT
      NBT  = int( (TMAX-TMIN+1.0E-6)/TBIN )

      DO 510 IFILT = 1, NFILT

         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         if ( .not. USE_FILT(ifilt_obs) ) goto 510

      DO 520 i  = 1, NBT
        NOBS    = NOBS + 1

         IF ( NOBS .GT. MXEP_SNLCPAK ) THEN
            write(C1ERR,661) NOBS, MXEP_SNLCPAK
            c2err = 'Increase bound for best-fit array.'
            CALL MADABORT('SNLCPLOT(SNFIT)', C1ERR, C2ERR)
         ENDIF

        xi      = float(i) - 0.5 
        TOBS    = TMIN + TBIN * xi 
        VFILTOBS(NOBS)      = IFILT_OBS
        VMJD(NOBS)          = TOBS + PKMJD + MJDOFF
        VTOBS(NOBS)         = TOBS
        VFLUXOBS(NOBS)      = GET_FLUX_FITFUN(ifilt_obs, Tobs,  0)
        VFLUXOBS_ERR(NOBS)  = GET_FLUX_FITFUN(ifilt_obs, Tobs, 60)

c Dec 10 2017: check for filter-remap option
        IF ( NFILT_REMAP_TABLE > 0 ) THEN
          CALL FILTER_REMAP_FETCH(IFILT_OBS,            ! (I)
     &              IFILTOBS_REMAP, IFILT_REMAP_TMP)    ! (O)
          VFILTOBS(NOBS)  = IFILTOBS_REMAP  
        ENDIF

         IF ( DO_RESTFLUX ) THEN
           VFILTREST(NOBS) = -9
           VFLUXREST(NOBS) = -999.
         ENDIF

 520  CONTINUE
 510  CONTINUE

      call flush(6)

      CALL SNLCPAK_DATA(CCID, NOBS, VMJD,VTOBS, VFLUXOBS, VFLUXOBS_ERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_FITFUN, LENCCID)

c fill output structure and write to disk
      CALL SNLCPAK_FILL(CCID, LENCCID)

c set global flag.
      MADE_LCPLOT = .TRUE.

      RETURN
      END   ! end of SNLCPLOT

C ============================================
+DECK,SNPKTEXT.
      SUBROUTINE SNLCPAK_DISPLAYTEXT_FIT()

      IMPLICIT NONE
c Create strings and pass them to generic wrapper SNLCPAK_DISPLAYTEXT()
c
c May 2013: tack on optional FITMAGDIF result 

+CDE,SNDATCOM. 
+CDE,SNANAFIT.    public snana.car
+CDE,SNFITCOM.    fitter info
+CDE,FILTCOM.

      CHARACTER  
     &   CCID*(MXCHAR_CCID), TEXT_forC*80
     &  ,CPAR*20, SPAR*20
     &  ,cDIST*60, cZPH*60, cCHI2*60
     &  ,cMAGDIF*28

      INTEGER
     &   LENCCID, LENTEXT, LENc, LENs, LENDIST, LENZPH, LENCHI2
     &  ,NDOF

      REAL*8  D, DERR, ZPH, ZPHERR, CHI2

      REAL*4 MAGVAL4, MAGERR4, PROB_MAGDIF4(2)

      LOGICAL LTMP

C -------------- BEGIN ------------

      LENCCID = ISNLC_LENCCID
      CCID = SNLC_CCID(1:LENCCID) // char(0)

      LENTEXT = LEN(TEXT_forC)

c ----------------------------------
c type and redshift
      write(TEXT_forC,40) ISNLC_TYPE, 
     &                SNLC_REDSHIFT, SNLC_REDSHIFT_ERR
 40   format('TYPE = ', I3, 5x,'z = ', F5.3,' +- ', F5.3 )


c tack on optional FITMAGDIF result (May 2013)
      LTMP = FILTER_FITMAGDIF .NE. '' 
      CALL GET_FITMAGDIF(MAGVAL4, MAGERR4, PROB_MAGDIF4 ) 
      IF ( LTMP .and. MAGERR4 .GE. 0.0 ) THEN
         write(cMAGDIF,44) FILTER_FITMAGDIF, MAGVAL4, MAGERR4
44       format('DELTA',A1,' = ', F5.2, ' +-',F5.2)
         TEXT_forC = TEXT_forC(1:50) // cMAGDIF
      ENDIF

c termination char
      TEXT_forC = TEXT_forC(1:LENTEXT-1) // char(0)

      CALL SNLCPAK_DISPLAYTEXT(CCID, TEXT_forC, LENCCID, LENTEXT )  

c ----------------------------------
c color and stretch params
      CPAR = PARNAME_STORE(IPAR_COLOR) ;  LENc = INDEX(CPAR, ' ') - 1      
      SPAR = PARNAME_STORE(IPAR_SHAPE) ;  LENs = INDEX(SPAR, ' ') - 1      
      write(TEXT_forC,41) 
     &    CPAR(1:LENc)
     &   ,LCVAL_STORE(IPAR_COLOR), LCERR_STORE(IPAR_COLOR)
     &   ,SPAR(1:LENs)
     &   ,LCVAL_STORE(IPAR_SHAPE), LCERR_STORE(IPAR_SHAPE)
     &   ,char(0)
 41   format(A,' = ',F6.3, ' +-', F6.3, 5x, 
     &       A,' = ',F6.3, ' +-', F6.3, A)
      CALL SNLCPAK_DISPLAYTEXT(CCID, TEXT_forC, LENCCID, LENTEXT )  

c ---------------------------------
c now distance (MU and or PHOTOZ) and chi2

      cDIST = ''  ; LENDIST = 0
      cZPH  = ''  ; LENZPH  = 0 
      cCHI2 = ''  ; LENCHI2 = 0

      if ( INISTP(IPAR_DLMAG) > 0.0 ) then  
         D    = LCVAL_STORE(IPAR_DLMAG)  ! MU or x0
         DERR = LCERR_STORE(IPAR_DLMAG)  ! error on above
         if ( D < 0.01 ) then  ! x0 in units of E-4
            write(cDIST,51) 10000.*D, 10000.*DERR
            LENDIST = INDEX(cDIST,'E') + 2
         else if ( D < 2.0 ) then ! x0 in units of E-2
            write(cDIST,52) 100.*D, 100.*DERR
            LENDIST = INDEX(cDIST,'E') + 2
         else  ! it's MU
            write(cDIST,55) D, DERR
            LENDIST = INDEX(cDIST,'+') + 7
         endif
 51      format( 'x0 = ('F6.3, ' +-', F6.3, ')xE-4'  )
 52      format( 'x0 = ('F6.3, ' +-', F6.3, ')xE-2'  )
 55      format( 'mu = ',F6.3, ' +-', F6.3  )
      endif

      if ( INISTP(IPAR_zPHOT) > 0.0 ) then  
         ZPH    = LCVAL_STORE(IPAR_zPHOT)
         ZPHERR = LCERR_STORE(IPAR_zPHOT)
         write(cZPH,60) ZPH, ZPHERR
 60      format('zPHOT = ', F6.3, ' +-',F6.3 )
         LENZPH = INDEX(cDIST,'+') + 7
      endif

c and finall the chi2/dof
      CHI2 = LCCHI2_STORE(1)
      NDOF = INT( XNFITDOF(0))
      if ( CHI2 .LT. 999.99 ) then
        write(cCHI2,71) CHI2, NDOF
        LENCHI2 = 24
      else
        write(cCHI2,72) CHI2, NDOF
        LENCHI2 = 27
      endif
 71   format('chi2/dof = ',F5.1,' /', I5)
 72   format('chi2/dof = ',F8.1,' /', I5)



c glue the pieces together into one string.

      TEXT_forC = cDIST(1:LENDIST) // '   ' 
     &         // cZPH(1:LENZPH)   // '   ' 
     &         // cCHI2(1:LENCHI2) // char(0)

      CALL SNLCPAK_DISPLAYTEXT(CCID, TEXT_forC, LENCCID, LENTEXT )  

      RETURN
      END



C =====================================================
+PATCH,*SNTABFIT.
C =====================================================

c routines need to create fitres table and NN table

C ========================================
+DECK,TABLE_SNFIT.
      SUBROUTINE TABLE_SNFIT(ID,IFLAG)

C Created Feb 1, 2013
C Book and load table.
c
c ID    = table identifier
c IFLAG = IFLAG_INI or IFLAG_ANA
c
c
c     HISTORY
c July 19 2016: call TABLE_STRING_TERMINATION(+1/-1)
c               to protect strings for ROOT.
c
c Apr 18 2022: pass ID and IFLAG args
c -----------------------------------------

      IMPLICIT NONE

      INTEGER ID, IFLAG

c local var

+CDE,SNDATCOM.
+CDE,SNFITCOM.

      INTEGER i, LENNAME, LENFMT
      CHARACTER NAME*40, TEXTFMT*20, TEXTFMT_forC*20
      LOGICAL CREATE_FILE

c ----------------- BEGIN ------------------------
      
cc xxxx      ID = IDTABLE_FITRES

c ----------------------------------
      
      IF ( IFLAG == IFLAG_INI ) THEN
         
         NAME    = 'FITRES' // char(0)
         LENNAME  = INDEX(NAME,   ' ') - 1

         TEXTFMT  = TEXTFORMAT_TABLE(ITABLE_FITRES)
         LENFMT   = INDEX(TEXTFMT,' ') - 1
         TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)

         CALL SNTABLE_CREATE(ID,NAME,TEXTFMT_forC, LENNAME,LENFMT)  ! C fun

           CALL INIT_TABLE_SNANAVAR(ID, 'SNANA', 2)
           CALL INIT_TABLE_SNFITVAR(ID, 'SNFIT'   )

c         optional epoch-dependent par
          IF ( OPT_TABLE(ITABLE_FITRES) .EQ. 2 ) THEN
             CALL INIT_TABLE_SNFITEP(ID, 'SNFITEP')
          ENDIF

c       for sims ...
          IF ( LSIM_SNANA ) THEN
            CALL INIT_TABLE_SIMVAR(ID, 'SIMVAR')
          ENDIF

        RETURN
      ENDIF

c ------------------------------------
c  fill table

      IF ( IFLAG == IFLAG_ANA ) THEN

c   terminate strings for C table-functions (snana.car routine)
        CALL TABLE_STRING_TERMINATION(+1)

        CALL SNTABLE_FILL(ID)  ! generic C function

        CALL TABLE_STRING_TERMINATION(-1)  ! remove termination
      END IF

c ------------------------------------

      RETURN
      END  ! end of TABLE_SNFIT


C =====================================
+DECK,TBFITVAR.
      SUBROUTINE INIT_TABLE_SNFITVAR(ID,BLOCK)
c
c Created Feb 1, 2013
c
c Initialize variables for snfitres-analysis table.
c Call generic function SNTABLE_ADDCOL() that loads a table 
c for each selected format: CERNLIB, ROOT, HDF5 ...
c The VARLIST string is constructed for HBNAME so that it trivially
c works for HBOOK; will need extra parsing (in SNTABLE_ADDCOL)
c for root and hdf5.  
c
c This routine is intended to replace CWNT_HBNAMES_SNFITVAR()
c
c Apr 29, 2013:
c    ERR_[PARNAME] -> [PARNAME]ERR to have same names in the
c    text/fitres file. Also changed PHOTOZ -> ZPHOT in FITPAR_INI
c    Note extra SUFFIX arg in TABLE_PARNAMES.
c
c    ERRFLAG[ipar1][ipar2] -> ERRFLAG_[parname]
c
c    RHO[ipar1][ipar2] -> REDCOV_[nam1]_[nam2]
c         and add COV_[nam1]_[nam2]
c
c June 14, 2013: add optional Zmax variables for 1/Vmax option
c
c Jan  4 2016: add MNSTAT_COV
c Aug 29 2017: add fit params for IDEAL fit
c
c Mar 19 2018: 
c   + call function SKIPTABLE_FITPAR(VARNAME)
c   + write OPT_PHOTOZ to table if ZPHOT info is suppressed.
c
c Nov 11 2019:
c  Protect adding non-PKMJD covariance columns if there aren't any
c  when stretch and color are both fixed instead of floated.
c
c Mar 02 2022: add zPRIOR and zPRIOR_ERR
c
c --------------

      IMPLICIT NONE
      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK

c local var
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.
+CDE,USRTAGCM.
+CDE,TABLEVARCOM.
+CDE,VMAXCOM.
+CDE,FITIDEALCOM.

      INTEGER IPAR_START
      PARAMETER (IPAR_START=3)  ! skip ISN and ITER for CWN

      INTEGER 
     &    IFILT, IFILT_OBS, OPT_STORE, USE4TEXT
     &   ,LENLIST, LENPKMJD, LENNAME, LENNAME2, LENBLOCK, LENPACK
     &   ,NTPAR_MIN, NTPAR_MAX, NTPAR, ipar

      LOGICAL   LTMP
      CHARACTER varlist*1000, VARNAME*60, STR_IPACK*40, CBLOCK*40
      CHARACTER CFILT*1, SUFFIX_R*12, SUFFIX_I*12, PNAM*40

      LOGICAL  SKIPTABLE_FITPAR  ! function

C ---------------- BEGIN ------------

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENBLOCK = INDEX(BLOCK//' ',' ') - 1
      LENLIST  = LEN(VARLIST)
      CBLOCK   = BLOCK(1:LENBLOCK) // char(0)

c mar 18 2018: write OPT_PHOTOZ if ZPHOT output is suppressed 
      IF ( .not. WRTABLEFILE_ZPHOT ) then
         VARLIST = 'OPT_PHOTOZ:I' // char(0)
         LENLIST = INDEX(VARLIST, ' ') - 1
         CALL SNTABLE_ADDCOL(ID, CBLOCK, OPT_PHOTOZ,
     &           VARLIST(1:LENLIST)//char(0), 1, LENBLOCK, LENLIST )
      ENDIF

c - - - - start with SNANA-analogs that could not be computed in snana

      CALL TABLE_VARLIST_FILTERS('SNRMAX','F',SURVEY_FILTERS_TABLE,
     &        VARLIST, LENLIST)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBL_SNRMAX, 
     &           VARLIST(1:LENLIST)//char(0),0, LENBLOCK, LENLIST )


      CALL TABLE_VARLIST_FILTERS('XTMW', 'F', SURVEY_FILTERS_TABLE, 
     &        VARLIST, LENLIST)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBL_XTMW, 
     &           VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST )
      LENLIST = LEN(VARLIST)

c - - - - fit parameters and errors (skip BIDON values)

      NTPAR_MIN = IPAR_START
      NTPAR_MAX = IPAR_MAX

      DO 380 ipar = NTPAR_MIN, NTPAR_MAX
         VARNAME = PARNAME_STORE(ipar)
         LENNAME = INDEX(VARNAME,' ') - 1

         IF( SKIPTABLE_FITPAR(VARNAME) ) GOTO 380

         VARLIST = VARNAME(1:LENNAME)// ':F'   ! include cast
         LENLIST = INDEX(VARLIST,' ') - 1
         CALL SNTABLE_ADDCOL(ID, CBLOCK, LCVAL_STORE(ipar), 
     &        VARLIST(1:LENLIST)//char(0), 1, LENBLOCK, LENLIST)

c now the fitted error.
         VARLIST  = VARNAME(1:LENNAME) // 'ERR:F' 
         LENLIST  = INDEX(VARLIST,' ') - 1
         CALL SNTABLE_ADDCOL(ID, CBLOCK, LCERR_STORE(ipar), 
     &        VARLIST(1:LENLIST)//char(0), 1, LENBLOCK, LENLIST)

 380  CONTINUE


c ----------------------------------------------------
c check for additional IDEAL fit with FLUX = TRUEFLUX

      IF ( SIMFIT_IDEAL_PRESCALE > 0  ) THEN
        DO 381 ipar = NTPAR_MIN, NTPAR_MAX
          VARNAME = PARNAME_STORE(ipar)
          LENNAME = INDEX(VARNAME,' ') - 1

          IF ( SKIPTABLE_FITPAR(VARNAME) ) GOTO 381

c xxx mark delete  IF ( VARNAME(1:5) .EQ. 'BIDON'    ) GOTO 381
c xxx          IF ( VARNAME(1:8) .EQ. 'REDSHIFT' ) GOTO 381

          VARLIST = VARNAME(1:LENNAME)// '_IDEAL:F'   ! include cast
          LENLIST = INDEX(VARLIST,' ') - 1
          CALL SNTABLE_ADDCOL(ID, CBLOCK, FITPAR_IDEAL(ipar), 
     &        VARLIST(1:LENLIST)//char(0), 1, LENBLOCK, LENLIST)
 381  CONTINUE

      ENDIF

c ----------------------------------------------------
c marginalized PDF-probs
      IF ( NGRID_PDF > 0 ) THEN

         DO 388 ipar = 3, IPAR_MAX  ! skip ISN and ITER
            PNAM    = PARNAME_STORE(IPAR)
            if ( PNAM(1:5) .EQ. 'BIDON' ) GOTO 388
            LENNAME = INDEX(PNAM,' ') - 1
            VARNAME = 'PDFPROB_' // PNAM(1:LENNAME) // ':F' // char(0)
            CALL SNTABLE_ADDCOL(ID, CBLOCK, PDFPROB2_STORE(IPAR), 
     &           VARNAME, 0, LENBLOCK, 30)
 388    CONTINUE

      ENDIF

c - - - - -  ERRFLAGs - - - - - -

      CALL TABLE_VARLIST_ERRFLAG(NTPAR_MIN, NTPAR_MAX, VARLIST, LENLIST)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, ERRTYPE_STORE(NTPAR_MIN), 
     &        VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)

c - - - - - - 
c add Covariance status (Jan 2016) from MNSTAT call
c  MNSTAT_COV  = 2 -> was forced to be pos-definite
c              = 3 -> full accurate coc matrix
c  MNSTAT_COV  < 2 -> bad matrix and is rejected

      VARLIST = 'MNSTAT_COV:I' // char(0)
      LENLIST = LEN(VARLIST)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, MNSTAT_COV, VARLIST, 0,
     &                   LENBLOCK, LENLIST)

c - - - - correlations - - - - - -

c reduced covariance (-1 <= RHO <=  +1)
      USE4TEXT = 0
      CALL TABLE_VARLIST_COV(1, VARLIST, LENLIST, LENPKMJD ) 
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBL_REDCOV, 
     &        VARLIST(1:LENLIST)//char(0), USE4TEXT, LENBLOCK,LENLIST)

c full covariance; 
      CALL TABLE_VARLIST_COV(2, VARLIST, LENLIST, LENPKMJD )

c add PKMJD-covariances 
      IF (LENPKMJD > 0 ) THEN
         USE4TEXT = 0
         CALL SNTABLE_ADDCOL(ID, CBLOCK, TBL_COV, 
     &        VARLIST(1:LENPKMJD)//char(0), USE4TEXT, LENBLOCK,LENPKMJD)
      ENDIF

c add other [non-PKMJD] covariances and include in optional text table.
c Make sure to skip the comma after the PKMJD-covariance list.
      IF ( LENLIST > LENPKMJD ) THEN
        USE4TEXT = 1
        CALL SNTABLE_ADDCOL(ID, CBLOCK, TBL_COV(NCOV_TBL_PKMJD+1), 
     &        VARLIST(LENPKMJD+2:LENLIST)//char(0), 
     &        USE4TEXT, LENBLOCK, LENLIST-LENPKMJD )
      ENDIF
c - - - - - -   PHOTOZ - - - - - 

      LENLIST = LEN(VARLIST)

      IF ( DOFIT_PHOTOZ ) THEN

        VARLIST = 'zPRIOR:F,zPRIORERR:F' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, PRIOR_PHOTOZ, VARLIST,1,
     &                   LENBLOCK, LENLIST)

        VARLIST = 'ZPULL:F' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, PHOTOZ_ERR_ZPULL, VARLIST,0,
     &                   LENBLOCK, LENLIST)

        VARLIST = 'NEARDROP:I' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, IFILT_NEARDROP, VARLIST,0,
     &                   LENBLOCK, LENLIST)

        VARLIST = 'DZMIN1:F,DZMIN2:F' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, PHOTODZ_MIN, VARLIST,0,
     &                   LENBLOCK, LENLIST)

        VARLIST = 'DZ1ZMIN1:F,DZ1ZMIN2:F' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, PHOTODZ1Z_MIN, VARLIST,0, 
     &                   LENBLOCK, LENLIST)

      ENDIF

c - - - - -  misc. variables - - - -        

      DO 333 IPAR = IPAR_MAX+1, NPLOTPAR
         VARNAME  = PARNAME_STORE(ipar)
         LENNAME  = INDEX(VARNAME,' ') - 1
         VARLIST  = VARNAME(1:LENNAME)// ':F'   ! include cast
         LENLIST  = INDEX(VARLIST,' ') - 1
         USE4TEXT = PAROPT_STORE(ipar)

         CALL SNTABLE_ADDCOL(ID, CBLOCK, LCVAL_STORE(ipar), 
     &        VARLIST(1:LENLIST)//char(0), USE4TEXT, 
     &         LENBLOCK, LENLIST )       

 333  CONTINUE

c - - - - - - - - - - - - - - - - - - - - 

      LENLIST = LEN(VARLIST)

c - - - - - NFILT used in fit - - - - - 

      VARLIST = 'NFILT_USEFIT:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, NFILT_OBS_USEFIT, VARLIST, 0,
     &                   LENBLOCK, LENLIST)

c - - - - - Zmax for 1/Vmax option

      DO 404 IFILT = 1, NFILT_VMAX

         CFILT = FILTLIST_VMAX(IFILT:IFILT)
         SUFFIX_R = '_' // CFILT // ':F' // char(0)
         SUFFIX_I = '_' // CFILT // ':I' // char(0)

         VARLIST = 'mag_Vmax' // SUFFIX_R
         CALL SNTABLE_ADDCOL(ID, CBLOCK, MAG_LIST_VMAX(ifilt), VARLIST,
     &        0, LENBLOCK, LENLIST)  

         VARLIST = 'Trest_Vmax' // SUFFIX_R
         CALL SNTABLE_ADDCOL(ID,CBLOCK,TREST_LIST_VMAX(ifilt),VARLIST,
     &        0, LENBLOCK, LENLIST)
         
         VARLIST = 'z_Vmax' // SUFFIX_R
         CALL SNTABLE_ADDCOL(ID, CBLOCK, z_LIST_VMAX(ifilt), VARLIST,
     &        0, LENBLOCK, LENLIST)

         VARLIST = 'vol_Vmax' // SUFFIX_R
         CALL SNTABLE_ADDCOL(ID, CBLOCK, VOL_LIST_VMAX(ifilt), VARLIST,
     &        0, LENBLOCK, LENLIST)

         VARLIST = 'NEP_Vmax' // SUFFIX_I
         CALL SNTABLE_ADDCOL(ID, CBLOCK, NEP_LIST_VMAX(ifilt), VARLIST,
     &        0, LENBLOCK, LENLIST)

 404  CONTINUE

      RETURN
      END   ! end of  INIT_TABLE_SNFITVAR


C =====================================
+DECK,SKIPTABLE_FITPAR.
      LOGICAL FUNCTION SKIPTABLE_FITPAR(VARNAME)

c Created Mar 2018
c Return TRUE if this variable should be suppressed
c from table output.

      IMPLICIT NONE
      CHARACTER VARNAME*(*)  ! (I) name of fitpar variable to check

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.

      LOGICAL  SKIP

c ------------- BEGIN -------------
      SKIP = .FALSE.

      IF ( VARNAME(1:5) .EQ. 'BIDON'    ) SKIP = .TRUE.
      IF ( VARNAME(1:8) .EQ. 'REDSHIFT' ) SKIP = .TRUE.

      IF ( VARNAME(1:5) .EQ. 'zPHOT' ) THEN
        IF ( DOFIT_PHOTOZ .and. (.not.WRTABLEFILE_ZPHOT) )then
           SKIP = .TRUE.
        ENDIF
      ENDIF

       SKIPTABLE_FITPAR = SKIP
      RETURN
      END

C ========================================
+DECK,TBFITEP.
      SUBROUTINE INIT_TABLE_SNFITEP(ID,BLOCK)

c Created Feb 2, 2013

c Init table for epoch-dependent variables.
c (replaces CWNT_HBNAMES_RESID)
c 
c Feb 22 2016: always do the extra EP variables, even for TERSE format.
c              See EXTRA_EPVAR
c
c Jul 22 2017: add BAND (character for IFILT_OBS)
c Jan 23 2020: add AVWARP for rest-frame models with k-corrections
c
c ----------------------------------------------

      IMPLICIT NONE
      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FITRESTCOM.

      INTEGER LENB, LENV
      CHARACTER CBLK*40, CNFIT*14, VARNAME*40
      LOGICAL EXTRA_EPVAR

c ---------------- BEGIN ----------------

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENV   = LEN(VARNAME)
      LENB   = INDEX(BLOCK//' ',' ') - 1
      CBLK   = BLOCK(1:LENB) // char(0)
c --------------------------------

      write(CNFIT,15) MXFIT_DATA 
15    format('NPTFIT[',I4.4,']' )  ! no spaces or commas in string
      VARNAME = CNFIT(1:12)  // char(0)  ! Nobs used in fit + NREJECT
      CALL SNTABLE_ADDCOL(ID, CBLK, NFITDATA_TOTAL, 
     &     VARNAME, 0, LENB,LENV)

      VARNAME = 'REJECT(NPTFIT):I' // char(0)  ! 1 -> rejected from fit
      CALL SNTABLE_ADDCOL(ID,CBLK, I4EP_FIT(1,IEP_REJECT),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'MJD(NPTFIT):F'  // char(0)   ! MJD
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_MJD), 
     &        VARNAME, 0, LENB, LENV)

      VARNAME = 'TOBS(NPTFIT):F'  // char(0)     ! MJD - PEAKMJD
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_TOBS),
     &        VARNAME, 0, LENB, LENV)

      VARNAME = 'TREST(NPTFIT):F'  // char(0)  ! Tobs/(1+z)
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_TREST), 
     &         VARNAME, 0, LENB,LENV)

      VARNAME = 'IFILTOBS(NPTFIT):I' // char(0)  ! abs. obs-frame filter indx
      CALL SNTABLE_ADDCOL(ID,CBLK, I4EP_FIT(1,IEP_IFILT_OBS), 
     &      VARNAME, 0, LENB,LENV)

c xxxxxxxxxxxxxxxxxxxxxx
c Jul 22 2017: add BAND, but beware that MXFIT_DATA must be < 1000
c              to work with HBOOK. Also doens't work right with HBOOK
c              when lower and upper case are mixed: e.g., grGR              
c      VARNAME = 'BAND(NPTFIT):C*4' // char(0)  ! abs. obs-frame filter char
c      CALL SNTABLE_ADDCOL(ID,CBLK, BANDEP_FIT(1),
c     &      VARNAME, 0, LENB, LENV)
c xxxxxxxxxxxxxxxxxxxxxx

c xxxx remove IDTEL Nov 30 2020 xxxxxxx
c      VARNAME = 'IDTEL(NPTFIT):I' // char(0)   ! telescope/survey ID
c      CALL SNTABLE_ADDCOL(ID,CBLK, I4EP_FIT(1,IEP_IDTEL), 
c     &       VARNAME, 0, LENB,LENV)
cv xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

      VARNAME = 'FLUXCAL_DATA(NPTFIT):F' // char(0)  ! FLUXCAL, data
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_DATAFLUX), 
     &        VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXCAL_DATA_ERR(NPTFIT):F' // char(0) 
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_DATAFLUX_ERR), 
     &        VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXCAL_MODEL(NPTFIT):F' // char(0)  ! fluxcal from best-fit
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_MODELFLUX), 
     &        VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXCAL_MODEL_ERR(NPTFIT):F' // char(0)  ! error on above
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_MODELFLUX_ERR), 
     &        VARNAME, 0, LENB,LENV)

      VARNAME = 'MODELMAG_ERR(NPTFIT):F' // char(0)  ! model error, mag
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_MODELMAG_ERR), 
     &       VARNAME, 0, LENB,LENV)

      VARNAME = 'FUDGEFLUX_ERR(NPTFIT):F' // char(0) ! fudge error on flux
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_FUDGEFLUX_ERR), 
     &        VARNAME, 0, LENB,LENV)

      VARNAME = 'LAMREST(NPTFIT):F' // char(0)  ! <lam_obs>/(1+z)
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_LAMREST), 
     &       VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXDIF(NPTFIT):F' // char(0)  ! data-model flux dif
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_RESID), 
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXDIF_ERR(NPTFIT):F' // char(0)  ! dif err,include model err
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_RESID_ERR), 
     &       VARNAME, 0, LENB,LENV)

      VARNAME = 'MAGDIF(NPTFIT):F' // char(0)  ! data-model magDif
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_MAGDIF), 
     &       VARNAME, 0, LENB,LENV)

      VARNAME = 'CHI2FLUX(NPTFIT):F' // char(0)  ! (DIF/DIF_ERR)**2
      CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_DELCHI2), 
     &       VARNAME, 0, LENB,LENV)


      IF ( LSIM_SNANA .or. LSIM_MAGOBS ) THEN
         VARNAME = 'FLUXCAL_SIM(NPTFIT):F' // char(0) 
         CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_SIM_FLUXCAL), 
     &        VARNAME, 0, LENB,LENV)

         VARNAME = 'CHI2FLUX_SIM(NPTFIT):F' // char(0) 
         CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_SIM_DELCHI2), 
     &        VARNAME, 0, LENB,LENV)
      ENDIF

c extra 'observing' variables

      EXTRA_EPVAR = .TRUE.
      IF ( EXTRA_EPVAR ) THEN
        VARNAME = 'PSF(NPTFIT):F' // char(0)  ! PSF-sigma arcsec
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_PSF), 
     &       VARNAME, 0, LENB,LENV)

        VARNAME = 'NEA(NPTFIT):F' // char(0)  ! noise-equiv-area, asec^2
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_NEA), 
     &       VARNAME, 0, LENB,LENV)

        VARNAME = 'SKYSIG(NPTFIT):F' // char(0)  ! sky noise per pixel
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_SKYSIG), 
     &       VARNAME, 0, LENB,LENV)

        VARNAME = 'SKYSIG_T(NPTFIT):F' // char(0)  ! templ noise per pixel
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_SKYSIG_T), 
     &       VARNAME, 0, LENB,LENV)

        VARNAME = 'ZP(NPTFIT):F' // char(0)  ! zeropoint, FLUX(ADU) to mag
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_ZP), 
     &       VARNAME, 0, LENB,LENV)

        VARNAME = 'ZP_ERR(NPTFIT):F' // char(0)  ! error on above
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_ZPERR), 
     &       VARNAME, 0, LENB,LENV)

        VARNAME = 'GAIN(NPTFIT):F' // char(0)  ! e/ADU
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_GAIN), 
     &       VARNAME, 0, LENB,LENV)

        if ( SNLC_NXPIX > 0 ) then
           VARNAME = 'XPIX(NPTFIT):F' // char(0)  
           CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_XPIX), 
     &          VARNAME, 0, LENB,LENV)

           VARNAME = 'YPIX(NPTFIT):F' // char(0)  
           CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_YPIX), 
     &          VARNAME, 0, LENB,LENV)

           VARNAME = 'AREAFRAC(NPTFIT):F' // char(0)  
           CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_AREAFRAC), 
     &          VARNAME, 0, LENB,LENV)
        endif

        VARNAME = 'SKYFLUXCAL(NPTFIT):F' // char(0)  ! FLUXCAL(SKY)/pix 
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_SKYFLUXCAL), 
     &       VARNAME, 0, LENB,LENV)

        VARNAME = 'SBFLUXCAL(NPTFIT):F' // char(0)  ! host surf. bright/asec^2
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_SBFLUXCAL), 
     &         VARNAME, 0, LENB,LENV)

        VARNAME = 'ERRTEST(NPTFIT):F' // char(0)  ! calc/true error ratio
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_ERRTEST), 
     &        VARNAME, 0, LENB,LENV)

        VARNAME = 'FLUXERRCALC_SIM(NPTFIT):F' // char(0)  ! calc error
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_ERRCALC), 
     &        VARNAME, 0, LENB,LENV)

        VARNAME = 'PHOTPROB(NPTFIT):F' // char(0)  ! Dec 17, 2014
        CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_PHOTPROB), 
     &        VARNAME, 0, LENB,LENV)

      ENDIF

c optionl rest-frame info for rest-frame model

      IF ( LREST_FITMODEL .or. NFILTDEF_FITRESTMAG > 0 ) THEN
         VARNAME = 'IFILTREST1(NPTFIT):I' // char(0)  ! nearest IFILT_REST
         CALL SNTABLE_ADDCOL(ID,CBLK, I4EP_FIT(1,IEP_IFILT_REST1), 
     &         VARNAME, 0, LENB, LENV)

         VARNAME = 'IFILTREST2(NPTFIT):I' // char(0)  ! 2nd nearest IFILT_REST
         CALL SNTABLE_ADDCOL(ID,CBLK, I4EP_FIT(1,IEP_IFILT_REST2), 
     &         VARNAME, 0, LENB, LENV)

         VARNAME = 'AVWARP(NPTFIT):F' // char(0)  ! AVwarp for kcor
         CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_AVWARP), 
     &         VARNAME, 0, LENB,LENV)

         VARNAME = 'KCOR(NPTFIT):F' // char(0)  ! k correction
         CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_KCOR), 
     &         VARNAME, 0, LENB,LENV)

         VARNAME = 'FLUXCAL_REST(NPTFIT):F' // char(0) 
         CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_DATAFLUX_REST),
     &         VARNAME, 0, LENB,LENV)

         IF ( LSIM_SNANA ) THEN
           VARNAME = 'SIM_FLUXCAL_REST(NPTFIT):F' // char(0)
           CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_SIM_FLUXREST),
     &          VARNAME, 0, LENB,LENV)

           VARNAME = 'SIM_MAGREST(NPTFIT):F' // char(0)
           CALL SNTABLE_ADDCOL(ID,CBLK, R4EP_FIT(1,JEP_SIM_MAGREST), 
     &          VARNAME, 0, LENB,LENV)
         ENDIF

      ENDIF

      RETURN
      END   ! end of INIT_TABLE_SNFITEP

C ======================
+DECK,TBVARERR.
      SUBROUTINE TABLE_VARLIST_ERRFLAG(IPAR_MIN,IPAR_MAX, 
     &                                 VARLIST,LENLIST )

C Created Sep 2012
c Return VARLIST string for HBNAME call to initialize ERRFLAGs.
c
c Feb  5, 2013: return LENLIST
c Apr 29, 2013: ERRFLAG_[ipar] -> ERRFLAG_[name] to be more clear
c
c ----------------------------

c subroutine args

      IMPLICIT NONE
      INTEGER IPAR_MIN, IPAR_MAX  ! (I) IPAR range
      CHARACTER VARLIST*(*)       ! (O) comma-separate par-name list
      INTEGER   LENLIST           ! (O) length of VARLIST

c local var
+CDE,SNDATCOM.
+CDE,SNANAFIT.

      INTEGER ipar,  LENNAME, LENPACK
      character CTMP*20, C2*2, STR_IPACK*40, NAME*40

C ----------- BEGIN ------------

      do ipar = IPAR_MIN, IPAR_MAX

         write(c2,22) ipar
22       format(I2.2)

         NAME    = PARNAME_STORE(IPAR)
         LENNAME = INDEX(NAME,' ') - 1

         CTMP = 'ERRFLAG_' // NAME(1:LENNAME) // ':I' 

         if ( ipar  .EQ. IPAR_MIN ) then
            VARLIST = CTMP
         else
            LENLIST = INDEX(VARLIST,' ') - 1           
            VARLIST = VARLIST(1:LENLIST) // ',' // CTMP
         endif
      enddo

      LENLIST = INDEX(VARLIST,' ') - 1   

      RETURN
      END

C =======================================================
+DECK,TBLVARCOV.
      SUBROUTINE TABLE_VARLIST_COV(FLAGCOV,VARLIST,LENLIST,LENPKMJD)

c Created Sep 2012
c Return covariance VARLIST to pass to SNTABLE_ADDCOL().
c
c Input:
c   FLAGCOV   = 1, 2 --> reduced, full covariance
c
c Outputs:
c   VARLIST  = string to pass to SNTABLE_ADDCOL. 
c   LENLIST  = length of entire varlist
c   LENPKMJD = length of sub-list with only the PKMJD elements.
c
c In addition to return arguments, the following globals
c are also computed to help evaluate the COV arrays needed 
c to fill the SNTABLE(s).
c
c   NCOV_TBL, NCOV_TBL_PKMJD, IPAR_TBL_COV
c
c
c          HISTORY
c        ~~~~~~~~~~~
c
c Apr 29 2013: RHO -> REDCOV and replace IPAR with PARNAME_STORE
c              e.g., RHO34 -> REDCOV_pkmjd_x1
c
c May 13 2014: 
c   - remove terms with BIDON and add FLAGPKMJD flag.
c   - overhaul using new keep, TABLEVARCOM.
c
c Mar 19 2018: check SKIP_ZPHOT option
c 
c ------------------------------------

      IMPLICIT NONE
      INTEGER   FLAGCOV              ! (I)
      CHARACTER VARLIST*(*)          ! (O) 
      INTEGER   LENLIST, LENPKMJD    ! (O) 
      
c local args

+CDE,SNDATCOM.
+CDE,SNANAFIT.         PARNAME_STORE  is here
+CDE,SNFITPAR.
+CDE,TABLEVARCOM.

      INTEGER IPAR1, IPAR2,  LENNAME, LEN1, LEN2
      character ctmp*60, NAM1*40, NAM2*40
      LOGICAL SKIP_ZPHOT

C -------------------- BEGIN ----------------

      LENLIST  = 0
      LENPKMJD = 0

      NCOV_TBL = 0  ;  NCOV_TBL_PKMJD = 0
      SKIP_ZPHOT = (.not. WRTABLEFILE_ZPHOT)

      DO 21 ipar1 = IPAR_PEAKMJD, IPAR_MAX-1  ! start with PEAKMJD
         if ( .not. FLOATPAR(ipar1) ) GOTO 21
         if ( IPAR1 .EQ. IPAR_ZPHOT .and. SKIP_ZPHOT) goto 21

      DO 22 ipar2 = ipar1+1, IPAR_MAX
         if ( .not. FLOATPAR(ipar2) ) GOTO 22
         if ( IPAR2 .EQ. IPAR_ZPHOT .and. SKIP_ZPHOT) goto 22

         NAM1 = PARNAME_STORE(ipar1) ; LEN1 = INDEX(NAM1,' ') - 1
         NAM2 = PARNAME_STORE(ipar2) ; LEN2 = INDEX(NAM2,' ') - 1

         if ( NAM1(1:5) .EQ. 'BIDON' ) GOTO 22
         if ( NAM2(1:5) .EQ. 'BIDON' ) GOTO 22
         if ( NAM2(1:5) .EQ. 'PKMJD' ) GOTO 22

         IF ( FLAGCOV .EQ. 1 ) THEN   
            write(ctmp,30) 'REDCOV', NAM1(1:LEN1), NAM2(1:LEN2)
         ELSE
            write(ctmp,30) 'COV',    NAM1(1:LEN1), NAM2(1:LEN2)
         ENDIF

30       format( A, '_', A, '_', A )

         LENNAME   = INDEX(Ctmp,' ') - 1
         LENLIST   = INDEX(VARLIST,' ') - 1
         NCOV_TBL  = NCOV_TBL + 1
         IPAR_TBL_COV(1,NCOV_TBL) = IPAR1
         IPAR_TBL_COV(2,NCOV_TBL) = IPAR2

         if ( NCOV_TBL .EQ. 1 ) then
            VARLIST = CTMP(1:LENNAME) // ':F'
         else
            VARLIST = VARLIST(1:LENLIST) // ',' // 
     &           CTMP(1:LENNAME) // ':F'
         endif

         if ( IPAR1 .EQ. IPAR_PEAKMJD ) then
            NCOV_TBL_PKMJD = NCOV_TBL_PKMJD + 1
            LENPKMJD = INDEX(VARLIST,' ') - 1
         endif

22    CONTINUE
21    CONTINUE

      LENLIST = INDEX(VARLIST,' ') - 1

      RETURN
      END   ! end of TABLE_VARLIST_COV


C ===================================================
+DECK,TABLE_SNSPEC_SALT2.
      SUBROUTINE TABLE_SNSPEC_SALT2(isn)   
c
c Prepare table for SALT2 spectra computed from LC fit params.
c 
c Mar 21 2022: compute TBLSPEC_MAG_MODEL[_ERR] for each band and MJD
c
c -------------------------------
      IMPLICIT NONE
      INTEGER   ISN   ! 0->init, otherwise fill

c local var

+CDE,SNDATCOM.
+CDE,SNFITCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.
+CDE,TABLEVARCOM.

      INTEGER ID, i, ep, LENNAME, LENFMT
      INTEGER IFILT, IFILTOBS, IFILTOBS_TMP
      REAL    Tobs, z, x0, x1, c, MWEBV
      REAL*8  FLUX8, FLUXERR8, MAG8, MAGERR8, KCOR8
      CHARACTER NAME*40, TEXTFMT*20, TEXTFMT_forC*20

c function
      INTEGER  getSpec_band_SALT2
      EXTERNAL getSpec_band_SALT2
c ----------------- BEGIN ------------------------
      
      ID = IDTABLE_MODELSPEC

c ----------------------------------

      IF ( ISN .EQ. 0 ) THEN

         NAME    = 'SPECTRA' // char(0)
         LENNAME  = INDEX(NAME,   ' ') - 1

         TEXTFMT  = TEXTFORMAT_TABLE(ITABLE_FITRES)
         LENFMT   = INDEX(TEXTFMT,' ') - 1
         TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)

         CALL SNTABLE_CREATE(ID,NAME,TEXTFMT_forC, LENNAME,LENFMT)  ! C fun

         CALL INIT_TABLE_SNSPECVAR(ID, 'SNSPEC' )

        RETURN
      ENDIF

c ------------------------------------
c  fill table
      
c   terminate strings for C table-functions (snana.car routine)
      CALL TABLE_STRING_TERMINATION(+1)

      DO 400 i = 1, NFITDATA + NFITDATA_REJECT  
          ep   = EPLIST_FIT(i)
          IFILTOBS = I4EP_ALL(ep,IEP_IFILT_OBS) 

          TBLSPEC_MJD               = R4EP_ALL(ep,JEP_MJD) + MJDOFF    
          TBLSPEC8_MJD              = R8EP_MJD(i)  ! note different index
          TBLSPEC_TREST             = R4EP_ALL(ep,JEP_TREST) 
          TBLSPEC_TOBS              = R4EP_ALL(ep,JEP_TOBS) 
          TBLSPEC_LAMREST           = R4EP_ALL(ep,JEP_LAMREST) 
          TBLSPEC_IFILTOBS          = IFILTOBS
          TBLSPEC_CCDNUM            = I4EP_ALL(ep,IEP_CCDNUM) 
          TBLSPEC_IMGNUM            = I4EP_ALL(ep,IEP_IMGNUM)
          TBLSPEC_FLUXCAL_DATA      = R4EP_ALL(ep,JEP_DATAFLUX)
          TBLSPEC_FLUXCAL_DATA_ERR  = R4EP_ALL(ep,JEP_DATAFLUX_ERR)
          TBLSPEC_FLUXCAL_MODEL     = R4EP_ALL(ep,JEP_MODELFLUX)
          TBLSPEC_FLUXCAL_MODEL_ERR = R4EP_ALL(ep,JEP_MODELFLUX_ERR)
          TBLSPEC_FIELD             = SNLC_FIELD(ep) 
          TBLSPEC_CFILT             = 
     &        filtdef_string(IFILTOBS:IFILTOBS) // char(0)

c Mar21 2022: compute model mag for every band at every MJD
          DO ifilt = 1, NFILTDEF_SURVEY
            ifiltobs_tmp = IFILTDEF_MAP_SURVEY(ifilt)
            CALL MODELMAG_CALC(IFILTOBS_TMP, 'OBS', TBLSPEC8_MJD,            
     &          FLUX8, FLUXERR8, MAG8, MAGERR8, KCOR8 )
            TBLSPEC_MAG_MODEL(ifiltobs_tmp)     = sngl(MAG8)
            TBLSPEC_MAG_MODEL_ERR(ifiltobs_tmp) = sngl(MAGERR8)
          ENDDO

          Tobs  = TBLSPEC_TOBS
          z     = SNLC_REDSHIFT
          x0    = LCVAL_STORE(IPAR_x0)
          x1    = LCVAL_STORE(IPAR_SHAPE)
          c     = LCVAL_STORE(IPAR_COLOR)
          MWEBV = SNLC_MWEBV

          NBLAM_TBLSPEC = 
     &      getSpec_band_SALT2(IFILTOBS, Tobs,    ! (I)
     &      z, x0, x1, c, MWEBV,                  ! (I)
     &      TBLSPEC_LAMLIST, TBLSPEC_FLUXLIST )   ! (O)

+SELF,IF=REMOVE.
          print*,' xxx ----------', ep,' ---------- '
          print*,' xxx NBLAM   = ', NBLAM_TBLSPEC
          print*,' xxx IFILTOBS= ', IFILTOBS
          print*,' xxx Tobs, z = ', Tobs, z
          print*,' xxx x1,x1,c = ', x0, x1, c
          print*,' xxx MWEBV   = ', MWEBV
+SELF.
   
          IF ( NBLAM_TBLSPEC > MXLAM_TBLSPEC ) THEN
            write(C1ERR,661) NBLAM_TBLSPEC, MXLAM_TBLSPEC
661         format('NBLAM=',I5,' exceeds bound of ', I5)
            c2err = 'Check MXLAM_TBLSPEC'
            CALL MADABORT('TABLE_SNSPEC_SALT2', C1ERR, C2ERR)
          ENDIF

          IF ( NBLAM_TBLSPEC > 0 ) THEN
             CALL SNTABLE_FILL(ID)  ! generic C function
          ENDIF

400   CONTINUE

      CALL TABLE_STRING_TERMINATION(-1)  ! remove termination

c ------------------------------------

      RETURN
      END  ! TABLE_SNSPEC_SALT2

C =====================================
+DECK,TBSPECVAR.
      SUBROUTINE INIT_TABLE_SNSPECVAR(ID,BLOCK)
c
c Created Nov 18 2016
c
c Initialize variables to store SALT2 spectrum for each epoch.
c Store epoch variables as scalars; e.g., MJD, TOBS, FLUXCAL.
c Store spectrum as vector array: LAMLIST and FLUXLIST.
c
c Initial use is that spectra are needed for chromatic 
c corrections for each epoch (for DES).
c
c Call generic function SNTABLE_ADDCOL() that loads a table 
c for each selected format: CERNLIB, ROOT, HDF5 ...
c
c Mar 21 2022: load all model mags for each obs.
c
c --------------

      IMPLICIT NONE
      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK

c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.
+CDE,USRTAGCM.
+CDE,TABLEVARCOM.
+CDE,VMAXCOM.

      INTEGER 
     &    IFILT, IFILT_OBS, USE4TEXT
     &   ,LENLIST, LENNAME, LENBLOCK, LENPACK

      CHARACTER VARNAME*60, CBLOCK*40, CNFIT*20, CFILT*2

C ---------------- BEGIN ------------

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENBLOCK = INDEX(BLOCK//' ',' ') - 1
      CBLOCK   = BLOCK(1:LENBLOCK) // char(0)

c - - - - 
      VARNAME = 'CCID:C*20' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_CCID, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'FIELD:C*20' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_FIELD, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'BAND:C*4' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_CFILT, VARNAME, 1,
     &                   LENBLOCK, 4 )

      VARNAME = 'CCDNUM:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_CCDNUM, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'IMGNUM:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_IMGNUM, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'IFILTOBS:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_IFILTOBS, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'MJD:D' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC8_MJD, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'TREST:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_TREST, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'LAMREST:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_LAMREST, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'FLUXCAL_DATA:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_FLUXCAL_DATA, VARNAME, 1,
     &                   LENBLOCK, 20 )

      VARNAME = 'FLUXCAL_DATA_ERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK,TBLSPEC_FLUXCAL_DATA_ERR,VARNAME,1,
     &                   LENBLOCK, 20 )

      VARNAME = 'FLUXCAL_MODEL:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_FLUXCAL_MODEL, 
     &            VARNAME, 1, LENBLOCK, 20 )

      VARNAME = 'FLUXCAL_MODEL_ERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, TBLSPEC_FLUXCAL_MODEL_ERR, 
     &            VARNAME, 1, LENBLOCK, 20 )

c - - - - -
c Mar 21 2022: write model mag for all bands at each obs
c   initial use is for DCR correction in DES.   

      DO 20 ifilt  = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         cfilt     = FILTDEF_STRING(ifilt_obs:ifilt_obs)   
         VARNAME   = 'MAG_MODEL_' // cfilt(1:1) // ':F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, 
     &       TBLSPEC_MAG_MODEL(ifilt_obs), 
     &       VARNAME, 1, LENBLOCK, 20 )
20    CONTINUE

      DO 21 ifilt  = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         cfilt     = FILTDEF_STRING(ifilt_obs:ifilt_obs)   
         VARNAME   = 'MAG_MODEL_ERR_' // cfilt(1:1) // ':F'//char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, 
     &       TBLSPEC_MAG_MODEL_ERR(ifilt_obs), 
     &       VARNAME, 1, LENBLOCK, 20 )
21    CONTINUE

c - - - - - 
      write(CNFIT,15) MXLAM_TBLSPEC
15    format('NBLAM[',I4.4,']' )  ! no spaces or commas in string
      VARNAME = CNFIT(1:11)  // char(0)  ! Num lambda bins
      CALL SNTABLE_ADDCOL(ID, CBLOCK, NBLAM_TBLSPEC, 
     &     VARNAME, 0, LENBLOCK, 20)

      VARNAME = 'SPEC_LAMLIST(NBLAM):F'  // char(0)   ! wavelength list
      CALL SNTABLE_ADDCOL(ID,CBLOCK, TBLSPEC_LAMLIST,
     &        VARNAME, 0, LENBLOCK, 20)

      VARNAME = 'SPEC_FLUXLIST(NBLAM):F'  // char(0)   ! spec-fluxList
      CALL SNTABLE_ADDCOL(ID,CBLOCK, TBLSPEC_FLUXLIST,
     &        VARNAME, 0, LENBLOCK, 20)

      RETURN
      END     ! INIT_TABLE_SNSPECVAR

C ===================================================
+DECK,FITPAR_NEARNBR_APPLY.
      SUBROUTINE FITPAR_NEARNBR_APPLY

C
C Jun 2013
C shell to call NEARNBR_LOADVAL and NEARNBR_APPLY
c Can be used for both training and apply mode, but here it
c is used only for training mode.
c
c Apr 23 2014: call IPAR = IPAR_PARNAME_STORE(VARNAME) 
c              to associate each NN-sepmax variable with snana variable.
c              Replaces original hard-wired IPAR_LIST.
c
c Jan 18 2016: check NN_ITYPE_FIX
c Oct  7 2016: pass CCID to NEARNBR_LOADVAL
c
C ----------

      IMPLICIT NONE

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITCOM.
+CDE,NNCOM.
+CDE,FITRESTCOM.

      REAL*8    DVAL, MAGVAL, MAGERR
      INTEGER   LV, i, IPAR, IPAR_ABS
      CHARACTER CCID_forC*(MXCHAR_CCID)
      CHARACTER VARNAME_forC*80, tmpName*80, FNAM*20
      CHARACTER VARNAME*80

c results
      INTEGER ITYPE, ITYPE_BEST, NCELL_TOT, NCELL, NTYPE
      INTEGER 
     &   ITYPE_LIST(NN_MXTYPE)
     &  ,NCELL_TRAIN_LIST(NN_MXTYPE)

      REAL XCELL_TRAIN, XNTOT_TRAIN

c function
      INTEGER IPAR_PARNAME_STORE

C -------------- BEGIN -----------------

      NN_ITYPE = -9
      NN_NCELL =  0

      CCID_forC = SNLC_CCID(1:ISNLC_LENCCID)//char(0)

c check option to fix NN_ITYPE for spec-confirmed sample so that
c output table has NN info to match that of photoID table
      IF ( NN_ITYPE_FIX .GE. 0 ) THEN
         NN_ITYPE     = NN_ITYPE_FIX
         NN_NCELL     = 0
         RETURN
      ENDIF

c ----------

      IF ( NVAR_NEARNBR .EQ. 0 ) RETURN

      FNAM = 'FITPAR_NEARNBR_APPLY'

      DO 30 i = 1, NVAR_NEARNBR
         ! get snlc_fit IPAR  index for this NN variable index
         VARNAME  = NEARNBR_SEPMAX_VARNAME(i)
         IPAR     = IPAR_PARNAME_STORE(VARNAME)
         IPAR_ABS = abs(IPAR)

         IF ( IPAR_ABS .EQ. 0  .or. IPAR_ABS > MXFITPAR ) THEN
            write(c1err,661) IPAR, i, VARNAME
 661        format('Invalid IPAR = ', I4, '  for i=',I2, '  = ', A8)
            c2err = 'Something is messed up.'
            CALL MADABORT(FNAM, c1err, c2err )  
         ENDIF

c translate snana parname of 'REDSHIFT' to 'z', unless photoz fit.
         tmpName = VARNAME   ! xxxx PARNAME_STORE(IPAR_ABS)
         IF ( IPAR_ABS .EQ. IPAR_zPHOT ) THEN
            IF ( .NOT. DOFIT_PHOTOZ ) tmpName = 'z'
         ENDIF

         LV = INDEX(tmpName,' ') - 1
         VARNAME_forC = tmpName(1:LV) // char(0)

         IF ( IPAR > 0 ) THEN 
            DVAL = LCVAL_STORE(IPAR_ABS)
         ELSE
            DVAL = LCERR_STORE(IPAR_ABS)
         ENDIF

c xxxxxxxxxxxxxxxxxxxxxx
c         print*,' xxx IPAR=', IPAR,'  VARNAME=', VARNAME_forC(1:LV),
c     &            '  DVAL=', SNGL(DVAL)
c xxxxxxxxxxxxxxxxxxxxxx

         CALL NEARNBR_LOADVAL(CCID_forC, VARNAME_forC, DVAL, 
     &       ISNLC_LENCCID, LV )  
 30   CONTINUE

c --------------------------------------------------
c load true sim-type only when doing the training.

      IF (  FLAG_NEARNBR == NNFLAG_TRAIN ) THEN
         tmpName      = NEARNBR_TRUETYPE_VARNAME
         LV           = index(tmpName,' ') - 1
         VARNAME_forC = tmpName(1:LV) // char(0)

         IF ( tmpName .EQ. 'SIM_TYPE_INDEX' ) THEN
            DVAL    = DBLE(SIM_GENTYPE)
         ELSE IF ( tmpName .EQ. 'SIM_NON1A' ) THEN ! legacy name
            DVAL  = DBLE(SIM_TEMPLATE_INDEX)
         ELSE IF ( tmpName .EQ. 'SIM_TEMPLATE_INDEX' ) THEN  ! 7.31.2018
            DVAL  = DBLE(SIM_TEMPLATE_INDEX)
         ELSE
            c1err = 'Unrecognized true-type index: '
            c2err = tmpName
            CALL MADABORT(FNAM, c1err, c2err )  
         ENDIF        

         CALL NEARNBR_LOADVAL(CCID_forC, VARNAME_forC, DVAL, 
     &        ISNLC_LENCCID, LV )  
      ENDIF

c -------------------------------------------
c run the analysis.
      CALL  NEARNBR_APPLY(CCID_forC, ISNLC_LENCCID)

c ---------------------
c Apr 7 2014
      CALL NEARNBR_GETRESULTS(CCID_forC, ITYPE_BEST, 
     &      NTYPE, ITYPE_LIST, NCELL_TRAIN_LIST, ISNLC_LENCCID )

      XNTOT_TRAIN  = 0.0 
      DO  i = 1, NTYPE
         XNTOT_TRAIN = XNTOT_TRAIN + float(NCELL_TRAIN_LIST(i))
      ENDDO

      NN_ITYPE     = ITYPE_BEST        ! most probably ITYPE 
      NN_NCELL     = INT(XNTOT_TRAIN)

c apply user-ITYPE ranges to determine NN_PROB_XX
      NN_PROB_IA  = 0.0
      NN_PROB_II  = 0.0
      NN_PROB_IBC = 0.0

c increment how many for each ITYPE_BEST
      IF ( ITYPE_BEST == 1 ) THEN
          NNSUM_IA = NNSUM_IA + 1
      ELSE IF ( ITYPE_BEST .GE. 0 ) THEN
          NNSUM_NON1A = NNSUM_NON1A + 1
      ELSE
          NNSUM_UNKNOWN = NNSUM_UNKNOWN + 1
          RETURN
      ENDIF

c - - - -  - - - - - - - -
      DO 202 i = 1, NTYPE
         ITYPE = ITYPE_LIST(i)
         NCELL = NCELL_TRAIN_LIST(i)        
         XCELL_TRAIN = FLOAT( NCELL_TRAIN_LIST(i) )

         if ( ITYPE == NN_ITYPE_SNIA ) THEN
              NN_PROB_IA  = NN_PROB_IA    + XCELL_TRAIN
          endif  

c          write(6,333) ITYPE, NCELL, NN_NCELL, int(NN_PROB_IA)
333       format(' xxx ITYPE=',I3, 3x,'NCELL=',I4,'/',I4,
     &          3x,'NN_IA=',I4)
202   CONTINUE
     
      IF( XNTOT_TRAIN > 0.0 ) THEN
         NN_PROB_IA   = NN_PROB_IA  / XNTOT_TRAIN
      ENDIF

      RETURN
      END      ! end FITPAR_NEARNBR_APPLY

C ===============================
+DECK,IPAR_PARNAME_STORE.
      INTEGER FUNCTION IPAR_PARNAME_STORE(VARNAME)

C Apr 23 2014, R. Kessler
C for input string VARNAME, return IPAR such that
c    VARNAME = PARNAME_STORE(IPAR).
c If VARNAME has 'ERR' at the end, then return negative IPAR value
c
c Nov 14 2014: fix bug to allow zPHOT as well as z.
c Jan 02 2016: check for 'ERR' extension

      IMPLICIT NONE
      CHARACTER VARNAME*(*)  ! (I) variable name to analyze
      
c local var

+CDE,SNDATCOM. 
+CDE,SNANAFIT.
+CDE,SNFITPAR.
+CDE,SNFITINP.
+CDE,FITRESTCOM.

      CHARACTER tmpName*40, cfilt*2, FNAM*20, VLOC*40
      INTEGER IPAR, ifilt, LENPAR, LENLOC
      LOGICAL ISERR

C ----------- BEGIN -----------

      IPAR = -99
      FNAM = 'IPAR_PARNAME_STORE' 

c ------------------------------
c check for 'ERR' at the end
      ISERR  = .FALSE.
      LENPAR = INDEX(VARNAME,' ') - 1
      VLOC   = VARNAME
      IF ( LENPAR > 3 ) THEN
         IF ( VARNAME(LENPAR-2:LENPAR) .EQ. 'ERR' ) then
           ISERR = .TRUE.
           VLOC  = VARNAME(1:LENPAR-3)
         ENDIF
      ENDIF

      LENLOC = INDEX(VLOC,' ') - 1

c ------------------------------
      IF ( VLOC(1:LENLOC) .EQ. 'z' ) THEN  
         IPAR = IPAR_zPHOT  ! allow 'z' instead of longer 'REDSHIFT'
      ELSE IF ( VLOC(1:LENLOC) .EQ. PARNAME_STORE(IPAR_zPHOT) ) THEN
         IPAR = IPAR_zPHOT
      ELSE IF ( VLOC(1:LENLOC) .EQ. PARNAME_STORE(IPAR_COLOR) ) THEN
         IPAR = IPAR_COLOR
      ELSE IF ( VLOC(1:LENLOC) .EQ. PARNAME_STORE(IPAR_SHAPE) ) THEN
         IPAR = IPAR_SHAPE
      ELSE IF ( VLOC(1:3) .EQ. 'M0_' ) THEN

c      check FITRESTMAG variables 
         DO ifilt    = 1, NFILTDEF_FITRESTMAG
            cfilt    = FILTLIST_FITRESTMAG(ifilt:ifilt)
            tmpName  = 'M0_' // cfilt
            if ( VARNAME .EQ. tmpName ) then
               IPAR = IPAROFF_FITRESTMAG + 2*ifilt-1 ! skip errors
            endif
         ENDDO
         IF ( IPAR < 0 ) then
            c1err = 'Cannot identify VARANME = ' // VARNAME
            c2err = 'Check NEARNBR options.'
            CALL MADABORT(FNAM, c1err, c2err )  
         endif
      ELSE
	 CALL PRINT_PREABORT_BANNER(FNAM//CHAR(0), 40)
         print*,'   LENPAR, LENLOC, ISERR = ', LENPAR, LENLOC, ISERR
         print*,'   VARNAME = ', VARNAME(1:20)
         print*,'   VARNAME(LENPAR-3:LENPAR) = ',
     &              VARNAME(LENPAR-3:LENPAR) 
         print*,'   VLOC    = ', VLOC(1:20)

         c1err = 'Cannot determine IPAR for VARNAME=' 
     &             // VARNAME(1:12)
         c2err = 'Check NEANBR options.'
         CALL MADABORT(FNAM, c1err, c2err )           
      ENDIF

      IF ( ISERR ) THEN
        IPAR_PARNAME_STORE = -IPAR
      ELSE
        IPAR_PARNAME_STORE = +IPAR
      ENDIF

      RETURN
      END  ! end of  IPAR_PARNAME_STORE


C =====================================================
+PATCH,*HFUNS.


C =====================
+DECK,HFUNMIN.
      SUBROUTINE HFUNMIN()
c
c Oct 22, 2008
c
c Plot function (chi2) around minimum for each fit-parameter.
c Plot 2D functions of chi2 vs. filter, where filter=0 
c corresponds to the data chi2 that excludes the prior,
c
c Useful namelist control variables
c
c   LPLOTCHI2 = T             ! global flag to call HFUNMIN
c   IPAR_PLOTCHI2     = 9     ! plot only this IPAR (default=all)
c   FILTLIST_DMPFCN   = 'r'   ! dump FCN for r 
c   FILTLIST_DMPFUN   = 'r'   ! dump USRFUN for r and TREST_DMPFUN below
c   SCALE_PLOTCHI2    = 1.0   ! scale range to plot chi2
c   TREST_DMPFUN      = 12.07, 12.09
c
c
c Aug 31, 2009: check IPAR_PLOTCHI2 for option to plot chi2
c               for just one parameter.
c
c               If FILTLIST_DMPFCN[FUN] is set, then apply dump
c               only within +-10 bins of chi2 minimum.
c               See internal arrays LDMPFCN_PLOTCHI2
c               and LDMPFUN_PLOTCHI2. 
c               
c Jun 22, 2012:
c   Plot only filters used in fit so that hid=1 has correct 
c   filter-list for generic snana#chi2nearmin macro.
c   See NFILT_OBS_USEFIT.
c
c Feb 6, 2013: replace hbook calls with SNHIST_XXX routines.
c
c ----------------------

      IMPLICIT NONE

c hard-wire  a few things
      INTEGER HOFF, NFITSIG, NBFITPAR
      PARAMETER ( 
     &    HOFF      = 2000  ! hbook offset
     &   ,NFITSIG   = 10    ! go out +-NSIG sigma from central value
     &   ,NBFITPAR  = 100   ! Number of fitpar bins to compute chi2
c     &   ,NBFITPAR  = 500   ! Number of fitpar bins to compute chi2
     &      )


+CDE,SNDATCOM. 
+CDE,SNANAFIT.  
+CDE,SNFITCOM.   private fitter info
+CDE,SNLCINP.
+CDE,FILTCOM.

  
      CHARACTER chis*80

      INTEGER 
     &   hid, NBx, NBf, NHB(2), ipar, ix, i, LL, LF
     &  ,ifilt, ifilt_obs, NFUSE
     &  ,IPAR_LOOP1, IPAR_LOOP2
     &  ,NDIM1, NDIM2

c SNHIST args

      REAL*8
     &    xmin, xmax, dx, xcen, xbin, xtmp, x(2)
     &  , fmin, fmax, f, XHMIN(2), XHMAX(2)
     &  , chi2

      LOGICAL LBK2, LTEST, LDMPCHECK

c FCNSNLC args
      INTEGER IFLAG

      DOUBLE PRECISION
     &    GRAD8(MXFITPAR)
     &   ,FITSAVE8(MXFITPAR)
     &   ,FITPARLOC8(MXFITPAR)
     &   ,FITERRLOC8(MXFITPAR)
     &   ,chi8, USRFUN

      EXTERNAL USRFUN

C ------------------- BEGIN ---------------------

      NDIM1 = 1
      NDIM2 = 2

      print*,'  '
      print*,'    CALL HFUNMIN for CID = ', SNLC_CCID
      CALL FLUSH(6)

      IFLAG = FCNFLAG_USER
      NBx   = NBFITPAR  ! number of bins to plot chi2
  
      fmin  = -0.5
      fmax  = float(NFILT_OBS_USEFIT) + 0.5
      NBf   = int(fmax - fmin + 0.001 )

      DO ipar = 1, IPAR_MAX
         FITPARLOC8(ipar) = FITVAL(ipar,NFIT_ITERATION)
         FITERRLOC8(ipar) = FITERR(ipar,NFIT_ITERATION)
         FITSAVE8(ipar)   = FITPARLOC8(ipar)
      ENDDO


      IF ( IPAR_PLOTCHI2 .GT. 0 ) THEN
         IPAR_LOOP1 = IPAR_PLOTCHI2
         IPAR_LOOP2 = IPAR_PLOTCHI2
      ELSE
         IPAR_LOOP1 = 1
         IPAR_LOOP2 = IPAR_MAX
      ENDIF

      DO 100 ipar = IPAR_LOOP1, IPAR_LOOP2

         if ( FITERRLOC8(ipar) .LE. 0.0 ) goto 100

         print*,'      Plot chi2 around minimum of : ', 
     &          PARNAME_STORE(ipar)

         xcen = FITPARLOC8(ipar)
         dx   = FITERRLOC8(ipar) * float(NFITSIG)

         dx = dx * SCALE_PLOTCHI2

         xmin =  -dx 
         xmax =  +dx 
         xbin = (xmax - xmin) / float(NBx)
         
c book chi2 vs. par - par(at min) vs. filter
 
        LL = INDEX(PARNAME_STORE(ipar),' ' ) - 1
        LF = INDEX(FILTLIST_FIT_USE,   ' ' ) - 1
        chis = 'FUN-chi2  vs.  [D]' // PARNAME_STORE(ipar)(1:LL) // 
     &    ' and filters ' // FILTLIST_FIT_USE(1:LF) // char(0)

        hid      = HOFF + ipar
        NHB(1)   = NBX  ; NHB(2)   = NBF
        XHMIN(1) = xmin ; XHMIN(2) = fmin
        XHMAX(1) = xmax ; XHMAX(2) = fmax
    
        CALL SNHIST_INIT ( NDIM2, hid, chis, 
     &             NHB, XHMIN, XHMAX, LEN(chis) )

         DO ix = 1, NBx

             LDMPCHECK = ( IPAR .EQ. IPAR_PLOTCHI2 )
cc     &          .and.    ( abs(xtmp-xcen) .LE. 10.*xbin )

             FCN_FITCHI2(0) = 0.0
             do ifilt = 1, NFILTDEF_SURVEY
               FCN_FITCHI2(ifilt) = 0.0

c check for filters to dump near the minimum
               ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
               if ( LDMPCHECK ) then
                 LDMPFCN(ifilt_obs) = LDMPFCN_PLOTCHI2(ifilt_obs)
                 LDMPFUN(ifilt_obs) = LDMPFUN_PLOTCHI2(ifilt_obs)
                 LDMPFCN(0)         = .true. ! xxx ?? 9.30.2021
               else
                 LDMPFCN(ifilt_obs) = .FALSE.
                 LDMPFUN(ifilt_obs) = .FALSE.
               endif

             enddo ! ifilt

            xtmp = Xcen + Xmin + ( float(ix) - 0.5 ) * xbin
            FITPARLOC8(ipar) = DBLE(xtmp)

            CALL FITINI_EPVAR(NFIT_ITERATION)
            CALL FCNSNLC(NFITPAR_MN,GRAD8,CHI8,FITPARLOC8,IFLAG,USRFUN)

            NFUSE = 0
            do 444 ifilt = 0, NFILTDEF_SURVEY

               if ( ifilt .GT. 0 ) then
                 ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
                 if ( .NOT. USE_FILT(ifilt_obs) ) goto 444
                 NFUSE = NFUSE + 1
               endif

               x(1)     = xtmp - xcen
               x(2)     = float(NFUSE)
               chi2     = FCN_FITCHI2(ifilt)  ! chi2 excluding prior
               CALL SNHIST_FILL(NDIM2, HID, X, CHI2)
444          continue

         ENDDO  ! end ix loop over fitpar

         FITPARLOC8(ipar) = FITSAVE8(ipar)

100   CONTINUE  ! end if IPAR loop

      DO ifilt_obs = 1, MXFILT_ALL
         LDMPFCN(ifilt_obs) = .FALSE. 
         LDMPFUN(ifilt_obs) = .FALSE. 
      ENDDO
      print*, ' ' 

      RETURN
      END


C ================================
+DECK,MONSIMEFF.
      SUBROUTINE MON_SIMEFF
c
c Aug 2011: Plot SIMEFF vs. whatever.
c Feb 2013: replace HBOOK and HF2 with SNHIST_XXXX utils

      IMPLICIT NONE

c local var

+CDE,SNDATCOM.
+CDE,SNFITPAR.

      INTEGER hid, NBAV, NBZ, iav, ilum, iz, ISN, NDIM, NBIN(2)
      REAL*8  
     &   XVAL(10), EFF, AV, DELTA, Z, WGT
     &  ,AVMIN, AVMAX, AVBIN
     &  ,ZMIN,  ZMAX,  ZBIN, MWEBV
     &  ,DMIN(2), DMAX(2), DVAL(2)

      CHARACTER chis*80

c function
      REAL*8  SNLC_FIT_SIMEFF

C ------------- BEGIN ----------

C hard wire redshift and AV bins

      NDIM  = 2  ! 2D plots
      WGT   = 1.0

      AVMIN = -0.1
      AVMAX =  2.0
      AVBIN =  0.02
      NBAV   = (AVMAX - AVMIN + 1.0E-5)/AVBIN

      ZMIN = 0.05
      ZMAX = 0.95
      ZBIN = 0.10
      NBZ   = (ZMAX - ZMIN + 1.0E-5)/ZBIN

      NBIN(1) = NBZ
      NBIN(2) = NBAV
      DMIN(1) = ZMIN
      DMIN(2) = AVMIN
      DMAX(1) = ZMAX
      DMAX(2) = AVMAX

c set artificial ISN index to and set MWEBV=0 temporarily
      ISN = 1
      MWEBV = SNLC_MWEBV
      SNLC_MWEBV = 0.0

     
      DO 100 ilum = 1, 5  ! loop over DELTA values

        DELTA = -0.5 + float(ilum-1)*.2
        XVAL(IPAR_SHAPE)  = DELTA

c book EFF vs. AV & Z for this DELTA value.
          write(chis,20) DELTA
20        format('SIMEFF vs. AV and z,  DELTA=',F5.2)
          chis = chis(1:40) // char(0)
          hid = 18000 + ilum
          CALL SNHIST_INIT(NDIM, HID, CHIS, NBIN,DMIN,DMAX, 80 )

        DO 201 iz  = 1, NBZ
          Z  = ZMIN + ZBIN * (FLOAT(iz)-0.5)
          XVAL(IPAR_zPHOT)   = Z
        DO 202 iav = 1, 210
          AV = AVMIN + AVBIN * (FLOAT(iav)-0.5)
          XVAL(IPAR_AV)  = AV
          EFF  = SNLC_FIT_SIMEFF(ISN,XVAL)

          DVAL(1) = Z
          DVAL(2) = AV
          CALL SNHIST_FILL(NDIM, HID, DVAL, EFF )

202     CONTINUE

201     CONTINUE

100   CONTINUE

c restore MWEBV
      SNLC_MWEBV = MWEBV

      RETURN
      END
