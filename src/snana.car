+KEEP,HISTORY.   
c
c Program to read light curves and apply user selection
c cuts specified in the &SNLCINP namelist.
c Can also fit function to estimate time of peak brightness.
c

+PATCH,*SNCOM.

+KEEP,SNPAR.

      CHARACTER  SNTABLE_LIST_DEFAULT*60

c parameters used by snana code

      INTEGER 
     &   MXVERS, MXSURVEY, MXSNLC,MXCID, MXCID_CHECK,MXEPOCH, MXITER
     &  ,MXFILT_ALL, MXFILT_OBS, MXFILT_REST, ONE
     &  ,MXFILT_CALIB, MXFILT_SNRMAX, MXEP_MODELGRID
     &  ,MXIDFIELD, MXFIELD_OVP, MXSEASON
     &  ,MXSNHOST, MXZPHOT_Q
     &  ,MXTABLE1D_KCOR,MXTABLE1D_LCMAG,MXTABLE1D_MWXT,MXTABLE1D_AVWARP
     &  ,MXZBIN_KCOR, MXTBIN_KCOR, MXAVBIN_KCOR, MXCBIN_AVWARP
     &  ,MNTYPE, MXTYPE, MXLISTNML, MXIGNORE_LIST
     &  ,MXVAR_PRIVATE, MXCUT_PRIVATE, MXVAR_TERSE, MXBIT_PHOTFLAG
     &  ,HOFF_NOCUTS, HOFF_CUTS, HOFF_SIM
     &  ,LUNNML, LUNDAT, LUNTMP, LUNFIT, LUNPKMJD, LUNDMP
     &  ,LUNCID, LUNOUT
     &  ,LUNRES1, LUNRES2, LUNINTERP, LUNLIST, LUNIGNORE, LUNSALT2
     &  ,LUNLIST2, LUNIGNORE2
     &  ,ISTAGE_INIT, ISTAGE_RDSN, ISTAGE_CUTS, ISTAGE_USRANA
     &  ,ISTAGE_TEST
     &  ,INTERP_LINEAR, INTERP_SMOOTH, INTERP_ZSMOOTH
     &  ,MXERRTYPE, ERRTYPE_MINOS, ERRTYPE_PARAB, ERRTYPE_MARG
     &  ,ERRTYPE_BAD
     &  ,FCNFLAG_USER, FCNFLAG_FAST, FCNFLAG_LAST, FCNFLAG_USESIM
     &  ,FCNFLAG_PRIOR_ONLY, FCNFLAG_SIGMA_ONLY, FCNFLAG_MAX
     &  ,OPT_INTEGPDF_QUITCHI2, OPT_INTEGPDF_FULL
     &  ,OPT_SNXT_CCM89, OPT_SNXT_SJPAR
     &  ,OPT_MWCOLORLAW_DEFAULT, OPT_MWEBV_DEFAULT
     &  ,OPT_KCORERR_SJ, OPT_KCORERR_SJ5, OPT_KCORERR_SMOOTH
     &  ,OPTMASK_SNDATA_GLOBAL, OPTMASK_SNDATA_HEAD, OPTMASK_SNDATA_OBS
     &  ,OPTMASK_SNDATA_SPEC, OPTMASK_SNDATA_DUMP, OPTMASK_SNDATA_ALL
     &  ,OPTMASK_SNDATA_REQUIRE, OPTMASK_SNDATA_DONE
     &  ,MXLINE_ARGS, MXKEY_ARGS, MXEPOCH_IGNORE
     &  ,NPAR_ANYLC, MXPAR_SIMSED, MXPAR_LCLIB
     &  ,MXLAMBIN_SNSED, MXCUTBIT
     &  ,OPT_FILTUPD_EACHSN, OPT_FILTUPD_MAP, OPT_FILTUPD_SAMEFILT
     &  ,OPT_FILTOBS, OPT_FILTREST
     &  ,ISTAT_READAGAIN, ISTAT_SKIP
     &  ,IDTABLE_MCMC
     &  ,ITABLE_SNANA,  ITABLE_FITRES, ITABLE_OUTLIER
     &  ,ITABLE_SNLCPAK, ITABLE_SPECPAK
     &  ,ITABLE_MODELSPEC, ITABLE_MARZ, ITABLE_DMPFCN, MXTABLE
     &  ,IDTABLE_SNANA, IDTABLE_FITRES, IDTABLE_OUTLIER
     &  ,IDTABLE_MODELSPEC, IDTABLE_MARZ, IDTABLE_DMPFCN
     &  ,OPT_PARSTORE_TEXTTABLE
     &  ,MSKOPT_PARSE_WORDS_STRING
     &  ,MSKOPT_PARSE_WORDS_FILE
     &  ,MSKOPT_PARSE_WORDS_IGNORECOMMA
     &  ,MSKOPT_PARSE_WORDS_IGNORECOMMENT
     &  ,MSKOPT_PARSE_WORDS_FIRSTLINE
c
     &  ,MODEL_STRETCH
     &  ,MODEL_STRETCH2
     &  ,MODEL_MLCS2k2
     &  ,MODEL_SNOOPY
     &  ,MODEL_SALT2, MODEL_SALT3
     &  ,MODEL_BAYESN
     &  ,MODEL_SIMSED
     &  ,MODEL_BYOSED
     &  ,MODEL_SNEMO
     &  ,MODEL_NON1A
     &  ,MODEL_LCLIB    ! Sep 2017
     &  ,MODEL_FIXMAG   ! force mags to user-value
     &  ,MXMODEL_INDEX
c
     &  ,MXCHAR_CCID, MXCHAR_VERSION, MXCHAR_SURVEY
     &  ,MXCHAR_PATH, MXCHAR_FILENAME, MXCHAR_MODELNAME
     &  ,MXCHAR_FIELDNAME, MXCHAR_PARNAME, MXCHAR_CUTNAME
     &  ,MXCHAR_FILEWORD,  MXCHAR_ARG, MXFILE_LIST
     &  ,FLAG_DOCANA_START, FLAG_DOCANA_END, FLAG_DOCANA_ERROR
c
     &  ,SNLCPAK_EPFLAG_FLUXDATA     ! DATA flux per epoch
     &  ,SNLCPAK_EPFLAG_FLUXMODEL    ! MODEL flux per epoch
     &  ,SNLCPAK_EPFLAG_REJECT   ! REJECT flag (1=> excluded from fit)
     &  ,SNLCPAK_EPFLAG_CHI2     ! data-fit chi2 per epoch
     &  ,SNLCPAK_EPFLAG_FITFUN   ! smooth  fitfun curve
     &  ,SNLCPAK_EPFLAG_FLUXSIM  ! SIM flux per epoch
     &  ,SNLCPAK_EPFLAG_FLUXREST ! rest-frame flux per epoch (optional)
     &  ,SNLCPAK_EPFLAG_KCOR     ! rest-frame kcor (Jan 2020)
     &  ,SNLCPAK_EPFLAG_AVWARP   ! rest-frame AVWARP
     &  ,SNLCPAK_EPFLAG_SIMFLUXREST ! idem for sim truth
     &  ,SNLCPAK_EPFLAG_ERRCALC    ! FLUX-ERROR calculated from PSF,ZP,SKY
     &  ,SNLCPAK_BANDFLAG_PKFLUX   ! peak flux vs. filter
     &  ,SNLCPAK_BANDFLAG_PKMJD    ! peak MJD  vs. filter
     &  ,SNLCPAK_BANDFLAG_NDOF     ! Ndof vs. filter
     &  ,SNLCPAK_BANDFLAG_CHI2     ! chi2 vs. filter
c
     &  ,IFLAG_INI, IFLAG_ANA, IFLAG_END
     &  ,MASK_FLUXCOR_SNANA, MASK_FLUXERRCOR_SNANA
     &  ,EXIT_ERRCODE_SNANA, EXIT_ERRCODE_SNFIT, EXIT_ERRCODE_PSNID
     &  ,ERRFLAG_MNFIT_INITPAR, ERRFLAG_MNFIT_FIXPAR, ERRFLAG_MNFIT_NAN
     &  ,MXMASK_zSOURCE
     
      REAL*8 
     &   ZERO8, ONE8, TEN8,  PI, LOGTEN
     &  ,PDFMIN, PDFMAX_EDGE, PDFMIN_GOOD
     &  ,KCORPACK
     &  ,XTMW_FRACERR
     &  ,MJDOFF
     &  ,ZEROPOINT_FLUXCAL_DEFAULT
     &  ,RV_MWCOLORLAW_DEFAULT
     &  ,CUTVAL_OPEN, IGNORE_HEADVAL
     
      REAL NULLVAL, MAG_SATURATE, LEGACY_INIT_VAL

      PARAMETER (                   ! BEGIN SNANA PARAMS
     &   SNTABLE_LIST_DEFAULT = 'SNANA  FITRES  LCPLOT'
     &  ,MXVERS        = 50         ! max number of versions to read
     &  ,MXSURVEY      = 100        ! max number of SURVEY_NAMEs to store
     &  ,MXITER        = 12         ! max # fit iterations
     &  ,MXSNLC        = 10000000    ! max number of SNe (fits format)
     &  ,MXIGNORE_LIST = 500        ! max size of IGNORE_LIST
     &  ,MXCID       = 299 999 999  ! max CID = 300 million -1 (9 digits)
     &  ,MXCID_CHECK =  99 999 999  ! MXCID to check duplicates
     &  ,MXEPOCH     = 30000      ! max number of filter-epochs per SN
     &  ,MXEP_MODELGRID = 200     ! max model grid for SNANA+SIM_MAGOBS table
     &  ,MXIDFIELD   = 200        ! max FIELD ID in SURVEY.DEF
     &  ,MXFIELD_OVP = 12         ! max number of overlapping fields
     &  ,MXSEASON    = 100        ! max number of seasons
     &  ,MXSNHOST    = 2          ! max number of host matches to read/write
     &  ,MXZPHOT_Q   = 20         ! max number of zphot quantiles (May 2022)
     &  ,MXVAR_PRIVATE = 40       ! max number of private variables
     &  ,MXCUT_PRIVATE = 10        ! max number of cuts on private var
     &  ,MXVAR_TERSE   = 30       ! max number of text-data  columms
     &  ,MXBIT_PHOTFLAG = 30      ! max number of PHOTFLAG bits
     &  ,MXLISTNML   = 52    ! max list size for some NML lists    
     &  ,MXFILT_OBS  = 80    ! max number of used observer filters
     &  ,MXFILT_ALL  = 100   ! max number of all possible filter defs
     &  ,MXFILT_REST = 40    ! max number of rest-frame filter types (was 12)
     &  ,MXFILT_CALIB = MXFILT_REST ! max number of filters used in calib table
     &  ,MXFILT_SNRMAX =  8       ! no more than this many SNRMAX(filt) cuts
     &  ,MNTYPE       =   1       ! min sn "type"
     &  ,MXTYPE       = 1000      ! max sn "type"
     &  ,MXZBIN_KCOR  = 100       ! max # Z-bins for KCOR tables
     &  ,MXTBIN_KCOR  = 150       ! max # Epochs for KCOR tables
     &  ,MXAVBIN_KCOR = 100      ! max # AV bins for KCOR tables
     &  ,MXCBIN_AVWARP = 100      ! max color index for AVWARP table
     &  ,MXTABLE1D_KCOR   = 10 000 000  ! max number of KCOR bins
     &  ,MXTABLE1D_AVWARP =  1 500 000  ! max number of bins for AVWARP table
     &  ,MXTABLE1D_LCMAG  =  2 000 000  ! idem for LCMAG  table
     &  ,MXTABLE1D_MWXT   =  2 000 000  ! idem for MWXT table
     &  ,KCORPACK      = 1000.  ! store KCOR * KCORPACK as I*2
     &  ,XTMW_FRACERR  = 0.16   ! error on MW Xtinc is 16% of XTMW
c
     &  ,HOFF_NOCUTS = 100
     &  ,HOFF_CUTS   = 200
     &  ,HOFF_SIM    = 20000
     &  ,LUNNML    = 22  ! LUN for input namelist
     &  ,LUNDAT    = 23  ! LUN for data      
     &  ,LUNTMP    = 24
     &  ,LUNOUT    = 25
     &  ,LUNFIT    = 26
     &  ,LUNLIST   = 27  
     &  ,LUNIGNORE = 28  
     &  ,LUNDMP    = 29
     &  ,LUNRES1   = 31  ! for DMP_FITRES 
     &  ,LUNRES2   = 32
     &  ,LUNINTERP = 33  ! for FLUX,MAGs interpolated at SN,MJD
     &  ,LUNSALT2  = 34  ! for SALT2 dictFile
     &  ,LUNPKMJD  = 35
     &  ,LUNCID    = 36  ! reserved for reading SNCID_LIST_FILE
     &  ,LUNLIST2  = 47
     &  ,LUNIGNORE2= 48
     &  ,ISTAGE_INIT    = 10       ! init has finished
     &  ,ISTAGE_RDSN    = 20       ! SN have been read
     &  ,ISTAGE_CUTS    = 30       ! cuts have been applied
     &  ,ISTAGE_USRANA  = 40       ! USRANA has been called.
     &  ,ISTAGE_TEST    = 90       ! set for testing
     &  ,ZERO8          = 0.0
     &  ,ONE8           = 1.0
     &  ,ONE            = 1
     &  ,TEN8           = 10.0
     &  ,LOGTEN         = 2.302585092994
     &  ,INTERP_LINEAR  = 1    ! option flag to use linear DFINT
     &  ,INTERP_SMOOTH  = 2    ! option flag to use smoothing
     &  ,INTERP_ZSMOOTH = 3    ! linear DFINT, but smooth along z
c
     &  ,MXERRTYPE      = 10
     &  ,ERRTYPE_MINOS  = 1
     &  ,ERRTYPE_PARAB  = 2
     &  ,ERRTYPE_MARG   = 3  ! marginalized error
     &  ,ERRTYPE_BAD    = 6
C
     &  ,FCNFLAG_LAST     = 3    ! last MINUIT call
     &  ,FCNFLAG_USER     = 90   ! pass this IFLAG for user-FCNSNLC calls
     &  ,FCNFLAG_FAST     = 91   ! go as fast as possible (no LAST if-block)
     &  ,FCNFLAG_PRIOR_ONLY = 92
     &  ,FCNFLAG_SIGMA_ONLY = 93
     &  ,FCNFLAG_USESIM     = 99   ! pass this IFLAG to use SIM params
     &  ,FCNFLAG_MAX        = 100
c     
     &  ,PI     = 3.1415926535898
     &  ,PDFMIN      = 1.0E-5   ! used to speed up PDF integration
     &  ,PDFMAX_EDGE = 0.03     ! max allowed PDF value at edges
     &  ,PDFMIN_GOOD = 1.0E-4   ! PDF > PDFMIN_GOOD counts as good point
     &  ,OPT_INTEGPDF_QUITCHI2 = 2  ! abort FCNSNLC if chi2 > quitchi2
     &  ,OPT_INTEGPDF_FULL     = 1  ! do full FCNSNLC evaluation
c 
     &  ,OPT_SNXT_CCM89   = 1  ! exact SN etinction using INIT_XTHOST
     &  ,OPT_SNXT_SJPAR   = 2  ! SN extinction with Jha's parameters
     &  ,OPT_KCORERR_SMOOTH = 1 ! use smooth half-Gaussian 
     &  ,OPT_KCORERR_SJ     = 2   ! use Saurabh's Kcor error 
     &  ,OPT_KCORERR_SJ5    = 5  ! x5 Saurabh's Kcor error 
c
     &  ,OPTMASK_SNDATA_GLOBAL =  1
     &  ,OPTMASK_SNDATA_HEAD   =  2
     &  ,OPTMASK_SNDATA_OBS    =  4
     &  ,OPTMASK_SNDATA_SPEC   =  8
     &  ,OPTMASK_SNDATA_ALL    = 2+4+8  ! HEAD + OBS + SPEC
     &  ,OPTMASK_SNDATA_DONE   = 16     ! done reading data version
     &  ,OPTMASK_SNDATA_DUMP   = 32     ! flag to dump variable
     &  ,OPTMASK_SNDATA_REQUIRE= 64     ! flag to require variable
c
     &  ,RV_MWCOLORLAW_DEFAULT  = 3.1   ! A_V/E(B-V)
     &  ,OPT_MWCOLORLAW_DEFAULT = 99    ! Fitzpatrick 99
     &  ,OPT_MWEBV_DEFAULT      =  1    ! whatever is in the data file
c
     &  ,MXLINE_ARGS      = 100  ! max number of command line args
     &  ,MXKEY_ARGS       =   5  ! max number of args per key
     &  ,ZEROPOINT_FLUXCAL_DEFAULT  = 27.5
     &  ,MXEPOCH_IGNORE   = 1000
     &  ,NPAR_ANYLC       = 10   ! for MNFIT_PKMJD 
     &  ,MXPAR_SIMSED     = 100  ! max number of SIMSED parameters
     &  ,MXPAR_LCLIB      = 40   ! should be same as in genmag_LCLIB.h
     &  ,MXLAMBIN_SNSED   = 6000 ! May 2024: raised from 4k -> 6k
     &  ,MXCUTBIT         = 64   ! max number of cut bits
c
     &  ,OPT_FILTUPD_EACHSN   = 1  ! default filter-updates
     &  ,OPT_FILTUPD_MAP      = 2  ! default filter-updates
     &  ,OPT_FILTUPD_SAMEFILT = 3  ! test: use same filter each SN
     &  ,OPT_FILTREST         = 1
     &  ,OPT_FILTOBS          = 2
     &  ,ISTAT_READAGAIN      = 7 
     &  ,ISTAT_SKIP           = -1
c
     &  ,ITABLE_SNANA=1, ITABLE_FITRES=2, ITABLE_OUTLIER=3
     &  ,ITABLE_SNLCPAK=4, ITABLE_SPECPAK=5
     &  ,ITABLE_MODELSPEC=6, ITABLE_MARZ=7, ITABLE_DMPFCN=8
     &  ,MXTABLE = 10
     &  ,IDTABLE_SNANA     = 7100  ! anaysis variables, every event
     &  ,IDTABLE_FITRES    = 7788  ! SNANA table + fit results, passing cuts
     &  ,IDTABLE_OUTLIER   = 7800  ! outlier fluxes (Mar 2021)
     &  ,IDTABLE_MODELSPEC = 8000  ! SALT2 model spectra from LC fit
     &  ,IDTABLE_MARZ      = 8100  ! MARZ table for spectra
     &  ,IDTABLE_DMPFCN    = 8200  ! for DMPFCN (jan 2025)
     &  ,IDTABLE_MCMC      = 7711  ! obsolete ?
     &  ,OPT_PARSTORE_TEXTTABLE = 1  ! tag subset for TEXT table.
     &  ,MSKOPT_PARSE_WORDS_FILE    = 1   ! parse file
     &  ,MSKOPT_PARSE_WORDS_STRING  = 2   ! for store_PARSE_WORDS: string
     &  ,MSKOPT_PARSE_WORDS_IGNORECOMMA   = 4  ! ignore comma for string
     &  ,MSKOPT_PARSE_WORDS_IGNORECOMMENT = 8  ! ignore comment lines
     &  ,MSKOPT_PARSE_WORDS_FIRSTLINE     = 16 ! read only 1st line of file
c 
     &  ,MODEL_STRETCH    = 1
     &  ,MODEL_STRETCH2   = 2
     &  ,MODEL_MLCS2k2    = 3
     &  ,MODEL_SNOOPY     = 4
     &  ,MODEL_SALT2      = 6
     &  ,MODEL_SALT3      = 9 ! May 31 2019
     &  ,MODEL_BAYESN     = 13 ! Oct 7 2022: GN
     &  ,MODEL_SIMSED     = 7
     &  ,MODEL_BYOSED     = 8 
     &  ,MODEL_SNEMO      = 9
     &  ,MODEL_NON1A      = 10
     &  ,MODEL_LCLIB      = 12
     &  ,MODEL_FIXMAG     = 20
     &  ,MXMODEL_INDEX    = 20
     &  ,NULLVAL          = -99999.
     &  ,LEGACY_INIT_VAL  = 1.0E8
     &  ,IGNORE_HEADVAL   = -5555.
c
     &  ,MXCHAR_CCID       = 20   ! max len of CCID string (i.e, SN name)
     &  ,MXCHAR_VERSION    = 72   ! max len of VERSION_PHOTOMETRY
     &  ,MXCHAR_SURVEY     = 40   ! max len of SURVEY_NAME
     &  ,MXCHAR_PATH       = 160  ! max len of path
     &  ,MXCHAR_FILENAME   = 300  ! max len of filename with full path
     &  ,MXCHAR_MODELNAME  = 72   ! max len of model name
     &  ,MXCHAR_FIELDNAME  = 20   ! max len of field name
     &  ,MXCHAR_PARNAME    = 20   ! max len of parameter name
     &  ,MXCHAR_CUTNAME    = 300  ! to define cut names
     &  ,MXCHAR_FILEWORD   =  60  ! size of FILEWORD_LIST
     &  ,MXCHAR_ARG        = 800  ! max lenth of command line arg
     &  ,MXFILE_LIST       =  10  ! max number of files in input list
c
     &  ,FLAG_DOCANA_START  =  1  ! flags DOCUMENTATION key
     &  ,FLAG_DOCANA_END    =  2  ! flags DOCUMENTATION_END 
     &  ,FLAG_DOCANA_ERROR  = -1  ! flags missing DOCANA keys

     &  ,SNLCPAK_EPFLAG_FLUXDATA    = 1    ! epoch-dependent
     &  ,SNLCPAK_EPFLAG_FLUXMODEL   = 11
     &  ,SNLCPAK_EPFLAG_REJECT      = 2
     &  ,SNLCPAK_EPFLAG_CHI2        = 3
     &  ,SNLCPAK_EPFLAG_FITFUN      = 4
     &  ,SNLCPAK_EPFLAG_FLUXSIM     = 5    ! epoch-dependent
     &  ,SNLCPAK_EPFLAG_FLUXREST    = 6
     &  ,SNLCPAK_EPFLAG_KCOR        = 7
     &  ,SNLCPAK_EPFLAG_AVWARP      = 8
     &  ,SNLCPAK_EPFLAG_SIMFLUXREST = 9
     &  ,SNLCPAK_EPFLAG_ERRCALC     = 10
     &  ,SNLCPAK_BANDFLAG_NDOF    = 100
     &  ,SNLCPAK_BANDFLAG_PKFLUX  = 101  ! filter-dependent 
     &  ,SNLCPAK_BANDFLAG_PKMJD   = 102
     &  ,SNLCPAK_BANDFLAG_CHI2    = 103
c
     &  ,IFLAG_INI=1, IFLAG_ANA=2, IFLAG_END=3
     &  ,MAG_SATURATE = -7.0    ! for sim only
     &  ,CUTVAL_OPEN  = 1.0E12  ! cutwin value to accept everything.
     &  ,MASK_FLUXCOR_SNANA    = 1
     &  ,MASK_FLUXERRCOR_SNANA = 2
c
     &  ,EXIT_ERRCODE_SNANA = 21
     &  ,EXIT_ERRCODE_SNFIT = 22
     &  ,EXIT_ERRCODE_PSNID = 23
     &  ,ERRFLAG_MNFIT_INITPAR = 91
     &  ,ERRFLAG_MNFIT_FIXPAR  = 92
     &  ,ERRFLAG_MNFIT_NAN     = 93
     &  ,MXMASK_zSOURCE        = 128  ! max mask value for MASK_zSOURCE
     &      )

c physical constants

      REAL*8  
     &   PARSEC, CLIGHT, PEAKMAG_AT_10PC
     &  ,Zat10pc
     &  ,OMAT_DEFAULT, OMATERR_DEFAULT
     &  ,OLAM_DEFAULT, OLAMERR_DEFAULT
     &  ,ORAD_DEFAULT
     &  ,H0_DEFAULT,   H0ERR_DEFAULT
     &  ,W0_DEFAULT,   W0ERR_DEFAULT
     &  ,DWDA_DEFAULT, DWDAERR_DEFAULT

      PARAMETER (
     &   PARSEC        = 3.085678E13  ! 1 parsec (km)
     &  ,CLIGHT        = 2.998E5      ! c (km/sec)
c
     &  ,H0_DEFAULT        = 70.0  ! standard value
     &  ,W0_DEFAULT        = -1.0
     &  ,DWDA_DEFAULT      =  0.0
     &  ,OMAT_DEFAULT      =  0.315  ! Planck 2018 (updated Mar 2020)
     &  ,OLAM_DEFAULT      =  0.685  ! idem
     &  ,ORAD_DEFAULT      =  1.2E-5
c
     &  ,H0ERR_DEFAULT        =  7.0
     &  ,W0ERR_DEFAULT        =  0.1
     &  ,DWDAERR_DEFAULT      =  0.0
     &  ,OMATERR_DEFAULT      =  0.03
     &  ,OLAMERR_DEFAULT      =  0.03
c
     &  ,PEAKMAG_AT_10PC   = -19.6  
     &  ,Zat10pc           = 2.34E-9   ! magic redshift at 10 pc
     &  ,MJDOFF            = 0.0       ! 53000.
     &     )


+KEEP,SNFILECOM.

c Sep 9, 2010: Pulled out of SNDATACOM 

      CHARACTER
     &   SNDATA_ROOT*(MXCHAR_PATH)
     &  ,SNANA_DIR*(MXCHAR_PATH)
     &  ,HOST_MACHINE*(MXCHAR_PATH)     ! name of host machine
     &  ,SNDATA_PATH*(MXCHAR_PATH)      ! subdir with data or sim files
     &  ,SNLIST_FILE*(MXCHAR_FILENAME)  ! input list of SNDATA Files
     &  ,SNREADME_FILE(MXVERS)*(MXCHAR_FILENAME)   ! name of EVERY README file
     &  ,SNDATA_FILE_CURRENT*(MXCHAR_FILENAME)     ! current file being read
     &  ,GLOBAL_BANNER*120
     &  ,SNDATA_PREFIX*(MXCHAR_FILENAME)  ! $SNDATA_ROOT/lcmerge/$VERSION
     &  ,C1ERR*88, C2ERR*88    ! generic error strings
    
      LOGICAL LFLAG_RDHEAD_ONLY

      COMMON / SNFILECOM / 
     &   SNDATA_ROOT, SNANA_DIR, HOST_MACHINE, SNLIST_FILE
     &  ,SNDATA_FILE_CURRENT
     &  ,GLOBAL_BANNER, SNDATA_PREFIX, SNREADME_FILE, SNDATA_PATH
     &  ,C1ERR, C2ERR, LFLAG_RDHEAD_ONLY
     

+KEEP,SNDATCOM.

+CDE,SNPAR.
+CDE,SNFILECOM.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,SNHOSTCOM.
cc +CDE,PARSECOM.
+CDE,SNSIMCOM.

+KEEP,CTRLCOM.

c control variables and counters.

      INTEGER 
     &   ISTAGE_SNANA       ! current stage of processing
     &  ,NACCEPT_CUT(MXCUTBIT) ! Number of SN that pass each cut
     &  ,NACCEPT_CID           ! # SN with valid CID
     &  ,NACCEPT_TYPE          ! # SN with valid TYPE
     &  ,NACCEPT_Z             ! idem with valid redshift
     &  ,NACCEPT_ZERR          ! idem with valid redshift error
c
     &  ,NCALL_SNANA_DRIVER
     &  ,NCALL_FCNFLAG(FCNFLAG_MAX)
c
     &  ,NPASSCUT_INCREMENT(-1:MXTYPE,100)  ! 100 > NCUTBIT_SNLC 
     &  ,NPASSCUT_FIT(-1:MXTYPE)
     &  ,NSTORE_MAGCOR         ! number of stored MAGCOR values
     &  ,NUSE_MAGCOR           ! number of used MAGCOR values
     &  ,SIGN_MAGCOR           ! add or subtract
     &  ,FORCEMASK_FLUXCOR   ! mask to force fluxCor, even if already applied  
     &  ,EXIT_ERRCODE        ! used for abort

      INTEGER*8
     &   JTIME_START
     &  ,JTIME_LOOPSTART        ! time at start of fits with TIME()
     &  ,JTIME_LOOPEND          ! time and end

      LOGICAL 
     &   DO_FIT
     &  ,DO_GETINFO        ! T=>GETINFO flag to print and quit
     &  ,DO_FLUXERRCALC    ! T => compute error from PSF,SKY & ZPT  
     &  ,LSIM_SNANA        ! simulated with SNANA
     &  ,LSIM_MAGOBS   ! data-like, but with SIM_MAGOBS (e.g. fakes on images)
     &  ,ISJOB_SNANA          ! =T for snana.exe only.
     &  ,ISJOB_SNFIT          ! =T for snlc_fit or psnid
     &  ,ISJOB_PSNID
     &  ,ISJOB_SIM    ! either SNANA sim or fakes (LSIM_SNANA or LSIM_MAGOBS)
     &  ,ISJOB_BATCH  ! true if JOBSPLIT passed on command line (Aug 2020)
     &  ,REDUCE_STDOUT_BATCH   ! T => suppress stdout for JOBSPLIT(1)>1
     &  ,REFORMAT              ! T => a reformat option has been set
     &  ,REFORMAT_SNANA        ! T => reformat SNANA format
     &  ,REFORMAT_SAVE_BADEPOCHS ! T => include reject epochs (default=F)
     &  ,REFORMAT_BAND_NAME    ! T => [band] -> [SURVEY]-[band]
     &  ,REFORMAT_SPECTRA_INCLUDE ! include spectra in data reformat (default=F)
     &  ,REFORMAT_SPECTRA_ONLY    ! reformat only spectra (OPT_REFORMAT_SPECTRA>0)
     &  ,REFORMAT_PRIVATE      ! T-> include private variables (default=T)
     &  ,REFORMAT_SIMTRUTH     ! T -> include SIM truth (default=T)
     &  ,STDOUT_UPDATE         ! T => update event to screen
     &  ,DOFUDGE_HOSTNOISE     ! T => FUDGE_HOSTNOISE_FILE is set
     &  ,DOFUDGE_NONLIN        ! T => NONLINEARITY_FILE is set
     &  ,DOFUDGE_FLUXERRMODEL  ! T => FLUXERRMODEL_FILE
     &  ,DOzSHIFT              ! T => apply a zSHIFT systematic
     &  ,ISCORRECT_SIGN_VPEC   ! T => data has correct VPEC sign (10/2020)
     &  ,DOFIX_WRONG_SIGN_VPEC ! T => flip VPEC sign
     &  ,UNIT_PSF_NEA          ! T => read NEA from data; else it's PSF
     &  ,FOUND_ATMOS           ! T=> found atmos variables (dRA,dDEC,AIRMASS)
     &  ,USE_SNCID_FILE         ! bit0 of OPT_SNCID_LIST
     &  ,USE_INIVAL_SNCID_FILE  ! bit1 of OPT_SNCID_LIST
     &  ,USE_PRIOR_SNCID_FILE   ! bit2 of OPT_SNCID_LIST     
     
      CHARACTER
     &    SNANA_VERSION*60        ! e.g., v11_04h-[commit-id]
     &   ,SNANA_VERSION_DATA*60   ! SNANA version used create FITS data
     &   ,REFORMAT_VERSION*(MXCHAR_VERSION)
     &   ,DATATYPE*12  ! e..g, 'DATA', 'FAKE', 'SNANA_SIM'

c global survey info
      CHARACTER
     &   SURVEY_NAME*(MXCHAR_SURVEY)
     &  ,SURVEY_NAME_LIST(MXSURVEY)*(MXCHAR_SURVEY) ! in SURVEY.DEF file
     &  ,SUBSURVEY_NAME*(MXCHAR_SURVEY)  ! e.g.,  SURVEY:  BLA(SUBSURVEY)
     &  ,SUBSURVEY_NAME_LIST*(MXCHAR_FILENAME) ! comma-sep list
     &  ,SURVEY_FILTERS*(MXFILT_ALL)  ! read from data file 
     &  ,SURVEY_FIELDNAME(MXIDFIELD)*(MXCHAR_FIELDNAME) ! from SURVEY.DEF

      INTEGER 
     &   NFIELD_SURVEY             ! number of survey fields in SURVEY.DEF
     &  ,SURVEY_IDFIELD(MXIDFIELD) ! integer ID for each field

      REAL
     &   ZEROPOINT_FLUXCAL(MXFILT_OBS)  ! defines calibrated flux

      INTEGER*4
     &   N_VERSION             ! number of photometry version to read
     &  ,N_SNLC_READ(MXVERS)   ! total numbrer of LC per version
     &  ,N_SNLC_PROC           ! number of SNLC processed with SNANA_DRIVER
     &  ,N_SNLC_CUTS           ! Number of SN after cuts (bookkeeping only)
     &  ,N_SNLC_SPEC           ! idem, but with 1 or more spectra
     &  ,N_SNLC_FIT            ! Number of fitted SN
     &  ,N_SNLC_FITCUTS        ! Number of fitted SN after fit cuts
     &  ,N_SNLC_COVFIX         ! Number of SN with fixed COV to be invertible
     &  ,N_SNHOST_ZSPEC        ! for YAML out file
     &  ,N_SNHOST_ZPHOT        ! idem
     &  ,N_MASK_zSOURCE_LC_CUTS(0:MXMASK_zSOURCE)     ! Nevt per bit mask (after SNANA/LC cuts)
     &  ,N_MASK_zSOURCE_LCFIT_CUTS(0:MXMASK_zSOURCE)  ! Nevt per bit mask (after LCFIT & cuts)
     &  ,N_DUPLICATE_CID       ! Number of duplicate CIDs 
     &  ,N_DUPLICATE_MJD       ! Number of duplicate MJD+BAND (Jun 2017)
     &  ,NSTORE_DUPLICATE_MJD  ! Number stored
     &  ,N_SNFILE              ! # of SN files to read per version
     &  ,N_SNFILE_LAST         ! idem, as of last version
     &  ,ABSO_OFFSET           ! used to compute ABSO_INDEX
     &  ,ABSO_INDEX            ! absolute index (row or file number)
     &  ,NEPOCH_TOT            ! total number of epochs read from files
     &  ,NEPOCH_USE            ! total number of used epochs   
     &  ,NEPOCH_CUT            ! total number of epochs passing cuts
     &  ,NEPOCH_BADPHOT        ! # epochs with bad PHOTFLAG (per event)
     &  ,NEPOCH_BADPHOT_SUM    ! # epochs with bad PHOTFLAG (summed)
     &  ,IDSURVEY              ! survey ID from SURVEY.DEF
     &  ,IDSUBSURVEY           ! =IDSURVEY unless subSurvey is different
     &  ,IDSURVEY_LIST(MXSURVEY) ! corresponds to SURVEY_NAME_LIST
     &  ,NSURVEY_LIST          ! size of SURVEY_NAME_LIST & IDSURVEY_LIST

      LOGICAL*1
     &    EXIST_CALIB_FILE 
     &   ,EXIST_FILT(MXFILT_OBS)  ! T => at least one point per filt
     &   ,FOUND_SURVEY
     &   ,FORMAT_TEXT    ! ascii/txt for input data
     &   ,FORMAT_FITS    ! snfitsio for input data.

      INTEGER N_SNLC_PLOT
      LOGICAL MADE_LCPLOT  ! SAVE:  T if LC plot was made


      COMMON / CTRLCOM / 
     &     SNANA_VERSION, SNANA_VERSION_DATA, REFORMAT_VERSION, DATATYPE
     &    ,SURVEY_NAME, SURVEY_NAME_LIST
     &    ,SUBSURVEY_NAME, SUBSURVEY_NAME_LIST
     &    ,NSURVEY_LIST, IDSURVEY, IDSUBSURVEY, IDSURVEY_LIST
     &    ,SURVEY_FILTERS
     &    ,SURVEY_FIELDNAME, SURVEY_IDFIELD, NFIELD_SURVEY
     &    ,ISJOB_SNANA, ISJOB_SNFIT, ISJOB_PSNID, ISJOB_SIM, ISJOB_BATCH
     &    ,REDUCE_STDOUT_BATCH
     &    ,ZEROPOINT_FLUXCAL
     &    ,NACCEPT_CUT, NACCEPT_CID, NACCEPT_TYPE
     &    ,NACCEPT_Z, NACCEPT_ZERR
     &    ,DO_FIT, DO_GETINFO, DO_FLUXERRCALC
     &    ,NSTORE_MAGCOR, NUSE_MAGCOR, SIGN_MAGCOR, FORCEMASK_FLUXCOR
     &    ,LSIM_SNANA, LSIM_MAGOBS
     &    ,ISTAGE_SNANA
     &    ,N_VERSION, N_SNLC_READ, N_SNLC_PROC, N_SNLC_CUTS, N_SNLC_SPEC
     &    ,N_SNLC_FIT, N_SNLC_FITCUTS, N_SNLC_COVFIX
     &    ,N_SNHOST_ZSPEC, N_SNHOST_ZPHOT
     &    ,N_MASK_zSOURCE_LC_CUTS, N_MASK_zSOURCE_LCFIT_CUTS
     &    ,N_SNFILE, N_SNFILE_LAST, N_DUPLICATE_CID
     &    ,N_DUPLICATE_MJD, NSTORE_DUPLICATE_MJD
     &    ,NEPOCH_TOT, NEPOCH_USE, NEPOCH_CUT
     &    ,NEPOCH_BADPHOT, NEPOCH_BADPHOT_SUM
     &    ,ABSO_OFFSET, ABSO_INDEX
     &    ,REFORMAT, REFORMAT_SPECTRA_INCLUDE, REFORMAT_SPECTRA_ONLY
     &    ,REFORMAT_SNANA, REFORMAT_PRIVATE, REFORMAT_BAND_NAME
     &    ,REFORMAT_SAVE_BADEPOCHS, REFORMAT_SIMTRUTH
     &    ,STDOUT_UPDATE, ISCORRECT_SIGN_VPEC, DOFIX_WRONG_SIGN_VPEC
     &    ,DOFUDGE_HOSTNOISE, DOFUDGE_NONLIN, DOFUDGE_FLUXERRMODEL
     &    ,DOzSHIFT
     &    ,USE_SNCID_FILE, USE_INIVAL_SNCID_FILE, USE_PRIOR_SNCID_FILE
     &    ,NCALL_SNANA_DRIVER, NCALL_FCNFLAG
     &    ,NPASSCUT_INCREMENT, NPASSCUT_FIT
     &    ,N_SNLC_PLOT, MADE_LCPLOT, UNIT_PSF_NEA, FOUND_ATMOS
     &    ,EXIT_ERRCODE

      COMMON / CTRLCOM8 / JTIME_START, JTIME_LOOPSTART, JTIME_LOOPEND

c logical *1 stuff

      COMMON / SNDATCOM1 / EXIST_CALIB_FILE, EXIST_FILT, FOUND_SURVEY
     &    ,FORMAT_TEXT, FORMAT_FITS

c SNTABLE control variables (May 2014)
      LOGICAL
     &   USE_TABLEFILE_ROOT   ! write table in ROOT format
     &  ,USE_TABLEFILE_TEXT   ! write table in TEXT format
     &  ,USE_TABLEFILE_MARZ   ! write table in MARZ/FITS format
     &  ,USE_TABLEFILE        ! T if either any of the above are set
     &  ,WRTABLEFILE_IAUC     ! T-> SNID -> IAUC (for writing tables)
     &  ,WRTABLEFILE_SIMVAR   ! T-> include SIM_XXX vars for simulation
     &  ,WRTABLEFILE_ZPHOT    ! T-> include ZPHOT info for PHOTOZ fit
     &  ,WRTABLEFILE_HOST_TEXT  ! T-> add HOST info in SNANA TEXT table 
     &  ,WRTABLEFILE_HOST2_TEXT ! T-> add HOST and HOST2 info in SNANA TEXT table 
     &  ,WRTABLEFILE_ERRCALC_TEXT! T-> add ERRCALC info in LCPLOT TEXT table 

      INTEGER
     &   OPT_TABLE(MXTABLE)       ! option(s) for each table
     &  ,CUTMASK_SNANA_TABLE      ! select CUTFLAG_SNANA for SNANA table

      REAL
     &   PRESCALE_TABLE(MXTABLE)  ! table pre-scale (to reduce size)

      CHARACTER 
     &   TEXTFORMAT_TABLE(MXTABLE)*8
     
c arrays for TABLE_FILTER_REMAP (Feb 2017)
      INTEGER NFILT_REMAP_TABLE, IFILTLIST_REMAP_TABLE(MXFILT_ALL)
      CHARACTER FILTLIST_REMAP_TABLE*(MXFILT_ALL)

c Sep 23 2017: allow user codes to add private variables to SNTABLE
      INTEGER   NTABLEVAR_USER  ! e.g., set in snana_private.cra
      CHARACTER TABLEVARNAME_USER(MXVAR_PRIVATE)*40
      REAL      TABLEVALUE_USER(MXVAR_PRIVATE)
 
      COMMON / SNTABLECOM / 
     &     USE_TABLEFILE_ROOT
     &    ,USE_TABLEFILE_TEXT, USE_TABLEFILE_MARZ, USE_TABLEFILE
     &    ,OPT_TABLE, TEXTFORMAT_TABLE
     &    ,CUTMASK_SNANA_TABLE, WRTABLEFILE_IAUC, WRTABLEFILE_SIMVAR
     &    ,WRTABLEFILE_ZPHOT
     &    ,WRTABLEFILE_HOST_TEXT, WRTABLEFILE_HOST2_TEXT
     &    ,WRTABLEFILE_ERRCALC_TEXT 
c
     &    ,NFILT_REMAP_TABLE, IFILTLIST_REMAP_TABLE
     &    ,FILTLIST_REMAP_TABLE
     &    ,NTABLEVAR_USER, TABLEVARNAME_USER
     &    ,TABLEVALUE_USER, PRESCALE_TABLE

c May 6, 2008: define lists for epochs to ignore
 
      INTEGER NEPOCH_IGNORE, NEPOCH_IGNORE_WRFITS
      CHARACTER 
     &   EPOCH_IGNORE_CCID(MXEPOCH_IGNORE)*(MXCHAR_CCID)
     &  ,EPOCH_IGNORE_FILT(MXEPOCH_IGNORE)*4
     &  ,EPOCH_IGNORE_LASTFILE*(MXCHAR_FILENAME)

      REAL*8 
     &   EPOCH_IGNORE_MJD(MXEPOCH_IGNORE)

      COMMON / EPIGNORE_COM / NEPOCH_IGNORE, NEPOCH_IGNORE_WRFITS
     &  ,EPOCH_IGNORE_CCID, EPOCH_IGNORE_FILT, EPOCH_IGNORE_LASTFILE
      COMMON / EPIGNORE_COM8 / EPOCH_IGNORE_MJD


      REAL*8  DUPLICATE_MJDLIST(200)
      COMMON / DUPMJDCOM / DUPLICATE_MJDLIST

+KEEP,OUTLIERCOM.

      INTEGER MXFILT_OUTLIER
      PARAMETER ( MXFILT_OUTLIER = 100) ! avoid includig FILTCOM

      CHARACTER OUTLIER_TABLE_NAME*12

      REAL
     &   NSIGCUT_OUTLIER    ! e.g., SNTABLE_LIST='OUTLIER(nsig:3.5)'
     &  ,FTRUECUT_OUTLIER   ! e.g., SNTABLE_LIST='OUTLIER(Ftrue:0.0)'
     &  ,SBMAGCUT_OUTLIER   ! e.g., SNTABLE_LIST='OUTLIER(sbmag:25.0)

      REAL*8 OUTLIER_MJD
      REAL*4 
     &   OUTLIER_FLUXCAL_DATA, OUTLIER_FLUXCAL_ERR_DATA
     &  ,OUTLIER_FLUXCAL_ERR_CALC
     &  ,OUTLIER_FLUXCAL_TRUE
     &  ,OUTLIER_FLUXCAL_FIT, OUTLIER_FLUXCAL_ERR_FIT
     &  ,OUTLIER_FLUXCAL_ERRTOT_FIT  ! data + fit errors in quadrature
     &  ,OUTLIER_AREAFRAC
     &  ,OUTLIER_ZP, OUTLIER_NEA, OUTLIER_PSF, OUTLIER_SKYSIG
     &  ,OUTLIER_NSIG, OUTLIER_LOGSNR, OUTLIER_SBMAG
     &  ,OUTLIER_z, OUTLIER_TREST  ! for LC FIT only

      INTEGER   
     &    NEP_OUTLIER_TOT, NEP_OUTLIER_PEREVT
     &   ,NEP_OUTLIER_CHECK(MXFILT_OUTLIER)  ! total epochs checked per band
     &   ,NEP_OUTLIER_FOUND(MXFILT_OUTLIER)  ! Noutlier per band
     &   ,OUTLIER_IFILTOBS, OUTLIER_CCDNUM, OUTLIER_PHOTFLAG
     &   ,OUTLIER_IXPIX, OUTLIER_IYPIX

      CHARACTER OUTLIER_BAND*4, OUTLIER_FIELD*20

      COMMON / OUTLIERCUTS /
     &   NSIGCUT_OUTLIER, FTRUECUT_OUTLIER, SBMAGCUT_OUTLIER

      COMMON / OUTLIERCOM8 / OUTLIER_MJD 
      COMMON / OUTLIERCOM4 / NEP_OUTLIER_TOT, NEP_OUTLIER_PEREVT
     &  ,NEP_OUTLIER_CHECK, NEP_OUTLIER_FOUND, OUTLIER_TABLE_NAME
     &  ,OUTLIER_FLUXCAL_DATA, OUTLIER_FLUXCAL_ERR_DATA
     &  ,OUTLIER_FLUXCAL_ERR_CALC
     &  ,OUTLIER_FLUXCAL_TRUE
     &  ,OUTLIER_FLUXCAL_FIT, OUTLIER_FLUXCAL_ERR_FIT
     &  ,OUTLIER_FLUXCAL_ERRTOT_FIT
     &  ,OUTLIER_IXPIX, OUTLIER_IYPIX, OUTLIER_AREAFRAC
     &  ,OUTLIER_ZP, OUTLIER_NEA, OUTLIER_PSF, OUTLIER_SKYSIG
     &  ,OUTLIER_NSIG, OUTLIER_LOGSNR, OUTLIER_SBMAG
     &  ,OUTLIER_z, OUTLIER_TREST 
     &  ,OUTLIER_IFILTOBS, OUTLIER_BAND, OUTLIER_FIELD
     &  ,OUTLIER_CCDNUM, OUTLIER_PHOTFLAG

c efficiency for PHOTFLAG bits

      INTEGER
     &   NEP_OUTLIER_VS_PHOTBIT(2,MXBIT_PHOTFLAG)    ! 1=TOT, 2=bit set
     &  ,NEP_ALL_VS_PHOTBIT(2,MXBIT_PHOTFLAG)        ! 1=TOT, 2=bit set
      
      COMMON /OUTLIER_PHOTPROB /
     &  NEP_OUTLIER_VS_PHOTBIT, NEP_ALL_VS_PHOTBIT

+KEEP,USRTAGCM.

      INTEGER MXUSERTAG
      PARAMETER ( MXUSERTAG = 1000 ) ! max number of user tags

      INTEGER
     &   N_USERTAGS           ! number of tags in USERTAGS_FILE
     &  ,USERTAG_VALUELIST(MXUSERTAG)  ! list of user tags
     &  ,USERTAG                   ! USERTAG value  for current SN

      BYTE
     &   USERTAG_USED(MXUSERTAG)   ! mark when each USERTAG is used

      CHARACTER 
     &   USERTAG_CCIDLIST(MXUSERTAG)*(MXCHAR_CCID)  ! list of CCID

      COMMON / USERTAGCOM / 
     &   N_USERTAGS, USERTAG_VALUELIST, USERTAG_CCIDLIST
     &  ,USERTAG, USERTAG_USED


+KEEP,REQEPCOM.
      CHARACTER FILTLIST_REQEP*(MXFILT_ALL)
      INTEGER NFILT_REQEP, IFILTLIST_REQEP(MXFILT_ALL)
      REAL  TRANGE_REQEP(3), SNRMIN_REQEP
      LOGICAL ISFRAME_REST_REQEP, ISFRAME_OBS_REQEP

      COMMON / REQEPINP / 
     &    NFILT_REQEP, FILTLIST_REQEP, IFILTLIST_REQEP
     &   ,TRANGE_REQEP, SNRMIN_REQEP
     &   ,ISFRAME_REST_REQEP, ISFRAME_OBS_REQEP

      REAL NDAYS_ABOVE_SNRMIN_REQEP
      COMMON / REQEPCOM / NDAYS_ABOVE_SNRMIN_REQEP


+KEEP,EARLYCOM.

      REAL DT_SAMENIGHT
ccc   PARAMETER (DT_SAMENIGHT = 0.333) ! same night within 1/3 day = 8 hr
      PARAMETER (DT_SAMENIGHT = 0.400) ! same night within 0.4 day

c variables for selecting the early part of a light curve
      INTEGER    NOBS_EARLYLC, NNIGHT_EARLYLC
      INTEGER    NPHOTMASK_START_EARLYLC
      REAL       NSNR_START_EARLYLC
      REAL       MJDLAST_EARLYLC, MJDLAST_SELECT
  
      COMMON / EARLYCOM / 
     &   NOBS_EARLYLC, NNIGHT_EARLYLC, 
     &   NPHOTMASK_START_EARLYLC, NSNR_START_EARLYLC,
     &   MJDLAST_EARLYLC, MJDLAST_SELECT

c parameters parsed from EARLYLC_STRING:
      INTEGER  MAXOBS_EARLYLC, MAXNIGHT_EARLYLC, PHOTMASK_EARLYLC,
     &         NDAYADD_EARLYLC, PHOTMASK_START_EARLYLC
      REAL  SNRMIN_EARLYLC, PHOTPROBMIN_EARLYLC, SNR_START_EARLYLC
      CHARACTER  FILTERS_EARLYLC*(MXFILT_ALL)

      COMMON / EARLYINP / 
     &   MAXOBS_EARLYLC, MAXNIGHT_EARLYLC, NDAYADD_EARLYLC
     &  ,FILTERS_EARLYLC
     &  ,SNRMIN_EARLYLC, PHOTPROBMIN_EARLYLC, PHOTMASK_EARLYLC
     &  ,PHOTMASK_START_EARLYLC, SNR_START_EARLYLC

+KEEP,INTERPCM.

c arrays for interpolation

      INTEGER MXINTERP
      PARAMETER ( MXINTERP = 1000) ! ->1000 Nov 19 2019 (was 100)

      INTEGER*4 
     &   N_INTERP_MJDLIST        ! # SN MJDs to interpolate
     
      REAL*8    
     &   INTERP8_MJDLIST(MXINTERP)

      CHARACTER 
     &   INTERP_CCIDLIST(MXINTERP)*(MXCHAR_CCID)

      INTEGER N_INTERP_MJDLIST_DONE
      LOGICAL INTERP_MJDLIST_DONE(MXINTERP)

      COMMON / SNMJD_INTERPCOM /
     &    N_INTERP_MJDLIST, INTERP_CCIDLIST
     &   ,INTERP_MJDLIST_DONE, N_INTERP_MJDLIST_DONE

      COMMON / SNMJD_INTERPCOM8 / INTERP8_MJDLIST

+KEEP,SNLCCOM.

c Main common block variables for light curves and
c analysis-related variables.    

      INTEGER
     &   SNLC_CID                  ! integer CID 
     &  ,INDEX_CID_MATCH           ! ISN index from SNCID_LIST_FILE
     &  ,ISNLC_SNRECON_USE(MXEPOCH)  ! 1 -> epoch used in SNRECON
     &  ,ISNLC_PHOTFLAG(MXEPOCH)     ! photomety flags
     &  ,ISNLC_zFLAG                 ! zspec-quality flag (May 2020), data only
     &  ,ISNLC_zSOURCE               ! mask indicating the source of redshift
     &  ,ISNLC_LENCCID     ! char-len of CCID
     &  ,ISNLC_LENIAUC     ! char-len of IAUC name
     &  ,ISNLC_LENNAME     ! char-len of transient name
     &  ,ISNLC_VERSION     ! photometry version index vs. ISN     
     &  ,ISNLC_TYPE        ! type (120=confirmed Ia, etc ...)
     &  ,ISNLC_IFILE       ! ifile index, text format only
     &  ,ISNLC_IFILT_OBS(MXEPOCH) ! filt-index for each epoch/SN
     &  ,ISNLC_NEWMJD_HEAD   ! Number of NEWMJDs in header
     &  ,ISNLC_NEWMJD_FOUND  ! Number of NEWMJDs found in file
     &  ,ISNLC_NEWMJD_STORE  ! Number of NEWMJDs stored
     &  ,ISNLC_NEWMJD_CUTS   ! Number of NEWMJDs after cuts
     &  ,ISNLC_EPOCH_RANGE_NEWMJD(2,MXEPOCH)
     &  ,ISNLC_NFILT_NEWMJD(MXEPOCH)   ! # observed filters per NEWMJD
     &  ,ISNLC_NFILT_SNRMAX      ! number of filters passing SNR cut
     &  ,ISNLC_NFILT_SNRMAX2     ! idem for 2nd SNRMAX cut
     &  ,ISNLC_NFILT_TRESTMIN   ! Nfilt passing TRESTMIN cut
     &  ,ISNLC_NFILT_TRESTMAX   ! idem for TRESTMAX
     &  ,ISNLC_NFILT_TREST2     ! Nfilt passing CUTWIN_TREST2 cut
     &  ,ISNLC_NEPOCH_FOUND     ! actual number of epochs found
     &  ,ISNLC_NEPOCH_STORE     ! number of epochs stored in memory
     &  ,ISNLC_NEPOCH_USE       ! used after PHOTMASK cuts
     &  ,ISNLC_NEPOCH_PHOTPROB  ! NEPOCH with PHOTPROB >= 0
     &  ,ISNLC_NEPOCH_FILT(MXFILT_OBS)  ! NEPOCH vs. filter
     &  ,ISNLC_NOBS_DETECT      ! NOBS with detection
     &  ,ISNLC_NOBS_PREDETECT   ! NOBS in CUTWIN_TOBS_PREDETECT window
c
     &  ,ISNLC_FAKE             ! => real data, else it's a fake
     &  ,ISNLC_CCDNUM(MXEPOCH)  ! read from header (May 2017)
     &  ,ISNLC_IMGNUM(MXEPOCH)  ! Oct 2021: IMAGE NUNBER (e.g., EXPNUM, VISIT_ID)
     &  ,ISNLC_IDFIELD(MXEPOCH) ! integer field id      
     &  ,ISNLC_NFIELD_OVP       ! number of fields (>=2 for overlap)
     &  ,ISNLC_CUTFLAG_REQEP        ! idem
     &  ,ISNLC_CUTFLAG_PRIVATE      ! idem for private var cuts
     &  ,ISNLC_CUTFLAG_SIMVAR       ! idem for SIMVAR cuts
     &  ,ISNLC_WRMASK_FLUXCOR_SNANA   ! write if fudges applied to data
     &  ,ISNLC_RDMASK_FLUXCOR_SNANA   ! read if SNANA fudges applied to data
      
      REAL*8
     &   SNLC8_RA        ! RA   vs. SN
     &  ,SNLC8_DEC       ! DEC  vs. SN
     &  ,SNLC8_MJD(MXEPOCH)  ! MJD for each epoch
     &  ,SNLC8_MJDMIN        !   min MJD among all measurements
     &  ,SNLC8_MJDMAX        !   max MJD ...
     &  ,SNLC8_MJD_TRIGGER   ! MJD of trigger bit (see PHOTFLAG_TRIGGER)
     &  ,SNLC8_MJD_DETECT_FIRST
     &  ,SNLC8_MJD_DETECT_LAST
     &  ,SNLC8_FLUXCAL(MXEPOCH) ! to call functions requiring double
     &  ,SNLC8_FLUXCAL_ERRTOT(MXEPOCH)
     
      REAL 
     &   SNLC_ZHELIO        ! redshift used for final analysis 
     &  ,SNLC_ZHELIO_ERR    ! error on above 
     &  ,SNLC_ZCMB          ! redshift used for final analysis 
     &  ,SNLC_ZCMB_ERR      ! error on above 
     &  ,SNLC_ZHD           ! redshift used for Hubble diagram 
     &  ,SNLC_ZHD_ERR       ! error on above
     &  ,SNLC_ZSN           ! redshift of SN only (ignoring host-z)
     &  ,SNLC_ZSN_ERR       ! error on above
     &  ,SNLC_REDSHIFT      ! redshift used for light curve fit
     &  ,SNLC_REDSHIFT_ERR  ! error on above 
     &  ,SNLC_VPEC          ! pec. velocity
     &  ,SNLC_VPEC_ERR      ! error on above
     &  ,SNLC_LENSDMU       ! measured LENSDMU  from WL (Jan 2025)
     &  ,SNLC_LENSDMU_ERR   ! error on measurement
     &  ,SNLC_ZPEC
     &  ,SNLC_ZPEC_ERR
     &  ,SNLC_Trestmin  ! earliest epoch, rest frame days since peak
     &  ,SNLC_Trestmax  ! latest   epoch, rest frame days since peak
     &  ,SNLC_TrestRange
     &  ,SNLC_Tobsmin   ! earliest epoch, obs frame days since peak
     &  ,SNLC_Tobsmax   ! latest   epoch, obs frame days since peak
     &  ,SNLC_TGAPMAX     ! max gap within TREST-range
     &  ,SNLC_T0GAPMAX    ! max gap near peak 
     &  ,SNLC_SNRMAX_FILT(0:MXFILT_OBS)   ! max S/N per filter/SN
     &  ,SNLC_SNRMAX_SORT(MXFILT_OBS)     ! 1st, 2nd ... SNRMAX by filt
     &  ,SNLC_SNRSUM
     &  ,SNLC_FLUXCALMAX(MXFILT_OBS)    ! max flux per filter/SN
     &  ,SNLC_FLUXCALMAX_ERR(MXFILT_OBS)  ! uncertainty on above
     &  ,SNLC_SNANAFIT_PEAKMJD     ! SNANA-estimate of PEAKKMJD
     &  ,SNLC_SNANAFIT_PEAKMJD_FITPAR(MXFILT_OBS,NPAR_ANYLC)
     &  ,SNLC_SNANAFIT_PEAKMJD_FITERR(MXFILT_OBS,NPAR_ANYLC)
     &  ,SNLC_PHOTPROB(MXEPOCH)   ! generic 'fit probability' per epoch
     &  ,SNLC_PHOTPROB_MIN        ! min photprob for PHOTPROB>0
     &  ,SNLC_TOBS(MXEPOCH)        ! MJD-SET_PEAKMJD
     &  ,SNLC_TREST(MXEPOCH)       !  MJD-SET_PEAKMJD)/(1+z)
     &  ,SNLC_GAIN(MXEPOCH)      ! e/AUD
     &  ,SNLC_RDNOISE(MXEPOCH)   ! read noise per pix, e-
     &  ,SNLC_PIXSIZE            ! pixel size
     &  ,SNLC_NXPIX              ! total number of X-pixels (Aug 7 2014)
     &  ,SNLC_NYPIX              ! total number of Y-pixels
     &  ,SNLC_XPIX(MXEPOCH)      ! pixel location
     &  ,SNLC_YPIX(MXEPOCH)      ! pixel location
     &  ,SNLC_AREAFRAC(MXEPOCH)  ! area-frac contained by XPIX,YPIX
     &  ,SNLC_AREAFRAC_AVG       ! average over epochs (May 2020)
     &  ,SNLC_dRA(MXEPOCH)       ! RA(obs) - RA_AVG(band)
     &  ,SNLC_dDEC(MXEPOCH)
     &  ,SNLC_AIRMASS(MXEPOCH)
     &  ,SNLC_MWEBV              ! Milky Way Galactic E(B-V)
     &  ,SNLC_MWEBV_ERR          ! error on above
     &  ,SNLC_SKYSIG(MXEPOCH)    ! sigma on above
     &  ,SNLC_SKYSIG_T(MXEPOCH)  ! sigma on template run
     &  ,SNLC_PSF_SIG1(MXEPOCH)  ! sigma, pixels
     &  ,SNLC_PSF_SIG2(MXEPOCH)
     &  ,SNLC_PSF_RATIO(MXEPOCH)
     &  ,SNLC_PSF_FWHM_ARCSEC(MXEPOCH) 
     &  ,SNLC_PSF_NEA(MXEPOCH)     ! Noise-equivalent area (pixels)
     &  ,SNLC_SNR(MXEPOCH)         ! SNR
     &  ,SNLC_FLUXCAL_OFF(MXFILT_OBS)    ! add SN light from template
     &  ,SNLC_FLUXCAL_ERRCALC(MXEPOCH)   ! calc a-la simulation
     &  ,SNLC_FLUXCAL_HOSTERRCALC(MXEPOCH)   ! idem for host error
     &  ,SNLC_FLUXCAL(MXEPOCH)
     &  ,SNLC_FLUXCAL_ERRTOT(MXEPOCH)
     &  ,SNLC_FLUXCAL_ERRTEST(MXEPOCH)   ! ERRCALC/ERRTRUE (Nov 2019
     &  ,SNLC_FLUXCAL_FIT(MXEPOCH)       ! used for outlier table
     &  ,SNLC_FLUXCAL_ERR_FIT(MXEPOCH)   ! idem
     &  ,SNLC_FLUXCAL_ERRTOT_FIT(MXEPOCH)   ! sqrt[cov(data)+cov(fit)]
     &  ,SNLC_MAG(MXEPOCH)
     &  ,SNLC_MAG_ERRPLUS(MXEPOCH)
     &  ,SNLC_MAG_ERRMINUS(MXEPOCH)
     &  ,SNLC_ZEROPT(MXEPOCH)
     &  ,SNLC_ZEROPT_ERR(MXEPOCH)
     &  ,SNLC_ZEROPT_forCUT(MXEPOCH)  ! depends on CUTWIN_ZPADU or CUTWIN_ZPNPE
     &  ,SNLC_TEXPOSE(MXEPOCH)     
     &  ,SNLC_DLMAG                   ! 5*log10(10pc/DL)
     &  ,SNLC_SKYFLUXCAL(MXEPOCH)     ! calculated sky fluxcal/pixel
     &  ,SNLC_MWXT_MAG(MXFILT_OBS)        ! mag stellar extinct
     &  ,SNLC_MWXT_FLUXFRAC(MXFILT_OBS)   ! same for flux (< 1)
     &  ,SNLC_MWXT_MAGERR(MXFILT_OBS)     ! Galactic mag err per filter
     &  ,SNLC_SEARCH_PEAKMJD            ! external PEAKMJD
     &  ,SNLC_DTOBS(MXEPOCH)            ! time since last obs  
     &  ,SNLC_DTOBS_SAMEFILT(MXEPOCH)   ! idem, but same filter
     &  ,SNLC_TLIVE_DETECT     ! MJD(last detection) - MJD(1st detection)

      INTEGER 
     &   NSEASON_TOT     ! total number of seasons
     &  ,NSEASON_ACTIVE  ! total number of active seasons

      REAL*4
     &   MULTISEASON_CHI2RED(MXSEASON) ! borrow another 'MX' param
     &  ,MULTISEASON_AVGFLUX(MXSEASON)
     &  ,MULTISEASON_MJDMIN(MXSEASON)
     &  ,MULTISEASON_MJDMAX(MXSEASON)

      CHARACTER
     &   SNLC_CCID*(MXCHAR_CCID)    ! public integer or string name
     &  ,SNLC_NAME_IAUC*(MXCHAR_CCID)      ! public IAUC name
     &  ,SNLC_NAME_TRANSIENT*(MXCHAR_CCID) ! internal transient name (July 2024)
     &  ,SNLC_CASTCID*8             ! = 'INT' or 'CHAR' to indicate cast
     &  ,SNLC_FIELD(MXEPOCH)*(MXCHAR_FIELDNAME)    ! char field name
     &  ,SNLC_FIELD_OVPLIST(MXFIELD_OVP)*(MXCHAR_FIELDNAME)  ! sparse list of overlap fields
     &  ,SNLC_FIELDLIST*(MXCHAR_FIELDNAME) ! e.g., '82S', '82N+82S'

      COMMON / SNLC8COM /
     &   SNLC8_RA, SNLC8_DEC
     &  ,SNLC8_MJD, SNLC8_MJDMIN, SNLC8_MJDMAX
     &  ,SNLC8_MJD_TRIGGER,SNLC8_MJD_DETECT_FIRST,SNLC8_MJD_DETECT_LAST
     &  ,SNLC8_FLUXCAL, SNLC8_FLUXCAL_ERRTOT

      COMMON / SNLCCOM /
     &     SNLC_CID, SNLC_CCID,  SNLC_CASTCID
     &    ,SNLC_NAME_IAUC, SNLC_NAME_TRANSIENT
     &    ,INDEX_CID_MATCH
     &    ,SNLC_FIELD, SNLC_FIELD_OVPLIST, SNLC_FIELDLIST
     &    ,SNLC_SNANAFIT_PEAKMJD
     &    ,SNLC_SNANAFIT_PEAKMJD_FITPAR
     &    ,SNLC_SNANAFIT_PEAKMJD_FITERR
     &    ,SNLC_SEARCH_PEAKMJD
     &    ,SNLC_ZHELIO, SNLC_ZHELIO_ERR
     &    ,SNLC_ZCMB,   SNLC_ZCMB_ERR, SNLC_ZHD, SNLC_ZHD_ERR
     &    ,SNLC_ZSN, SNLC_ZSN_ERR
     &    ,SNLC_REDSHIFT, SNLC_REDSHIFT_ERR
     &    ,SNLC_VPEC, SNLC_VPEC_ERR, SNLC_ZPEC, SNLC_ZPEC_ERR
     &    ,SNLC_LENSDMU, SNLC_LENSDMU_ERR
     &    ,SNLC_TRESTMIN, SNLC_TRESTMAX, SNLC_TrestRange, SNLC_TREST
     &    ,SNLC_TGAPMAX,  SNLC_T0GAPMAX
     &    ,SNLC_Tobsmin, SNLC_Tobsmax, SNLC_TOBS
     &    ,SNLC_SNRMAX_FILT, SNLC_SNRMAX_SORT, SNLC_SNRSUM
     &    ,SNLC_FLUXCALMAX, SNLC_FLUXCALMAX_ERR
     &    ,SNLC_PHOTPROB, SNLC_PHOTPROB_MIN
     &    ,SNLC_GAIN, SNLC_RDNOISE
     &    ,SNLC_MWXT_MAG, SNLC_MWXT_FLUXFRAC, SNLC_MWXT_MAGERR
     &    ,SNLC_MWEBV, SNLC_MWEBV_ERR
     &    ,SNLC_XPIX, SNLC_YPIX, SNLC_PIXSIZE, SNLC_NXPIX, SNLC_NYPIX
     &    ,SNLC_AREAFRAC_AVG, SNLC_AREAFRAC
     &    ,SNLC_dRA, SNLC_dDEC, SNLC_AIRMASS
     &    ,SNLC_SKYSIG,  SNLC_SKYSIG_T
     &    ,SNLC_PSF_SIG1, SNLC_PSF_SIG2, SNLC_PSF_RATIO
     &    ,SNLC_PSF_NEA, SNLC_PSF_FWHM_ARCSEC
c
     &    ,SNLC_SNR, SNLC_FLUXCAL_OFF
     &    ,SNLC_FLUXCAL_ERRCALC, SNLC_FLUXCAL_ERRTEST
     &    ,SNLC_FLUXCAL_HOSTERRCALC
     &    ,SNLC_FLUXCAL, SNLC_FLUXCAL_ERRTOT
     &    ,SNLC_FLUXCAL_FIT,SNLC_FLUXCAL_ERR_FIT,SNLC_FLUXCAL_ERRTOT_FIT
     &    ,SNLC_MAG, SNLC_MAG_ERRPLUS, SNLC_MAG_ERRMINUS
     &    ,SNLC_ZEROPT, SNLC_ZEROPT_ERR, SNLC_ZEROPT_forCUT
     &    ,SNLC_TEXPOSE
     &    ,SNLC_SKYFLUXCAL, SNLC_DLMAG
     &    ,SNLC_DTOBS, SNLC_DTOBS_SAMEFILT

      COMMON / ISNCOM /      
     &     ISNLC_VERSION, ISNLC_SNRECON_USE, ISNLC_PHOTFLAG
     &    ,ISNLC_TYPE, ISNLC_zFLAG, ISNLC_zSOURCE, ISNLC_IFILE
     &    ,ISNLC_LENCCID, ISNLC_LENIAUC, ISNLC_LENNAME
     &    ,ISNLC_NFILT_NEWMJD, ISNLC_IFILT_OBS
     &    ,ISNLC_NEWMJD_HEAD, ISNLC_NEWMJD_FOUND, ISNLC_NEWMJD_STORE
     &    ,ISNLC_NEWMJD_CUTS, ISNLC_EPOCH_RANGE_NEWMJD
     &    ,ISNLC_NEPOCH_FOUND, ISNLC_NEPOCH_STORE
     &    ,ISNLC_NEPOCH_USE, ISNLC_NEPOCH_PHOTPROB
     &    ,ISNLC_NEPOCH_FILT,  ISNLC_NOBS_PREDETECT
     &    ,ISNLC_NOBS_DETECT, SNLC_TLIVE_DETECT
     &    ,ISNLC_FAKE, ISNLC_CCDNUM, ISNLC_IMGNUM
     &    ,ISNLC_NFILT_SNRMAX, ISNLC_NFILT_SNRMAX2
     &    ,ISNLC_NFILT_TRESTMIN, ISNLC_NFILT_TRESTMAX
     &    ,ISNLC_NFILT_TREST2
     &    ,ISNLC_IDFIELD, ISNLC_NFIELD_OVP
     &    ,ISNLC_CUTFLAG_REQEP
     &    ,ISNLC_CUTFLAG_PRIVATE
     &    ,ISNLC_CUTFLAG_SIMVAR
     &    ,ISNLC_WRMASK_FLUXCOR_SNANA, ISNLC_RDMASK_FLUXCOR_SNANA

c - - - - -  ADDCOL stuff - - - - - - -
c ADDCOL arrays are loaded with original filter indices,
c or with REMAPed filter indices. Allows using unique
c pointer for calls to SNTABLE_ADDCOL.

      CHARACTER 
     &    ADDCOL_FILTERS*(MXFILT_ALL) ! SURVEY_FILTERS

      REAL      
     &    ADDCOL_SNHOST_MAGOBS(MXFILT_ALL,MXSNHOST)
     &   ,ADDCOL_SNHOST_SBFLUXCAL(MXFILT_ALL)
     &   ,ADDCOL_SNHOST_SBMAG(MXFILT_ALL)
     &   ,ADDCOL_FLUXCALMAX(MXFILT_ALL)
     &   ,ADDCOL_FLUXCALMAX_ERR(MXFILT_ALL)
     &   ,ADDCOL_CHI2_FITPKMJD(MXFILT_ALL)
     &   ,ADDCOL_SNRMAX(MXFILT_ALL)
     &   ,ADDCOL_XTMW(MXFILT_ALL)
     &   ,ADDCOL_PROB_TRUEFLUX(MXFILT_ALL)

      INTEGER
     &    ADDCOL_NDOF_FITPKMJD(MXFILT_ALL)
     &   ,ADDCOL_NDOF_TRUEFLUX(MXFILT_ALL)
 
      COMMON / ADDCOL_FILTERCOM /
     &   ADDCOL_FILTERS, ADDCOL_SNHOST_MAGOBS
     &  ,ADDCOL_SNHOST_SBFLUXCAL, ADDCOL_SNHOST_SBMAG
     &  ,ADDCOL_FLUXCALMAX, ADDCOL_FLUXCALMAX_ERR
     &  ,ADDCOL_CHI2_FITPKMJD, ADDCOL_NDOF_FITPKMJD
     &  ,ADDCOL_SNRMAX, ADDCOL_XTMW
     &  ,ADDCOL_PROB_TRUEFLUX, ADDCOL_NDOF_TRUEFLUX


c - - - -- MULTI-SEASON STUFF - - - -
      COMMON / MULTISEASONCOM / NSEASON_TOT, NSEASON_ACTIVE
     &  ,MULTISEASON_CHI2RED, MULTISEASON_AVGFLUX
     &  ,MULTISEASON_MJDMIN,  MULTISEASON_MJDMAX

+KEEP,SPECCOM.
c  Apr 2019
c  Read spectra to pass into tables for plotting.
c  Not intended for analysis.
     
      INTEGER MXVAR_SPECTRUM, MXSPECTRUM, MXLAM_SPECTRUM     

      PARAMETER (
     &   MXVAR_SPECTRUM = 10     ! max number of variables after SPEC: key
     &  ,MXSPECTRUM     = 200   ! max number of spectra to read per event
     &  ,MXLAM_SPECTRUM = 20000  ! max number of wave bins per spectrum
     &        )

      LOGICAL RDFLAG_SPECTRUM
      CHARACTER VARNAMES_SPECTRUM(MXVAR_SPECTRUM)*40

      INTEGER 
     &    NVAR_SPECTRUM           ! number of spectrum variables to read
     &   ,NSPECTRUM                    ! Number of spectra
     &   ,ID_SPECTRUM(MXSPECTRUM)      ! ID for each spectrum
     &   ,NLAMBIN_SPECTRUM(MXSPECTRUM) ! Number of wave bins per spectrum
     &   ,NLAMBIN_READ                 ! keep track of wave index

      REAL*8 
     &    MJD_SPECTRUM(MXSPECTRUM) 
     &   ,TOBS_SPECTRUM(MXSPECTRUM)
     &   ,TEXPOSE_SPECTRUM(MXSPECTRUM)
c
     &   ,LAMMIN_SPECTRUM(MXLAM_SPECTRUM)
     &   ,LAMMAX_SPECTRUM(MXLAM_SPECTRUM)
     &   ,FLAM_SPECTRUM(MXLAM_SPECTRUM)
     &   ,FLAMERR_SPECTRUM(MXLAM_SPECTRUM)
     &   ,SIM_FLAM_SPECTRUM(MXLAM_SPECTRUM)

      COMMON/SPECCOM4/ RDFLAG_SPECTRUM
     &   ,NVAR_SPECTRUM, NSPECTRUM, ID_SPECTRUM, NLAMBIN_SPECTRUM
     &   ,VARNAMES_SPECTRUM, NLAMBIN_READ

      COMMON/SPECCOM8/ 
     &    MJD_SPECTRUM, TOBS_SPECTRUM, TEXPOSE_SPECTRUM
     &   ,LAMMIN_SPECTRUM, LAMMAX_SPECTRUM
     &   ,FLAM_SPECTRUM, FLAMERR_SPECTRUM, SIM_FLAM_SPECTRUM

+KEEP,SNSIMCOM.

c simulation parameters (if FAKE=2)

      REAL*8  SIM8_RA, SIM8_DECL

      REAL
     &   SIM_REDSHIFT_HELIO
     &  ,SIM_REDSHIFT_CMB
     &  ,SIM_REDSHIFT_HOST
     &  ,SIM_VPEC
     &  ,SIM_DLMAG
     &  ,SIM_LENSDMU
     &  ,SIM_MUSHIFT 
     &  ,SIM_MWEBV
     &  ,SIM_MWRV
c
     &  ,SIM_WGT_POPULATION     ! Dec 2023: for biasCor sims only
     &  ,SIM_SALT2x0
     &  ,SIM_SALT2mb
     &  ,SIM_COLORPAR, SIM_COLORLAW, SIM_AV, SIM_RV
     &  ,SIM_SHAPEPAR, SIM_SHAPELAW
     &  ,SIM_PEAKMJD, SIM_MJD_EXPLODE
     &  ,SIM_EXPOSURE_TIME(MXFILT_OBS)  ! relative exposure time
     &  ,SIM_PEAKMAG(MXFILT_OBS)
     &  ,SIM_EPMAGOBS(MXEPOCH)      ! true epoch mag at each filter/epoch
     &  ,SIM_EPFLUXCAL(MXEPOCH)     ! true fluxcal at each filter/epoch
     &  ,SIM_EPSNRMON(MXEPOCH)      ! optional SNR at MAGMONITOR
     &  ,SIM_EPMAGREST(MXEPOCH)     ! true rest-frame mag
     &  ,SIM_EPFLUXCAL_HOSTERR(MXEPOCH) ! true error from host noise
     &  ,SIM_EPCHI2FLUX(MXEPOCH)    ! data-sim chi2 per epoch
     &  ,SIM_EPPULL(MXEPOCH)        ! pull per epoch (F-Ftrue)/sig)
     &  ,SIM_EPdRA(MXEPOCH)
     &  ,SIM_EPdDEC(MXEPOCH)
     &  ,SIM_EPdMAG(MXEPOCH)
c
     &  ,SIMSED_PARVAL(MXPAR_SIMSED)
     &  ,PySEDMODEL_PARVAL(MXPAR_SIMSED)    ! Dec 10 2018
     &  ,LCLIB_PARVAL(MXPAR_LCLIB)
     &  ,SIM_HOSTLIB_PARVAL(MXPAR_SIMSED) ! HOSTLIB params
     &  ,SIM_MAGSMEAR_COH
     &  ,SIM_SALT2gammaDM             ! usually this is gamma or gamma/2
     &  ,SIM_TEMPLATEMAG(MXFILT_ALL)  ! image-sub template, not LCLIB template
     &  ,SIM_LCWIDTH(MXFILT_ALL)      ! computed from SIM_EPFLUXCAL
c 
     &  ,SIM_MODELGRID_TOBS(MXEP_MODELGRID)    ! for SNANA+SIM_MAGOBS table
     &  ,SIM_MODELGRID_MAGOBS(MXEP_MODELGRID,MXFILT_OBS/2) ! idem

c xxx mark del May 19 2025  REAL SIM_OM, SIM_OL, SIM_w0, SIM_wa, SIM_MUSHIFT ! read from README

      INTEGER
     &   SIM_MODEL_INDEX      ! model index (MLCS,SALT2,NON1a ...)
     &  ,SIM_GENTYPE          ! generated SNTYPE; SIM_TYPE_INDEX
     &  ,SIM_TEMPLATE_INDEX   ! template index for NON1ASED, SIMSED, LCLIB ...
     &  ,SIM_SEARCHEFF_MASK   ! bits 1,2 => found by software,humans
     &  ,SIM_LIBID            ! LIBID for each event
     &  ,SIM_NGEN_LIBID       ! NGEN for this LIBID (usually 1)
     &  ,SIM_NOBS_UNDEFINED   ! NOBS where model is undefined
     &  ,SIM_NSUBSAMPLE_MARK  ! Number of marked sub-samples
     &  ,SIM_SUBSAMPLE_INDEX  ! sub-sample index
     &  ,SIM_REDSHIFT_FLAG    ! points to source of redshift     
     &  ,SIMOPT_MWCOLORLAW    ! option for MW color law
     &  ,SIMOPT_MWEBV         ! option to modify MWEBV_SFD map
     &  ,NPAR_SIMSED
     &  ,NPAR_PySEDMODEL      ! BYOSED, SNEMO ...
     &  ,NPAR_LCLIB
     &  ,NPAR_SIM_HOSTLIB
     &  ,SIM_EPFILTREST(MXEPOCH)
     &  ,SIMLIB_MSKOPT        ! SIMLIB option mask (Dec 2015)
     &  ,SIM_BIASCOR_MASK     ! non-zero -> it's a biasCor sim
     &  ,NEP_SIM_MODELGRID
     &  ,NEP_SIM_MAGOBS          ! number of sim epochs with MAGOBS < 99

      
      INTEGER*8  SIM_HOSTLIB_GALID
      REAL*8    DSIM_HOSTLIB_GALID  ! for table only

      CHARACTER 
     &   SIMNAME_MODEL*(MXCHAR_MODELNAME)     ! SALT2, mlcs2k2, NON1A, etc ...
     &  ,SIMNAME_TYPE*12      ! Ia, Ib, II, IIN, etc ...
     &  ,SIMNAME_SHAPEPAR*40  ! DELTA, x1, stretch ...
     &  ,SIMNAME_SHAPELAW*40  ! alpha ...
     &  ,SIMNAME_COLORPAR*40  ! AV, c ...
     &  ,SIMNAME_COLORLAW*40  ! RV,  beta ...
     &  ,SIMLIB_FILENAME*200  ! SIMLIB file used to generate sim
     &  ,SIMSED_KEYWORD(MXPAR_SIMSED)*80 ! full keyname in header
     &  ,SIMSED_PARNAME(MXPAR_SIMSED)*20 ! parname for fitres and ntuple
     &  ,PySEDMODEL_NAME*20              ! e.g., 'BYOSED' , 'SNEMO'
     &  ,PySEDMODEL_KEYWORD(MXPAR_SIMSED)*80 ! full keyname in header
     &  ,PySEDMODEL_PARNAME(MXPAR_SIMSED)*20 ! parname for fitres and ntuple
     &  ,LCLIB_KEYWORD(MXPAR_LCLIB)*80 ! full keyname in header
     &  ,LCLIB_PARNAME(MXPAR_LCLIB)*20 ! parname for fitres and ntuple
     &  ,SIM_HOSTLIB_KEYWORD(MXPAR_SIMSED)*60 ! full keyname
     &  ,SIM_HOSTLIB_PARNAME(MXPAR_SIMSED)*60 ! parname 
     &  ,SIMNAME_SNRMON*40

      LOGICAL
     &  LSIM_TRUE_SNIa   ! true SNIa (SALT3 or BAYES or MLCS ...)
     & ,LSIM_TRUE_NONIa  ! true NONIa (SNCC, AGN, TDE ...)
      
      COMMON / SNSIMCOM / SIMNAME_MODEL, SIM_MODEL_INDEX
     &  ,SIM_REDSHIFT_HELIO, SIM_REDSHIFT_CMB, SIM_REDSHIFT_HOST
     &  ,SIM_REDSHIFT_FLAG
     &  ,SIM_VPEC, SIM_DLMAG, SIM_LENSDMU, SIM_MUSHIFT
     &  ,SIM_WGT_POPULATION, SIM_SALT2x0, SIM_SALT2mb
     &  ,SIM_COLORPAR, SIM_COLORLAW, SIM_AV, SIM_RV
     &  ,SIM_SHAPEPAR, SIM_SHAPELAW, SIM_PEAKMJD, SIM_MJD_EXPLODE
     &  ,SIM_MWEBV,SIM_MWRV
     &  ,SIM_EXPOSURE_TIME, SIM_TEMPLATE_INDEX, SIM_TEMPLATEMAG
     &  ,SIM_GENTYPE, SIMNAME_TYPE, SIM_LCWIDTH
     &  ,SIM_SEARCHEFF_MASK, SIM_LIBID, SIM_NGEN_LIBID
     &  ,SIM_NOBS_UNDEFINED, SIM_NSUBSAMPLE_MARK, SIM_SUBSAMPLE_INDEX
     &  ,SIM_PEAKMAG, SIM_EPMAGOBS, SIM_EPFLUXCAL, NEP_SIM_MAGOBS
     &  ,SIM_EPSNRMON, SIM_EPCHI2FLUX, SIM_EPPULL, SIM_EPFLUXCAL_HOSTERR
     &  ,SIM_EPdRA, SIM_EPdDEC, SIM_EPdMAG
     &  ,SIMNAME_SHAPEPAR,  SIMNAME_SHAPELAW
     &  ,SIMNAME_COLORPAR,  SIMNAME_COLORLAW, SIMNAME_SNRMON
     &  ,SIMLIB_FILENAME, SIMLIB_MSKOPT, SIM_BIASCOR_MASK
     &  ,SIMOPT_MWCOLORLAW, SIMOPT_MWEBV
     &  ,SIM_EPFILTREST, SIM_EPMAGREST,  SIM_MAGSMEAR_COH
     &  ,SIM_SALT2gammaDM
     &  ,NEP_SIM_MODELGRID, SIM_MODELGRID_TOBS, SIM_MODELGRID_MAGOBS
c xxx mark delete      &  ,SIM_OM, SIM_OL, SIM_w0, SIM_wa, SIM_MUSHIFT
     &  ,LSIM_TRUE_SNIa, LSIM_TRUE_NONIa

      COMMON / SIMSEDCOM /
     &  NPAR_SIMSED, SIMSED_PARVAL, SIMSED_PARNAME, SIMSED_KEYWORD

      COMMON / PySEDCOM /
     &   PySEDMODEL_NAME, NPAR_PySEDMODEL, PySEDMODEL_PARVAL, 
     &   PySEDMODEL_PARNAME, PySEDMODEL_KEYWORD

      COMMON / LCLIBCOM / 
     &   NPAR_LCLIB, LCLIB_PARVAL, LCLIB_KEYWORD, LCLIB_PARNAME

      COMMON / SIMHOSTCOM / 
     &    NPAR_SIM_HOSTLIB, SIM_HOSTLIB_PARVAL
     &   ,SIM_HOSTLIB_PARNAME, SIM_HOSTLIB_KEYWORD

      COMMON / SNSIMCOM8 / 
     &   SIM8_RA, SIM8_DECL, SIM_HOSTLIB_GALID, DSIM_HOSTLIB_GALID

+KEEP,PRIVCOM.

c Nov 2012: PRIVATE_VAR variables in data files
c Aug 2014: MXVAR_PRIVATE -> 28 (was 20)

      REAL*8  PRIVATE_NULL
      PARAMETER ( PRIVATE_NULL = -999.0909 )

      INTEGER   
     &   NVAR_PRIVATE        ! Number of private  variables
     &  ,NCUT_PRIVATE       

c for  the following header key
c    PRIVATE(BLA): 44.4
c we have
c   VARANME = 'BLA'
c   KEYWORD = 'PRIVATE(BLA)'
c   VALUE   = 44.4

      CHARACTER 
     &   PRIVATE_VARNAME(MXVAR_PRIVATE)*(MXCHAR_FILEWORD)
     &  ,PRIVATE_KEYWORD(MXVAR_PRIVATE)*(MXCHAR_FILEWORD)

      REAL*8   
     &    PRIVATE_VALUE(MXVAR_PRIVATE)    ! value for each var
     &   ,PRIVATE_CUTWIN(2,MXVAR_PRIVATE) ! cut-window on each var

      INTEGER USE_PRIVATE_CUTWIN(MXVAR_PRIVATE)  ! 1=cutwin, -1=veto

      COMMON / PRIVATE_VARCOM  / 
     &     NVAR_PRIVATE, PRIVATE_VARNAME, PRIVATE_KEYWORD
     &    ,NCUT_PRIVATE, USE_PRIVATE_CUTWIN

      COMMON / PRIVATECOM8 / PRIVATE_VALUE, PRIVATE_CUTWIN
    

+KEEP,SNHOSTCOM.

c Host galaxy parameters.

c logical flags for output tables
      LOGICAL 
     &   EXIST_SNHOST_ANGSEP
     &  ,EXIST_SNHOST_DDLR
     &  ,EXIST_SNHOST_CONFUSION
     &  ,EXIST_SNHOST_ZPHOT
     &  ,EXIST_SNHOST_LOGMASS
     &  ,EXIST_SNHOST_LOGSFR
     &  ,EXIST_SNHOST_LOGsSFR
     &  ,EXIST_SNHOST_COLOR
     &  ,EXIST_SNHOST_MAGOBS
     &  ,EXIST_SNHOST_SB

      INTEGER*8  SNHOST_OBJID(MXSNHOST)    ! int id
      REAL*8    DSNHOST_OBJID(MXSNHOST)   ! for tables only
      CHARACTER VARNAME_ZPHOT_Q(MXSNHOST,MXZPHOT_Q)*40

      REAL
     &   SNHOST_ANGSEP(MXSNHOST)      ! SN-host sep, arcsec
     &  ,SNHOST_DDLR(MXSNHOST)        ! SNSEP/DLR
     &  ,SNHOST_CONFUSION             ! HC analog from Gupta 2016
     &  ,SNHOST_ZPHOT(MXSNHOST), SNHOST_ZPHOT_ERR(MXSNHOST)
     &  ,SNHOST_ZPHOT_Q(MXSNHOST,MXZPHOT_Q)
     &  ,SNHOST_ZPHOT_PERCENTILE(MXZPHOT_Q)
     &  ,SNHOST_QZPHOT_MEAN(MXSNHOST), SNHOST_QZPHOT_STD(MXSNHOST) 
     &  ,SNHOST_ZSPEC(MXSNHOST), SNHOST_ZSPEC_ERR(MXSNHOST)
     &  ,SNHOST_LOGMASS(MXSNHOST)
     &  ,SNHOST_LOGMASS_ERR(MXSNHOST)
     &  ,SNHOST_LOGSFR(MXSNHOST)
     &  ,SNHOST_LOGSFR_ERR(MXSNHOST)
     &  ,SNHOST_LOGsSFR(MXSNHOST)
     &  ,SNHOST_LOGsSFR_ERR(MXSNHOST)
     &  ,SNHOST_COLOR(MXSNHOST)
     &  ,SNHOST_COLOR_ERR(MXSNHOST)
     &  ,SNHOST_SBFLUXCAL(MXFILT_ALL)  ! surface brightness FLUXCAL /asec^2
     &  ,SNHOST_MAGOBS(MXFILT_ALL,(MXSNHOST))       ! observer-frame mags
     &  ,SNHOST_MAGOBS_ERR(MXFILT_ALL,(MXSNHOST))   ! error on above

      REAL*8 
     &    SNHOST8_RA(MXSNHOST)
     &   ,SNHOST8_DEC(MXSNHOST)

c quantites which do not depend on which host
      INTEGER*4 
     &    SNHOST_NMATCH   ! number of host matches, e.g., d_DLR<4
     &   ,SNHOST_NMATCH2  ! number of host matches, e.g., d_DLR<7
     &   ,SNHOST_NZPHOT_Q        ! Ma 2022: number of zphot quantiles
     &   ,SNHOST_FLAG(MXSNHOST)  ! May 21 2021: indicate problems with host

      REAL
     &   SNHOST_SBFLUXCAL_ERR(MXFILT_ALL)
     &  ,SNHOST_SBMAG(MXFILT_ALL)        ! surface brightness mag/asec^2

      COMMON / SNHOSTCOM / 
     &   EXIST_SNHOST_ANGSEP, EXIST_SNHOST_DDLR, EXIST_SNHOST_CONFUSION
     &  ,EXIST_SNHOST_ZPHOT,  EXIST_SNHOST_LOGMASS, EXIST_SNHOST_LOGSFR
     &  ,EXIST_SNHOST_LOGsSFR, EXIST_SNHOST_COLOR
     &  ,EXIST_SNHOST_MAGOBS, EXIST_SNHOST_SB
c
     &  ,SNHOST_NMATCH, SNHOST_NMATCH2, SNHOST_FLAG
     &  ,SNHOST_ANGSEP, SNHOST_DDLR, SNHOST_CONFUSION
     &  ,SNHOST_ZPHOT,   SNHOST_ZPHOT_ERR
     &  ,SNHOST_ZPHOT_Q, SNHOST_ZPHOT_PERCENTILE, SNHOST_NZPHOT_Q
     &  ,SNHOST_QZPHOT_MEAN, SNHOST_QZPHOT_STD
     &  ,VARNAME_ZPHOT_Q
     &  ,SNHOST_ZSPEC,   SNHOST_ZSPEC_ERR 
     &  ,SNHOST_LOGMASS, SNHOST_LOGMASS_ERR
     &  ,SNHOST_LOGSFR, SNHOST_LOGSFR_ERR
     &  ,SNHOST_LOGsSFR,    SNHOST_LOGsSFR_ERR
     &  ,SNHOST_COLOR,    SNHOST_COLOR_ERR
     &  ,SNHOST_SBFLUXCAL, SNHOST_SBFLUXCAL_ERR, SNHOST_SBMAG
     &  ,SNHOST_MAGOBS, SNHOST_MAGOBS_ERR

      COMMON / SNHOSTCOM8 / 
     &   SNHOST_OBJID, DSNHOST_OBJID, SNHOST8_RA, SNHOST8_DEC

+KEEP,SIMLIBCOM.

c Feb 2017: common block for writing SIMLIB file to SIMLIB_OUT

      INTEGER MXLIST_SKY
      PARAMETER ( MXLIST_SKY = 20)
      INTEGER  NLIST_SKY 
      REAL*8   SKYLAM_LIST(MXLIST_SKY), SKYMAG_LIST(MXLIST_SKY)
      REAL*8   PSF_FWHM_GUESS, PIXSIZE_GUESS, ADD_SKYSIG_PIX
   
      LOGICAL ISGROUND, FOUND_TEMPLATE_INFO ! T=> ground based survey
      REAL  
     &    SIMLIB_ZPERR(MXFILT_ALL)
     &   ,SIMLIB_TEMPLATE_SKYSIG(MXFILT_ALL)
     &   ,SIMLIB_TEMPLATE_ZPT(MXFILT_ALL)


      COMMON/SIMLIBCOM4/ NLIST_SKY, ISGROUND, FOUND_TEMPLATE_INFO
     &   ,SIMLIB_ZPERR
     &   ,SIMLIB_TEMPLATE_SKYSIG, SIMLIB_TEMPLATE_ZPT

      COMMON/SIMLIBCOM8/ 
     &   SKYLAM_LIST, SKYMAG_LIST
     &  ,PSF_FWHM_GUESS, PIXSIZE_GUESS, ADD_SKYSIG_PIX


c --- hard-wire ground based array of SKYMAG vs. lambda
c Apr 6 2020: 
c  Add J,H,K from Table 3 of arxiv:0809.4988, and increase NLIST->10.
c  This CALAR ALTO paper doesn't have a table of mean filter wavelengths,
c  so we take <SKYLAM> from CSP JHK bands.

      INTEGER  NLIST_SKY_GROUND
      PARAMETER ( NLIST_SKY_GROUND = 10 )
      REAL*8 SKYLAM_GROUND_LIST(NLIST_SKY_GROUND)
      REAL*8 SKYMAG_GROUND_LIST(NLIST_SKY_GROUND)
      
c ugrizY mag/asec^2 are from LSST DEEP-drill cadence; 
c v is made up to extend bluer.
      DATA SKYLAM_GROUND_LIST / 
     &     2700.0, 3714.0, 4790.0, 6220.0,  ! v,u,g,r
     &     7544.0, 8679.0, 10095,           ! i,z,Y
     &     12500.0, 18900.0, 21500.  /      ! J,H,K (Apr 2020)
      DATA SKYMAG_GROUND_LIST / 
     &     23.8, 22.7,  21.0,  20.4,    ! v,u,g,r 
     &     19.4, 18.1,  17.9,           ! i,z,Y
     &     16.0, 14.0,  12.4  /         ! J,H,K (Apr 2020)

c --- hard-write space based array pf SKYMAG vs. lambda

      INTEGER  NLIST_SKY_SPACE
      PARAMETER ( NLIST_SKY_SPACE = 13 )
      REAL*8 SKYLAM_SPACE_LIST(NLIST_SKY_SPACE)
      REAL*8 SKYMAG_SPACE_LIST(NLIST_SKY_SPACE)
      
c from WFIRST sims
      DATA SKYLAM_SPACE_LIST / 
     &        1000.0,  4330.0,  6258.0,  8052.0,          ! x,B,R,I
     &        8745.0, 10653.0, 12976.0, 15848.0, 20000.,  ! Z,Y,J,H,FUDGE
     &        27700.0, 35600.0, 44400.0, 50000.0        / ! NIRCAM LW
      DATA SKYMAG_SPACE_LIST / 
     &        24.0,    23.8,     23.6,   23.5,
     &        23.5,    23.7,     23.8,   23.9, 24.2,     
     &        23.1,    23.3,     22.3,   22.0	        /

+KEEP,TRUECHI2COM.

c for fakes and sim, compute sum[F-Ftrue]^2/sigma^2 per band
c The zeroth element is all bands together.

      REAL    
     &   CHI2_TRUEFLUX(0:MXFILT_ALL)
     &  ,PROB_TRUEFLUX(0:MXFILT_ALL)

      INTEGER NDOF_TRUEFLUX(0:MXFILT_ALL)

      COMMON /  TRUECHI2COM / 
     &   NDOF_TRUEFLUX, CHI2_TRUEFLUX, PROB_TRUEFLUX

+KEEP,SNCUTS.

c Define cut-window for each variables
c and cut-mask for each epoch.
c User must fill cutwin_XXX arrays in main routine.

      INTEGER 
     &   CUTBIT_CID, CUTBIT_SNTYPE
     &  ,CUTBIT_REDSHIFT, CUTBIT_REDSHIFT_ERR
     &  ,CUTBIT_RA,  CUTBIT_DEC
     &  ,CUTBIT_HOSTSEP
     &  ,CUTBIT_Trestmin, CUTBIT_Trestmax, CUTBIT_TrestRange
     &  ,CUTBIT_TREST2
     &  ,CUTBIT_Tgapmax,  CUTBIT_T0gapmax
     &  ,CUTBIT_Tobsmin,  CUTBIT_Tobsmax
     &  ,CUTBIT_SEARCH           ! sim only
     &  ,CUTBIT_PEAKMJD
     &  ,CUTBIT_NOBS_PREDETECT     ! Mar 2025
     &  ,CUTBIT_NEPOCH
     &  ,CUTBIT_SNRMAX         ! global SNRMAX cut; any filter(s)
     &  ,CUTBIT_SNRMAX2        ! 2nd global SNRMAX cut; any filter(s)
     &  ,CUTBIT_SNRSUM         ! cut on sqrt[ sum SNR_i^2 ]
     &  ,CUTBIT_NFIELD         ! cut on number of fields used by SN
     &  ,CUTBIT_MWEBV          ! cut on Galactic extinct (May 8 2012)
     &  ,CUTBIT_NSEASON_ACTIVE ! Nseason with activity
     &  ,CUTBIT_REQEP          ! required epochs (to select short events)
     &  ,CUTBIT_PRIVATE        ! all private-var cuts together (Nov 3 2014)
     &  ,CUTBIT_SIMVAR         ! SIMVAR cuts
     &  ,CUTBIT_OFFSET_SBFLUX  ! host surface brightness
     &  ,CUTBIT_OFFSET_SNRMAX  ! SNRMAX cuts in each filter     
     &  ,CUTBIT_MJD_MARKER     ! things above do NOT depend on epoch
     &  ,CUTBIT_PSF,  CUTBIT_ZP, CUTBIT_ZPERR
     &  ,CUTBIT_PHOTPROB
     &  ,CUTBIT_TREST, CUTBIT_TOBS, CUTBIT_MJD
     &  ,CUTBIT_ERRTEST          ! epoch cut on ERRCALC/ERRTRUE
     &  ,CUTBIT_SIMPULL          ! cut on (F-F_true)/sigma_F
     &  ,CUTBIT_TREST_TRUEFLUX2  ! for sim or fakes, require valid flux
     &  ,CUTBIT_NFILT_SNRMAX
     &  ,CUTBIT_NFILT_SNRMAX2
     &  ,CUTBIT_NFILT_TRESTMIN
     &  ,CUTBIT_NFILT_TRESTMAX
     &  ,CUTBIT_NFILT_TREST2
     &  ,CUTBIT_OFFSET
     &  ,NCUTBIT
     &  ,NCUTBIT_SNLC

      PARAMETER (
     &   CUTBIT_CID            = 1
     &  ,CUTBIT_SNTYPE         = 2
     &  ,CUTBIT_REDSHIFT       = 3
     &  ,CUTBIT_REDSHIFT_ERR   = 4
     &  ,CUTBIT_RA             = 5
     &  ,CUTBIT_DEC            = 6
     &  ,CUTBIT_HOSTSEP        = 7
     &  ,CUTBIT_TrestMIN       = 8
     &  ,CUTBIT_TrestMAX       = 9
     &  ,CUTBIT_TrestRange     = 10  ! Dec 2017 (TrestMax-TrestMin)
     &  ,CUTBIT_Trest2         = 11 
     &  ,CUTBIT_Tgapmax        = 12
     &  ,CUTBIT_T0gapMAX       = 13
     &  ,CUTBIT_TobsMIN        = 14 
     &  ,CUTBIT_TobsMAX        = 15
     &  ,CUTBIT_PEAKMJD        = 16
c
     &  ,CUTBIT_NOBS_PREDETECT = 17  ! Mar 2025
     &  ,CUTBIT_NSEASON_ACTIVE = 18  ! May 2019
c
     &  ,CUTBIT_NEPOCH         = 19  ! total # of measurements
     &  ,CUTBIT_SEARCH         = 20  ! found by search (SIM only)
     &  ,CUTBIT_NFILT_SNRMAX   = 21
     &  ,CUTBIT_NFILT_SNRMAX2  = 22
     &  ,CUTBIT_NFILT_TRESTMIN = 23
     &  ,CUTBIT_NFILT_TRESTMAX = 24
     &  ,CUTBIT_NFILT_TREST2   = 25
     &  ,CUTBIT_SNRMAX         = 26
     &  ,CUTBIT_SNRMAX2        = 27
     &  ,CUTBIT_SNRSUM         = 28  ! Jul 2024
     &  ,CUTBIT_NFIELD         = 29
     &  ,CUTBIT_MWEBV          = 30 
     &  ,CUTBIT_REQEP          = 31  ! required epochs (9/17/2017)
     &  ,CUTBIT_PRIVATE        = 32  ! all private-var cuts
     &  ,CUTBIT_SIMVAR         = 33  ! 
     &  ,CUTBIT_OFFSET_SBFLUX  = 34 
     &  ,CUTBIT_OFFSET_SNRMAX  = 34 + MXFILT_SNRMAX
     &  ,CUTBIT_MJD_MARKER     = CUTBIT_OFFSET_SNRMAX + MXFILT_SNRMAX
     &  ,NCUTBIT_SNLC          = CUTBIT_MJD_MARKER
c SN-dependent cuts above
c MJD-dependent cuts below
     &  ,CUTBIT_PSF          = CUTBIT_MJD_MARKER + 1  ! PSF cut
     &  ,CUTBIT_ZP           = CUTBIT_MJD_MARKER + 2  ! ZP  cut (Feb 2018)
     &  ,CUTBIT_ZPERR        = CUTBIT_MJD_MARKER + 3  ! ZPERR (Feb 2020)
     &  ,CUTBIT_PHOTPROB     = CUTBIT_MJD_MARKER + 4
     &  ,CUTBIT_Trest        = CUTBIT_MJD_MARKER + 5
     &  ,CUTBIT_Tobs         = CUTBIT_MJD_MARKER + 6
     &  ,CUTBIT_MJD          = CUTBIT_MJD_MARKER + 7  
     &  ,CUTBIT_TREST_TRUEFLUX2= CUTBIT_MJD_MARKER + 8
     &  ,CUTBIT_ERRTEST      = CUTBIT_MJD_MARKER + 9
     &  ,CUTBIT_SIMPULL      = CUTBIT_MJD_MARKER + 10 ! Mar 2021
c
     &  ,CUTBIT_OFFSET       = CUTBIT_SIMPULL
     &  ,NCUTBIT             = CUTBIT_OFFSET  
     &      )

c Define cut-masks with 64-BIT integers

      INTEGER*8
     &   CUTMASK8_SN             ! cutmask for each SN
     &  ,CUTMASK8_MJD(MXEPOCH)   ! cutmask vs. MJD, isn
     &  ,CUTMASK8_SN_ALL         ! all bits for SN cuts
     &  ,CUTMASK8_MJD_ALL        ! all bits for MJD cuts

      BYTE MJDMASK(MXEPOCH)  ! logical for each epoch,SN

      LOGICAL
     &   LSNCUTS       ! T=> passes cuts 1 to CUTBIT_MJD_MARKER
     &  ,PASS_PRIVCUTS ! T=> pass cuts on private var in data header
     &  ,PASS_SIMCUTS  ! T=> pass cuts on SIMVAR
    
      INTEGER 
     &   NCCID_LIST      ! size of SNCCID_LIST
     &  ,NCID_LIST       ! size of SNCID_LIST
     &  ,NCCID_IGNORE    ! size of SNCCID_IGNORE
     &  ,NCID_IGNORE     ! size of NCID_IGNORE
     &  ,CUTFLAG_SNANA   ! bits 0,1 -> LSNCUTS,LSNFITOK=T (for ntuple)
     &  ,ERRFLAG_FIT     ! error flag from fit (0=OK)

c stuff cut vars
      CHARACTER CUTVAR_NAME(NCUTBIT)*28

c define namelist cuts

      INTEGER 
     &   SNTYPE_LIST(MXLISTNML)    ! I: user list of types to select
     &  ,SNTYPE_IGNORE(MXLISTNML)  ! I: types to ignore
     &  ,SNCID_LIST(MXLISTNML)     ! I: user-list of integer CIDs
     &  ,MXEVT_PROCESS             ! I: quit after processing this many
     &  ,MXEVT_CUTS                ! I: quit after Nevt passing cuts
     &  ,CCDNUM_LIST(MXLISTNML)    ! I: user-list of CCDNUMs (Dec 2017)
     &  ,SIM_TEMPLATE_INDEX_LIST(MXLISTNML)
     &  ,SNCID_IGNORE(MXLISTNML)   ! I: list of CIDs to ignore
     &  ,PHOTFLAG_MSKREJ(5)        ! I: PHOTFLAG mask-bits to reject, 1,2 => logical OR,AND
     &  ,PHOTFLAG_BITLIST_REJECT(MXBIT_PHOTFLAG)  ! I: bits to reject
     &  ,IDFIELD_LIST(MXLISTNML)   ! 
     &  ,NIDFIELD_LIST
     &  ,NSNTYPE_LIST           ! size of SNTYPE_LIST
     &  ,NCCDNUM_LIST           ! size of CCDNUM list
     &  ,NSIM_TEMPLATE_INDEX_LIST
     &  ,NSNTYPE_IGNORE
     &  ,NFILT_SNRMAX           ! number of CUTWIN_SNRMAX_FILT cuts
     &  ,IFILT_SNRMAX(MXFILT_SNRMAX) ! store filt index for SNRMAX cuts
     &  ,NFILT_HOST_SBFLUX      ! Nfilt to cut on HOST_SBFLUX
     &  ,IFILT_HOST_SBFLUX(MXFILT_SNRMAX)

      LOGICAL DOALL_SNTEL, DOALL_SNFIELD

      character 
     &    SNFIELD_LIST(MXLISTNML)*60  ! I:  list of fields to use (or 'ALL')
     &   ,SNCCID_LIST(MXLISTNML)*(MXCHAR_CCID)   ! I: list of CIDs to process
     &   ,SNCCID_IGNORE(MXLISTNML)*(MXCHAR_CCID) ! I: list of CIDs to ignore
     &   ,SNCID_IGNORE_FILE*(MXCHAR_FILENAME)    ! I: file with CIDs to ignore
     &   ,SNCCID_IGNORE_ALL(MXIGNORE_LIST)*(MXCHAR_CCID)

c# -----------  SN-dependent cut-window  ! I: --------------------------------
      REAL
     &   snlc_cutvar(NCUTBIT_SNLC)
     &  ,snep_cutvar(CUTBIT_MJD_MARKER:NCUTBIT,MXEPOCH)
     &  ,cutwin_var(2,NCUTBIT)   
     &  ,cutwin_cid(2)           ! candidate id
     &  ,cutwin_sntype(2)        ! 
     &  ,cutwin_redshift(2)      ! I: redshift cut
     &  ,cutwin_redshift_err(2)  ! I: cut on redshift uncertainty
     &  ,cutwin_ra(2)            ! I: cut on RA
     &  ,cutwin_dec(2)           ! I: cut on DEC
     &  ,cutwin_hostsep(2)       ! I: cut on host-SN sep, arcsec
     &  ,cutwin_sbflux_filt(2,MXFILT_SNRMAX) 
     &  ,cutwin_Nepoch(2)        ! I: cut on Nepoch 
     &  ,cutwin_snrmax_filt(2,MXFILT_SNRMAX)   ! filled from SNCUT_SNRMAX
     &  ,cutwin_snrmax(2)        ! I: global SNRMAX cut
     &  ,cutwin_snrmax2(2)       ! I: 2nd global SNRMAX cut (different band)
     &  ,cutwin_snrsum(2)        ! I: cut on sqrt[  sum(SNR_i^2) ]
     &  ,cutwin_nfield(2)        ! I: number of fields (usually 1)
     &  ,cutwin_mwebv(2)         ! I: Galactic extinction
     &  ,cutwin_nseason_active(2)      ! I: number of seasons with detection
     &  ,cutwin_cutflag_reqep(2)       ! for internal use only
     &  ,cutwin_cutflag_private(2)     ! for internal use only
     &  ,cutwin_cutflag_simvar(2)      ! for internal use only
     &  ,cutwin_nfilt_snrmax(2)  ! I: Nfilt passing global SNRMAX cut
     &  ,cutwin_nfilt_snrmax2(2) ! I: Nfilt passing 2nd-best SNRMAX
     &  ,cutwin_nfilt_trestmin(2)! I: Nfilt passing Trestmin cut
     &  ,cutwin_nfilt_trestmax(2)! I: Nfilt passing Trestmax cut
     &  ,cutwin_nfilt_trest2(2)  ! I: Nfilt passinng Trest2 cut
     &  ,cutwin_nband_thresh(2)  ! I: number of bands above $band_THRESH
     &  ,cutwin_Trestmin(2)      ! I: cut on earliest epoch, rest frame days
     &  ,cutwin_Trestmax(2)      ! I: cut on  latest epoch, rest frame day
     &  ,cutwin_TrestRange(2)    ! I: cut on Trestmax - Trestmin
     &  ,cutwin_Trest2(2)        ! I: cut on CUTWIN_NFILT_TREST2
     &  ,cutwin_Tgapmax(2)         ! I: max Trest-gap within cutwin_TREST(2)
     &  ,cutwin_T0gapmax(2)        ! I: max Trest-gap near peak 
     &  ,cutwin_Tobsmin(2)         ! I: cut on min Tobs
     &  ,cutwin_Tobsmax(2)         ! I: cut on max Tobs
     &  ,cutwin_peakmjd(2)         ! I: cut on search peakMJD
     &  ,cutwin_tobs_predetect(2)  ! I: pre-detection Tobs window  e.g. -10, 0 w.r.t. MJD_DETECT_FIRST
     &  ,cutwin_nobs_predetect(2)  ! I: Nobs required in pre-detect time window
c  
c  Below are Epoch-dependent cuts
c# -----------  epoch-dependent cut windows  ! I: --------------------------------
     &  ,cutwin_psf(2)           ! I: PSF cut, FWHM, ARCSEC
     &  ,cutwin_zp(2)            ! I: ZEROPT cut, ADU or NPE
     &  ,cutwin_zpADU(2)         ! I: ZEROPT cut, ADU
     &  ,cutwin_zpNPE(2)         ! I: ZEROPT cut, NPE
     &  ,cutwin_ZPERR(2)         ! I: ZPERR cut
     &  ,cutwin_photprob(2)      ! I: cut on PHOTPROP (e.g., real/bogus)
     &  ,cutwin_errtest(2)       ! I: cut on ERRCALC/ERRTRUE
     &  ,cutwin_simpull(2)       ! I: cut on (F-Ftrue)/sigmaF
     &  ,cutwin_Trest_trueflux(2) ! I: Trest range requiring valid true flux
     &  ,cutwin_Trest_trueflux2(2)! I: cut on logical flag
     &  ,cutwin_Trest(2)         ! I: cut on all epochs, rest frame days
     &  ,cutwin_Tobs(2)          ! I: cut on all epochs, obs-frame days
     &  ,cutwin_MJD(2)           ! I: cut on MJD range
     &  ,cutwin_mjd_exclude(2)   ! I: MJD window to exclude
     &  ,cutwin_SEARCHEFF_MASK(2)       ! I: cut on SIM_SEARCHEFF_MASK
     &  ,cutwin_snrmin_filt(2,MXFILT_OBS) ! filled from EPCUT_SNRMIN
     &  ,cutwin_restlam(2)                ! I: cut on <LAMREST>, no cutBit
     &  ,cutwin_lamrest(2)                ! I: same as above
     &  ,cutwin_lamobs(2)                 ! I: cut on <LAMOBS>, no cutBit
     &  ,cutwin_snr_nodetect(2)    ! I: SNR cut for non-detections
c
c define character strings to specify cuts and filters
c 'SNCUT' specifies cut on each SN
c 'EPCUT' specifies selection cut on each epoch

  ! I:# --------------------------------
      CHARACTER*(MXCHAR_CUTNAME)
     &  SNCUT_SNRMAX  ! I: max SNR required in each passband
                      ! I: example: 'u 10.  g 5.0  r 5.0  i 5.0  z -10.'
c
     & ,EPCUT_SNRMIN  ! I: min SNR accepted for each epoch/filter
                      ! I: example: 'u 20000.  g -4.  r -4.  i -4.  z 20000.'
c
     & ,EPCUT_SKYSIG  ! I: max SKY noise accepted each epoch/filter
                      ! I: example: 'u 20.  g 50.  r 80.  i 120.  z 200.'
c
     & ,EPCUT_PSFSIG  ! max PSF (arcsec) accepted each epoch/filter
                      ! example: 'u 1.8  g 1.5  r 1.6  i 1.8  z 2.0'
c
     & ,SNCUT_HOST_SBFLUX ! I: require min surface brightness,
                          ! I: example 'r 1000.' -> SBFLUX > 1000

      ! I:# --------------------------------
c ----------
c systematic tests for calibration:
c 'U 01 B -0.01' => shift U & B mags of primary

     &  ,MAGOBS_SHIFT_PRIMARY  ! I: shift primary mags  (for syst test)
     &  ,MAGOBS_SHIFT_ZP       ! I: shift zero points (e.g.,AB off for SDSS)
     &  ,MAGREST_SHIFT_PRIMARY ! I: idem for rest-frame mags 
     &  ,MAGREST_SHIFT_ZP      ! I: idem for rest-frame ZP
     &  ,FILTER_LAMSHIFT       ! I: e.g., 'r -2.4  i 6.2'  ! in Angstroms
c -------
c Fluxcal fudges for systematic tests (fudge photometry offsets and errors)
c Note that error is added in quadrature; ERROR<0 is subtracted in quadrature.
     &  ,FUDGE_FLUXCAL_OFFSET  ! I: shift all FLUXCAL
     &  ,FUDGE_FLUXCAL_ERROR   ! I: fudge net FLUXCAL error in each band
     &  ,FUDGE_FLUXCAL_ERRPIX  ! I: per-pixel error --> FLUXCAL error propto PSF
     &  ,FUDGE_MAG_ERROR       ! I: add stat error per band
     &  ,FUDGE_MAG_COVERR      ! I: add covariant error per band
     &  ,FUDGE_FLUXERR_SCALE   ! I: scale error in each band
     &  ,SIM_FUDGE_MAG_ERROR   ! I: add stat error per band, sim only
     
      REAL
     &   MAGOBS_SHIFT_PRIMARY_FILT(MXFILT_ALL) ! shift mag of primary ref
     &  ,MAGOBS_SHIFT_ZP_USER(MXFILT_ALL)      ! user ZP shift
     &  ,MAGOBS_SHIFT_ZP_FILT(MXFILT_ALL)      ! user ZP shift + system ZP
     &  ,FLUXSCALE_ZP_FILT(MXFILT_ALL)         ! corresponding flux scale
     &  ,MAGREST_SHIFT_PRIMARY_FILT(MXFILT_ALL) ! shift mag of primary ref
     &  ,MAGREST_SHIFT_ZP_USER(MXFILT_ALL)      ! shift zero points
     &  ,MAGREST_SHIFT_ZP_FILT(MXFILT_ALL)      ! shift zero points
     &  ,FILTER_LAMSHIFT_FILT(MXFILT_ALL)       ! shift filter trans
c
     &  ,MAGOBS_SHIFT_PRIMARY_PARAMS(3)       ! poly-fun of lambda;
     &  ,MAGOBS_SHIFT_ZP_PARAMS(3)            ! A0 + A1*LAM + A2*LAM^2
     &  ,FUDGE_FLUXCAL_OFFSET_FILT(MXFILT_ALL)
     &  ,FUDGE_FLUXCAL_ERROR_FILT(MXFILT_ALL)
     &  ,FUDGE_FLUXCAL_ERRPIX_FILT(MXFILT_ALL)
     &  ,FUDGE_FLUXERR_SCALE_FILT(MXFILT_ALL)
     &  ,FUDGE_MAG_ERROR_FILT(MXFILT_ALL)
     &  ,FUDGE_MAG_COVERR_FILT(MXFILT_ALL)
     &  ,SIM_FUDGE_MAG_ERROR_FILT(MXFILT_ALL)
     &  ,MWEBV_SCALE        ! I: scale MW extinc for syst test
     &  ,MWEBV_SHIFT        ! I: shift MW extinc
     &  ,MWEBV_FORCE        ! I: force specific MWEBV value (Feb 2020)

      REAL 
     &   RV_MWCOLORLAW   ! I: RV for Galactic extinction 

      INTEGER 
     &   OPT_MWCOLORLAW    ! I: MW color law opt (89, 94, 99 ...)
     &  ,OPT_MWEBV         ! I: option to modify SFD maps
      REAL
     &   PARLIST_MWCOLORLAW(10) ! I: params for MWCOLORLAW calc
     
      LOGICAL 
     &   USE_MWCOR          ! I:  T=> correct data flux for MW extinc;
                            ! I:  F=> leave data, correct fit model for MW.
      REAL 
     &   REDSHIFT_FINAL_SHIFT     ! I: artificial z-shift
     &  ,HOSTGAL_PHOTOZ_SHIFT     ! I: obsolete 
     &  ,HOSTGAL_SPECZ_SHIFT      ! I: obsolete 
     &  ,HOSTGAL_ZPHOT_SHIFT      ! I: apply only when zFINAL = HOST_ZPHOT
     &  ,HOSTGAL_ZSPEC_SHIFT      ! I: apply only when zFINAL = HOST_ZPHOT     
     &  ,FLUXERRCALC_ZPTERR

      COMMON / SNCUTCOM / CUTMASK8_SN, CUTMASK8_MJD
     &   ,CUTMASK8_SN_ALL, CUTMASK8_MJD_ALL
     &   ,cutwin_var, cutvar_name
     &   ,snlc_cutvar, snep_cutvar
     &   ,cutwin_snrmin_filt, LSNCUTS
     &   ,PASS_PRIVCUTS, PASS_SIMCUTS
     &   ,CUTFLAG_SNANA , ERRFLAG_FIT 
     &   ,NCCID_LIST, NCCID_IGNORE, NCID_LIST, NCID_IGNORE
     &   ,SNTYPE_LIST, SNCID_LIST, SNCCID_LIST
     &   ,SNCCID_IGNORE,SNCID_IGNORE_FILE,SNCID_IGNORE,SNCCID_IGNORE_ALL
     &   ,MXEVT_PROCESS, MXEVT_CUTS
     &   ,SNTYPE_IGNORE, CCDNUM_LIST, SIM_TEMPLATE_INDEX_LIST
     &   ,SNFIELD_LIST, IDFIELD_LIST, NIDFIELD_LIST, DOALL_SNFIELD
     &   ,NSNTYPE_LIST, NCCDNUM_LIST, NSIM_TEMPLATE_INDEX_LIST
     &   ,NSNTYPE_IGNORE, NFILT_SNRMAX, IFILT_SNRMAX
     &   ,NFILT_HOST_SBFLUX, IFILT_HOST_SBFLUX
     &   ,PHOTFLAG_MSKREJ, PHOTFLAG_BITLIST_REJECT, USE_MWCOR
     &   ,MAGOBS_SHIFT_PRIMARY, MAGOBS_SHIFT_PRIMARY_FILT
     &   ,MAGOBS_SHIFT_ZP, MAGOBS_SHIFT_ZP_FILT, FLUXSCALE_ZP_FILT
     &   ,MAGOBS_SHIFT_ZP_USER
     &   ,MAGOBS_SHIFT_PRIMARY_PARAMS, MAGOBS_SHIFT_ZP_PARAMS
     &   ,MAGREST_SHIFT_PRIMARY, MAGREST_SHIFT_PRIMARY_FILT
     &   ,MAGREST_SHIFT_ZP, MAGREST_SHIFT_ZP_FILT
     &   ,MAGREST_SHIFT_ZP_USER
     &   ,FILTER_LAMSHIFT, FILTER_LAMSHIFT_FILT
     &   ,FUDGE_FLUXCAL_OFFSET,FUDGE_FLUXCAL_ERROR,FUDGE_FLUXCAL_ERRPIX
     &   ,FUDGE_FLUXERR_SCALE
     &   ,FUDGE_FLUXCAL_OFFSET_FILT
     &   ,FUDGE_FLUXCAL_ERROR_FILT, FUDGE_FLUXCAL_ERRPIX_FILT
     &   ,FUDGE_FLUXERR_SCALE_FILT
     &   ,FUDGE_MAG_ERROR, FUDGE_MAG_ERROR_FILT
     &   ,FUDGE_MAG_COVERR, FUDGE_MAG_COVERR_FILT
     &   ,SIM_FUDGE_MAG_ERROR, SIM_FUDGE_MAG_ERROR_FILT
     &   ,RV_MWCOLORLAW, OPT_MWCOLORLAW, PARLIST_MWCOLORLAW, OPT_MWEBV
     &   ,MWEBV_SCALE, MWEBV_SHIFT, MWEBV_FORCE
     &   ,HOSTGAL_ZPHOT_SHIFT, HOSTGAL_ZSPEC_SHIFT
     &   ,HOSTGAL_PHOTOZ_SHIFT, HOSTGAL_SPECZ_SHIFT   ! obsolete Dec 2024
     &   ,REDSHIFT_FINAL_SHIFT, FLUXERRCALC_ZPTERR 
     &   ,CUTWIN_MJD_EXCLUDE

      COMMON / BYTEMASKCOM / MJDMASK

      EQUIVALENCE 
     &    ( cutwin_var(1,cutbit_cid),       cutwin_cid )
     &   ,( cutwin_var(1,cutbit_sntype),    cutwin_sntype )
     &   ,( cutwin_var(1,cutbit_redshift),  cutwin_redshift )
     &   ,( cutwin_var(1,cutbit_redshift_err),cutwin_redshift_err )
     &   ,( cutwin_var(1,cutbit_ra),        cutwin_ra )
     &   ,( cutwin_var(1,cutbit_dec),       cutwin_dec )
     &   ,( cutwin_var(1,cutbit_hostsep),   cutwin_hostsep )
     &   ,( cutwin_var(1,cutbit_Nepoch),    cutwin_Nepoch )
     &   ,( cutwin_var(1,cutbit_psf),       cutwin_psf )
     &   ,( cutwin_var(1,cutbit_zp),        cutwin_zp  )
     &   ,( cutwin_var(1,cutbit_zperr),     cutwin_zperr  )
     &   ,( cutwin_var(1,cutbit_photprob),  cutwin_photprob  )
     &   ,( cutwin_var(1,cutbit_errtest),   cutwin_errtest   )
     &   ,( cutwin_var(1,cutbit_simpull),   cutwin_simpull   )
     &   ,( cutwin_var(1,cutbit_trest_trueflux2),cutwin_trest_trueflux2)
     &   ,( cutwin_var(1,cutbit_Nfilt_snrmax), cutwin_nfilt_snrmax )
     &   ,( cutwin_var(1,cutbit_Nfilt_snrmax2),cutwin_nfilt_snrmax2 )
     &   ,( cutwin_var(1,cutbit_Nfilt_trestmin),cutwin_nfilt_trestmin)
     &   ,( cutwin_var(1,cutbit_Nfilt_trestmax),cutwin_nfilt_trestmax)
     &   ,( cutwin_var(1,cutbit_Nfilt_trest2),  cutwin_nfilt_trest2)
     &   ,( cutwin_var(1,cutbit_Trestmin),  cutwin_Trestmin )
     &   ,( cutwin_var(1,cutbit_Trestmax),  cutwin_Trestmax )
     &   ,( cutwin_var(1,cutbit_TrestRange),cutwin_TrestRange )
     &   ,( cutwin_var(1,cutbit_Trest2),    cutwin_Trest2 )
     &   ,( cutwin_var(1,cutbit_Tgapmax),   cutwin_Tgapmax )
     &   ,( cutwin_var(1,cutbit_T0gapmax),  cutwin_T0gapmax )
     &   ,( cutwin_var(1,cutbit_Tobsmin),   cutwin_Tobsmin )
     &   ,( cutwin_var(1,cutbit_Tobsmax),   cutwin_Tobsmax )
     &   ,( cutwin_var(1,cutbit_Trest),     cutwin_Trest )
     &   ,( cutwin_var(1,cutbit_Trest_trueflux2),cutwin_Trest_trueflux2)
     &   ,( cutwin_var(1,cutbit_Tobs),      cutwin_Tobs )
     &   ,( cutwin_var(1,cutbit_MJD),       cutwin_MJD   )
     &   ,( cutwin_var(1,cutbit_peakmjd),   cutwin_peakmjd )
     &   ,( cutwin_var(1,cutbit_nobs_predetect),cutwin_nobs_predetect)
     &   ,( cutwin_var(1,cutbit_nseason_active),cutwin_nseason_active)
     &   ,( cutwin_var(1,cutbit_search),        cutwin_searcheff_mask)
     &   ,( cutwin_var(1,cutbit_snrmax),        cutwin_snrmax  )
     &   ,( cutwin_var(1,cutbit_snrmax2),       cutwin_snrmax2  )
     &   ,( cutwin_var(1,cutbit_snrsum),        cutwin_snrsum  )     
     &   ,( cutwin_var(1,cutbit_nfield),        cutwin_nfield  )
     &   ,( cutwin_var(1,cutbit_mwebv),         cutwin_mwebv  )
     &   ,( cutwin_var(1,cutbit_reqep),        cutwin_cutflag_reqep)
     &   ,( cutwin_var(1,cutbit_private),      cutwin_cutflag_private)
     &   ,( cutwin_var(1,cutbit_simvar),       cutwin_cutflag_simvar)
     &   ,( cutwin_var(1,cutbit_offset_sbflux+1), cutwin_sbflux_filt)
     &   ,( cutwin_var(1,cutbit_offset_snrmax+1), cutwin_snrmax_filt)
c
     &   ,( cutwin_restlam(1), cutwin_lamrest(1) )


+KEEP,SNLCINP.

c define general input to program: 
c
      CHARACTER*(MXCHAR_FILENAME)  ! user input files
     &   NMLFILE          ! name of input namelist file
     &  ,ROOTFILE_OUT     ! I: output filename for root for tables
     &  ,TEXTFILE_PREFIX  ! I: prefix for text file tables
     &  ,MARZFILE_OUT     ! I: output FITS file for input to MARZ (spectra)
     &  ,SNTABLE_LIST     ! I: list of SNTABLEs to create; e.g., 'SNANA FITRES'
     &  ,SNTABLE_APPEND_VARNAME  ! I: add this varname to output tables
     &  ,SNTABLE_FILTER_REMAP ! I: remap filters in tables
     &  ,CALIB_FILE           ! I: fits-formatted KCOR/calib tables
     &  ,KCOR_FILE            ! I: legacy key for CALIB_FILE 
     &  ,OVERRIDE_RESTLAM_BOUNDARY*80 ! I: for kcors; e.g., '5100(gV) 6200(rV)'
     &  ,EPOCH_IGNORE_FILE    ! I: user file with epochs to ignore
     &  ,OUT_EPOCH_IGNORE_FILE ! I: write this file with discarded epochs
     &  ,SNMJD_LIST_FILE      ! I: list of "CID MJD" to process
     &  ,SNMJD_OUT_FILE       ! I: MJD_LIST out file
     &  ,MNFIT_PKMJD_LOGFILE  ! I: separate log for PKMJD fits
     &  ,USERTAGS_FILE        ! I: optional int user tag per SN
     &  ,VPEC_FILE            ! obsolete? pec. velocity corrections
     &  ,SNCID_LIST_FILE      ! I: list of CID's to process
     &  ,SIMLIB_OUT           ! legacy name
     &  ,SIMLIB_OUTFILE       ! I: write simlib entry for each event
     &  ,SIMLIB_ZPERR_LIST    ! I: e.g., 'abc .01 def .02 ghi .005'
     &  ,NONLINEARITY_FILE    ! I: non-linearity map 
c
     &  ,FUDGE_HOSTNOISE_FILE  ! legacy: inflate error vs. hostSB (Mar 2015)
     &  ,FLUXERRMODEL_FILE     ! I: DATA ONLY: err-fudge maps
     &  ,SIM_FLUXERRMODEL_FILE ! I: idem, SIM only
     &  ,MAGCOR_FILE           ! I: DATA ONLY: mag-cor for each CID-MJD-band
     &  ,SIM_MAGCOR_FILE       ! I: idem, SIM only

      CHARACTER*(MXFILE_LIST*MXCHAR_FILENAME)
     &    HEADER_OVERRIDE_FILE       ! I: comma-sep list of files with CID VAR
     &   ,SIM_HEADER_OVERRIDE_FILE   ! I: same, but for sims

      CHARACTER  ! versions
     &   VERSION_PHOTOMETRY(MXVERS)*(MXCHAR_VERSION)   ! I: SN versions to read
     &  ,VERSION_PHOTOMETRY_WILDCARD*(MXCHAR_FILENAME) ! I: get list from glob
     &  ,VERSION_REFORMAT_FITS*(MXCHAR_VERSION)   ! I: reformat TEXT -> FITS
     &  ,VERSION_REFORMAT_TEXT*(MXCHAR_VERSION)   ! I: reformat FITS -> TEXT

      CHARACTER ! paths
     &   PRIVATE_DATA_PATH*(MXCHAR_PATH)    ! I: private data subdir 
     &  ,FILTER_UPDATE_PATH*(MXCHAR_PATH)   ! I: SN-dependent filter response

      CHARACTER  ! misc
     &   REFORMAT_KEYS*(MXCHAR_FILENAME)  !   global reformat info
     &  ,NONSURVEY_FILTERS*(MXFILT_ALL)   ! I: non-survey filters to add
     &  ,SNRMAX_FILTERS*(MXFILT_ALL)      ! I: list of filters for SNRMAX cuts
     &  ,FILTER_REPLACE*(MXFILT_ALL)      ! I: e.g., 'UGRIZ -> ugriz' 
     &  ,FILTLIST_LAMSHIFT*(MXFILT_ALL)   ! I: list of lam-shifted filters
     &  ,PRIVATE_CUTWIN_STRING(MXCUT_PRIVATE)*(MXCHAR_CUTNAME) ! I: cut on privat variables
     &  ,PRIVATE_VARNAME_READLIST*200   ! I: list of private vars to read (default=ALL)
     &  ,SIMVAR_CUTWIN_STRING*(MXCHAR_CUTNAME) ! I: cuts on SIM_XXX
     &  ,EARLYLC_STRING*(MXCHAR_CUTNAME)       ! I: see manual
     &  ,REQUIRE_EPOCHS_STRING*100  ! I: e.g., 'riz 10 7 20' uses CUTWIN_SNRMAX
     &  ,DUMP_STRING*100            ! 'funName CID-list'

      INTEGER 
     &   NFIT_ITERATION       ! I: number of fit iterations
     &  ,MINUIT_PRINT_LEVEL   ! -1 -> none
     &  ,INTERP_OPT           ! I:  interp option (see INTERP_XXX params)
     &  ,NLINE_ARGS       
     &  ,OPT_YAML             ! I: 1=> write YAML out even if not batch job
     &  ,OPT_REFORMAT_TEXT    ! I: 1=> re-write SNDATA files in text format; see manual options
     &  ,OPT_REFORMAT_FITS    ! I: 1=> re-write in FITSformat (data only); see manual options
     &  ,OPT_REFORMAT_SALT2   ! I: 1=> re-write SNDATA files in SALT2 format
     &  ,OPT_REFORMAT_SPECTRA ! I: 1=> 3-col text: lam, Flam, Flamerr (ignore photometry)
     &  ,OPTSIM_LCWIDTH       ! I: 1=> option to compute LC width
     &  ,DEBUG_FLAG           ! I: for internal debug
     &  ,JOBSPLIT(2)          ! I: for batch; process (1)-range of (2)=TOTAL
     &  ,JOBSPLIT_EXTERNAL(2) ! passed by submit_batch for text format 
     &  ,MXLC_FIT             ! I: stop after this many fits passing all cuts
     &  ,PHOTFLAG_DETECT      ! I: used to count NEPOCH_DETECT and TLIVE_DETECT
     &  ,PHOTFLAG_TRIGGER     ! I: determine MJD(trigger) for survey
     &  ,FLUXERRMODEL_OPTMASK ! I: see manual
     &  ,OPT_SIMLIB_OUT       ! I: bit mask of SIMLIB_OUT options
     &  ,SIMLIB_OUT_TMINFIX   ! I: choose PEAKMJD so that min(MJD-PEAKMJD)=TMINFIX
     &  ,REQUIRE_DOCANA 
     &  ,OPT_SNCID_LIST      ! I: 1=force all and ignore cuts;
                             ! I: 2=set INIVAL=FITPAR
                             ! I: 4=use each FITPAR and ERROR as prior
     &  ,OPT_VPEC_COR        ! I: 1=apply vpec cor (default)
     
      LOGICAL 
     &   LSIM_SEARCH_SPEC   ! I: T => require simulated SPEC-tag
     &  ,LSIM_SEARCH_ZHOST  ! I: T => require simulated zHOST
     &  ,LTEST_INTERP       ! I: T => calls TEST_KCOR
     &  ,LTEST_KCOR         ! I: T => calls TEST_INTERP
     &  ,LTEST_MAG          ! I: T => test GET_MAGLC  and GET_MWXT
     &  ,LTEST_U3BAND       ! I: T => require exactly 3 bands that include U
     &  ,USE_LINE_ARGS(MXLINE_ARGS)
     &  ,USE_SNHOST_ZPHOT    ! I: T=> replace SNLC_REDSHIFT -> SNHOST_ZPHOT
     &  ,USE_HOSTGAL_PHOTOZ  ! I: idem, but matches keyName in data files
c
     &  ,ABORT_ON_NOEPOCHS   ! I: T=> abort if there are no epochs to fit
     &  ,ABORT_ON_BADAVWARP  ! I: T=> abort if AVwarp cannot be determined
     &  ,ABORT_ON_BADZ       ! I: T=> abort on bad z in GET_KCOR8
     &  ,ABORT_ON_BADKCOR    ! I: T=> affects only the init stage (RDKCOR)
     &  ,ABORT_ON_BADSURVEY  ! I: T=> abort if SURVEY changes
     &  ,ABORT_ON_BADFILTER  ! I: T=> abort if fit band is not in SURVEY filters
     &  ,ABORT_ON_MARGPDF0   ! I: T=> abort if marginalized pdf=0 everywhere
     &  ,ABORT_ON_TRESTCUT   ! I: T=> abort if any Trest cut is set (for photoz)
     &  ,ABORT_ON_DUPLCID    ! I: T=> abort on duplicate CID
     &  ,ABORT_ON_DUPLMJD    ! I: T=> abort on repeat MJD+band (Jun 2017)
     &  ,ABORT_ON_NOPKMJD    ! I: T=> abort if no PKMJDINI (see OPT_SETPKMJD)
     &  ,USE_MINOS           ! I: T=> use MINOS instead of MINIMIZE
     &  ,LDMP_SNFAIL         ! I: T => dump reason for each SN failure
     &  ,LDMP_SNANA_VERSION  ! I: T => dump SNANA version and SNANA_DIR
     &  ,LDMP_AVWARP         ! I: dump GET_AVWARP8 (debug only)
     &  ,LDMP_KCORFUN        ! I: dump KCORFUN8 (debug only)
     &  ,LDMP_SATURATE       ! I: dump saturated observations
     &  ,USESIM_SNIA         ! I: default True -> process simulated SNIa 
     &  ,USESIM_NONIA        ! I: default True -> process simulated nonIa
     &  ,USESIM_TRUEFLUX     ! I: SNLC_FLUXCAL -> SIM_FLUXCAL 
     &  ,LPROB_TRUEFLUX      ! I: T=> compute F-Ftrue chi2 and PROB
     &  ,RESTORE_WRONG_VPEC  ! I: restore incorrect VPEC sign correction
     &  ,RESTORE_OVERRIDE_ZBUG ! I: restore z=zCMB insteead of zHEL
     &  ,RESTORE_MWEBV_ERR_BUG ! I: bug used MWEBV/6 if MWEBV_ERR < 0.001
     &  ,FORCE_STDOUT_BATCH    ! I: force all stdout in batch mode
     
c LC plot info

      INTEGER  
     &  MXLC_PLOT      ! I: max number of plots to make with SNLCPAK
     & ,NCCID_PLOT     ! I: size of SNCCID_PLOT array
      CHARACTER 
     &  SNCCID_PLOT(MXLISTNML)*(MXCHAR_CCID) ! I: string-list of CCIDs to plot
      REAL 
     &   MJDPERIOD_PLOT  ! I: fold LC onto this period (periodic transients)
     &  ,MJDSHIFT_PLOT   ! I: shift MJD for LC plot output

      REAL 
     &   DTOBS_MODEL_PLOT  ! I: binning (days) for overlaid best-fit model
     &  ,zTOL_HELIO2CMB    ! I: give warning if  zCMB and zHEL are off
     
c Oct 2014: variables to check for multi-season transient activity

      INTEGER  
     &   MULTISEASON_OPTMASK      ! option(s) for GET_MULTISEASON
      REAL
     &   MULTISEASON_TGAP              ! new season if time-gap > this
     &  ,MULTISEASON_NREJECT_OUTLIER   ! num outliers to reject per season
     &  ,MULTISEASON_CHI2RED_ACTIVE    ! min chi2red for active season

      REAL  
     &   SIM_PRESCALE        ! I: pre-scale applied only to SIM
     &  ,VPEC_ERR_OVERRIDE   ! I: override VPEC_ERR in data header (km/sec)
     &  ,SNTABLE_APPEND_VALUE   ! I: value for SNTABLE_APPEND_VARNAME
     &  ,QUANTILE_ZERRMIN    ! I: use quantile prior for zerr> this; else use Guass prior

c variables to control estimate of PEAKMJD
      INTEGER
     &   OPT_SETPKMJD            ! I: bit-mask options  to determined PKMJD
      REAL
     &   SNRCUT_SETPKMJD         ! I: define SNR for Fmax in clump method
     &  ,MJDWIN_SETPKMJD         ! I: MJD window for Fmax in clump method
     &  ,SHIFT_SETPKMJD          ! I: shift initial PKMJD for systematic test

c define reference cosmological parameters (double precision!)
c Aug 7, 2009: each parameter has dimension 2 for value & error

      REAL*8
     &   H0_REF(2)    ! I: reference H0  (70 => 70 km/s/MPc)
     &  ,OLAM_REF(2)  ! I: OMEGA_LAMBDA & uncertainty (for x0 prior)
     &  ,OMAT_REF(2)  ! I: OMEGA_MATTER & uncertainty (for x0 prior)
     &  ,ORAD_REF(2)  ! I: OMEGA_RAD & uncertainty (for x0 prior)
     &  ,W0_REF(2)    ! I: DE eq stat w = p/rho & uncertainty (for x0 prior)
     &  ,DWDA_REF(2)  ! I: DE dw/da [a = 1/(1+z)] & uncertainty

      INTEGER   NSIMVAR_CUTWIN
      REAL      SIMVAR_CUTWIN(2,MXCUT_PRIVATE)
      CHARACTER SIMVAR_CUTWIN_LIST(MXCUT_PRIVATE)*40      

      COMMON   / SNLCINP /  
     &      NLINE_ARGS, USE_LINE_ARGS, nmlfile 
     &    , VERSION_PHOTOMETRY, VERSION_PHOTOMETRY_WILDCARD
     &    , VERSION_REFORMAT_FITS, VERSION_REFORMAT_TEXT
     &    , JOBSPLIT, JOBSPLIT_EXTERNAL, SIM_PRESCALE, MXLC_FIT
     &    , PRIVATE_DATA_PATH, FILTER_UPDATE_PATH
     &    , NONSURVEY_FILTERS, SNRMAX_FILTERS, VPEC_ERR_OVERRIDE
     &    , FILTER_REPLACE, FILTLIST_LAMSHIFT
     &    , OPT_YAML
     &    , OPTSIM_LCWIDTH, OPT_REFORMAT_SPECTRA, OPT_REFORMAT_TEXT
     &    , OPT_REFORMAT_SALT2, REFORMAT_KEYS, OPT_REFORMAT_FITS
     &    , SNMJD_LIST_FILE, SNMJD_OUT_FILE, MNFIT_PKMJD_LOGFILE
     &    , EPOCH_IGNORE_FILE, OUT_EPOCH_IGNORE_FILE, NONLINEARITY_FILE
     &    , SNCID_LIST_FILE, OPT_SNCID_LIST, OPT_VPEC_COR
     &    , SIMLIB_OUT, SIMLIB_OUTFILE, SIMLIB_ZPERR_LIST
     &    , OPT_SIMLIB_OUT, SIMLIB_OUT_TMINFIX
     &    , rootfile_out, textfile_prefix
     &    , SNTABLE_LIST, SNTABLE_FILTER_REMAP, MARZFILE_OUT
     &    , SNTABLE_APPEND_VARNAME, SNTABLE_APPEND_VALUE
     &    , CALIB_FILE, KCOR_FILE, OVERRIDE_RESTLAM_BOUNDARY
     &    , USERTAGS_FILE
     &    , VPEC_FILE, HEADER_OVERRIDE_FILE, SIM_HEADER_OVERRIDE_FILE
     &    , FLUXERRMODEL_FILE,SIM_FLUXERRMODEL_FILE,FLUXERRMODEL_OPTMASK
     &    , MAGCOR_FILE, SIM_MAGCOR_FILE,  FUDGE_HOSTNOISE_FILE
     &    , NFIT_ITERATION, MINUIT_PRINT_LEVEL, INTERP_OPT, USE_MINOS
     &    , OPT_SETPKMJD, QUANTILE_ZERRMIN
     &    , SNRCUT_SETPKMJD, MJDWIN_SETPKMJD, SHIFT_SETPKMJD, DEBUG_FLAG
     &    , LSIM_SEARCH_SPEC, LSIM_SEARCH_zHOST
     &    , LDMP_AVWARP, LDMP_KCORFUN, LDMP_SNFAIL, LDMP_SNANA_VERSION
     &    , LDMP_SATURATE
     &    , LTEST_KCOR, LTEST_INTERP, LTEST_MAG, LTEST_U3BAND
     &    , USESIM_SNIA, USESIM_NONIA, USESIM_TRUEFLUX
     &    , USE_SNHOST_ZPHOT, USE_HOSTGAL_PHOTOZ
     &    , RESTORE_WRONG_VPEC, RESTORE_OVERRIDE_ZBUG
     &    , RESTORE_MWEBV_ERR_BUG
     &    , REQUIRE_DOCANA, FORCE_STDOUT_BATCH
     &    , LPROB_TRUEFLUX
     &    , ABORT_ON_NOEPOCHS, ABORT_ON_BADAVWARP, ABORT_ON_NOPKMJD
     &    , ABORT_ON_BADZ, ABORT_ON_BADKCOR, ABORT_ON_BADSURVEY
     &    , ABORT_ON_MARGPDF0, ABORT_ON_TRESTCUT
     &    , ABORT_ON_DUPLCID, ABORT_ON_DUPLMJD, ABORT_ON_BADFILTER
     &    , SNCUT_SNRMAX, SNCUT_HOST_SBFLUX
     &    , EPCUT_SNRMIN, EPCUT_SKYSIG, EPCUT_PSFSIG
     &    , CUTWIN_LAMREST, CUTWIN_LAMOBS, cutwin_snr_nodetect
     &    , PRIVATE_CUTWIN_STRING, PRIVATE_VARNAME_READLIST
     &    , SIMVAR_CUTWIN_STRING
     &    , NSIMVAR_CUTWIN, SIMVAR_CUTWIN, SIMVAR_CUTWIN_LIST
     &    , EARLYLC_STRING, REQUIRE_EPOCHS_STRING, DUMP_STRING
     &    , MXLC_PLOT, NCCID_PLOT, SNCCID_PLOT
     &    , MJDPERIOD_PLOT, MJDSHIFT_PLOT
     &    , DTOBS_MODEL_PLOT
     &    , MULTISEASON_OPTMASK, MULTISEASON_TGAP, zTOL_HELIO2CMB
     &    , MULTISEASON_NREJECT_OUTLIER, MULTISEASON_CHI2RED_ACTIVE
     &    , PHOTFLAG_DETECT, PHOTFLAG_TRIGGER
     &    , CUTWIN_ZPADU, CUTWIN_ZPNPE, CUTWIN_TREST_TRUEFLUX
     &    , cutwin_tobs_predetect

      COMMON / SNLCINP8 /
     &    H0_REF, OLAM_REF, OMAT_REF, ORAD_REF, W0_REF, DWDA_REF

      NAMELIST / SNLCINP / 
     &      VERSION_PHOTOMETRY, VERSION_PHOTOMETRY_WILDCARD
     &    , VERSION_REFORMAT_FITS, VERSION_REFORMAT_TEXT
     &    , PRIVATE_DATA_PATH, FILTER_UPDATE_PATH
     &    , NONSURVEY_FILTERS, SNRMAX_FILTERS, VPEC_ERR_OVERRIDE
     &    , FILTER_REPLACE, FILTLIST_LAMSHIFT
     &    , JOBSPLIT, JOBSPLIT_EXTERNAL, SIM_PRESCALE, MXLC_FIT
     &    , OPT_YAML
     &    , OPTSIM_LCWIDTH, OPT_REFORMAT_SPECTRA, OPT_REFORMAT_TEXT
     &    , OPT_REFORMAT_SALT2, REFORMAT_KEYS, OPT_REFORMAT_FITS
     &    , SNMJD_LIST_FILE, SNMJD_OUT_FILE, MNFIT_PKMJD_LOGFILE
     &    , rootfile_out, textfile_prefix
     &    , SNTABLE_LIST, SNTABLE_FILTER_REMAP, MARZFILE_OUT
     &    , SNTABLE_APPEND_VARNAME, SNTABLE_APPEND_VALUE
     &    , CALIB_FILE, KCOR_FILE, OVERRIDE_RESTLAM_BOUNDARY
     &    , USERTAGS_FILE
     &    , VPEC_FILE, HEADER_OVERRIDE_FILE, SIM_HEADER_OVERRIDE_FILE
     &    , EPOCH_IGNORE_FILE, OUT_EPOCH_IGNORE_FILE, NONLINEARITY_FILE
     &    , SNCID_LIST_FILE, OPT_SNCID_LIST, OPT_VPEC_COR
     &    , SIMLIB_OUT, SIMLIB_OUTFILE, SIMLIB_ZPERR_LIST
     &    , OPT_SIMLIB_OUT, SIMLIB_OUT_TMINFIX
     &    , NFIT_ITERATION, MINUIT_PRINT_LEVEL, INTERP_OPT, USE_MINOS
     &    , OPT_SETPKMJD, QUANTILE_ZERRMIN
     &    , SNRCUT_SETPKMJD, MJDWIN_SETPKMJD, SHIFT_SETPKMJD, DEBUG_FLAG
     &    , LSIM_SEARCH_SPEC, LSIM_SEARCH_ZHOST
     &    , LDMP_SNFAIL, LDMP_SNANA_VERSION, LDMP_SATURATE
     &    , LTEST_KCOR, LTEST_INTERP, LTEST_MAG, LTEST_U3BAND
     &    , USESIM_SNIA, USESIM_NONIA, USESIM_TRUEFLUX
     &    , USE_SNHOST_ZPHOT, USE_HOSTGAL_PHOTOZ
     &    , RESTORE_WRONG_VPEC, RESTORE_OVERRIDE_ZBUG
     &    , RESTORE_MWEBV_ERR_BUG
     &    , REQUIRE_DOCANA, FORCE_STDOUT_BATCH
     &    , LPROB_TRUEFLUX
     &    , ABORT_ON_NOEPOCHS, ABORT_ON_BADAVWARP, ABORT_ON_NOPKMJD
     &    , ABORT_ON_BADZ, ABORT_ON_BADKCOR, ABORT_ON_BADSURVEY
     &    , ABORT_ON_MARGPDF0, ABORT_ON_TRESTCUT
     &    , ABORT_ON_DUPLCID, ABORT_ON_DUPLMJD, ABORT_ON_BADFILTER
     &    , H0_REF, OLAM_REF, OMAT_REF, W0_REF, DWDA_REF
     &    , USE_MWCOR
     &    , MXLC_PLOT, NCCID_PLOT, SNCCID_PLOT
     &    , MJDPERIOD_PLOT, MJDSHIFT_PLOT
     &    , DTOBS_MODEL_PLOT
     &    , MULTISEASON_OPTMASK, MULTISEASON_TGAP, zTOL_HELIO2CMB
     &    , MULTISEASON_NREJECT_OUTLIER, MULTISEASON_CHI2RED_ACTIVE
     &    , PHOTFLAG_DETECT, PHOTFLAG_TRIGGER
c
c Below are cut-variables defined in SNCUTS
c
     &   ,SNTYPE_LIST, SNCID_LIST, SNCCID_LIST
     &   ,MXEVT_PROCESS, MXEVT_CUTS
     &   ,SNCCID_IGNORE, SNCID_IGNORE_FILE, SNCID_IGNORE
     &   ,SNTYPE_IGNORE, CCDNUM_LIST, SIM_TEMPLATE_INDEX_LIST
     &   ,SNFIELD_LIST
     &   ,PHOTFLAG_MSKREJ, PHOTFLAG_BITLIST_REJECT
     &   ,cutwin_cid, cutwin_sntype
     &   ,cutwin_redshift, cutwin_redshift_err
     &   ,cutwin_ra, cutwin_dec
     &   ,cutwin_hostsep,   cutwin_Nepoch
     &   ,cutwin_snrmax,    cutwin_snrmax2, cutwin_snrsum, cutwin_nfield
     &   ,cutwin_mwebv,     cutwin_nseason_active
     &   ,cutwin_Trestmin,   cutwin_Trestmax
     &   ,cutwin_TrestRange, cutwin_Trest, cutwin_Tobs
     &   ,cutwin_Tgapmax,  cutwin_T0gapmax
     &   ,cutwin_Tobsmin,  cutwin_Tobsmax
     &   ,cutwin_peakmjd,  cutwin_nobs_predetect, cutwin_mjd
c
     &   ,cutwin_psf, cutwin_zp,  CUTWIN_ZPADU, CUTWIN_ZPNPE
     &   ,cutwin_zperr, cutwin_photprob,  cutwin_errtest, cutwin_simpull
     &   ,cutwin_trest_trueflux, cutwin_nband_thresh
     &   ,cutwin_nfilt_snrmax,   cutwin_nfilt_snrmax2
     &   ,cutwin_nfilt_trestmin, cutwin_nfilt_trestmax
     &   ,cutwin_trest2, cutwin_nfilt_trest2
     &   ,cutwin_restlam, cutwin_lamrest, cutwin_lamobs
     &   ,cutwin_snr_nodetect
     &   ,PRIVATE_CUTWIN_STRING, PRIVATE_VARNAME_READLIST
     &   ,SIMVAR_CUTWIN_STRING
     &   ,EARLYLC_STRING, REQUIRE_EPOCHS_STRING, DUMP_STRING
c
     &   ,SNCUT_SNRMAX, SNCUT_HOST_SBFLUX
     &   ,EPCUT_SNRMIN, EPCUT_SKYSIG, EPCUT_PSFSIG
     &   ,MAGOBS_SHIFT_PRIMARY,  MAGOBS_SHIFT_ZP
     &   ,MAGREST_SHIFT_PRIMARY, MAGREST_SHIFT_ZP, FILTER_LAMSHIFT
     &   ,MAGOBS_SHIFT_PRIMARY_PARAMS, MAGOBS_SHIFT_ZP_PARAMS
     &   ,FUDGE_FLUXCAL_OFFSET,FUDGE_FLUXCAL_ERROR,FUDGE_FLUXCAL_ERRPIX
     &   ,FUDGE_FLUXERR_SCALE
     &   ,FUDGE_MAG_ERROR, FUDGE_MAG_COVERR, SIM_FUDGE_MAG_ERROR
     &   ,FLUXERRMODEL_FILE,SIM_FLUXERRMODEL_FILE,FLUXERRMODEL_OPTMASK
     &   ,MAGCOR_FILE, SIM_MAGCOR_FILE, FUDGE_HOSTNOISE_FILE
     &   ,RV_MWCOLORLAW, OPT_MWCOLORLAW, PARLIST_MWCOLORLAW, OPT_MWEBV
     &   ,MWEBV_SCALE, MWEBV_SHIFT, MWEBV_FORCE
     &   ,HOSTGAL_ZPHOT_SHIFT, HOSTGAL_ZSPEC_SHIFT
     &   ,HOSTGAL_PHOTOZ_SHIFT, HOSTGAL_SPECZ_SHIFT   ! obsolete
     &   ,REDSHIFT_FINAL_SHIFT, FLUXERRCALC_ZPTERR 
     &   ,CUTWIN_MJD_EXCLUDE, CUTWIN_TOBS_PREDETECT


c ---------- end of SNLCINP ---------


+KEEP,FITSCOM.

c define external C functions to read from fits files

c max length of catenated strings from all epochs;
c e.g., FIELD
c Aug 31 2023: 40k -> 80k
c Nov 16 2023: 80k -> 160k

      INTEGER MXLEN_EPSTRING
      PARAMETER (MXLEN_EPSTRING = 160000 ) 

      INTEGER  
     &   RD_SNFITSIO_PREP
     &  ,RD_SNFITSIO_STR  ! read string
     &  ,RD_SNFITSIO_INT  ! read int
     &  ,RD_SNFITSIO_SHT  ! read short int
     &  ,RD_SNFITSIO_FLT  ! read float
     &  ,RD_SNFITSIO_DBL  ! read double

      EXTERNAL 
     &   RD_SNFITSIO_PREP
     &  ,RD_SNFITSIO_STR
     &  ,RD_SNFITSIO_INT
     &  ,RD_SNFITSIO_SHT
     &  ,RD_SNFITSIO_FLT
     &  ,RD_SNFITSIO_DBL
     &  ,SET_RDMASK_SNFITSIO ! void

c Define index-lookup arrays used for faster reading of fits files
      INTEGER MXFITSPAR
      PARAMETER ( MXFITSPAR = 400 )

      INTEGER
     &   INDXFITS_HEAD(MXFITSPAR)    ! used in RDSNFITS_HEAD
     &  ,INDXFITS_EPCUTS(MXFITSPAR)  ! used in RDSNFITS_EPCUTS
     &  ,INDXFITS_PHOT(MXFITSPAR)    ! used in RDSNFITS_PHOT
     &  ,IPARFITS_HEAD
     &  ,SNFITSIO_CODE_IVERSION     ! FITSIO version used to write data

c defin epoch mask for which 
     
      INTEGER 
     &   EPOCH_RDMASK_SNFITSIO(MXEPOCH)  ! epochs to keep/reject

c define long fits-string returned by RD_SNFITSIO_STR
      CHARACTER STRFITS*(MXLEN_EPSTRING)

      COMMON / FITSCOM /  SNFITSIO_CODE_IVERSION
     &  ,INDXFITS_HEAD, INDXFITS_EPCUTS, INDXFITS_PHOT
     &  ,IPARFITS_HEAD
     &  ,EPOCH_RDMASK_SNFITSIO, STRFITS


+KEEP,FILTCOM.

c filter bandpasses.
c Jan 16 2017: MXLAMBIN_FILT -> 4000 (was 3000) for JWST test
c May 31 2024 sync MXLAMBIN_PRIM = MXLAMBIN_SNSED
c
      INTEGER MXLAMBIN_FILT, MXLAMBIN_PRIM
      PARAMETER ( 
     &   MXLAMBIN_FILT = 4000            ! max number of lambda bins per filter
     &  ,MXLAMBIN_PRIM = MXLAMBIN_SNSED  ! max lambda bins for primary
     &    )

c Define filter chars A-Z, a-z and 0-9, but do not change order of 
c original FILTDEF characters so that we can still use older Kcor files.
c
      CHARACTER FILTDEF_STRING*100
      PARAMETER (FILTDEF_STRING = 
     &  "ugrizYJHK UBVRIXy0123456789 abcdef " //  !  32
     &  "ACDEFGLMNOPQSTWZ " //                    ! +16
     &  "hjklmnopqstvwx "                         ! +14 = 62
cc     &  "~!@#$%^&*()-_=+[]{}<>,|;`'"  ! doesn't work for m0obs_[band] in tables 
     &         )

      CHARACTER
     &   FILTOBS_NAME(MXFILT_ALL)*40   ! full filternames
     &  ,FILTREST_NAME(MXFILT_ALL)*40  ! full filternames
     &  ,SURVEY_FILT_NAME(MXFILT_ALL)*60    ! survey(s) for this band
     &  ,PRIMARY_NAME*40               ! name of primary
     &  ,NONSURVEY_FILTERS_ADD*80      ! NONSURVEY_FILTERS that were added

      LOGICAL 
     &   LFILTDEF_OBS(MXFILT_ALL)  ! filter-trans define in KCOR file
     &  ,LFILTDEF_REST(MXFILT_ALL) ! filter-trans define in KCOR file
     &  ,LFILTDEF_NONSURVEY(MXFILT_ALL) ! part of NONSURVEY_FILTERS
     &  ,LFILTDEF_SNRMAX(MXFILT_ALL)    ! use for SNRMAX cut
     &  ,FREEZE_SURVEY_FILTERS     ! T=> do not re-read on 2nd version
     &  ,EXIST_BXFILT_OBS          ! T=> observer BX exists
     &  ,EXIST_BXFILT_REST         ! T=> idem for rest-frame

c define indices for legacy filters
      INTEGER
     &   IFILT_SDSS_u, IFILT_SDSS_g, IFILT_SDSS_r
     &  ,IFILT_SDSS_i, IFILT_SDSS_z
     &  ,IFILT_BESS_U, IFILT_BESS_B, IFILT_BESS_V
     &  ,IFILT_BESS_R, IFILT_BESS_I, IFILT_BESS_BX
     &  ,IFILT_Y, IFILT_J, IFILT_H, IFILT_K

c define filter set for survey (observer) and for rest-frame.
c Each set goes 1 - NFILTDEF_[SURVEY,REST]

      INTEGER
     &   NFILTDEF_SURVEY          ! no. survey (obs) filters
     &  ,NFILTDEF_READ            ! no. filters to read (excludes BX)
     &  ,NFILTDEF_OBS        ! actual NFILTDEF from kcor file; should = NFILTDEF_SURVEY
     &  ,IFILTDEF_MAP_SURVEY(MXFILT_OBS)     ! IFILT_OBS vs. sparse filter index
     &  ,IFILTDEF_INVMAP_SURVEY(MXFILT_ALL) ! sparse index vs. IFILT_OBS
c
     &  ,NFILTDEF_REST                 ! no. rest-filts defined in Kcor file
     &  ,IFILTDEF_MAP_REST(MXFILT_OBS) ! IFILT_REST vs. sparse filter index
     &  ,IFILTDEF_INVMAP_REST(MXFILT_ALL) ! sparse index vs. IFILT_REST
c
     &  ,NFILTDEF_IGNORE_REST
     &  ,IFILTDEF_IGNORE_REST(MXFILT_OBS)  ! nearest rest-filters to ignore

c variables used in fitter; these variables are over-written
c in FITPAR_PREP for each SN

      INTEGER
     &   IFILT_REST_MAP(MXFILT_OBS)  ! idem for rest-frame filter
     &  ,NFILT_OBS_USEFIT                ! number of filters used in fit
  
      INTEGER*8
     &  IFILT_OBS_EVAL_MASK(2,MXFILT_ALL) ! set for each filter

      character FILTLIST_FIT_USE*64  ! filter-list USED each fit

c define filter properties using MXFILT_ALL
c Nov 12, 2010: split FILT_XXX into FILTOBS_XXX and FILTREST_XXX
c
      INTEGER
     &   NLAMBIN_FILTOBS(MXFILT_ALL)   ! number of bins per transmission curve
     &  ,NLAMBIN_FILTREST(MXFILT_ALL)  ! number of bins per transmission curve
     &  ,NLAMBIN_PRIMARY               ! lambda bins for primary spec

      
      REAL 
     &   FILTOBS_TRANS(MXLAMBIN_FILT,MXFILT_ALL)   ! filter transmissions
     &  ,FILTOBS_TRANSMAX(MXFILT_ALL)              ! max trans
     &  ,FILTOBS_LAMBDA(MXLAMBIN_FILT,MXFILT_ALL)  ! corresponding lambda's (A)
     &  ,FILTOBS_LAMAVG(MXFILT_ALL)           ! effective central lambda
     &  ,FILTOBS_LAMRMS(MXFILT_ALL)           ! lambda-RMS
     &  ,FILTOBS_LAMRANGE(2,MXFILT_ALL)       ! min,max range in obs-frames
     &  ,FILTOBS_MAG_PRIMARY(MXFILT_ALL)      ! primary mag vs. ifilt_obs
     &  ,FILTOBS_ZPOFF_PRIMARY(MXFILT_ALL)    ! mag(native) - mag(synth)
     &  ,FILTOBS_ZPOFF_SNPHOT(MXFILT_ALL)     ! apply these ZPOFF to SNphot
c xxx mark      &  ,FILTOBS_LAMSHIFT(MXFILT_ALL)         ! lambda shift per filter
c
     &  ,FILTREST_TRANS(MXLAMBIN_FILT,MXFILT_ALL)   ! filter transmissions
     &  ,FILTREST_TRANSMAX(MXFILT_ALL)              ! max trans
     &  ,FILTREST_LAMBDA(MXLAMBIN_FILT,MXFILT_ALL)  !  lambda's (A)
     &  ,FILTREST_LAMAVG(MXFILT_ALL)           ! effective central lambda
     &  ,FILTREST_LAMRMS(MXFILT_ALL)           ! lambda-RMS
     &  ,FILTREST_LAMRANGE(2,MXFILT_ALL)       ! min,max range in rest-frames
     &  ,FILTREST_MAG_PRIMARY(MXFILT_ALL)      ! primary mag vs. ifilt
     &  ,FILTREST_ZPOFF_PRIMARY(MXFILT_ALL)    ! mag(native) - mag(synth)
     &  ,FILTREST_LAMSHIFT(MXFILT_ALL)         ! lambda shift per filter
c
     &  ,PRIMARY_FLUX(MXLAMBIN_PRIM)       ! primary spec for obs filters
     &  ,PRIMARY_LAM(MXLAMBIN_PRIM)   

c for remap
      INTEGER NFILT_REPLACE, IFILTOBS_REPLACE(MXFILT_ALL) 
      
      COMMON / FILTCOM / FILTOBS_NAME, FILTREST_NAME, SURVEY_FILT_NAME
     &   ,IFILT_SDSS_u, IFILT_SDSS_g, IFILT_SDSS_r
     &   ,IFILT_SDSS_i, IFILT_SDSS_z
     &   ,IFILT_BESS_U, IFILT_BESS_B, IFILT_BESS_V
     &   ,IFILT_BESS_R, IFILT_BESS_I, IFILT_BESS_BX
     &   ,IFILT_Y, IFILT_J, IFILT_H, IFILT_K
c
     &   ,NFILTDEF_SURVEY,  NFILTDEF_OBS, NFILTDEF_REST, NFILTDEF_READ
     &   ,FREEZE_SURVEY_FILTERS 
     &   ,EXIST_BXFILT_OBS,       EXIST_BXFILT_REST
     &   ,IFILTDEF_MAP_SURVEY,    IFILTDEF_MAP_REST
     &   ,IFILTDEF_INVMAP_SURVEY, IFILTDEF_INVMAP_REST
     &   ,NFILTDEF_IGNORE_REST,   IFILTDEF_IGNORE_REST
     &   ,LFILTDEF_OBS, LFILTDEF_REST
     &   ,LFILTDEF_NONSURVEY, NONSURVEY_FILTERS_ADD
     &   ,LFILTDEF_SNRMAX
c
     &   ,NLAMBIN_FILTOBS, FILTOBS_TRANS, FILTOBS_TRANSMAX
     &   ,FILTOBS_LAMBDA, FILTOBS_LAMAVG, FILTOBS_LAMRMS
     &   ,FILTOBS_LAMRANGE
     &   ,FILTOBS_MAG_PRIMARY, FILTOBS_ZPOFF_PRIMARY
     &   ,FILTOBS_ZPOFF_SNPHOT     ! xxx mark , FILTOBS_LAMSHIFT
c
     &   ,NLAMBIN_FILTREST, FILTREST_TRANS, FILTREST_TRANSMAX
     &   ,FILTREST_LAMBDA,  FILTREST_LAMAVG, FILTREST_LAMRMS
     &   ,FILTREST_MAG_PRIMARY, FILTREST_ZPOFF_PRIMARY
     &   ,FILTREST_LAMSHIFT, FILTREST_LAMRANGE
c
     &   ,IFILT_REST_MAP
     &   ,FILTLIST_FIT_USE, NFILT_OBS_USEFIT
     &   ,PRIMARY_FLUX, PRIMARY_LAM, NLAMBIN_PRIMARY, PRIMARY_NAME
c
     &   ,NFILT_REPLACE, IFILTOBS_REPLACE

      COMMON / FILTCOM8 / IFILT_OBS_EVAL_MASK

+KEEP,FILTUPDCM.

c Nov 2010
c information related to updating filter transmissions for each SN
c

      INTEGER  
     &  OPT_FILTER_UPDATE   ! global flag for filter update
     & ,DOFLAG_FILTER_UPDATE(MXFILT_ALL)  ! track which filters to update

      CHARACTER 
     &  FILTER_UPDATE_TOPDIR*(MXCHAR_FILENAME)  !full path to filt-trans files

      COMMON / FILTUPDCOM / 
     &   OPT_FILTER_UPDATE, DOFLAG_FILTER_UPDATE, FILTER_UPDATE_TOPDIR

c ------------------------------------

c define updated filt-tran for SN and REF;
c the FILTOBS_TRANS arrays change for each SN
      REAL
     &  FILTOBS_TRANSSN_UPD(MXLAMBIN_FILT,MXFILT_ALL)
     & ,FILTOBS_TRANSREF_UPD(MXLAMBIN_FILT,MXFILT_ALL)
     & ,FILTOBS_ZPOFF_UPD(MXFILT_ALL)

c filter subdir is
c    [PREFIX_UPD_FILTDIR][SNID][SUFFIX_UPD_FILTDIR]
c and filter filenames are
c    [PREFIX_TRANSSN][filt][SUFFIX_UPD_TRANSSN]

      character   
     &   PREFIX_UPD_TRANSSN*80         ! Filename prefix for SN trans
     &  ,PREFIX_UPD_TRANSREF*80
     &  ,PREFIX_UPD_FILTDIR*80
     &  ,SUFFIX_UPD_TRANSSN*80
     &  ,SUFFIX_UPD_TRANSREF*80
     &  ,SUFFIX_UPD_FILTDIR*80
     &  ,FILTER_UPDATE_DIR*(MXCHAR_PATH)  ! directory with filter updates
 
      LOGICAL FILTINFO_UPD_SN, FILTINFO_UPD_REF

c define common for filter-set per SN
      COMMON / FILTUPDCOM2 / 
     &   FILTOBS_TRANSSN_UPD, FILTOBS_TRANSREF_UPD
     &  ,FILTOBS_ZPOFF_UPD
     &  ,PREFIX_UPD_FILTDIR,  SUFFIX_UPD_FILTDIR
     &  ,PREFIX_UPD_TRANSSN,  SUFFIX_UPD_TRANSSN
     &  ,FILTINFO_UPD_SN
     &  ,PREFIX_UPD_TRANSREF, SUFFIX_UPD_TRANSREF
     &  ,FILTINFO_UPD_REF
     &  ,FILTER_UPDATE_DIR


c Define common for filter set mapping.
c There are two maps:
c   MAP1: subdir name vs. index
c   MAP2: indx vs. SNID

      INTEGER MXMAP1_FILTER_UPDATE, MXSNLC_FILTUPD
      PARAMETER ( MXMAP1_FILTER_UPDATE = 20 )
      PARAMETER ( MXSNLC_FILTUPD = 20000 ) ! replaces MXSNLC_FILES

c MAP1:
      INTEGER 
     &   NMAP1_FILTER_UPDATE
     &  ,MAP1_FILTER_UPDATE_INDX(MXMAP1_FILTER_UPDATE) 
      CHARACTER  
     &   MAP1_FILTER_UPDATE_SUBDIR(MXMAP1_FILTER_UPDATE)*100

c MAP2:
c WARNING: works only up to MXSNLC_FILTUPD << MXSNLC

      INTEGER 
     &   NMAP2_FILTER_UPDATE
     &  ,MAP2_FILTER_UPDATE_PTRMAP1(MXSNLC_FILTUPD)  ! points to MAP1 index
      CHARACTER
     &   MAP2_FILTER_UPDATE_CCID(MXSNLC_FILTUPD)*(MXCHAR_CCID)  ! CCID list

      COMMON / FILTUPD_MAPCOM / 
     &   NMAP1_FILTER_UPDATE
     &  ,MAP1_FILTER_UPDATE_INDX, MAP1_FILTER_UPDATE_SUBDIR
c
     &  ,NMAP2_FILTER_UPDATE
     &  ,MAP2_FILTER_UPDATE_PTRMAP1, MAP2_FILTER_UPDATE_CCID


+KEEP,SNANAFIT.

c store fit results for use in snana
c define arrays used in fit.

      INTEGER MXFITPAR, MXFITSTORE

      PARAMETER ( 
     &   MXFITPAR    =  12    ! max number of fit parameters
     &  ,MXFITSTORE  =  800   ! max number of storage params 
     &     )

      INTEGER 
     &   NFITPAR(0:MXFILT_OBS)   ! Nfitpar for 0=all, or 'ifilt'
     &  ,NFITPAR_MN         ! Minuit NFITPAR includes NFIXPAR
     &  ,NFIXPAR            ! Number of fixed parameters (i.e, INISTP=0)
     &  ,NPLOTPAR            ! Number of extra FITVAL parameters to plot
     &  ,NEPOCH_ALL(0:MXFILT_OBS)    ! fit+rejected epochs per filter
     &  ,NEPOCH_FIT(0:MXFILT_OBS)    ! number of epochs fit per filter
     &  ,NEPOCH_REJECT(0:MXFILT_OBS) ! number of epochs rejected by fit 
     &  ,NEPOCH_REJECT2          ! total rejected ep within TREST window
     &  ,ERRTYPE(MXFITPAR)  ! MINOS or PARAB
     &  ,PARPTR_CHI2
     &  ,PARPTR_IFILT_REST(MXFILT_ALL)
     &  ,PARPTR_FITRESTMAG

      DOUBLE PRECISION 
     &   INIVAL(MXFITPAR)
     &  ,INISTP(MXFITPAR)
     &  ,INIBND(2,MXFITPAR)
c
     &  ,FITVAL(MXFITPAR,0:MXITER)
     &  ,FITERR(MXFITPAR,0:MXITER)
     &  ,FITERR_PLUS(MXFITPAR,MXITER)
     &  ,FITERR_MINUS(MXFITPAR,MXITER)
     &  ,FITERR_RATIO(MXFITPAR,MXITER)  ! abs(EPLUS/Eminus)
c
     &  ,FITCHI2_MIN   ! min chi2 after minimization
     &  ,FITCHI2_QUIT  ! quit FCN calc if chi2 exceeds this value
     &  ,SIMCHI2_CHEAT ! chi2 using exact sim values
     &  ,FITERRMAT_SPARSE(MXFITPAR,MXFITPAR)
     &  ,FITERRMAT(MXFITPAR,MXFITPAR)
     &  ,FITCORMAT(MXFITPAR,MXFITPAR)
c
     &  ,PDFVAL(MXFITPAR)
     &  ,PDFERR(MXFITPAR)
     &  ,PDFPROB2(MXFITSTORE) 
     &  ,PDFERRMAT(MXFITPAR,MXFITPAR)
     &  ,PDFCORMAT(MXFITPAR,MXFITPAR)

c declare fit-storage arrays for all SN

      REAL 
     &   FITVAL_STORE(MXFITSTORE)
     &  ,FITERR_STORE(MXFITSTORE)
     &  ,PDFVAL_STORE(MXFITSTORE)  ! from average over PDF integral
     &  ,PDFERR_STORE(MXFITSTORE)  !
     &  ,PDFPROB2_STORE(MXFITSTORE)  !
     &  ,LCVAL_STORE(MXFITSTORE)   !  either FITVAL or PDFVAL
     &  ,LCERR_STORE(MXFITSTORE)   !  either FITERR or PDFERR
     &  ,LCFRACERRDIF_STORE(MXFITSTORE)  ! frac change on last 2 iter
c
     &  ,LCCHI2_STORE(4)        !  1,2,3,4=> TOTAL,data,prior,sigma
     &  ,LCPROBCHI2_STORE(4)    !  idem for prob
     &  ,FITCHI2_STORE(4)       !  idem for fit minimum
     &  ,FITPROBCHI2_STORE(4)
c
c  define a few intermediate-fit variables to identify cuts to more
c  quickly remove events.
     &  ,FITPROB_ITER1          ! total FITPROB after ITER=1
     &  ,FITCHI2RED_INI         ! first guess at fit chi2red
     &  ,FITCHI2RED_INI2        ! fit chi2red after rough adjustment
c
     &  ,INIVAL_STORE(MXFITSTORE)  ! store all inital values  
     &  ,SIMVAL_STORE(MXFITPAR)     ! sim values
c
     &  ,ERRMAX_BAD(MXFITPAR)     ! err < ERRMAX_BAD labelled bad
     &  ,MAG_XTMW_REF(MXFILT_ALL) ! ref MWXT mags subtracted from data
c
c ------ define FITANA_CUTWIN_XXX that depend on spec-vs-photoz fit
     &  ,FITANA_CUTWIN_TREST(2)
     &  ,FITANA_CUTWIN_TRESTMIN(2)
     &  ,FITANA_CUTWIN_TRESTMAX(2)
     &  ,FITANA_CUTWIN_TREST2(2)
     &  ,FITANA_CUTWIN_TGAPMAX(2)
     &  ,FITANA_CUTWIN_T0GAPMAX(2)
     &  ,FITANA_CUTWIN_SNRSUM(2)     ! Jul 2024
c ------ SNLC_XXX -> XXX_FIT re-evaluated after final fit
     &  ,TRESTMIN_FIT, TRESTMAX_FIT, TRESTRANGE_FIT
     &  ,TOBSMIN_FIT,  TOBSMAX_FIT
     &  ,TGAPMAX_FIT,  T0GAPMAX_FIT
     &  ,SNRSUM_FIT
     &  ,SNRMAX_FILT_FIT(MXFILT_OBS)      ! sparse ordering
     &  ,SNRMAX_SORT_FIT(MXFILT_OBS)

      INTEGER
     &   ERRTYPE_STORE(MXFITPAR)  ! MINOS or PARABOLIC
     &  ,NERRTYPE(MXERRTYPE)      ! # params per error type
     &  ,NDOF_STORE(4)            ! 1,2,3 => TOTAL, DATA, PRIOR, SIGMA
     &  ,NDOF_PRIOR
     &  ,NCALL_INTEGPDF
     &  ,TIME_INTEGPDF
     &  ,TIMESUM_INTEGPDF
     &  ,TIMEAVG_INTEGPDF
c ---- ISNLC_XXX  -> XXX_FIT  re-evaluated after fitting
     &  ,NFILT_TRESTMIN_FIT
     &  ,NFILT_TRESTMAX_FIT
     &  ,NFILT_TREST2_FIT
     &  ,NFILT_SNRMAX_FIT    ! added Sep 30 2012
     &  ,NFILT_SNRMAX2_FIT   ! added Sep 20 2012
     &  ,MNSTAT_COV          ! ISTAT returned from MNSTAT: see minuit manual

      CHARACTER 
     &   PARNAME_STORE(MXFITSTORE)*(MXCHAR_PARNAME)  ! stored parameter names
      INTEGER
     &   PAROPT_STORE(MXFITSTORE)  ! storage options for output

      LOGICAL 
     &   FLOATPAR(MXFITPAR)   ! T => ipar is floated in fit
     &  ,USEPDF_MARG          ! T => use margin. pdf-avg instead of fit-values
     &  ,LREPEAT_ITER         ! internal flag for repeated iteration
     &  ,LREPEAT_MINOS        ! repeat entire fit with MINOS (May 2018)

      COMMON / SNANAFIT4 / 
     &   NFITPAR_MN, NFITPAR, NFIXPAR, PARNAME_STORE, PAROPT_STORE
     &  ,NEPOCH_ALL, NEPOCH_FIT, NEPOCH_REJECT, NEPOCH_REJECT2
     &  ,NPLOTPAR, ERRTYPE, FLOATPAR, USEPDF_MARG
     &  ,PARPTR_CHI2, PARPTR_IFILT_REST, PARPTR_FITRESTMAG
     &  ,FITVAL_STORE, FITERR_STORE
     &  ,FITCHI2_STORE, FITPROBCHI2_STORE
     &  ,FITPROB_ITER1, FITCHI2RED_INI, FITCHI2RED_INI2
     &  ,PDFVAL_STORE, PDFERR_STORE, PDFPROB2_STORE
     &  ,LCVAL_STORE,  LCERR_STORE, LCFRACERRDIF_STORE
     &  ,LCCHI2_STORE, LCPROBCHI2_STORE
     &  ,INIVAL_STORE
     &  ,ERRTYPE_STORE, NERRTYPE, ERRMAX_BAD
     &  ,NDOF_STORE, NDOF_PRIOR, SIMVAL_STORE
     &  ,NCALL_INTEGPDF, TIME_INTEGPDF
     &  ,TIMESUM_INTEGPDF, TIMEAVG_INTEGPDF
c
     &  ,FITANA_CUTWIN_TREST
     &  ,FITANA_CUTWIN_TRESTMIN, FITANA_CUTWIN_TRESTMAX
     &  ,FITANA_CUTWIN_TREST2
     &  ,FITANA_CUTWIN_TGAPMAX,  FITANA_CUTWIN_T0GAPMAX     
     &  ,TRESTMIN_FIT, TRESTMAX_FIT, TRESTRANGE_FIT
     &  ,TobsMIN_FIT, TobsMAX_FIT, TGAPMAX_FIT, T0GAPMAX_FIT
     &  ,SNRMAX_FILT_FIT, SNRMAX_SORT_FIT
     &  ,FITANA_CUTWIN_SNRSUM, SNRSUM_FIT
     &  ,NFILT_TRESTMIN_FIT,NFILT_TRESTMAX_FIT,NFILT_TREST2_FIT
     &  ,NFILT_SNRMAX_FIT,   NFILT_SNRMAX2_FIT
     &  ,LREPEAT_ITER, LREPEAT_MINOS,  MNSTAT_COV

      COMMON / SNANAFIT8 / 
     &   INIVAL, INISTP, INIBND, FITVAL
     &  ,FITERR, FITERR_PLUS, FITERR_MINUS, FITERR_RATIO
     &  ,FITCHI2_MIN, FITCHI2_QUIT, SIMCHI2_CHEAT
     &  ,FITERRMAT_SPARSE, FITERRMAT, FITCORMAT
     &  ,PDFVAL, PDFERR, PDFPROB2, PDFERRMAT, PDFCORMAT
     &  ,MAG_XTMW_REF

C =============================================
+KEEP,MCMCCOM.  
  
c Created Nov 2009 for Ben Dilday's  MCMC method  
  
c a bunch of MCMC stuff  
      LOGICAL LMCMC  
     &  ,LTUP_MCMC    ! book/fill special ntuple  
  
      INTEGER   
     &   NMCMC_EVAL        ! number of total evaluations for MCMC  
     &  ,IMCMC_FLAG        ! a generic flag for MCMC variations  
     &  ,NMCMC_CHAINS      ! number of chains to run  
     &  ,NMCMC_BURN        ! size of burn in  
     &  ,IMCMC_STORE       ! store every nth chi2 in the ntuple  
   
      CHARACTER   
     &  CHOPT_MCMC*16     ! ??  
        
      REAL   
     &   MCMC_NSIG_STEP   ! ??  
     &  ,NSIG_MCMC_START  ! ??  
  
      COMMON / SNFMCMC / NMCMC_EVAL, IMCMC_FLAG  
     &     ,NMCMC_CHAINS, NMCMC_BURN,MCMC_NSIG_STEP  
     &     ,CHOPT_MCMC, LMCMC, LTUP_MCMC        
     &     ,IMCMC_STORE, NSIG_MCMC_START  
       
      NAMELIST / MCMCINP / NMCMC_EVAL, IMCMC_FLAG  
     &     ,NMCMC_CHAINS, NMCMC_BURN, MCMC_NSIG_STEP  
     &     ,CHOPT_MCMC, LMCMC, LTUP_MCMC        
     &     ,IMCMC_STORE, NSIG_MCMC_START  
  
 
C =============================================
+KEEP,MCMCTUP. 
c MCMCTUP parameters (created Nov 2009 by B.Dilday)  
  
      INTEGER 
     &   MXNTVAR  
     &  ,MAX_NMCMC_TOT   
     &  ,NTID  
     &  ,NCALL_MCMCTUP
        
      PARAMETER (     
     &     MXNTVAR = 100   
     &   , MAX_NMCMC_TOT = 2000000 ! max entries for mcmc ntuple   
     &   , NTID = IDTABLE_MCMC 
     &     )   
        
c     common block for ntuple stuff  
      CHARACTER MCMCTUPNAMES(MXNTVAR)*8   
      REAL MCMCTUPVALS(MXNTVAR)  
        
      COMMON / MCMCTUPCOM / MCMCTUPNAMES  
     &     ,MCMCTUPVALS, NCALL_MCMCTUP  
 
c ----------------------------
+KEEP,XTCOM.
c
c Created Nov 16, 2006
c extinction parameters:
c  XTmag = zeta(t) * [alpha + beta/RV] * AV
c XTPAR are Saurabh's parameters.
c
c Aug 30, 2010: add newer XTHOST - exact calculation

      INTEGER NRVBIN_XTHOST
      PARAMETER ( NRVBIN_XTHOST = 5 )

      REAL
     &   XTPAR_ZETA(MXFILT_ALL,MXTBIN_KCOR)
     &  ,XTPAR_ALPHA(MXFILT_ALL)
     &  ,XTPAR_BETA(MXFILT_ALL)
     &  ,XTHOST(MXFILT_ALL,MXTBIN_KCOR,NRVBIN_XTHOST)
     &  ,RVINV_XTHOST(NRVBIN_XTHOST)

      COMMON / XTCOM / XTPAR_ZETA, XTPAR_ALPHA, XTPAR_BETA, 
     &                 XTHOST, RVINV_XTHOST



+KEEP,PKMJDCOM.

c define bits for user option-mask OPT_SETPKMJD  (lsb = 0 )
      INTEGER 
     &   OPTBIT_SETPKMJD_ANYFUN
     &  ,OPTBIT_SETPKMJD_POLYCOR
     &  ,OPTBIT_SETPKMJD_NOABORT
     &  ,OPTBIT_SETPKMJD_FLUXMAX
     &  ,OPTBIT_SETPKMJD_SAVEPAR
     &  ,OPTBIT_SETPKMJD_FLUXMAX2
     &  ,OPTBIT_SETPKMJD_FLUXMAX3
     &  ,OPTBIT_SETPKMJD_TRIGGER
     &  ,OPTBIT_SETPKMJD_DUMP
     &  ,OPTBIT_SETPKMJD_SIM

      PARAMETER ( 
     &  OPTBIT_SETPKMJD_ANYFUN  = 0  ! (=1) use exact function from Bazin 09
     & ,OPTBIT_SETPKMJD_POLYCOR = 1  ! (=2) include POLY cor in Bazin function
     & ,OPTBIT_SETPKMJD_NOABORT = 2  ! (=4) do not abort if can't find PKMJD 
     & ,OPTBIT_SETPKMJD_FLUXMAX = 3  ! (=8) PEAKMJD=MJD(maxFlux) like JG
     & ,OPTBIT_SETPKMJD_FLUXMAX2= 4  ! (=16) PKMJD for Fmax clump
     & ,OPTBIT_SETPKMJD_FLUXMAX3= 5  ! (=32) idem, but log10(SNR) weight
     & ,OPTBIT_SETPKMJD_TRIGGER = 6  ! (=64) PKMJD = MJD_TRIGGER 
     & ,OPTBIT_SETPKMJD_SAVEPAR = 9  ! (=512) save fit params to SNANA table
     & ,OPTBIT_SETPKMJD_DUMP    =10  !(=1024) extra screen dump per SN/filter
     & ,OPTBIT_SETPKMJD_SIM     =11  !(=2048) PKMJDINI = SIM_PEAKMJD
     &   )

c Define fit params

      INTEGER 
     &   IPAR_ISN, IPAR_FILT, IPAR_MJDMIN, IPAR_MJDMAX
     &  ,IPAR_T0, IPAR_TRISE, IPAR_TFALL
     &  ,IPAR_A0, IPAR_A1, IPAR_A2
     
      REAL SNRMIN_forFLUXMAX

      PARAMETER (
     &   IPAR_ISN    = 1  ! fixed param
     &  ,IPAR_FILT   = 2  ! fixed param
     &  ,IPAR_MJDMIN = 3  ! fixed param (May 2019)
     &  ,IPAR_MJDMAX = 4  ! fixed param (May 2019)
     &  ,IPAR_T0     = 5
     &  ,IPAR_TRISE  = 6
     &  ,IPAR_TFALL  = 7
     &  ,IPAR_A0     = 8
     &  ,IPAR_A1     = 9
     &  ,IPAR_A2     = 10
     &  ,SNRMIN_forFLUXMAX  = 3.0   ! min SNR to consider for fluxmax
     &     )

       CHARACTER  PKPARNAME(NPAR_ANYLC)*16 
       DATA  PKPARNAME /
     &     'ISN', 'IFILTOBS', 'MJDMIN', 'MJDMAX', 
     &     'T0', 'TRISE', 'TFALL','A0', 'A1', 'A2' /

c -----
      REAL*8 FITERRMAT_PKMJD(NPAR_ANYLC,NPAR_ANYLC,MXFILT_ALL)

      COMMON / PKMJDCOM8 / FITERRMAT_PKMJD 

      REAL*4
     &   PKMJD_FIT(MXFILT_ALL)
     &  ,PKMJD_ERR(MXFILT_ALL)
     &  ,PKMJD_ERRMIN, PKMJD_ERRWGT  ! min and weighted error
     &  ,PKFLUX_FIT(MXFILT_ALL)
     &  ,PKFLUX_ERR(MXFILT_ALL)
     &  ,PKFLUX_ERRMIN, PKFLUX_ERRWGT  ! min and weighted error
     &  ,CHI2_FITPKMJD(MXFILT_ALL)

      INTEGER NFIT_PKMJD, NDOF_FITPKMJD(MXFILT_ALL)

      COMMON / PKMJDCOM4 /
     &   PKMJD_FIT, PKMJD_ERR, PKMJD_ERRMIN, PKMJD_ERRWGT
     &  ,PKFLUX_FIT, PKFLUX_ERR, PKFLUX_ERRMIN, PKFLUX_ERRWGT
     &  ,NFIT_PKMJD
     &  ,CHI2_FITPKMJD, NDOF_FITPKMJD

+KEEP,WRS2COM.

c Nov 03, 2011:
c common block for translating SNANA format into SALT2 format.

      INTEGER
     &   LEN_SURVEY, LEN_INST, LEN_MAGSYS,  LEN_PREFIX
     &  ,NREPLACE, IMAP_REPLACE(MXFILT_ALL)
     &  ,NEWKEY

      CHARACTER
     &   NAMEof_INSTRUMENT*(MXCHAR_FILEWORD)
     &  ,NAMEof_MAGSYS*(MXCHAR_FILEWORD)
     &  ,NAMEof_SURVEY*(MXCHAR_FILEWORD)
     &  ,NAMEof_PREFIX*(MXCHAR_FILEWORD)
     &  ,NAMEof_REPLACE(2)*(MXCHAR_FILEWORD)
     &  ,NEWKEY_NAME(20)*(MXCHAR_FILEWORD)
     &  ,NEWKEY_ARG(20)*(MXCHAR_FILEWORD)

      COMMON / WRS2COM /
     &   LEN_SURVEY, LEN_INST, LEN_MAGSYS, LEN_PREFIX
     &  ,NREPLACE, IMAP_REPLACE, NEWKEY
     &  ,NAMEof_INSTRUMENT, NAMEof_MAGSYS
     &  ,NAMEof_SURVEY, NAMEof_PREFIX
     &  ,NAMEof_REPLACE, NEWKEY_NAME, NEWKEY_ARG

C =================================================
+PATCH,*SNANA.

+USE,P=*SNMAIN,T=EXE.
+USE,P=*DATA_IO,T=EXE.
+USE,P=*SNUTIL,T=EXE.
+USE,P=*SNTABLE,T=EXE.
+USE,P=*CALIB,T=EXE.
c +USE,P=*CALIB_LEGACY,T=EXE,IF=KCOR.
+USE,P=*FITPKMJD,T=EXE.
+USE,P=*SPLINE,T=EXE.


C =============================================
+PATCH,*SNMAIN.
C =============================================

C =============================================
+DECK,MAIN.
      PROGRAM SNANA
c
c Main snana program.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,FILTCOM.

      INTEGER   IERR, IVERS, NFIT_PER_SN, JDIFF

c funtions

+SELF,IF=SNANA.
      INTEGER SNANA_GET_NLCPLOT
+SELF.

+SELF,IF=PSNID.
      INTEGER PSNID_GET_NFIT
+SELF.

      EXTERNAL PRINT_CPUTIME

C ------------------- BEGIN -------------------

      JTIME_START = TIME()

      CALL PARSE_SNANA_ARGS()

      ISTAGE_SNANA = 0

c init some variables
      CALL INIT_SNVAR()

      CALL WARN_OLDINPUTS("init"//char(0), 0);

c read namelist
      CALL RDSNNML(IERR) 
        IF ( IERR .NE. 0 ) GOTO 666 

      ISTAGE_SNANA = ISTAGE_INIT

c check for dump flags (call to C code)
      CALL INIT_SNANA_DUMP(DUMP_STRING//char(0) )

c check if format is FITS or ASCII (set logicals  FORMAT_FITS[TEXT])
      CALL CHECK_FORMAT()

c ------------------------------------------------
c            Misc. inits for options

c check for CID list from &SNLCINP and/or separate file
      CALL INIT_SNCID_LISTS() ! Jun 2021

c check for SN,MJD list from file ... used for interpolation
      CALL RDFILE_SNMJDLIST()

c read optional tags
      CALL RDFILE_USERTAGS()

c init multi-season analysis
      CALL MULTISEASON(IFLAG_INI)  ! 1 = init flag

c check reformat options
      CALL INIT_REFORMAT(1)

c -----------------------------------------------
c prepare reading data; determine FITS or TEXT; read global info ...
      CALL INIT_READ_DATA()

c check reformat options
      CALL INIT_REFORMAT(2)

c continue with initialization that may depend on SURVEY and FILTERS.

c process namelist strings after we know
c the filters and survey 
      CALL PROCSNNML(IERR) 
        IF ( IERR .NE. 0 ) GOTO 666 

      CALL INIT_FUDGE_FLUXCAL(IERR) ! fudge fluxes and/or errors
        IF ( IERR .NE. 0 ) GOTO 666 

c intialize cutmask after reading data
      CALL INIT_CUTMASK(IERR)
        IF ( IERR .NE. 0 ) GOTO 666 

c init early-LC selection
      CALL PARSE_EARLYLC_STRING()

c init REQUIRE_EPOCHS (Sep 2017)
      CALL PARSE_REQUIRE_EPOCHS_STRING()

c init cut-names now that we have the filter names 
      CALL INIT_CUTNAMES(IERR)
        IF ( IERR .NE. 0 ) GOTO 666 

      CALL READ_CALIB_WRAPPER(IERR)
        IF ( IERR .NE. 0 ) GOTO 666 

c option to create SIMLIB from data (call after RDKCOR, Feb 2017)
      CALL MAKE_SIMLIB_FILE(1)

c check for valid MW GALextinct option  and print message
      CALL INIT_GALextinct()

      ISTAGE_SNANA = ISTAGE_RDSN

c parse SNTABLE_LIST string to know what tables & LCPLOTs to make
      CALL INIT_SNTABLE_OPTIONS()

c --------------------------------------------
c init output file; set OPTFIT based on program.
+SELF,IF=SNANA.
      NFIT_PER_SN = SNANA_GET_NLCPLOT()
      ISJOB_SNANA = .TRUE.
      CALL MNDUMMY()   ! just to require minuit library.
+SELF,IF=SNFIT.
      NFIT_PER_SN = 1  ! only 1 fit per SN
      ISJOB_SNFIT = .TRUE.
      CALL MNDUMMY()   ! just to require minuit library.
+SELF,IF=PSNID.
      NFIT_PER_SN = PSNID_GET_NFIT()
      ISJOB_SNFIT = .TRUE.
      ISJOB_PSNID = .TRUE.
      IF ( OPT_SETPKMJD == 0 ) THEN  ! if default, then ...
        OPT_SETPKMJD = -1  ! DON'T estimate PKMJD before psnid (4/22/2014)
      ENDIF
+SELF.

      CALL INIT_OUTFILES(NFIT_PER_SN)

c Mar 2013, create subdir for monitor-init (CDTOPDIR below)
      CALL MAKEDIR_OUTPUT("MONINIT"//char(0), -1, 7 ) 

c --------------------------------------------
c plot a few Hubble diagrams for references
      IF ( USE_TABLEFILE )  CALL MON_HUBBLEREF ( IERR )

+SELF,IF=SNFIT.
c initialize fitter before SN are selected
      CALL PRBANNER ( "CALL FITPAR_INI" )
      CALL FITPAR_INI ( IERR )
         IF ( IERR .NE. 0 ) GOTO 666 
+SELF.

      CALL CDTOPDIR_OUTPUT(STDOUT_UPDATE)  ! climb out of MONINIT subdir (Mar 2013)

+SELF,IF=PSNID.
      CALL PRBANNER ( "CALL PSNIDINI" )
      CALL PSNIDINI(IERR)
+SELF.

c -------------------------------------------------
c Let user initialize their stuff before SN are selected
c Aug 14 2014: move after CDTOPDIR call.
 
      CALL PRBANNER ( "CALL USRINI" )
      CALL USRINI ( IERR )
         IF ( IERR .NE. 0 ) GOTO 666 
           
c check command-line args after all inits
      CALL CHECK_LINE_ARGS()

c pak global survey info after all initialization (Mar 24 2013)
      IF ( USE_TABLEFILE .and. NFIT_PER_SN>0 ) CALL SNLCPAK_SURVEY() 


+SELF,IF=TESTFUNS.
      IF ( LTEST_MAG    ) CALL TEST_MAG
      IF ( LTEST_KCOR   ) CALL TEST_KCOR   
cc      IF ( LTEST_INTERP ) CALL TEST_INTERP(INTERP_OPT)
+SELF.


c ######################################################
c
c   Read and process SN data : USRANA and MINUIT FIT
c
c ######################################################


c ------------------------------
      JTIME_LOOPSTART = TIME()
      JDIFF = JTIME_LOOPSTART - JTIME_START

      CALL PRINT_CPUTIME(JTIME_START, "CPUTIME_INIT"//char(0), 
     &            "second"//char(0), 0, 20,20)

      call flush(6)
c ------------------------------

      DO ivers = 1, N_VERSION
         CALL PROCESS_DATA_VERSION(IVERS)
      ENDDO

c ------------------------------
      JTIME_LOOPEND = TIME()
c ------------------------------

       CALL SNANA_END()

c ###################
c  graceful end here
      CALL EXIT(0)
c ###################


c abort-end here

666   CONTINUE
      c1err = 'Fatal error in MAIN'
      CALL MADABORT("MAIN", c1err, "Check what gaver abort.")

      CALL EXIT(0)

      END  ! end MAIN program

C ==========================================

+PATCH,*DATA_IO.

C ==========================================


C ==========================================
+DECK,INIT_READ_DATA.
      SUBROUTINE INIT_READ_DATA()

c Created Feb 2021
c Initialization driver for reading data files.
c Called once during global init stage.

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER IVERS, INIT_NUM

C ------------ BEGIN -----------

c one-time init for both FITS and TEXT (since we don't know format yet)   
      INIT_NUM = 0

      INIT_NUM = INIT_NUM+1
      CALL RD_SNFITSIO_INIT(INIT_NUM)

      INIT_NUM = INIT_NUM+1
      CALL RD_SNTEXTIO_INIT(INIT_NUM)

c set flag to read header of 1st light curve to get global info
c (SURVEY, FILTERS ..) needed for initialization

      IVERS = 1

      CALL GETINFO_PHOTOMETRY(IVERS)

      CALL EXEC_READ_DATA(IVERS,OPTMASK_SNDATA_GLOBAL) 

      RETURN
      END    ! end INIT_READ_DATA

C =============================== 
+DECK,INIT_READ_OVERRIDE.
      SUBROUTINE INIT_READ_OVERRIDE()

c Created May 2023
c Wrapper to call C-function RD_OVERRIDE_INIT
c
c Oct 2023: pass REQ_DOC=1 to require DOCANA.
c

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
      INTEGER LENF_DATA, LENF_SIM, LEN_PRIV, REQ_DOC
      CHARACTER STR_TMP*(10*MXCHAR_FILENAME)

C ------------ BEGIN -----------

      CALL ENVreplace(HEADER_OVERRIDE_FILE)
      CALL ENVreplace(SIM_HEADER_OVERRIDE_FILE)

      LENF_DATA = INDEX(HEADER_OVERRIDE_FILE,' ') - 1
      LENF_SIM  = INDEX(SIM_HEADER_OVERRIDE_FILE,' ') - 1
      IF ( LENF_DATA > 0 .AND. LSIM_SNANA ) THEN
          print*,' '
          print*,' !=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!='
          print*,'    WARNING: HEADER_OVERRIDE_FILE ignored for sim'
          print*,' !=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!=!='
          print*,' '
      ENDIF

      REQ_DOC = 1  ! require DOCANA

      IF ( LENF_DATA > 0 ) THEN
       STR_TMP = HEADER_OVERRIDE_FILE(1:LENF_DATA)//char(0)
       CALL RD_OVERRIDE_INIT(STR_TMP, REQ_DOC, LENF_DATA)
      ENDIF
      IF ( LENF_SIM > 0 ) THEN
        STR_TMP = SIM_HEADER_OVERRIDE_FILE(1:LENF_SIM)//char(0)
        CALL RD_OVERRIDE_INIT(STR_TMP, REQ_DOC, LENF_SIM)
      ENDIF
     
      LEN_PRIV = INDEX(PRIVATE_VARNAME_READLIST,' ') -1
      IF ( LEN_PRIV > 0 ) THEN
         STR_TMP = PRIVATE_VARNAME_READLIST(1:LEN_PRIV)//char(0)
         CALL RD_PRIVATE_INIT(STR_TMP, REQ_DOC, LEN_PRIV) ! Sep 2023
      ENDIF

      RETURN
      END   ! end INIT_READ_OVERRIDE

C ==============================================
+DECK,PREP_VERSION_SUBFOLDER.
      SUBROUTINE PREP_VERSION_SUBFOLDER()

c Created Apr 7 2021
c If VERSION_PHOTOMETRY includes a sub-folder, e.g.,
c     'JLA2014/JLA2014_CSP'
c then reset VERSION_PHOTOMTRY = 'JLA2014_CSP' and update
c PRIVATE_DATA_PATH to be 
c      SNDATA_ROOT/JLA2014          ! if input path is ''
c      [PRIVATE_DATA_PATH]/JLA2014  ! if input path is not ''
c
c Constraints
c   - multiple versions must be under same folder
c   - more than one slash in VERSION_PHOTOMETRY -> abort
c   - $ in VERSION_PHOTOMETRY -> abort (no ENVs)
c  
c -------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER iver, jslash, LENV, LENP
      CHARACTER 
     &   VERSION_ORIG*(MXCHAR_VERSION)
     &  ,VERSION*(MXCHAR_VERSION)
     &  ,FOLDER*(MXCHAR_VERSION)

C ------------- BEGIN ------------

      DO iver = 1, N_VERSION
         VERSION_ORIG = VERSION_PHOTOMETRY(iver)
         jslash  = INDEX(VERSION_ORIG,'/')
         LENV    = INDEX(VERSION_ORIG,' ') - 1
         IF ( jslash > 0 ) THEN
            folder  = VERSION_ORIG(1:jslash-1)
            VERSION = VERSION_ORIG(jslash+1:LENV)
             VERSION_PHOTOMETRY(iver) = VERSION
             IF ( PRIVATE_DATA_PATH == ' ' ) THEN
               LENP = INDEX(SNDATA_ROOT,' ') - 1
               PRIVATE_DATA_PATH = SNDATA_ROOT(1:LENP) 
     &              // '/lcmerge/' // folder 
             ELSE
               LENP = INDEX(PRIVATE_DATA_PATH,' ') - 1
               PRIVATE_DATA_PATH = PRIVATE_DATA_PATH(1:LENP) 
     &              // '/' // folder
             ENDIF

c xxxxxxxxx
c            print*,' xxx -------------------------------------- '
c            print*,' xxx VERSION_ORIG = ', VERSION_ORIG(1:40)
c            print*,' xxx --> VERSION  = ', VERSION(1:40)
c            print*,' xxx --> PATH = ', PRIVATE_DATA_PATH(1:80)
c xxxxxxxxx

         ENDIF
      ENDDO

      RETURN
      END  ! end PREP_VERSION_SUBFOLDER


C ===========================================
+DECK,READ_CALIB_WRAPPER.
      SUBROUTINE READ_CALIB_WRAPPER(IERR)
c
c Ceated Nov 2022
c Wrapper subroutine to check if kcor/calib file is defined,
c and to call read-kcor function with appropriate args.
c [uses refactored C code]

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IERR  ! (O) return non-zero on error
      LOGICAL IGNOREFILE_fortran, USE_CALIB

      INTEGER LENF, OPT_FRAME, IFILT, IFILTDEF_OBS, IFILTDEF_REST
      CHARACTER*(MXCHAR_FILENAME) cCALIB_FILE, cFILTERS
      LOGICAL EXIST_KCOR_FILE

      REAL*8 
     &   D_MAGOBS_SHIFT_PRIM(MXFILT_ALL)
     &  ,D_MAGREST_SHIFT_PRIM(MXFILT_ALL)
     &  ,LAMAVG, LAMRMS, LAMMIN, LAMMAX, ZPOFF, MAG_PRIM

c external C codes
      REAL*8  GET_CALIB_ZPOFF_FILE, GET_CALIB_PRIMARY_MAG

      EXTERNAL
     &    FLOAT2DOUBLE       
     &   ,READ_CALIB_DRIVER
     &   ,GET_CALIB_FILTINDEX_MAP
     &   ,GET_CALIB_FILTLAM_STATS
     &   ,GET_CALIB_ZPOFF_FILE
     &   ,GET_CALIB_PRIMARY_MAG
     &   ,GET_CALIB_NFILTDEF
     &   ,EXIST_CALIB_BXFILT
     &   ,GET_KCOR_ZRANGE

c ---------- BEGIN ---------
   
      IERR = 0 


c Feb 20 2025: check for legacy KCOR_FILE input
      EXIST_KCOR_FILE  = .NOT. IGNOREFILE_fortran(KCOR_FILE)
      IF ( EXIST_KCOR_FILE ) CALIB_FILE = KCOR_FILE

c ----------
      EXIST_CALIB_FILE = .NOT. IGNOREFILE_fortran(CALIB_FILE)

      if ( .NOT. EXIST_CALIB_FILE ) RETURN

      USE_CALIB = .false.
+SELF,IF=SNFIT.
      USE_CALIB = .true.
+SELF.


c prep arguments ...

      CALL ENVreplace(CALIB_FILE)  ! Mar 2016

      LENF = INDEX(CALIB_FILE,' ') - 1
      cCALIB_FILE = CALIB_FILE(1:LENF) // char(0)
      cFILTERS    = SURVEY_FILTERS(1:NFILTDEF_SURVEY) // char(0)

c convert primary mag-shifts from sngl to double precision
      CALL FLOAT2DOUBLE(MXFILT_ALL, MAGREST_SHIFT_PRIMARY_FILT,
     &           D_MAGREST_SHIFT_PRIM )  ! <== returned
      CALL FLOAT2DOUBLE(MXFILT_ALL, MAGOBS_SHIFT_PRIMARY_FILT,
     &           D_MAGOBS_SHIFT_PRIM )  ! <== returned


c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

c read kcor file and store information (C code)

      CALL READ_CALIB_DRIVER(cCALIB_FILE, cFILTERS, USE_CALIB,
     &           D_MAGREST_SHIFT_PRIM, D_MAGOBS_SHIFT_PRIM)

c @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

c check for option to update filter trans for each SN
      CALL FILTER_UPDATE_INIT(IERR)

c - - - - - - -  - -
c load filter information from C struct to fortran common blocks

c OBS frame map is already loaded; get rest-frame map
      OPT_FRAME = OPT_FILTREST - 1
      CALL GET_CALIB_FILTINDEX_MAP(OPT_FRAME, NFILTDEF_REST,   
     &        IFILTDEF_MAP_REST, IFILTDEF_INVMAP_REST)
           
c fetch wavelength stats per band: AVG, RMS, MIN, MAX         
      OPT_FRAME = OPT_FILTOBS - 1
      DO ifilt = 1, NFILTDEF_SURVEY
         ifiltdef_obs = IFILTDEF_MAP_SURVEY(ifilt)
         LFILTDEF_OBS(ifiltdef_obs) = .TRUE.

         CALL GET_CALIB_FILTLAM_STATS(OPT_FRAME, IFILTDEF_OBS,
     &       LAMAVG, LAMRMS, LAMMIN, LAMMAX)
         FILTOBS_LAMAVG(ifiltdef_obs)     = sngl(LAMAVG)
         FILTOBS_LAMRMS(ifiltdef_obs)     = sngl(LAMRMS)
         FILTOBS_LAMRANGE(1,ifiltdef_obs) = sngl(LAMMIN)
         FILTOBS_LAMRANGE(2,ifiltdef_obs) = sngl(LAMMAX)

c     store primary mags
         MAG_PRIM = GET_CALIB_PRIMARY_MAG(OPT_FRAME,IFILTDEF_OBS)
         FILTOBS_MAG_PRIMARY(IFILTDEF_OBS) = MAG_PRIM

c       fetch ZPOFF from ZPOFF.DAT file in filter dir
         ZPOFF = GET_CALIB_ZPOFF_FILE(OPT_FRAME,ifiltdef_obs) 
         FILTOBS_ZPOFF_SNPHOT(ifiltdef_obs) = sngl(ZPOFF)
      ENDDO

      OPT_FRAME = OPT_FILTREST - 1
      DO ifilt = 1, NFILTDEF_REST
         ifiltdef_rest = IFILTDEF_MAP_REST(ifilt)
         LFILTDEF_REST(ifiltdef_rest) = .TRUE.
         CALL GET_CALIB_FILTLAM_STATS(OPT_FRAME, IFILTDEF_REST,
     &       LAMAVG, LAMRMS, LAMMIN, LAMMAX)
         FILTREST_LAMAVG(ifiltdef_rest)     = sngl(LAMAVG)
         FILTREST_LAMRMS(ifiltdef_rest)     = sngl(LAMRMS)
         FILTREST_LAMRANGE(1,ifiltdef_rest) = sngl(LAMMIN)
         FILTREST_LAMRANGE(2,ifiltdef_rest) = sngl(LAMMAX)

c     store primary mags
         MAG_PRIM = GET_CALIB_PRIMARY_MAG(OPT_FRAME,IFILTDEF_REST)
         FILTREST_MAG_PRIMARY(IFILTDEF_REST) = MAG_PRIM
      ENDDO

c misc tasks to store info

      CALL SET_ZPOFF()

c store number of obs-frame and rest-frame filters
      CALL GET_CALIB_NFILTDEF(NFILTDEF_OBS,NFILTDEF_REST)

c check if BX filter is defined for OBS and REST fram
      CALL EXIST_CALIB_BXFILT(EXIST_BXFILT_REST,EXIST_BXFILT_OBS)
cc      print*,' xxx EXIST(BX) = ', EXIST_BXFILT_REST,EXIST_BXFILT_OBS

      RETURN
      END  ! end READ_CALIB_WRAPPER


C ==========================================
+DECK,EXEC_READ_DATA.
      SUBROUTINE EXEC_READ_DATA(IVERS,OPTMASK)

c Created Feb 2021
c Driver to read & analyze data for input version.
c Use logicals FORMAT_FITS and FORMAT_TEXT for format-specific 
c function calls.
c This subroutine replaces legacy RDVERSION_FITS & RDVERSION_TEXT
c
c Oct 17 2023: read spectra only if using a REFORMAT option.
c Sep 03 2024: set LRDFLAG_SPEC=T for SIMLIB_OUTFILE
c ------

      IMPLICIT NONE

      INTEGER 
     &   IVERS     ! (I) ! version index to read
     &  ,OPTMASK   ! (I) ! indicates GLOBAL or ALL

+CDE,SNDATCOM.
+CDE,SNLCINP.

c local var

      INTEGER   NSN_VERS, LEN_VERS, LEN_PATH, OPTRD
      INTEGER   IJOB, NJOBTOT, ISN, ISTAT
      INTEGER*8 JTIME_EVENTSTART
      LOGICAL   LRDFLAG_GLOBAL, LRDFLAG_ALL, LRDFLAG_SPEC
      LOGICAL   REFORMAT_LOCAL, WR_SIMLIB_OUTFILE
      CHARACTER cVERSION*(MXCHAR_VERSION), cPATH*(MXCHAR_PATH)
      CHARACTER FNAM*16

c functions
      LOGICAL  LDONE_CIDLIST, IGNOREFILE_fortran
      INTEGER  RD_SNFITSIO_PREP, RD_SNTEXTIO_PREP
      EXTERNAL RD_SNFITSIO_PREP, RD_SNTEXTIO_PREP, RD_SNFITSIO_EVENT
      EXTERNAL PRINT_CPUTIME
      
C --------------- BEGIN -----------

      FNAM = 'EXEC_READ_DATA'
      LRDFLAG_GLOBAL = ( OPTMASK .EQ. OPTMASK_SNDATA_GLOBAL)
      LRDFLAG_ALL    = ( OPTMASK .EQ. OPTMASK_SNDATA_ALL   )

      REFORMAT_LOCAL    = (REFORMAT_SNANA .or. REFORMAT_SPECTRA_ONLY)
      WR_SIMLIB_OUTFILE = (.not. IGNOREFILE_fortran(SIMLIB_OUTFILE) )
      
      LRDFLAG_SPEC   = (REFORMAT_LOCAL .or. USE_TABLEFILE_MARZ .or.
     &                  WR_SIMLIB_OUTFILE)
     &                 .and. (DEBUG_FLAG .NE. -333)  ! -333 suppresses reading SPEC
	  
      ISNLC_VERSION    = IVERS

c get version and private data path for this version
      cVERSION = VERSION_PHOTOMETRY(ivers)
      LEN_VERS = INDEX(cVERSION,' ') - 1
      cVERSION = VERSION_PHOTOMETRY(ivers)(1:LEN_VERS) // char(0)

      LEN_PATH = INDEX(PRIVATE_DATA_PATH,' ') - 1
      cPATH    = PRIVATE_DATA_PATH(1:LEN_PATH) // char(0)

c read global info and store in SNDATA struct in sndata.h
      OPTRD = 0   ;   
      IF ( FORMAT_FITS ) THEN       
         IF ( LRDFLAG_GLOBAL )          OPTRD = OPTRD + 2
         IF ( .NOT. REFORMAT_SIMTRUTH ) OPTRD = OPTRD + 256
         NSN_VERS  = RD_SNFITSIO_PREP(OPTRD, cPATH, cVERSION,
     &                    LEN_PATH, LEN_VERS )
      ELSE
         IF ( DEBUG_FLAG == 1024 ) OPTRD = OPTRD + 1024 ! generic DUMP
         if ( LRDFLAG_GLOBAL .or. IVERS > 1 ) then
            NSN_VERS = RD_SNTEXTIO_PREP(OPTRD, cPATH, cVERSION, 
     &              LEN_PATH, LEN_VERS)
         endif
      ENDIF

      IF ( NSN_VERS > MXSNLC-1 ) THEN
        write(C1err,161) NSN_VERS, MXSNLC
161     format('NSN_VERS=',I8,' exceeds bound MXSNLC=',I8 )
        C2err = 'Check MXSNLC parameter in snana.car'
        CALL MADABORT(FNAM, c1err, c2err )
      ENDIF

      N_SNLC_READ(IVERS) = NSN_VERS 

c read SNDATA struct and tranfer global info to fortran variables
      if ( LRDFLAG_GLOBAL .OR. IVERS > 1 ) then
         CALL INIT_READ_OVERRIDE()      ! May 2023         
         CALL RDGLOBAL_DRIVER()
         CALL INIT_SURVEY(NSN_VERS)     ! init a few things
         IF ( LRDFLAG_GLOBAL ) RETURN
      endif

c - - - - - - - - 
c if we get here, read & process events

c strip off info for SPLITTING jobs among multiple CPUs.
      NJOBTOT = JOBSPLIT(2)    ! total number of split jobs
      IJOB    = JOBSPLIT(1)    ! do IJOB of NJOBTOT
      IF ( NJOBTOT .GT. 1 ) THEN
        write(6,20) JOBSPLIT
20      format(T5,'Process SPLIT-JOB ',I3,' of ', I3 )
      ENDIF

c ------------------------------------------------------
c LOOP OVER EVENTS

      DO 100 isn = IJOB, NSN_VERS, NJOBTOT ! every NJOBTOT'th SN
	 
         IF ( N_SNLC_FITCUTS >= MXLC_FIT ) GOTO 100 

         CALL INIT_SNLC()

         ! absolute index independent of cuts or SPLIT jobs;
         ! used as integer index if CID is a string (see CIDASSIGN)
         ABSO_INDEX = ABSO_OFFSET + isn

c read header for event and load SNDATA struct.
c Note that ISN is a fortran index starting at 1
        IF ( FORMAT_FITS ) THEN
           CALL RD_SNFITSIO_EVENT(OPTMASK_SNDATA_HEAD,ISN) ! C func
        ELSE IF ( FORMAT_TEXT ) THEN
           CALL RD_SNTEXTIO_EVENT(OPTMASK_SNDATA_HEAD,ISN) ! C func
        ENDIF

c transfer from C struct to global fortran variables
        CALL RDHEAD_DRIVER(istat) 

        if ( ISTAT < 0 ) GOTO 100    ! failed cut on header var/CID

c Read observations for event and load SNDATA C-struct.
c Read optional SPECTRA and load GENSPEC C-struct.
c All reading is done here to avoid STORE_PARSE_WORDS conflicts below.
        IF ( FORMAT_FITS ) THEN
           CALL RD_SNFITSIO_EVENT(OPTMASK_SNDATA_OBS,ISN)
           IF ( LRDFLAG_SPEC ) THEN
              CALL RD_SNFITSIO_EVENT(OPTMASK_SNDATA_SPEC,ISN)
           ENDIF

        ELSE IF ( FORMAT_TEXT ) THEN
           CALL RD_SNTEXTIO_EVENT(OPTMASK_SNDATA_OBS, ISN) 
           IF ( LRDFLAG_SPEC ) THEN
              CALL RD_SNTEXTIO_EVENT(OPTMASK_SNDATA_SPEC,ISN) 
           ENDIF
        ENDIF

c transfer variables from C struct to fortran global variables

        CALL RDOBS_DRIVER()  

        IF ( LRDFLAG_SPEC ) CALL RDSPEC_DRIVER(0)  

c ---------------------------------------------------------------

         IF ( ISTAT .EQ. 0 ) THEN
            N_SNLC_PROC = N_SNLC_PROC + 1 ! number of processed LC
            call PRINT_RDSN()      ! print one-line summary
            CALL SNANA_DRIVER(ISN,N_SNLC_PROC)
         ENDIF


c stop reading if/when all CIDs are processed
        IF ( LDONE_CIDLIST() ) GOTO 500  

 100  CONTINUE          ! end ISN loop

 500  CONTINUE

c Mar 2025: indicate DONE for this version so that last FITS files can be closed
      IF ( FORMAT_FITS ) THEN
         CALL RD_SNFITSIO_EVENT(OPTMASK_SNDATA_DONE, 0)
      ENDIF

      ABSO_OFFSET = ABSO_OFFSET + N_SNLC_READ(IVERS)

      RETURN
      END   ! end EXEC_READ_DATA

C ==========================================
+DECK,GETINFO_PHOT.
      SUBROUTINE GETINFO_PHOTOMETRY(ivers)

c Shell to use getInfo_PHOTOMETRY_VERION() function to 
c get path to data, full name of list file and
c full name of readme file. Also construct
c SNDATA_PREFIX
c

      IMPLICIT NONE

      INTEGER IVERS  ! (I) version index

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LEN_VERS, istat, L1, L2, L3
      CHARACTER*(2*MXCHAR_FILENAME)
     &   VERSION, PATH, LIST_FILE, README_FILE
      CHARACTER FNAM*20, FIRST_WORD*60

      INTEGER   GETINFO_PHOTOMETRY_VERSION
      EXTERNAL  GETINFO_PHOTOMETRY_VERSION, CHECK_FILE_DOCANA

C ----------------- BEGIN --------------
      FNAM = "GETINFO_PHOTOMETRY"

      VERSION  = VERSION_PHOTOMETRY(ivers) 
      LEN_VERS = INDEX(VERSION,' ') - 1
      VERSION  = VERSION(1:LEN_VERS)  // char(0)

      L1   =  INDEX(PRIVATE_DATA_PATH,' ') - 1
      PATH =  PRIVATE_DATA_PATH(1:L1) // char(0) 

      ISTAT = GETINFO_PHOTOMETRY_VERSION ( 
     &               VERSION,                        ! input
     &               PATH, LIST_FILE, README_FILE,   ! returned
     &               LEN_VERS, L1, L2, L3 )

      L1 = INDEX(PATH,char(0)) - 1
      IF ( L1 > MXCHAR_PATH ) then
         CALL PRINT_PREABORT_BANNER(FNAM//char(0),40)
         print*,' SNDATA_PATH = ', PATH(1:L1)
         write(c1err,61) 'SNDATA_PATH', L1, MXCHAR_PATH
         write(c2err,62)
         CALL MADABORT(FNAM, C1err, C2err)
      ENDIF
      SNDATA_PATH = PATH(1:L1)           ! fill global

61    format('LEN(',A,')=',I3, 
     &      ' is too long (MXCHAR_PATH=',I3,')')
161   format('LEN(',A,')=',I3, 
     &      ' is too long (MXCHAR_FILENAME=',I3,')')
62    format('Check $SNDATA_ROOT');

      L2 = INDEX(LIST_FILE,char(0)) - 1
      IF ( L2 > MXCHAR_FILENAME ) then
         CALL PRINT_PREABORT_BANNER(FNAM//char(0),40)
         print*,' LIST_FILE = ', LIST_FILE(1:L2)

         write(c1err,161) 'LIST_FILE', L2, MXCHAR_FILENAME
         write(c2err,62)
         CALL MADABORT(FNAM, C1err, C2err)
      ENDIF

      SNLIST_FILE = LIST_FILE(1:L2)      ! fill global

      L3 = INDEX(README_FILE,char(0)) - 1
      IF ( L3 > MXCHAR_FILENAME ) then
         CALL PRINT_PREABORT_BANNER(FNAM//char(0),40)
         print*,' README_FILE = ', README_FILE(1:L3)
         write(c1err,161) 'README_FILE', L3, MXCHAR_FILENAME
         write(c2err,62)
         CALL MADABORT(FNAM, C1err, C2err)
      ENDIF
      SNREADME_FILE(IVERS) = README_FILE(1:L3)  ! fill global

      CALL CHECK_FILE_DOCANA(REQUIRE_DOCANA,README_FILE,MXCHAR_FILENAME)

c - - - - - - - -       
c construct prefix = path/[version]
      SNDATA_PREFIX = SNDATA_PATH(1:L1) // 
     &       '/'  // VERSION(1:LEN_VERS) 

      RETURN
      END   ! end of GETINFO_PHOTOMETRY


C ==================================================
+DECK,DUMP_README.
      SUBROUTINE DUMP_README(IVERS)

c Created Jun 2011
c Dump README file to stdout for this version.
c
C Use global SNDATA_PREFIX to construct the name
C of the README file for this version.
c This code was moved from RDSNDATA so that it can be
c called for both TEXT and FITS format.
c
c Feb 26 2015: SNFILE_README already filled, so don't fill it here.
c Feb 14 2020: fix first abort message, use FNAM.
c

      IMPLICIT NONE

      INTEGER IVERS, IERR  ! (I/O) 

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER LEN_README, IERROPEN, L1, LL

      CHARACTER 
     &   CMD*(MXCHAR_FILENAME+20)
     &  ,FILENAME*(MXCHAR_FILENAME)
     &  ,VERSION*(MXCHAR_VERSION)
     &  ,FNAM*12

      EXTERNAL READ_YAML_VALS

c --------------- BEGIN --------------

      IERR = 0
      FNAM = 'DUMP_README'

      L1 = INDEX( SNDATA_PREFIX, ' ' ) - 1

      FILENAME = SNREADME_FILE(IVERS)

      OPEN(UNIT = LUNDMP, FILE = FILENAME, 
     &     IOSTAT = IERROPEN, STATUS='OLD')
      LEN_README = INDEX ( FILENAME, ' ' ) - 1
      CLOSE ( UNIT = LUNDMP )
      IF ( IERROPEN .NE. 0 ) THEN 
        CALL PRINT_PREABORT_BANNER(FNAM(1:10)//char(0),10)
        print*,' FILENAME = ', FILENAME
        C1err = 'Could not find README file '
        C2err = 'For FILENAME above.'
        CALL MADABORT(FNAM, c1err, c2err )
      ENDIF


      LEN_README = INDEX ( FILENAME, ' ' ) - 1
      write(cmd,50) FILENAME(1:LEN_README)
50    format('cat ', A )

      VERSION  = VERSION_PHOTOMETRY(ivers) 
      LL       = index(VERSION,' ') - 1

      GLOBAL_BANNER = " DUMP README FILE for VERSION " 
     &       // VERSION(1:LL)
      CALL PRBANNER ( global_banner(1:80) )

      print*, cmd
        CALL FLUSH(6)
        CALL SYSTEM ( cmd )
        CALL FLUSH(6)
      print*,' '


      RETURN
      END    ! end DUMP_README


C ===========================================
+DECK,RDGLOBAL.
      SUBROUTINE RDGLOBAL_DRIVER()

c Created Feb 2021
c Refactor to use SNDATA struct; same for FITS and TEXT format.
c Transfer global variables from SNDATA struct to fortran: 
c SURVEY, FILTERS, etc ...
c
c Apr 24 2021: read SIM_BIASCOR_MASK
c Oct 08 2021: read SIM_MODEL_INDEX
c Dec 02 2022: fix subtle (harmless?) bug setting ISCORRECT_SIGN_VPEC
c
      IMPLICIT NONE

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITSCOM.
+CDE,SPECCOM.

      REAL*8    DARRAY(MXEPOCH)
      INTEGER   OPT, LEN
      CHARACTER STRING*100
      LOGICAL   ISCORRECT_BUG, ISCORRECT_FIX

      LOGICAL   correct_sign_vpec_data
      EXTERNAL  correct_sign_vpec_data
C ------------------ BEGIN -------------
      
      OPT  = OPTMASK_SNDATA_GLOBAL
c     &     + OPTMASK_SNDATA_DUMP

      global_banner =
     &   "RDGLOBAL: FETCH GLOBAL SURVEY INFO from HEADER"
      CALL PRBANNER(global_banner(1:60) )

      SNANA_VERSION_DATA = ''
      CALL FETCH_SNDATA_WRAPPER("SNANA_VERSION", 
     &     ONE, SNANA_VERSION_DATA, DARRAY, OPT)
      LEN = INDEX(SNANA_VERSION_DATA,' ') - 1

      ISCORRECT_SIGN_VPEC = 
     &      correct_sign_vpec_data(SNANA_VERSION_DATA(1:LEN)//char(0))

      CALL FETCH_SNDATA_WRAPPER("SURVEY", ONE, 
     &        SURVEY_NAME, DARRAY, OPT)

      IF ( .NOT. FREEZE_SURVEY_FILTERS ) THEN
         CALL FETCH_SNDATA_WRAPPER("FILTERS", 
     &        ONE, SURVEY_FILTERS, DARRAY, OPT)
         NFILTDEF_READ = INDEX(SURVEY_FILTERS,' ')
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("DATATYPE", 
     &     ONE, DATATYPE, DARRAY, OPT)

      ! set global logical based on DATATYPE
      IF ( DATATYPE(1:4) .EQ. 'DATA' ) THEN
         ! do nothing         
      ELSE IF ( DATATYPE(1:9)  .EQ. 'SIM_SNANA' ) THEN
         LSIM_SNANA = .TRUE.   ! SNANA sim
      ELSE IF ( DATATYPE(1:10) .EQ. 'SIM_MAGOBS' ) THEN
         LSIM_MAGOBS = .TRUE.  ! e..g, fakes overlaid on images
      ELSE
        C1err = 'Unrecognized DATATYPE = ' // DATATYPE
        C2err = 'Check DATATYPE key in FITS header.'
        CALL MADABORT("RDGLOBAL", c1err, c2err )
      ENDIF

c Mar 2022: check option to re-write sims to look like real data
      IF ( LSIM_SNANA .and. .not. REFORMAT_SIMTRUTH ) then
          LSIM_SNANA = .FALSE.
          DATATYPE   = 'DATA'
      ENDIF

      ISJOB_SIM = (LSIM_SNANA .or. LSIM_MAGOBS)

      CALL FETCH_SNDATA_WRAPPER("NXPIX", ONE, STRING, DARRAY, OPT)
      SNLC_NXPIX = int(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("NYPIX", ONE, STRING, DARRAY, OPT)
      SNLC_NYPIX = int(DARRAY(1))

      CALL RDGLOBAL_PRIVATE(OPT)

      CALL RDGLOBAL_ZPHOT_Q(OPT)  ! May 2022

      IF ( LSIM_SNANA ) THEN
         CALL FETCH_SNDATA_WRAPPER("SIMLIB_FILE", 
     &        ONE, SIMLIB_FILENAME, DARRAY, OPT)

         CALL FETCH_SNDATA_WRAPPER("SIMLIB_MSKOPT", 
     &        ONE, STRING, DARRAY, OPT)
         SIMLIB_MSKOPT = int(DARRAY(1))

         CALL FETCH_SNDATA_WRAPPER("SIMOPT_MWCOLORLAW", 
     &        ONE, STRING, DARRAY, OPT)
         SIMOPT_MWCOLORLAW = int(DARRAY(1))

         CALL FETCH_SNDATA_WRAPPER("SIMOPT_MWEBV", 
     &        ONE, STRING, DARRAY, OPT)
         SIMOPT_MWEBV = int(DARRAY(1))

         CALL FETCH_SNDATA_WRAPPER("SIM_MWRV", 
     &        ONE, STRING, DARRAY, OPT)
         SIM_MWRV = SNGL(DARRAY(1))

         CALL FETCH_SNDATA_WRAPPER("SIM_VARNAME_SNRMON",
     &        ONE, SIMNAME_SNRMON, DARRAY, OPT)

         CALL FETCH_SNDATA_WRAPPER("SIM_BIASCOR_MASK", 
     &        ONE, STRING, DARRAY, OPT)
         SIM_BIASCOR_MASK = int(DARRAY(1))

         CALL FETCH_SNDATA_WRAPPER("SIM_MODEL_INDEX",  ! Oct 8 2021
     &       ONE, STRING, DARRAY, OPT)
         SIM_MODEL_INDEX = INT(DARRAY(1))

         CALL RDGLOBAL_SIMSED(OPT)

         CALL FETCH_SNDATA_WRAPPER("PySEDMODEL", 
     &       ONE, STRING, DARRAY, OPT)
         CALL RDGLOBAL_PySEDMODEL(OPT,STRING)

         CALL RDGLOBAL_LCLIB(OPT)

         CALL RDGLOBAL_SIM_HOSTLIB(OPT)

c xxx mark delete          CALL RDGLOBAL_SIM_COSPAR()

      ENDIF  ! end LSIM_SNANA block


      RETURN
      END  ! end RDGLOBAL_DRIVER


C =======================================
+DECK,FETCH_SNDATA_WRAPPER.
      SUBROUTINE FETCH_SNDATA_WRAPPER(KEY, NARG, STRINGVAL, DVAL, OPT)

c Created Feb 7 2021
c Fortran wrapper to call C function fetch_SNDATA
c Note that NARG must  be 1 for string; NARG can be >1 for DVALs
c Return STRINGVAL or DVAL

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,FITSCOM.

c function args
      CHARACTER KEY*(*)       ! (I) key name 
      INTEGER   NARG          ! (I) number of args to return 
      CHARACTER STRINGVAL*(*) ! (O) string value for key
      REAL*8    DVAL(*)       ! (O) double value(s) for key
      INTEGER   OPT           ! (I) options: 1-> dump
c local args
      INTEGER   LEN_KEY, LEN_STR, LEN_WHAT, COPYFLAG
      LOGICAL   L_GLOBAL, L_HEAD, L_OBS, L_DUMP, L_REQUIRE
      CHARACTER cSTRING*(MXLEN_EPSTRING), FNAM*22
      CHARACTER cKEY*60, c1err*80, c2err*80, WHAT*8
      EXTERNAL  COPY_SNDATA_GLOBAL, COPY_SNDATA_HEAD
      EXTERNAL  COPY_SNDATA_OBS

c ------------ BEGIN ----------

      FNAM = 'FETCH_SNDATA_WRAPPER'
      L_GLOBAL  = ( IAND(OPT,OPTMASK_SNDATA_GLOBAL)   > 0 ) 
      L_HEAD    = ( IAND(OPT,OPTMASK_SNDATA_HEAD)     > 0 ) 
      L_OBS     = ( IAND(OPT,OPTMASK_SNDATA_OBS )     > 0 ) 
      L_DUMP    = ( IAND(OPT,OPTMASK_SNDATA_DUMP)     > 0 ) 
      L_REQUIRE = ( IAND(OPT,OPTMASK_SNDATA_REQUIRE ) > 0 ) 

      LEN_KEY = INDEX(KEY//' ',' ') - 1
      cKEY    = KEY(1:LEN_KEY) // char(0)

      DVAL(1) = -9.0 ; STRINGVAL = 'NOTSET'

      COPYFLAG = -1  ! flag to copy from SNDATA struct to cSTRING or DVAL

      IF ( L_GLOBAL ) THEN
         CALL copy_SNDATA_GLOBAL(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)
         WHAT = "GLOBAL"
      ELSE IF ( L_HEAD ) THEN
         CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)
         WHAT = "HEAD"
      ELSE IF ( L_OBS ) THEN
         CALL copy_SNDATA_OBS(copyFlag, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)
         WHAT = "OBS"
      ELSE 
         write(C1ERR, '("Invalid OPT=",I6)' ) OPT
         C2ERR = 'KEY = ' // KEY
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF   
cc      print*,' xxx FETCH_WRAP: ',cKEY, cSTRING


      LEN_STR   = INDEX(cSTRING,char(0)) - 1
      STRINGVAL = cSTRING(1:LEN_STR) 
      LEN_WHAT  = INDEX(WHAT,' ') - 1

      if ( LEN_STR < 0 ) then
         LEN_STR   = INDEX(cSTRING//' ', ' ') - 1
         write(C1ERR,161) LEN_STR, MXLEN_EPSTRING
161      format('Returned strlen=', I6,' ~=  MXLEN_EPSTRING=', I6)
	 write(C2ERR,162) KEY, NARG
162      format('KEY=',A, 4x, 'NARG=', I6)
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      if ( L_DUMP ) then
         write(6,66) WHAT(1:LEN_WHAT), KEY(1:LEN_KEY), 
     &        STRINGVAL(1:LEN_STR), DVAL(1)
 66      format(' xxx FETCH_SNDATA_',A,': ', 
     &        A,' = |', A, '|', 5x, G10.4 )
      endif

      RETURN
      END     ! end FETCH_SNDATA_WRAPPER.

C =======================================
+DECK,FETCH_GENSPEC_WRAPPER.
      SUBROUTINE FETCH_GENSPEC_WRAPPER(KEY, ISPEC, DVAL, OPT)

c Created Feb 18 2021
c Fortran wrapper to call C function copy_GENSPEC.
c Returns DVAL array. Calling function must be careful
c to provide adequate DVAL array size.
c 

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,FITSCOM.

c function args
      CHARACTER KEY*(*)       ! (I) key name 
      INTEGER   ISPEC         ! (I) spectrum index 
      REAL*8    DVAL(*)       ! (O) double value(s) for key
      INTEGER   OPT           ! (I) options: 1-> dump
c local args
      INTEGER   LEN_KEY, COPYFLAG, cISPEC
      CHARACTER cKEY*60
      LOGICAL   L_DUMP
      EXTERNAL  COPY_GENSPEC

c ------------ BEGIN ----------

      LEN_KEY = INDEX(KEY//' ',' ') - 1
      cKEY    = KEY(1:LEN_KEY) // char(0)
      cISPEC  = ISPEC - 1  ! C index for GENSPEC

      DVAL(1) = -9.0 ! init output arg
      COPYFLAG = -1  ! flag to copy from GENSPEC struct to DVAL

      CALL copy_GENSPEC(COPYFLAG, cKEY, cISPEC, DVAL)

      L_DUMP   = ( IAND(OPT,OPTMASK_SNDATA_DUMP) > 0 ) 
      if ( L_DUMP ) then
         write(6,66) KEY(1:LEN_KEY), ISPEC, DVAL(1),DVAL(2),DVAL(3)
 66      format(' xxx FETCH_GENSPEC: ', A8, '(',I2,') = ', 3G12.3 )
      endif

      RETURN
      END     ! end FETCH_GENSPEC_WRAPPER.


C =================================
+DECK,RDGLOB_PRIVATE.
      SUBROUTINE RDGLOBAL_PRIVATE(OPT)

c Refactored Feb 2021 to use SNDATA struct in sndata.h.
c  (previous name was RDPRIVATE_FITS)
c Read/parse names of PRIVATE keys from header if NVAR_PRIVATE > 0
c

      IMPLICIT NONE

      INTEGER   OPT  ! (I)  1 -> dump flag for FETCH_SNDATA_WRAPPER

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.


      INTEGER   IVAR, LEN
      REAL*8    DARRAY(MXVAR_PRIVATE)
      CHARACTER DUMSTRING*10, cnum*2, KEYNAME*20, KEYWORD*60
      CHARACTER VARNAME(20)*60
      LOGICAL   MATCH_VARNAME 

C -------------- BEGIN ---------------

      CALL FETCH_SNDATA_WRAPPER("NVAR_PRIVATE", 
     &     ONE, DUMSTRING, DARRAY, OPT)
      NVAR_PRIVATE = int(DARRAY(1))

cc      print*,' xxx OPT, NVAR_PRIVATE = ', OPT, NVAR_PRIVATE

      IF ( NVAR_PRIVATE .LE. 0 ) RETURN

      IF( NVAR_PRIVATE > MXVAR_PRIVATE ) THEN
         write(C1ERR,61) NVAR_PRIVATE, MXVAR_PRIVATE 
 61      format('NVAR_PRIVATE=',I4,' exceeds MXVAR_PRIVATE=',I4 )
         C2ERR = 'Check XXX_HEAD.FITS file'
         CALL MADABORT("RDGLOBAL_PRIVATE", C1ERR, C2ERR)
      ENDIF
c ----------------------------------------------

      DO 100 ivar = 1, NVAR_PRIVATE

        if ( ivar < 10 ) then
           write(cnum, '(I1)') ivar
        else
           write(cnum, '(I2)') ivar
        endif

        KEYNAME = "PRIVATE" // CNUM
        CALL FETCH_SNDATA_WRAPPER(KEYNAME, 
     &     ONE, KEYWORD, DARRAY, OPTMASK_SNDATA_GLOBAL )           

        PRIVATE_KEYWORD(ivar) = KEYWORD    ! load common block
        CALL PARSE_PRIVATE_KEYWORD(KEYWORD,ivar)

100   CONTINUE

      CALL FLUSH(6)

      RETURN
      END  ! end of RDGLOBAL_PRIVATE


C =================================
+DECK,RDGLOB_ZPHOT_Q.
      SUBROUTINE RDGLOBAL_ZPHOT_Q(OPT)

c Created May 12 2022
c Read/parse names host galaxy photo-z quantiles that determine
c column names. E.g., percentile 20 means HOSTGAL_ZPHOT_Q020 exists.
c

      IMPLICIT NONE

      INTEGER   OPT  ! (I)  1 -> dump flag for FETCH_SNDATA_WRAPPER

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      INTEGER   IVAR, q, PCT
      REAL*8    DARRAY(MXZPHOT_Q)
      CHARACTER DUMSTRING*10, cnum*2, KEYNAME*20, KEYWORD*80

C -------------- BEGIN ---------------

      CALL FETCH_SNDATA_WRAPPER("NZPHOT_Q", 
     &     ONE, DUMSTRING, DARRAY, OPT)
      SNHOST_NZPHOT_Q = int(DARRAY(1))

      IF ( SNHOST_NZPHOT_Q .LE. 0 ) RETURN

      IF( SNHOST_NZPHOT_Q > MXZPHOT_Q ) THEN
         write(C1ERR,61) SNHOST_NZPHOT_Q, MXZPHOT_Q
 61      format('NZPHOT_Q=',I4,' exceeds MXZPHOT_Q=',I4 )
         C2ERR = 'Check XXX_HEAD.FITS file'
         CALL MADABORT("RDGLOBAL_ZPHOT_Q", C1ERR, C2ERR)
      ENDIF
c ----------------------------------------------

      DO 100 ivar = 1, SNHOST_NZPHOT_Q 

        q = ivar - 1 ! C index 0 to N-1
        write(cnum, '(I2.2)') q
        KEYNAME = "PERCENTILE_ZPHOT_Q" // CNUM
        CALL FETCH_SNDATA_WRAPPER(KEYNAME, 
     &     ONE, KEYWORD, DARRAY, OPTMASK_SNDATA_GLOBAL )

        PCT = INT(DARRAY(1))
        SNHOST_ZPHOT_PERCENTILE(ivar) = SNGL(DARRAY(1))

c load varname for each HOSTGAL match; e.g., HOSTGAL_ZPHOT_Q030
        write(VARNAME_ZPHOT_Q(1,ivar),102) 'HOSTGAL',  PCT
        write(VARNAME_ZPHOT_Q(2,ivar),102) 'HOSTGAL2', PCT
102     format(A,'_ZPHOT_Q', I3.3)

100   CONTINUE

      write(6,40) SNHOST_NZPHOT_Q
40    format(T5,'Found NZPHOT_Q = ', I3, ' quantiles for HOST-zPHOT')
      CALL FLUSH(6)

      RETURN
      END  ! end of RDGLOBAL_ZPHOT_Q

C =======================================
+DECK,RDGLOB_SIMSED.
      SUBROUTINE RDGLOBAL_SIMSED(OPT)

c Refactored Feb 2021 (previous name: RDFITSHEAD_SIMSED_LEGACY)
c Read/parse SIMSED keys from header if NPAR_SIMSED exists.
c

      IMPLICIT NONE
      INTEGER OPT   ! (I) 1 -> dump 

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FITSCOM. 
      INTEGER   ipar, ipar_read, LENWD, IPAR_OFF, OPT_LOCAL
      REAL*8    DARRAY(MXPAR_SIMSED)
      CHARACTER DUM*20, KEYNAME*40, KEYWORD*80, c2*2, PARNAME*60

C -------------- BEGIN ---------------

      OPT_LOCAL = OPT

      CALL FETCH_SNDATA_WRAPPER("SIMSED_NPAR",ONE,DUM,DARRAY,OPT_LOCAL)
      NPAR_SIMSED = int(DARRAY(1))

      IF ( NPAR_SIMSED .LE. 0 ) RETURN

c ----------------------------------------------
c SIMSED before Dec 2018 had SIMSED_PAR01  to SIMSED_PAR[NN].
c After refactor, it is SIMSED_PAR00 to N-1.
c For back compatibility, check for SIMSED_PAR00/

      CALL FETCH_SNDATA_WRAPPER("SIMSED_PAR00", 
     &     ONE, KEYNAME, DARRAY, OPT_LOCAL)

      IF ( INDEX(KEYNAME,' ') > 2 ) THEN
         IPAR_OFF = 0  ! 0 to N-1 for SIMSED index after Dec 2018
      ELSE
         IPAR_OFF = 1  ! 1-N before Dec 2018 (e.g., PLASTICC)
      ENDIF     

      DO 100 ipar = 1, NPAR_SIMSED
        ipar_read = ipar + IPAR_OFF - 1   ! C-like index
        write(c2, '(I2.2)' ) ipar_read
        KEYNAME = "SIMSED_PAR" // C2 // char(0)
        CALL FETCH_SNDATA_WRAPPER(KEYNAME,ONE,KEYWORD,DARRAY,OPT_LOCAL)
       
        LENWD = INDEX(KEYWORD,' ') - 1
        CALL PARSE_PARENTHESES(KEYWORD(1:LENWD), PARNAME)
        SIMSED_KEYWORD(IPAR) = KEYWORD(1:LENWD) ! key(varname)
        SIMSED_PARNAME(IPAR) = PARNAME(1:20)    ! extracted varname

100   CONTINUE


      CALL FLUSH(6)

      RETURN
      END  ! end of RDGLOBAL_SIMSED

C =======================================
+DECK,RDGLOB_PySEDMODEL.
      SUBROUTINE RDGLOBAL_PySEDMODEL(OPT,MODEL_NAME)

c Created Dec 10 2018
c Refactored Feb 2021 to use SNDATA struct.
c
c Read/parse PySEDMODEL keys from header if NPAR_[BYOSED,SNEMO] exists.

      IMPLICIT NONE

      INTEGER   OPT            ! (I) 1 -> dump
      CHARACTER MODEL_NAME*(*) ! (I) e.g., 'BYOSED', 'SNEMO'
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   ipar, LENM, LENVAL, NPAR_LOCAL
      CHARACTER KEYNAME*80, KEYVAL*80, c2*2, PARNAME*60
      LOGICAL   LDMP, LVALID
      REAL*8    DARRAY(4)

C -------------- BEGIN ---------------

      LENM   = INDEX(MODEL_NAME,' ') - 1
      LVALID = .FALSE.
      IF ( MODEL_NAME(1:6) .EQ. 'BYOSED' ) LVALID = .TRUE.
      IF ( MODEL_NAME(1:5) .EQ. 'SNEMO'  ) LVALID = .TRUE.

c      print*,'    xxx MODEL_NAME, LVALID = ', 
c     &      MODEL_NAME(1:LENM), LVALID

      if ( .not. LVALID ) RETURN

      KEYNAME   = MODEL_NAME(1:LENM) // "_NPAR" 
      CALL FETCH_SNDATA_WRAPPER(KEYNAME, ONE, KEYVAL, DARRAY, OPT)

      LDMP = .FALSE.
      IF ( LDMP ) THEN
         print*,' xxx -------------------------------------- '
         print*,' xxx **** DUMP RDFITSHEAD_PySEDMODEL ***** '
         print*,' xxx MODEL_NAME = ', MODEL_NAME
         print*,' xxx KEYNAME    = ', KEYNAME(1:40)
         print*,' xxx KEYVAL     = ', KEYVAL(1:40)
      ENDIF

      NPAR_LOCAL = int(DARRAY(1))
      IF ( NPAR_LOCAL .LE. 0 ) RETURN

c ----------------------------------------------
c load global NPAR and MODEL_NAME
      NPAR_PySEDMODEL = NPAR_LOCAL
      PySEDMODEL_NAME = MODEL_NAME(1:LENM)

      DO 100 ipar = 1, NPAR_PySEDMODEL
        write(c2, '(I2.2)') ipar-1
        KEYNAME = MODEL_NAME(1:LENM) // "_PAR" // C2

        CALL FETCH_SNDATA_WRAPPER(KEYNAME, ONE, KEYVAL, DARRAY, OPT)

        LENVAL  = INDEX(KEYVAL,' ') - 1

        CALL PARSE_PARENTHESES(KEYVAL(1:LENVAL), PARNAME)
        PySEDMODEL_KEYWORD(IPAR) = KEYVAL(1:LENVAL) ! key(varname)
        PySEDMODEL_PARNAME(IPAR) = PARNAME(1:20)  ! extracted varname

100   CONTINUE

      CALL FLUSH(6)

      RETURN
      END  ! end of RDGLOBAL_PySEDMODEL

C =======================================
+DECK,RDGLOB_LCLIB.
      SUBROUTINE RDGLOBAL_LCLIB(OPT)

c Feb 2018
c Read/parse LCLIB keys from header if NPAR_LCLIB exists.
c

      IMPLICIT NONE

      INTEGER  OPT  ! (I) 
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   ipar, LENVAL
      REAL*8    DARRAY(4)
      CHARACTER KEYNAME*80, KEYVAL*80, c2*2, PARNAME*60

C -------------- BEGIN ---------------

      CALL FETCH_SNDATA_WRAPPER("LCLIB_NPAR",
     &       ONE, KEYVAL, DARRAY, OPT)

      NPAR_LCLIB = INT(DARRAY(1))
      IF ( NPAR_LCLIB .LE. 0 ) RETURN

c ----------------------------------------------

      DO 100 ipar = 1, NPAR_LCLIB
        write(c2, '(I2.2)') ipar-1
        KEYNAME = "LCLIB_PAR" // C2 
        CALL FETCH_SNDATA_WRAPPER(KEYNAME,
     &       ONE, KEYVAL, DARRAY, OPT)

        LENVAL  = INDEX(KEYVAL,' ') - 1
        CALL PARSE_PARENTHESES(KEYVAL(1:LENVAL), PARNAME)
        LCLIB_KEYWORD(IPAR) = KEYVAL(1:LENVAL) ! key(varname)
        LCLIB_PARNAME(IPAR) = PARNAME(1:20)  ! extracted varname

100   CONTINUE
      CALL FLUSH(6)
      RETURN
      END  ! end of RDGLOBAL_LCLIB

C =======================================
+DECK,RDGLOBAL_HOSTLIB.
      SUBROUTINE RDGLOBAL_SIM_HOSTLIB(OPT)

c Created Feb 2021 [refactored from RDFITSHEAD_SIM_HOSTLIB]
c Read/parse SIM_HOSTLIB keys from header if NPAR_SIM_HOSTLIB exists.
c These are extra HOSTLIB params used in wgtmaps, etc ...

      IMPLICIT NONE
      
      INTEGER OPT  ! (I)

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   ipar, LENVAL
      REAL*8    DARRAY(4)
      CHARACTER KEYNAME*80, KEYVAL*80, c2*2, PARNAME*60

C -------------- BEGIN ---------------

      CALL FETCH_SNDATA_WRAPPER("SIM_HOSTLIB_NPAR",
     &       ONE, KEYVAL, DARRAY, OPT)

      NPAR_SIM_HOSTLIB = INT(DARRAY(1))
      IF ( NPAR_SIM_HOSTLIB .LE. 0 ) RETURN
c ----------------------------------------------

      DO 100 ipar = 1, NPAR_SIM_HOSTLIB
        write(c2, '(I2.2)' ) ipar-1  ! C like index
        KEYNAME = "SIM_HOSTLIB_PAR" // C2 

        CALL FETCH_SNDATA_WRAPPER(KEYNAME,
     &       ONE, KEYVAL, DARRAY, OPT)

        LENVAL = INDEX(KEYVAL,' ') - 1
        CALL PARSE_PARENTHESES(KEYVAL(1:LENVAL), PARNAME)
        SIM_HOSTLIB_KEYWORD(IPAR) = KEYVAL(1:LENVAL) ! key(varname)
        SIM_HOSTLIB_PARNAME(IPAR) = PARNAME ! extracted varname

100   CONTINUE
      CALL FLUSH(6)
      RETURN
      END  ! end of RDGLOBAL_SIM_HOSTLIB

C ========================================
+DECK,RDGLOBAL_SIM_COSPAR.
      SUBROUTINE RDGLOBAL_SIM_COSPAR()
c
c Created Mar 2023
c Read simulated cosmology parameters from yaml-README 
c (instead of from data header)

      IMPLICIT NONE
+CDE,SNDATCOM.

      INTEGER LEN
      REAL*8 SIM_COSPAR(20)
      CHARACTER FNAM*24, KEYLIST*100, FILENAME*(MXCHAR_FILENAME)

c ------------- BEGIN --------------

      FNAM    = 'RDGLOBAL_SIM_COSPAR' // char(0)
      KEYLIST = 'OMEGA_MATTER,OMEGA_LAMBDA,w0_LAMBDA,wa_LAMBDA,MUSHIFT'
     &           //char(0)

      LEN = INDEX(SNREADME_FILE(1),' ') - 1
      FILENAME = SNREADME_FILE(1)(1:LEN) // char(0)

      CALL READ_YAML_VALS(FILENAME, KEYLIST, FNAM,
     &                      SIM_COSPAR) ! return SIM_COSPAR

c store cosmo params in globals

c xxxxxxx mark delete May 19 2025 xxxxxxx
c      SIM_OM = SIM_COSPAR(1)
c      SIM_OL = SIM_COSPAR(2)
c      SIM_w0 = SIM_COSPAR(3)
c      SIM_wa = SIM_COSPAR(4)
c      SIM_MUSHIFT = SIM_COSPAR(5)
c xxxxxxxxxxxxx end mark xxxxxxx

      RETURN
      END   ! end RDGLOBAL_SIM_COSPAR

C ===========================================
+DECK,RDHEAD_DRIVER.
      SUBROUTINE RDHEAD_DRIVER(ISTAT)

c Created Feb 2021 [refactored from PARSE_HEAD]
c Read header info and apply a few selection cuts to rapidly
c select small subsets:
c
c   CID
c   SNTYPE
c   REDSHIFT_ERR ??
c
      IMPLICIT NONE

      INTEGER ISTAT  ! (O) < 0 -> reject event

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER OPT, igal, CID
      REAL*8  DARRAY(10), TMPCUT
      CHARACTER STRING*100, FNAM*14
      LOGICAL   USECID

c functions
      INTEGER  GET_IDSURVEY
      LOGICAL  PASS_SNTYPE
cc xxx mark      EXTERNAL RD_SNFITSIO_EVENT, RD_SNTEXTIO_EVENT

C -------------- BEGIN ------------

      ISTAT = 0
      FNAM  = 'RDHEAD_DRIVER'

c - - - - -
c fetch SNDATA values and load fortran globals

      OPT = OPTMASK_SNDATA_HEAD 
c     &    + OPTMASK_SNDATA_DUMP

      DARRAY(1) = -999.0
      STRING    = ''

      CALL FETCH_SNDATA_WRAPPER("SUBSURVEY", 
     &     ONE, STRING, DARRAY, OPT)
      IF ( INDEX(STRING,' ') > 2 ) THEN
         SUBSURVEY_NAME = STRING(1:MXCHAR_SURVEY)
         IDSUBSURVEY    = GET_IDSURVEY(SUBSURVEY_NAME)
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("SNID", 
     &     ONE, SNLC_CCID, DARRAY, OPT)
      ISNLC_LENCCID = INDEX(SNLC_CCID,' ') - 1
      call checkString_CCID(SNLC_CCID)   ! abort if illegal char in name

      CALL FETCH_SNDATA_WRAPPER("NAME_IAUC", 
     &     ONE, SNLC_NAME_IAUC, DARRAY, OPT)
      ISNLC_LENIAUC = INDEX(SNLC_NAME_IAUC,' ') - 1
      call checkString_CCID(SNLC_NAME_IAUC) ! abort if illegal char in name
      IF ( WRTABLEFILE_IAUC .and. ISNLC_LENIAUC > 0 ) THEN
         SNLC_CCID      = SNLC_NAME_IAUC
         ISNLC_LENCCID  = ISNLC_LENIAUC
      ENDIF     

      CALL FETCH_SNDATA_WRAPPER("NAME_TRANSIENT",  ! July 2024
     &     ONE, SNLC_NAME_TRANSIENT, DARRAY, OPT)
      ISNLC_LENNAME = INDEX(SNLC_NAME_TRANSIENT,' ') - 1
      call checkString_CCID(SNLC_NAME_TRANSIENT)   ! abort if illegal char in name

c - - - - - - - - - - - - - - - - - - - - - - - - - -
c Convert CCID to integer CID, and check if this CCID is selected.
      CALL PARSE_CID( SNLC_CCID, SNLC_NAME_IAUC,    ! inputs
     &                  CID, USECID)                ! returns args
      SNLC_CID  = CID   ! load integer CID
      if ( .NOT. USECID ) then 
         ISTAT = ISTAT_SKIP;  RETURN
      endif
c - - - - - - - - - - - - - - - - - - - - - - - - - -

      CALL FETCH_SNDATA_WRAPPER("FAKE", 
     &     ONE, STRING, DARRAY, OPT)
      ISNLC_FAKE = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("RA",  ONE, STRING, DARRAY,  OPT)
      SNLC8_RA = DARRAY(1)

      CALL FETCH_SNDATA_WRAPPER("DEC", ONE, STRING, DARRAY, OPT)
      SNLC8_DEC = DARRAY(1)

      CALL FETCH_SNDATA_WRAPPER("PIXSIZE", ONE, STRING, DARRAY, OPT)
      SNLC_PIXSIZE = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("NXPIX", ONE, STRING, DARRAY, OPT)
      SNLC_NXPIX = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("NYPIX", ONE, STRING, DARRAY, OPT)
      SNLC_NYPIX = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SNTYPE", ONE, STRING, DARRAY, OPT)
      ISNLC_TYPE = INT(DARRAY(1))
      IF ( ISNLC_TYPE == -9 ) ISNLC_TYPE = 0 ! Jun 17 2022
      IF ( .NOT. PASS_SNTYPE(ISNLC_TYPE) ) THEN
         ISTAT = ISTAT_SKIP;  RETURN
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("MWEBV", ONE, STRING, DARRAY, OPT)
      SNLC_MWEBV = SNGL(DARRAY(1))
      SNLC_MWEBV_ERR = SNLC_MWEBV * sngl(XTMW_FRACERR)  ! default error

      TMPCUT = 1.0E-12
      IF ( RESTORE_MWEBV_ERR_BUG ) TMPCUT = 0.001
      CALL FETCH_SNDATA_WRAPPER("MWEBV_ERR", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) .GE. TMPCUT ) THEN 
         SNLC_MWEBV_ERR = SNGL(DARRAY(1))  ! override default error
      ENDIF

c - - - - - 
c read MJD-related variables (PEAK, trigger, first & last detection)
      CALL FETCH_SNDATA_WRAPPER("PEAKMJD", ONE, STRING, DARRAY, OPT)
      SNLC_SEARCH_PEAKMJD = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("MJD_TRIGGER", 
     &        ONE, STRING, DARRAY, OPT)
      SNLC8_MJD_TRIGGER = DARRAY(1)

      CALL FETCH_SNDATA_WRAPPER("MJD_DETECT_FIRST", 
     &        ONE, STRING, DARRAY, OPT)
      SNLC8_MJD_DETECT_FIRST = DARRAY(1)

      CALL FETCH_SNDATA_WRAPPER("MJD_DETECT_LAST", 
     &        ONE, STRING, DARRAY, OPT)
      SNLC8_MJD_DETECT_LAST = DARRAY(1)

c - - - - - -

      CALL FETCH_SNDATA_WRAPPER("NOBS", ONE, STRING, DARRAY, OPT)
      ISNLC_NEWMJD_FOUND = INT(DARRAY(1)) 

      CALL RDHEAD_REDSHIFT(OPT)

      DO igal = 1, MXSNHOST
         CALL RDHEAD_HOSTGAL(OPT,igal)
      ENDDO

      CALL RDHEAD_PRIVATE(OPT)

      IF ( LSIM_SNANA ) THEN
         CALL RDHEAD_SIM_SNANA(OPT)

c   reject event if user doesn't want to process true SNIa or NONIa
         if ( .NOT. USESIM_SNIA  .and. LSIM_TRUE_SNIa) THEN
	     ISTAT = ISTAT_SKIP ; RETURN
	 endif
         if ( .NOT. USESIM_NONIa .and. LSIM_TRUE_NONIa)  THEN
	    ISTAT = ISTAT_SKIP; RETURN
         endif

      ENDIF
      
      RETURN
      END   ! end RDHEAD_DRIVER

C ============================================
+DECK,RDHEAD_PRIVATE.
      SUBROUTINE RDHEAD_PRIVATE(OPT)

c Created Feb 2021 to read PRIVATE variables (pass from SNDATA struct)

      IMPLICIT NONE

      INTEGER OPT    ! OPT is arg for WRAPPER

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      INTEGER ivar, NVAR
      REAL*8 DARRAY(4)
      CHARACTER STRING*12, KEY*60

C ------------ BEGIN ---------

      NVAR = NVAR_PRIVATE
      DO ivar = 1, NVAR         
         KEY  = PRIVATE_KEYWORD(IVAR)
         CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
         PRIVATE_VALUE(IVAR) = DARRAY(1)
      ENDDO

      RETURN
      END   ! end RDHEAD_PRIVATE

C ============================================
+DECK,RDHEAD_HOSTGAL.
      SUBROUTINE RDHEAD_HOSTGAL(OPT,igal)

C Created Feb 9 2021 [refactored from PARSE_HOSTGAL]
c Transfer HOSTGAL info from SNDATA struct (sndata.h)
c to common block variable.s
c
c Mar 25 2021: fix bug setting EXIST_SNHOST_SB
c May 11 2021: read HOSTGAL_MAG (forgotten in I/O refactor)
c May 21 2021: read HOSTGAL_FLAG
c May 11 2022: read ZPHOT_Q

      IMPLICIT NONE

      INTEGER OPT, igal  ! OPT is arg for WRAPPER, igal is host index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
      INTEGER   LENPRE, ifilt, q
      CHARACTER PREFIX*20, STRING*40, KEY*60, KEY_PREFIX*60
      REAL*8    DARRAY(MXFILT_OBS), SB, MAG, zq
      LOGICAL LTMP, LZQ

C -------------- BEGIN ----------
      
      CALL SET_HOSTGAL_PREFIX(IGAL,PREFIX,LENPRE)

C Start with items that only appear once;
c i.e., do not depend on host-match.

      IF ( IGAL == 1 ) THEN

         CALL FETCH_SNDATA_WRAPPER("HOSTGAL_NMATCH", 
     &        ONE, STRING, DARRAY, OPT)
         SNHOST_NMATCH = INT(DARRAY(1))

         CALL FETCH_SNDATA_WRAPPER("HOSTGAL_NMATCH2", 
     &        ONE, STRING, DARRAY, OPT)
         SNHOST_NMATCH2 = INT(DARRAY(1))

         KEY_PREFIX = "HOSTGAL_SB_FLUXCAL"
         CALL RDHEAD_FILTERLOOP(KEY_PREFIX, SNHOST_SBFLUXCAL, OPT)
         DO ifilt = 1, NFILTDEF_READ
            SB = SNHOST_SBFLUXCAL(ifilt)
            if ( SB > -998.0 ) EXIST_SNHOST_SB = .TRUE.
         ENDDO

         KEY_PREFIX = "HOSTGAL_MAG"
         CALL RDHEAD_FILTERLOOP(KEY_PREFIX, SNHOST_MAGOBS, OPT)
         DO ifilt = 1, NFILTDEF_READ
            MAG   = SNHOST_MAGOBS(ifilt,1)
            if ( MAG > -998.0 ) EXIST_SNHOST_MAGOBS = .TRUE. 
         ENDDO

         KEY_PREFIX = "HOSTGAL_SB_FLUXCAL"
         CALL RDHEAD_FILTERLOOP(KEY_PREFIX, SNHOST_SBFLUXCAL, OPT)
         DO ifilt = 1, NFILTDEF_READ
            SB = SNHOST_SBFLUXCAL(ifilt)
            if ( SB > -998.0 ) EXIST_SNHOST_SB = .TRUE.
         ENDDO
        
      ENDIF  ! end IGAL=1

c - - - - - - - - 

      KEY    = PREFIX(1:LENPRE)//'_OBJID'
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_OBJID(igal)  = INT8(DARRAY(1))
      DSNHOST_OBJID(igal) = DARRAY(1)

      KEY    = PREFIX(1:LENPRE)//'_FLAG'
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_FLAG(igal)  = INT(DARRAY(1))

c - - - 
      KEY    = PREFIX(1:LENPRE)//'_PHOTOZ'
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_ZPHOT(igal)     = SNGL(DARRAY(1)) 

      KEY    = PREFIX(1:LENPRE)//'_PHOTOZ_ERR'
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_ZPHOT_ERR(igal) = SNGL(DARRAY(1))

c read ZPHOT_Q (May 2022)
      if ( SNHOST_NZPHOT_Q > 0 ) then
        DO q = 1, SNHOST_NZPHOT_Q
          KEY = VARNAME_ZPHOT_Q(igal,q)
          CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
          SNHOST_ZPHOT_Q(igal,q) = SNGL(DARRAY(1)) 
        ENDDO

        SNHOST_QZPHOT_MEAN(igal) = -9.0
	SNHOST_QZPHOT_STD(igal)  = -9.0	
	
c          print*,' xxx ------------------------------------------- '
c          print*,' xxx CID ,igal = ', SNLC_CCID, igal
c          print*,' xxx SNHOST_ZPHOT_Q = ', SNHOST_ZPHOT_Q(igal,1:12)
      endif      

      IF ( SNHOST_ZPHOT(igal) > 0.0 ) EXIST_SNHOST_ZPHOT = .TRUE.
c - - - -

      KEY    = PREFIX(1:LENPRE)//'_SPECZ' 
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_ZSPEC(igal)     = SNGL(DARRAY(1))

      KEY    = PREFIX(1:LENPRE)//'_SPECZ_ERR' 
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_ZSPEC_ERR(igal)     = SNGL(DARRAY(1))

c - - - 

      KEY  = PREFIX(1:LENPRE)//'_RA'
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST8_RA(igal) = DARRAY(1) 

      KEY  = PREFIX(1:LENPRE)//'_DEC'
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST8_DEC(igal) = DARRAY(1) 

      KEY  = PREFIX(1:LENPRE)//'_SNSEP'
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_ANGSEP(igal) = SNGL(DARRAY(1))
      IF ( SNHOST_ANGSEP(igal) > 0.0 ) EXIST_SNHOST_ANGSEP = .TRUE.

      KEY  = PREFIX(1:LENPRE)//'_DDLR'
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_DDLR(igal) = SNGL(DARRAY(1))
      IF ( SNHOST_DDLR(igal) > 0.0 )  EXIST_SNHOST_DDLR = .TRUE.

c - - - - - - - - - - - -  -

      KEY    = PREFIX(1:LENPRE)//'_LOGMASS' ;   
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_LOGMASS(igal)   = SNGL(DARRAY(1))

      KEY    = PREFIX(1:LENPRE)//'_LOGMASS_ERR' ;   
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_LOGMASS_ERR(igal)   = SNGL(DARRAY(1))

c xxx   if(SNHOST_LOGMASS(igal) > -9000.) EXIST_SNHOST_LOGMASS = .TRUE.
      EXIST_SNHOST_LOGMASS = .TRUE.

c - - - -

      KEY    = PREFIX(1:LENPRE)//'_LOGSFR' ;
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_LOGSFR(igal)     = SNGL(DARRAY(1))

      KEY    = PREFIX(1:LENPRE)//'_LOGSFR_ERR' ;
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_LOGSFR_ERR(igal)     = SNGL(DARRAY(1))

c xxx   IF(SNHOST_LOGSFR(igal) > -9000.0) EXIST_SNHOST_LOGSFR = .TRUE.
      EXIST_SNHOST_LOGSFR = .TRUE.
c - - - -

      KEY    = PREFIX(1:LENPRE)//'_LOGsSFR' ;   
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_LOGsSFR(igal)     = SNGL(DARRAY(1))

      KEY    = PREFIX(1:LENPRE)//'_LOGsSFR_ERR' ;   
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_LOGsSFR_ERR(igal)     = SNGL(DARRAY(1))
 
c xxx   IF(SNHOST_LOGsSFR(igal) > -9000.0) EXIST_SNHOST_LOGsSFR = .TRUE.
      EXIST_SNHOST_LOGsSFR = .TRUE.  ! Jun 13 2024

c - - - -

      KEY    = PREFIX(1:LENPRE)//'_COLOR' ;
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_COLOR(igal)     = SNGL(DARRAY(1))

      KEY    = PREFIX(1:LENPRE)//'_COLOR_ERR' ;
      CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
      SNHOST_COLOR_ERR(igal)     = SNGL(DARRAY(1))

c xxx   IF(SNHOST_COLOR(igal) > -9000.0) EXIST_SNHOST_COLOR = .TRUE.
      EXIST_SNHOST_COLOR = .TRUE.   ! Jun 13 2024
c - - - 
      KEY_PREFIX = PREFIX(1:LENPRE) // "_MAG"
      CALL RDHEAD_FILTERLOOP(KEY_PREFIX, SNHOST_MAGOBS(ifilt,igal), OPT)

      RETURN
      END    ! end RDHEAD_HOSTGAL

C ===========================================
+DECK,RDHEAD_FILT.
      SUBROUTINE RDHEAD_FILTERLOOP(KEY_PREFIX, FARRAY, OPT)

c Created Feb 2021
c Check keys KEY_PREFIX_[band] and return float FARRAY(ifilt).
c Mar 23 2021: fix bug using LENPRE

      IMPLICIT NONE

      CHARACTER KEY_PREFIX*(*)  ! (I) check keys KEY_PREFIX_[band]
      REAL      FARRAY(*)       ! (O) value vs. ifilt
      INTEGER   OPT             ! (I) argument for FETCH_SNDATA_WRAPPER
      
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER   IFILT, IFILT_OBS, LENPRE
      CHARACTER STRING*10, BAND*2, KEY*60
      REAL*8    DARRAY(4)

C --------------- BEGIN ---------     

      LENPRE = INDEX(KEY_PREFIX//' ',' ') - 1

      DO ifilt     = 1, NFILTDEF_READ
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         band      = FILTDEF_STRING(ifilt_obs:ifilt_obs)
         KEY       = KEY_PREFIX(1:LENPRE) // '_' // band
         CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
         FARRAY(ifilt) = SNGL(DARRAY(1))

c         write(6,66) KEY, FARRAY(ifilt)     ! xxx
c66       format(' xxx ', A20,' = ', F12.5 ) ! xxx

      ENDDO
      RETURN
      END   ! end RDHEAD_FILTERLOOP

C ===========================================
+DECK,RDHEAD_REDSHIFT.
      SUBROUTINE RDHEAD_REDSHIFT(OPT)

c Created Feb 2021 [refactored from PARSE_REDSHIFT]
c Read/store redshift & vpec info
c Note tat REDSHIFT_FINAL is used for LC fitting.
c
c Jun 5 2021: no longer apply REDSHIFT_FINAL_SHIFT here; see SET_zSHIFT().
c Aug 19 2024: check OPT_VPEC_COR option to disable VPEC
c
      IMPLICIT NONE

      INTEGER OPT    ! (I) argument for FETCH_SNDATA_WRAPPER

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER STRING*40
      REAL*8 DARRAY(10)

C ----------- BEGIN ------------

      CALL FETCH_SNDATA_WRAPPER("REDSHIFT_HELIO", 
     &       ONE, STRING, DARRAY, OPT)
      SNLC_zHELIO = SNGL(DARRAY(1)) 
      SNLC_REDSHIFT = SNLC_zHELIO  ! used for LC fitting

      CALL FETCH_SNDATA_WRAPPER("REDSHIFT_HELIO_ERR", 
     &       ONE, STRING, DARRAY, OPT)
      SNLC_zHELIO_ERR = SNGL(DARRAY(1))
      SNLC_REDSHIFT_ERR = SNLC_zHELIO_ERR

c - - - - -

      CALL FETCH_SNDATA_WRAPPER("REDSHIFT_FINAL", 
     &       ONE, STRING, DARRAY, OPT)
      SNLC_zCMB = SNGL(DARRAY(1))  !

      
      CALL FETCH_SNDATA_WRAPPER("REDSHIFT_FINAL_ERR", 
     &       ONE, STRING, DARRAY, OPT)
      SNLC_zCMB_ERR = SNGL(DARRAY(1))


c if no REDSHIFT_FINAL, try alternative REDSHIFT_CMB
c (beware that VPEC correction should NOT be included here)
      IF ( SNLC_zCMB < 0.0 ) THEN
         CALL FETCH_SNDATA_WRAPPER("REDSHIFT_CMB",
     &         ONE, STRING, DARRAY, OPT)
         SNLC_zCMB = SNGL(DARRAY(1))

         CALL FETCH_SNDATA_WRAPPER("REDSHIFT_CMB_ERR",
     &         ONE, STRING, DARRAY, OPT)
         SNLC_zCMB_ERR = SNGL(DARRAY(1))
      ENDIF

c - - - - - - - - - - 
c assign light curve redshift if not already assigned by Z_HELIO
c i.e., light curve analysis should use Z_HELIO if it's defined;
c otherwise use Z_CMB

      IF ( SNLC_ZHELIO < 0.0 ) then
         SNLC_REDSHIFT      = SNLC_zCMB
         SNLC_REDSHIFT_ERR  = SNLC_zCMB_ERR
      ENDIF

c ---------------------------
c LENSDMU (Feb 2025)

      CALL FETCH_SNDATA_WRAPPER("LENSDMU", ONE, STRING, DARRAY, OPT)
      SNLC_LENSDMU = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("LENSDMU_ERR", ONE, STRING, DARRAY, OPT)
      SNLC_LENSDMU_ERR = SNGL(DARRAY(1))

c -------------------------
c VPEC 

      CALL FETCH_SNDATA_WRAPPER("VPEC", ONE, STRING, DARRAY, OPT)
      SNLC_VPEC = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("VPEC_ERR", ONE, STRING, DARRAY, OPT)
      SNLC_VPEC_ERR = SNGL(DARRAY(1))
	 
c Oct 26 2020: check option to fix VPEC sign convention in older FITS data
      if ( DOFIX_WRONG_SIGN_VPEC ) then
         SNLC_VPEC = -1.0 * SNLC_VPEC
      endif

      IF (  abs(VPEC_ERR_OVERRIDE) > .001 ) THEN
         SNLC_VPEC_ERR = VPEC_ERR_OVERRIDE  ! Jan 11 2018
      ENDIF

      if ( OPT_VPEC_COR == 0 ) then  ! Aug 19 2024
          SNLC_VPEC     = 0.0
	  SNLC_VPEC_ERR = 0.0
      endif

c redshift quality flag (real data only)
      CALL FETCH_SNDATA_WRAPPER("REDSHIFT_QUALITYFLAG", 
     &    ONE, STRING, DARRAY, OPT)
      ISNLC_zFLAG = INT(DARRAY(1))

c mask redshift source (march 14 2024)
      CALL FETCH_SNDATA_WRAPPER("MASK_REDSHIFT_SOURCE",
     &    ONE, STRING, DARRAY, OPT)
      ISNLC_zSOURCE = INT(DARRAY(1))

      RETURN
      END    ! end RDHEAD_REDSHIFT

C =============================
+DECK,RDHEAD_SIM_SNANA.
      SUBROUTINE RDHEAD_SIM_SNANA(OPT)

      IMPLICIT NONE

      INTEGER OPT    ! (I) argument for FETCH_SNDATA_WRAPPER

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER ipar
      CHARACTER STRING*100, KEY*80
      REAL*8 DARRAY(10)

c functions
      INTEGER ISMODEL_SNIa
      
C ----------- BEGIN ----------

      STRING  = 'DUMMY'
      
      CALL FETCH_SNDATA_WRAPPER("SIM_MODEL_NAME",  ! e.g., SALT2, BYOSED
     &    ONE, STRING, DARRAY, OPT)
      SIMNAME_MODEL = STRING(1:MXCHAR_MODELNAME)

      CALL FETCH_SNDATA_WRAPPER("SIM_TYPE_NAME",  ! e.g., Ia, Ibc
     &    ONE, STRING, DARRAY, OPT)
      SIMNAME_TYPE = STRING(1:12)

      CALL FETCH_SNDATA_WRAPPER("SIM_MODEL_INDEX",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_MODEL_INDEX = INT(DARRAY(1))

        ! set TRUE_SNIa and NONIa  logicals (Apr 2024)
      LSIM_TRUE_SNIa = .FALSE.
      IF ( ISMODEL_SNIa(SIM_MODEL_INDEX) > 0 ) LSIM_TRUE_SNIa=.TRUE.
      LSIM_TRUE_NONIa = .NOT. LSIM_TRUE_SNIa
            
      CALL FETCH_SNDATA_WRAPPER("SIM_TYPE_INDEX",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_GENTYPE = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_TEMPLATE_INDEX",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_TEMPLATE_INDEX = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_SUBSAMPLE_INDEX",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_SUBSAMPLE_INDEX = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_LIBID",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_LIBID = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_NGEN_LIBID",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_NGEN_LIBID = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_NOBS_UNDEFINED",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_NOBS_UNDEFINED = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_SEARCHEFF_MASK",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_SEARCHEFF_MASK = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_REDSHIFT_HELIO",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_REDSHIFT_HELIO = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_REDSHIFT_CMB",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_REDSHIFT_CMB = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_REDSHIFT_HOST",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_REDSHIFT_HOST = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_REDSHIFT_FLAG",  
     &    ONE, STRING, DARRAY, OPT)
      SIM_REDSHIFT_FLAG = INT(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_VPEC",
     &    ONE, STRING, DARRAY, OPT)
      SIM_VPEC = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_HOSTLIB_GALID",
     &    ONE, STRING, DARRAY, OPT)
      DSIM_HOSTLIB_GALID = DARRAY(1)
      SIM_HOSTLIB_GALID  = DSIM_HOSTLIB_GALID

      do ipar = 1, NPAR_SIM_HOSTLIB
         CALL FETCH_SNDATA_WRAPPER(SIM_HOSTLIB_KEYWORD(ipar),
     &        ONE, STRING, DARRAY, OPT)
         SIM_HOSTLIB_PARVAL(ipar) = SNGL(DARRAY(1))
      enddo

      CALL FETCH_SNDATA_WRAPPER("SIM_DLMU",
     &    ONE, STRING, DARRAY, OPT)
      SIM_DLMAG = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_LENSDMU",
     &    ONE, STRING, DARRAY, OPT)
      SIM_LENSDMU = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_MUSHIFT",
     &    ONE, STRING, DARRAY, OPT)
      SIM_MUSHIFT = SNGL(DARRAY(1))


      CALL FETCH_SNDATA_WRAPPER("SIM_MWEBV",
     &    ONE, STRING, DARRAY, OPT)
      SIM_MWEBV = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_PEAKMJD",
     &    ONE, STRING, DARRAY, OPT)
      SIM_PEAKMJD = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_MJD_EXPLODE",
     &    ONE, STRING, DARRAY, OPT)
      SIM_MJD_EXPLODE = SNGL(DARRAY(1))

c - - - - model params - - - - - 

      CALL FETCH_SNDATA_WRAPPER("SIM_MAGSMEAR_COH",
     &    ONE, STRING, DARRAY, OPT)
      SIM_MAGSMEAR_COH = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_WGT_POPULATION",
     &    ONE, STRING, DARRAY, OPT)
      SIM_WGT_POPULATION = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_SALT2x0",
     &    ONE, STRING, DARRAY, OPT)
      SIM_SALT2x0 = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_SALT2mB",
     &    ONE, STRING, DARRAY, OPT)
      SIM_SALT2mB = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_SALT2c", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_COLORPAR     = SNGL(DARRAY(1))
         SIMNAME_COLORPAR = 'SIM_c'
         SIMNAME_COLORLAW = 'SIM_beta'
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("SIM_SALT2alpha",ONE,STRING,DARRAY,OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_SHAPELAW     = SNGL(DARRAY(1))
         SIMNAME_SHAPELAW = 'SIM_alpha'
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("SIM_SALT2beta",ONE,STRING,DARRAY,OPT)
      if ( DARRAY(1) > -8.0 )  SIM_COLORLAW = SNGL(DARRAY(1))

      CALL FETCH_SNDATA_WRAPPER("SIM_AV", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_AV = SNGL(DARRAY(1))
c copy SIM_AV as color param if NOT SALT2 model; otherwise leave 
c SIM_AV as separate from SALT2c.
        if ( SIM_MODEL_INDEX .NE. MODEL_SALT2 ) then
           SIM_COLORPAR     =  SIM_AV 
           SIMNAME_COLORPAR = 'SIM_AV'  ! Jul 2016: SIMAV->SIM_AV 
           SIMNAME_COLORLAW = 'SIM_RV'  ! Jul 2016: SIMRV->SIM_RV
        endif

      ENDIF

      CALL FETCH_SNDATA_WRAPPER("SIM_RV", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_RV = SNGL(DARRAY(1))
         if ( SIM_MODEL_INDEX .NE. MODEL_SALT2 ) then
            SIM_COLORLAW = SIM_RV
         endif
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("SIM_SALT2gammaDM",
     &     ONE, STRING, DARRAY, OPT)
      SIM_SALT2gammaDM = SNGL(DARRAY(1))

c - - -  shape params - - - -

      CALL FETCH_SNDATA_WRAPPER("SIM_STRETCH", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_SHAPEPAR     = SNGL(DARRAY(1))
         SIMNAME_SHAPEPAR = 'SIM_STRETCH'
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("SIM_DELTA", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_SHAPEPAR     = SNGL(DARRAY(1))
         SIMNAME_SHAPEPAR = 'SIM_DELTA'
      ENDIF

c   Jun 2023 - check for THETA for BayeSN model
      CALL FETCH_SNDATA_WRAPPER("SIM_THETA", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_SHAPEPAR     = SNGL(DARRAY(1))
         SIMNAME_SHAPEPAR = 'SIM_THETA'
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("SIM_DM15", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_SHAPEPAR     = SNGL(DARRAY(1))
         SIMNAME_SHAPEPAR = 'SIM_DM15'
      ENDIF

      CALL FETCH_SNDATA_WRAPPER("SIM_SALT2x1", ONE, STRING, DARRAY, OPT)
      IF ( DARRAY(1) > -8.0 ) THEN
         SIM_SHAPEPAR     = SNGL(DARRAY(1))
         SIMNAME_SHAPEPAR = 'SIM_x1'
      ENDIF

c - - - -  filter dependent keys  - - - - -

      CALL RDHEAD_FILTERLOOP("SIM_PEAKMAG",  SIM_PEAKMAG, OPT)
      CALL RDHEAD_FILTERLOOP("SIM_EXPOSURE", SIM_EXPOSURE_TIME, OPT)
      CALL RDHEAD_FILTERLOOP("SIM_TEMPLATEMAG", SIM_TEMPLATEMAG, OPT) ! 9.20.2021

      
c - - -  model params: SIMSED, LCLIB, etc   - - - -

      DO ipar = 1, NPAR_SIMSED
         KEY  = SIMSED_KEYWORD(ipar)
         CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
         SIMSED_PARVAL(ipar) = SNGL(DARRAY(1))
      ENDDO


      DO ipar = 1, NPAR_PySEDMODEL
         KEY  = PySEDMODEL_KEYWORD(ipar)
         CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
         PySEDMODEL_PARVAL(ipar) = SNGL(DARRAY(1))
      ENDDO

      DO ipar = 1, NPAR_LCLIB
         KEY = LCLIB_KEYWORD(ipar)
         CALL FETCH_SNDATA_WRAPPER(KEY, ONE, STRING, DARRAY, OPT)
         LCLIB_PARVAL(ipar) = SNGL(DARRAY(1))
      ENDDO

      RETURN
      END    ! end RDHEAD_SIM_SNANA


C ===========================================
+DECK,RDOBS_DRIVER.
      SUBROUTINE RDOBS_DRIVER()

C Created Feb 11 2021
C Read event (FITS or TEXT format) and transfer epoch-dependent 
c information from SNDATA C-struct to fortran variables.
c
c Jun 7 2021: abort on undefined filter

      IMPLICIT NONE
cc      INTEGER  ISN    ! (I) sparse SN index

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FITSCOM.
+CDE,FILTCOM.

      REAL*8 MJD_SAFETEY
      PARAMETER ( MJD_SAFETEY = 10.0 ) ! extra margin for MJD window

      INTEGER OPT, NOBS_STORE, o, LENTMP, IFILT, IFILT_OBS
      REAL*8 DARRAY(MXEPOCH), MJD_WINDOW(2), MJD
      REAL   z, z1, TOBS_MIN, TOBS_MAX
      CHARACTER STRING*12, FNAM*14, CFILT*2

      INTEGER  SELECT_MJD_SNDATA
      EXTERNAL SELECT_MJD_SNDATA

C ---------- BEGIN --------

      FNAM = 'RDOBS_DRIVER'

c set MJD window for copy SNDATA obs
      MJD_WINDOW(1) = 0.0;   MJD_WINDOW(2) = 1.0E6  ! default

c check to refine window around approx peakmjd
      if ( SNLC_SEARCH_PEAKMJD > 40000.0 ) then
         z  = SNLC_REDSHIFT
         z1 = 1.0 + z ;   
         if ( z < 0.0 ) z1 = 1.0 + CUTWIN_REDSHIFT(2)
         TOBS_MIN = CUTWIN_TREST(1)*z1  ! note this is usually negative
         TOBS_MAX = CUTWIN_TREST(2)*z1  ! usually positive
         MJD_WINDOW(1) = SNLC_SEARCH_PEAKMJD + TOBS_MIN - MJD_SAFETEY
         MJD_WINDOW(2) = SNLC_SEARCH_PEAKMJD + TOBS_MAX + MJD_SAFETEY
      endif

      NOBS_STORE = SELECT_MJD_SNDATA(MJD_WINDOW)  ! C function

      if ( NOBS_STORE > MXEPOCH ) then
         write(C1ERR,660) NOBS_STORE, MXEPOCH
660      format('NOBS_STORE = ', I6, ' exceeds MXEPOCH=', I6)
         C2ERR = 'Need to increase MXEPOCH in snana.car'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      ISNLC_NEWMJD_STORE = NOBS_STORE  ! store in global
      ISNLC_NEPOCH_STORE = NOBS_STORE

c - - - - - - - - - - - 
c fetch SNDATA values and load fortran globals

      OPT = OPTMASK_SNDATA_OBS
c     &    + OPTMASK_SNDATA_DUMP

      DARRAY(1) = -999.0 ;      STRING = ''

      CALL FETCH_SNDATA_WRAPPER("MJD",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC8_MJD(o) = DARRAY(o);  ENDDO

      CALL FETCH_SNDATA_WRAPPER("BAND",  
     &      NOBS_STORE, STRFITS, DARRAY, OPT)
      CALL UNPACK_SNFITSIO_STR(NOBS_STORE, "FLT", STRFITS)

      CALL FETCH_SNDATA_WRAPPER("CCDNUM",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; ISNLC_CCDNUM(o)=int(DARRAY(o)); ENDDO

      CALL FETCH_SNDATA_WRAPPER("IMGNUM",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; ISNLC_IMGNUM(o)=int(DARRAY(o)); ENDDO


      CALL FETCH_SNDATA_WRAPPER("FIELD",  
     &      NOBS_STORE, STRFITS, DARRAY, OPT)
      CALL UNPACK_SNFITSIO_STR(NOBS_STORE, "FIELD", STRFITS)
      
      CALL FETCH_SNDATA_WRAPPER("PHOTFLAG",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; ISNLC_PHOTFLAG(o)=int(DARRAY(o)); ENDDO

      CALL FETCH_SNDATA_WRAPPER("PHOTPROB",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_PHOTPROB(o)=SNGL(DARRAY(o)); ENDDO

      CALL FETCH_SNDATA_WRAPPER("FLUXCAL",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_FLUXCAL(o)=SNGL(DARRAY(o)); ENDDO

      CALL FETCH_SNDATA_WRAPPER("FLUXCALERR",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_FLUXCAL_ERRTOT(o)=SNGL(DARRAY(o)); ENDDO

c - - - - 
      UNIT_PSF_NEA = .FALSE.
      CALL FETCH_SNDATA_WRAPPER("PSF_NEA",  
     &     NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE
         SNLC_PSF_NEA(o)=SNGL(DARRAY(o))
         if ( SNLC_PSF_NEA(o) > 0.0 ) UNIT_PSF_NEA = .true.
      ENDDO

      IF ( .NOT. UNIT_PSF_NEA ) THEN
         CALL FETCH_SNDATA_WRAPPER("PSF_SIG1",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
         DO o=1,NOBS_STORE; SNLC_PSF_SIG1(o)=SNGL(DARRAY(o)); ENDDO

         CALL FETCH_SNDATA_WRAPPER("PSF_SIG2",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
         DO o=1,NOBS_STORE; SNLC_PSF_SIG2(o)=SNGL(DARRAY(o)); ENDDO

         CALL FETCH_SNDATA_WRAPPER("PSF_RATIO",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
         DO o=1,NOBS_STORE; SNLC_PSF_RATIO(o)=SNGL(DARRAY(o)); ENDDO
      ENDIF
c - - - - -

      CALL FETCH_SNDATA_WRAPPER("SKY_SIG",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_SKYSIG(o)=SNGL(DARRAY(o)); ENDDO

      CALL FETCH_SNDATA_WRAPPER("SKY_SIG_T",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_SKYSIG_T(o)=SNGL(DARRAY(o)); ENDDO

      CALL FETCH_SNDATA_WRAPPER("ZEROPT",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_ZEROPT(o)=SNGL(DARRAY(o)); ENDDO

      CALL FETCH_SNDATA_WRAPPER("ZEROPT_ERR",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_ZEROPT_ERR(o)=SNGL(DARRAY(o)); ENDDO

      CALL FETCH_SNDATA_WRAPPER("TEXPOSE",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_TEXPOSE(o)=SNGL(DARRAY(o)); ENDDO
      
      CALL FETCH_SNDATA_WRAPPER("GAIN",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SNLC_GAIN(o)=SNGL(DARRAY(o)); ENDDO

      IF ( SNLC_NXPIX > 0.0 ) THEN
         CALL FETCH_SNDATA_WRAPPER("XPIX",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
         DO o=1,NOBS_STORE; SNLC_XPIX(o)=SNGL(DARRAY(o)); ENDDO

         CALL FETCH_SNDATA_WRAPPER("YPIX",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
         DO o=1,NOBS_STORE; SNLC_YPIX(o)=SNGL(DARRAY(o)); ENDDO
      ENDIF

c read optional variables for Atmos/DCR (Jul 2023)
      FOUND_ATMOS = .FALSE.
      CALL FETCH_SNDATA_WRAPPER("AIRMASS",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE
          SNLC_AIRMASS(o)=SNGL(DARRAY(o))
          if ( SNLC_AIRMASS(o) > .9 ) FOUND_ATMOS = .true.
      ENDDO

      IF ( FOUND_ATMOS ) THEN
        CALL FETCH_SNDATA_WRAPPER("dRA",  
     &        NOBS_STORE, STRING, DARRAY, OPT)
        DO o=1,NOBS_STORE; SNLC_dRA(o)=SNGL(DARRAY(o)); ENDDO

        CALL FETCH_SNDATA_WRAPPER("dDEC",  
     &          NOBS_STORE, STRING, DARRAY, OPT)
        DO o=1,NOBS_STORE; SNLC_dDEC(o)=SNGL(DARRAY(o)); ENDDO
      ENDIF


c ----------------------------------------------
c ----------- SIM QUANTITIES BELOW -------------
c ----------------------------------------------

      if ( .NOT. ISJOB_SIM ) GOTO 800

c read SIM_MAGOBS for SNANA sim or FAKES ...

      CALL FETCH_SNDATA_WRAPPER("SIM_MAGOBS",  
     &      NOBS_STORE, STRING, DARRAY, OPT)
      DO o=1,NOBS_STORE; SIM_EPMAGOBS(o)=SNGL(DARRAY(o)); ENDDO

c the rest is for SNANA sim only ...

      if ( .NOT. LSIM_SNANA ) GOTO 800

      LENTMP = INDEX(SIMNAME_SNRMON,' ') - 1
      IF ( LENTMP > 2 ) THEN
         CALL FETCH_SNDATA_WRAPPER(SIMNAME_SNRMON,
     &        NOBS_STORE, STRING, DARRAY, OPT)
         DO o=1,NOBS_STORE; SIM_EPSNRMON(o)=SNGL(DARRAY(o)); ENDDO
      ENDIF

c ---------------------------------
 800  CONTINUE

c compute a few misc variables related to input data;
c these are essentially change of units.

      DO o = 1, NOBS_STORE
        CALL SET_EPVAR_MISC(o)   ! set SNLC_ZP (ADU or Npe) and PSF_FWHM

        ISNLC_EPOCH_RANGE_NEWMJD(1,o) = o
        ISNLC_EPOCH_RANGE_NEWMJD(2,o) = o

        IFILT_OBS = ISNLC_IFILT_OBS(o)
        IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 

        IF ( IFILT < 0 ) THEN
           MJD = SNLC8_MJD(o)
           cfilt  = filtdef_string(ifilt_obs:ifilt_obs)
           write(c1err,61) IFILT_OBS, CFILT, SNLC_CCID(1:ISNLC_LENCCID)
61         format('Invalid IFILT_OBS=',I3, '(',A1,') for CID=',A)
           write(c2err,62) MJD
62         format('Check FILTERS key and MJD=', F9.3)
           CALL MADABORT(FNAM, c1err,c2err)
        ENDIF

        ISNLC_NEPOCH_FILT(ifilt) = 
     &       ISNLC_NEPOCH_FILT(ifilt) + 1

c        print*,' xxx o, ifilt, ifilt_obs = ',
c     &        o, ifilt, ifilt_obs 
      ENDDO

c Since SET_PEAKMJD has not been called [yet], 
c apply all epoch cuts EXCEPT for Trest.

      CALL SELECT_EPOCH_DRIVER(1) ! 1 -> all obs/epoch cuts EXCEPT for Trest

      RETURN
      END       ! end RDOBS_DRIVER


C ===========================================
+DECK,RDSPEC_DRIVER.
      SUBROUTINE RDSPEC_DRIVER(ISPEC)

c
C Created Feb 17 2021
C Read spectra (FITS or TEXT format) and transfer 
C information from GENSPEC C-struct to fortran variables.
C
C ISPEC = 0 -> read header info
C ISPEC > 0 -> read wave-dependent arrays for ISPEC

      IMPLICIT NONE

      INTEGER ISPEC  ! (I)

c local var

+CDE,SNDATCOM.
+CDE,SPECCOM.

      INTEGER    OPT, NBLAM, I
      REAL*8     DVAL(10)
      CHARACTER  FNAM*14

C ------------ BEGIN ----------

      FNAM = 'RDSPEC_DRIVER'
      OPT = 0
c     &    + OPTMASK_SNDATA_DUMP

      IF ( ISPEC == 0 ) THEN
         CALL FETCH_GENSPEC_WRAPPER("NSPECTRA", -9, DVAL, OPT)
         NSPECTRUM = INT(DVAL(1))

         IF ( NSPECTRUM .LE. 0 ) RETURN

         IF ( NSPECTRUM > MXSPECTRUM .or. NSPECTRUM < 0 ) THEN
            write(c1err, '(A,I3)' ) 'Invalid NSPECTRUM = ', NSPECTRUM
            write(c2err, '(A,I3)' ) 'MXSPECTRUM = ', MXSPECTRUM
            CALL MADABORT(FNAM, c1err,c2err)
         ENDIF

         
c load up all the spec-header info now; the big LAM-dependent
c arrays are loaded later with ISPEC > 0.
        
         DO I = 1, NSPECTRUM 
            CALL FETCH_GENSPEC_WRAPPER("NBLAM", I, DVAL, OPT)
            NLAMBIN_SPECTRUM(I) = INT(DVAL(1))
            NBLAM = NLAMBIN_SPECTRUM(I)

            if ( NBLAM > MXLAM_SPECTRUM .or. NBLAM < 0 ) then
               write(c1err,'(A,I8)') 'Invalid NLAMBIN = ', NBLAM
               write(c2err,'(A,I8)') 'MXLAM_SPECTRUM=',MXLAM_SPECTRUM
               CALL MADABORT(FNAM, c1err,c2err)
            endif

            CALL FETCH_GENSPEC_WRAPPER("ID", I, DVAL, OPT)
            ID_SPECTRUM(I)    = INT(DVAL(1))

            CALL FETCH_GENSPEC_WRAPPER("MJD", I, DVAL, OPT)
            MJD_SPECTRUM(I)    = DVAL(1)
            TOBS_SPECTRUM(I)   = DVAL(1) - SNLC_SEARCH_PEAKMJD 

            CALL FETCH_GENSPEC_WRAPPER("TEXPOSE", I, 
     &           TEXPOSE_SPECTRUM(I), OPT)
         ENDDO

         RETURN
      ENDIF
         
c - - - - - - -  -
c retreive SPECTRUM for ISPEC.
c wave-dependent arrays
      CALL FETCH_GENSPEC_WRAPPER("LAMMIN", ISPEC, 
     &     LAMMIN_SPECTRUM, OPT)
      CALL FETCH_GENSPEC_WRAPPER("LAMMAX", ISPEC, 
     &     LAMMAX_SPECTRUM, OPT)
      
      CALL FETCH_GENSPEC_WRAPPER("FLAM", ISPEC, 
     &     FLAM_SPECTRUM, OPT)
      CALL FETCH_GENSPEC_WRAPPER("FLAMERR", ISPEC, 
     &     FLAMERR_SPECTRUM, OPT)
      
      IF (  LSIM_SNANA ) THEN
         CALL FETCH_GENSPEC_WRAPPER("SIM_FLAM", ISPEC, 
     &        SIM_FLAM_SPECTRUM, OPT)
      ENDIF

      RETURN
      END     ! end RDSPEC_DRIVER


C ==============================================
+DECK,LDONE_CIDLIST.
      LOGICAL FUNCTION LDONE_CIDLIST()

c Jun 2011:
c Returns TRUE if all CID in the list have been processed;
c allows parsing function to stop early.
c
c May 18, 2012: return FALSE if interp-option is set
c Jun 25, 2019: check MXEVT_PROCESS
c Oct 12, 2021: check MXEVT_CUTS
c -----------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,INTERPCM.

      LOGICAL LNCID

c ------------- BEGIN --------------

      LDONE_CIDLIST = .FALSE.  ! default

      if ( N_SNLC_PROC .GE. MXEVT_PROCESS ) then
         LDONE_CIDLIST = .TRUE.
         RETURN
      endif

      if ( N_SNLC_CUTS .GE. MXEVT_CUTS ) then
         LDONE_CIDLIST = .TRUE.
         RETURN
      endif

c if CUTWIN_CID is set then return FALSE
      if ( cutwin_cid(1) .GT. 0 ) RETURN
      if ( cutwin_cid(2) .GT. 0 ) RETURN
     
      if ( SNCID_LIST_FILE .NE. ' ' ) RETURN ! Nov 2013

c return FALSE if interp-option is set but not finished
     
      if ( N_INTERP_MJDLIST .GT. 0 .and. 
     &     N_INTERP_MJDLIST_DONE .LT. N_INTERP_MJDLIST ) THEN
           LDONE_CIDLIST = .FALSE.
           RETURN
      endif

      LNCID = NACCEPT_CID .EQ. (NCID_LIST + NCCID_LIST)
      IF ( LNCID ) THEN
        LDONE_CIDLIST = .TRUE.
      ENDIF

      RETURN
      END       ! END OF LDONE_CIDLIST


C =======================
+DECK,PRSPRVKEY.
      SUBROUTINE PARSE_PRIVATE_KEYWORD(CWORD, IVAR_PRIVATE)

c For input CWORD = 'PRIVATE($VARNAME)', strip out the $VARNAME
c and load PRIVATE_VARNAME(IVAR_PRIVATE) = $VARNAME
c
c Apr 27 2021: check veto option with VARNAME != VALUE
c
      IMPLICIT NONE

c input args
      CHARACTER CWORD*60     ! (I) text string to parse
      INTEGER IVAR_PRIVATE   ! (I) PRIVATE parameter index

c local args
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      INTEGER J1, J2, LK, IVAR, LEN_NAME, NMATCH, icut
      INTEGER NWD, LWD1, LWD2, LWD3, MSKOPT
      CHARACTER VARNAME*60, STR*(MXCHAR_CUTNAME), CUTSTRING*30
      CHARACTER CWD1*60, CWD2*60, CWD3*60, FNAM*30

      LOGICAL LCUTWIN
      REAL*8 CUTWIN(2)

c function
      INTEGER NMATCH_PRIVATE

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------------- BEGIN --------------

      FNAM = 'PARSE_PRIVATE_KEYWORD'

c store keyword WITHOUT the ':' on the end.
      LK = INDEX( CWORD , ':' ) - 1
      IF ( LK .LT. 0 ) LK = INDEX(CWORD,' ' ) - 1
      PRIVATE_KEYWORD(IVAR_PRIVATE) = CWORD(1:LK)

c now extract the parameter name from inside the ().
c For example, if KEYWORD = 'PRIVATE(BLA):'
c then the VARNAME is 'BLA'.

      J1 = INDEX( CWORD , '(' ) 
      J2 = INDEX( CWORD , ')' ) 

      IF ( J1 .EQ. 0 .or. J2 .EQ. 0 ) THEN
         c1err = 'Invalid PRIVATE_KEYWORD = ' // CWORD(1:LK)
         c2err = 'Expecting to find key-string  PRIVATE(PARNAME)'
         CALL MADABORT("PARSE_PRIVATE_KEYWORD", c1err,c2err)
      ENDIF


      VARNAME = CWORD(j1+1:j2-1)
      LEN_NAME = INDEX(VARNAME // ' ', ' ' ) - 1

c load parameter name into global variable

      PRIVATE_VARNAME(IVAR_PRIVATE) = VARNAME

c ----------------------------------------------------
c make sure that this NAME has not already been used

      NMATCH = NMATCH_PRIVATE(VARNAME,IVAR)

      IF ( NMATCH > 1 ) then
         c1err = 'found duplicate PRIVATE variable: ' 
     &                // VARNAME(1:LEN_NAME)
         c2err = 'Check PRIVATE(XXX) keys'
         CALL MADABORT("PARSE_PRIVATE_KEYWORD", c1err,c2err)
      ENDIF

c -------- check for cut on private var (Nov 4 2014) ---------
c Allow two syntaxes:
c  VARNAME CUTMIN CUTMAX    or
c  VARNAME != VETO_VALUE

      LCUTWIN = .FALSE.
      CUTSTRING = ''
      DO 400 icut = 1, MXCUT_PRIVATE

         STR = PRIVATE_CUTWIN_STRING(icut)  ! 'VARNAME CUTMIN CUTMAX'
         if ( STR .EQ. '' ) GOTO 400
 
c        skip if already found
         CUTWIN(2) = PRIVATE_CUTWIN(2,IVAR_PRIVATE) 
         if ( CUTWIN(2) < .99*CUTVAL_OPEN ) GOTO 400

c break up string into pieces
         MSKOPT = MSKOPT_PARSE_WORDS_STRING
         NWD = STORE_PARSE_WORDS(MSKOPT,STR//' '//char(0), 
     &        FNAM//char(0), 60, 30)
         call get_PARSE_WORD_fortran(1,CWD1,LWD1)

         if ( VARNAME .EQ. CWD1 ) then
            NCUT_PRIVATE = NCUT_PRIVATE + 1
            LCUTWIN = .TRUE.

            call get_PARSE_WORD_fortran(2,CWD2,LWD2)
            call get_PARSE_WORD_fortran(3,CWD3,LWD3)

            if ( CWD2(1:2) .EQ. '!=' ) then
               read(CWD3,*) CUTWIN(1)
               CUTWIN(2) = CUTWIN(1)
               USE_PRIVATE_CUTWIN(IVAR_PRIVATE) = -1 ! veto flag
               write(CUTSTRING,446) CUTWIN(1)
            else
               read(CWD2,*) CUTWIN(1)
               read(CWD3,*) CUTWIN(2)
               USE_PRIVATE_CUTWIN(IVAR_PRIVATE) = 1 ! normal cutwin
               write(CUTSTRING,444) CUTWIN
            endif

            PRIVATE_CUTWIN(1,IVAR_PRIVATE) = CUTWIN(1)
            PRIVATE_CUTWIN(2,IVAR_PRIVATE) = CUTWIN(2)

 444        format('CUT: ',G9.3,' to ', G9.3)
 446        format('VETO: ', G9.3)
         endif
 400  CONTINUE

c ----------------------------
c print one-line summary

      IF ( .NOT. DO_GETINFO ) THEN
        write(6,500) CWORD(1:LK), CUTSTRING
 500    format(T5,'Found ', A, T50,A)
        call flush(6)
      ENDIF

      RETURN
      END  ! end  PARSE_PRIVATE_KEYWORD

C ===============================
+DECK,NMAPRIV.
      INTEGER FUNCTION NMATCH_PRIVATE(NAME,IVAR_PRIVATE)

c
c Return number of NAME matches ; check both
c PRIVATE_VARNAME and PRIVATE_KEYWORD.
c Also returns IVAR_PRIVATE that is valid if NMATCH=1

      IMPLICIT  NONE
      CHARACTER NAME*(*)
      INTEGER   IVAR_PRIVATE
+CDE,SNPAR.
+CDE,PRIVCOM.

      INTEGER 
     &   IVAR 
     &  ,LEN_TMP, LEN_NAME
     &  ,NMATCH

      CHARACTER TMPNAME*60

C --------------- BEGIN --------------

      IVAR_PRIVATE   = -9
      NMATCH_PRIVATE =  0
      NMATCH         =  0
      LEN_NAME       = INDEX(NAME//' ' , ' ') - 1

      DO 30 IVAR = 1, NVAR_PRIVATE
        TMPNAME  = PRIVATE_VARNAME(IVAR)
        LEN_TMP  = INDEX(TMPNAME,' ') - 1
        IF ( LEN_TMP .NE. LEN_NAME ) goto 30

        if ( NAME(1:LEN_NAME) .EQ. TMPNAME(1:LEN_NAME) ) then
           IVAR_PRIVATE = IVAR
           NMATCH = NMATCH + 1
        endif
30    CONTINUE

c check the full name 'PRIVATE($VARNAME)'

      DO 32 IVAR = 1, NVAR_PRIVATE
        TMPNAME  = PRIVATE_KEYWORD(IVAR)
        LEN_TMP  = INDEX(TMPNAME,' ') - 1
        IF ( LEN_TMP .NE. LEN_NAME ) goto 32

        if ( NAME(1:LEN_NAME) .EQ. TMPNAME(1:LEN_NAME) ) then
           IVAR_PRIVATE = IVAR
           NMATCH = NMATCH + 1
        endif

32    CONTINUE


      NMATCH_PRIVATE = NMATCH

      RETURN
      END


C END_DATA_IO

C ==========================================
+PATCH,*SNUTIL.

+DECK,PROCESS_DATA.
      SUBROUTINE PROCESS_DATA_VERSION(IVERS)

c Created Feb 16 2021 as part of I/O refactor.
c Called from MAIN to read & ananlyze events.

      IMPLICIT NONE

      INTEGER IVERS  ! (I) version index to process

+CDE,SNDATCOM.
+CDE,SNLCINP.

C --------------- BEGIN -------------

      CALL GETINFO_PHOTOMETRY(ivers)

      CALL READ_EPIGNORE_FILE(ivers)

      CALL EXEC_READ_DATA(ivers,OPTMASK_SNDATA_ALL)

      RETURN
      END   ! end PROCESS_DATA_VERSION

C ==========================================
+DECK,PARSE_SNANA_ARGS.
      SUBROUTINE PARSE_SNANA_ARGS()
c
c Nov 08, 2012
c Parse command-line arguments and store in LINE_ARGS array. 
c (code moved from main)
c
c May 2019: check option to call DUMP_SNANA_VERSION
c Dec 2020: abort on ARG string length too long.
c Aug 2020: of no args, call function to print help menu
c Dec 2022: get SNANA_VERSION here to print it after full command

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
      INTEGER i, LL, LL_SNANA, istat
      CHARACTER ARG1*(MXCHAR_ARG), ARG2*(MXCHAR_ARG)
      CHARACTER FNAM*20, COMMAND*2000, CODE_FILENAME*40
      CHARACTER CMD_HELP*100, CMD_SNANA_HELP*100

      EXTERNAL GET_SNANA_VERSION

C ------------------- BEGIN ---------------

      FNAM = 'PARSE_SNANA_ARGS'

      NLINE_ARGS = IARGC()  ! intrinsic fortran function

c get SNANA version from C function
      call GET_SNANA_VERSION(SNANA_VERSION,40)
      LL_SNANA = index(SNANA_VERSION, char(0) ) - 1
      SNANA_VERSION(LL_SNANA+1:LL_SNANA+2) = ' '

c - - - - - - - - - - - - - - - - - - 
c Aug 2022: if there are no arguments, print help menu
      IF ( NLINE_ARGS == 0 ) THEN 

c  always print help for &SNLCINP base code inputs
         CMD_SNANA_HELP = 'help_inputs_fortran.py ' // 'snana.car'
         CALL SYSTEM(CMD_SNANA_HELP)

+SELF,IF=SNANA.
          CODE_FILENAME = ''
+SELF,IF=SNFIT.
          CODE_FILENAME = 'snlc_fit.car'
+SELF,IF=PSNID.
          CODE_FILENAME = 'psnid.car'
+SELF.

	 if ( CODE_FILENAME .NE. '' )  then
            CMD_HELP = 'help_inputs_fortran.py ' // CODE_FILENAME
            CALL SYSTEM(CMD_HELP)
         endif
         STOP
      ENDIF
c - - - - - - - - - - - - - - - - - - 

      IF ( NLINE_ARGS .GT. MXLINE_ARGS ) THEN
         write(c1err,661) NLINE_ARGS
         write(c2err,662) MXLINE_ARGS
661      format(I3,' command-line arguments exceeds bound of')
662      format('MXLINE_ARGS = ', I4)
         CALL  MADABORT("PARSE_SNANA_ARGS", C1ERR, C2ERR)
      ENDIF


      CALL GET_COMMAND(COMMAND,LL, istat)

c abort on bad string length
      DO i = 1, NLINE_ARGS
        CALL GETARG(i, ARG1)       

        if ( ARG1(MXCHAR_ARG:MXCHAR_ARG) .NE. ' ' ) then
           CALL PRINT_PREABORT_BANNER(FNAM//char(0),20)
           print*,'  ARG = ', ARG1
           c1err = 'String length too long for command-line ARG ' //
     &             ' (see above)'
           write(c2err, '(A,I6)' ) 'MXCHAR_ARG = ', MXCHAR_ARG
           CALL MADABORT(FNAM, c1err, c2err)
        endif

        USE_LINE_ARGS(i) = .FALSE.
      ENDDO

      CALL GETARG(1, ARG1)
      CALL GETARG(2, ARG2)

c check option to dump SNANA version and SNANA_DIR 
c (for SNANA_CodeTests.py)
c    snana.exe --snana_version

      IF ( ARG1 .EQ. '--SNANA_VERSION' .or.
     &     ARG1 .EQ. '--snana_version'  ) THEN
         CALL DUMP_SNANA_VERSION()
      ELSE
         print*,' Full command:  ', COMMAND(1:LL)
         print*,' '
         print*,' SNANA_VERSION: ', SNANA_VERSION(1:LL_SNANA)
         print*,' '

      ENDIF

c snana.exe GETINFO <VERSION_PHOTOMETRY>
      DO_GETINFO = .FALSE.
      IF ( ARG1 .EQ. 'GETINFO' ) THEN
         CALL DUMP_INFO_VERSION_PHOTOMETRY(ARG2)
      ENDIF

      RETURN
      END      ! end PARSE_SNANA_ARGS


C ==================================
+DECK,DUMP_SNANA_VERSION.
      SUBROUTINE DUMP_SNANA_VERSION()

c Created May 2019
c Dump SNANA version and SNANA_DIR, then quit.

      IMPLICIT NONE
      INTEGER LL
      CHARACTER SNANA_VERSION*40, SNANA_DIR*200
      
      call GET_SNANA_VERSION(SNANA_VERSION,LL)
      LL = index(SNANA_VERSION, char(0) ) - 1
      print*,'SNANA_VERSION: ', SNANA_VERSION(1:LL)
      
      CALL GETENV ( 'SNANA_DIR', SNANA_DIR )
      LL = INDEX(SNANA_DIR,' ') - 1
      print*,'SNANA_DIR: ', SNANA_DIR(1:LL)

      CALL EXIT(0)

      RETURN
      END

C ======================================
+DECK,DUMP_INFO_VER_PHOT.
      SUBROUTINE DUMP_INFO_VERSION_PHOTOMETRY(VERSION_ARG)

c Created Aug 29 2019
c dump path and format for VERSION_PHOTOMETRY; then quit.
c
c Apr 2021: pass VERSION_ARG and dump more info
c Jan 10 2022: write NVAR_PRIVATE

      IMPLICIT NONE
      CHARACTER VERSION_ARG*(*)  ! VERSION or PATH/VERSION

+CDE,SNDATCOM.
+CDE,SNLCINP.      
+CDE,FILTCOM.
+CDE,PRIVCOM.

c local var
      CHARACTER VERSION*(MXCHAR_FILENAME), COMMENT*40
      INTEGER IERR, LEN, JSLASH
C -------------- BEGIN ------------   

      DO_GETINFO = .TRUE.

c if VERSION_ARG has full path, split it into PRIVATE_DATA_PATH and 
c VERSION_PHOTOMETRY

      LEN     = INDEX(VERSION_ARG,' ') -1
      JSLASH  = INDEX(VERSION_ARG, '/', BACK = .True. )
      IF ( JSLASH > 1 ) THEN
         VERSION_PHOTOMETRY(1) = VERSION_ARG(JSLASH+1:LEN)
         PRIVATE_DATA_PATH     = VERSION_ARG(1:JSLASH-1)
      ELSE
         VERSION_PHOTOMETRY(1) = VERSION_ARG(1:LEN)
      ENDIF

      CALL INIT_SNVAR()
      CALL CHECK_FORMAT()
      CALL INIT_READ_DATA()

c - - - - - - - - - - - -
      print*,' '
      print*,' '

      VERSION = VERSION_PHOTOMETRY(1)
      LEN     = INDEX(VERSION,' ')-1
      write(6,20) 'VERSION:', VERSION(1:LEN), ''

      LEN = INDEX(SNDATA_PATH,' ') - 1
      write(6,20) 'SNDATA_PATH:', SNDATA_PATH(1:LEN), ' '

      LEN = INDEX(SNLIST_FILE,' ') - 1
      write(6,20) 'LIST_FILE:  ', SNLIST_FILE(1:LEN), ' '

      LEN = INDEX(SNREADME_FILE(1),' ') - 1
      write(6,20) 'README_FILE:', SNREADME_FILE(1)(1:LEN), ' '

 20   format(A, 2x, A,  3x, A)
 21   format(A, 2x, I8, 3x, A)
c - - - - - - - - - - - -
      if ( FORMAT_TEXT ) then
         write(6,20) 'FORMAT: ', 'TEXT', 
     &         '# one TEXT file per SN'
      else
         write(6,20) 'FORMAT: ', 'FITS', 
     &         '# FITS-HEADER and FITS-PHOT file'
      endif

      LEN = INDEX(SURVEY_NAME,' ') - 1
      write(6,20) 'SURVEY: ', SURVEY_NAME(1:LEN), ' ' 

      write(6,20) 'FILTERS:', SURVEY_FILTERS(1:NFILTDEF_SURVEY), ' '

      write(6,21) 'NEVENT: ',  N_SNLC_READ(1), ' '

      COMMENT = ''
      IF ( DATATYPE == 'SIM_MAGOBS' ) THEN
         COMMENT='# Fakes overlaid on images'
      ENDIF
      write(6,20) 'DATATYPE: ',  DATATYPE, COMMENT

      write(6,21) 'NVAR_PRIVATE: ',  NVAR_PRIVATE, ' '

      CALL FLUSH(6)
      CALL EXIT(0)

      RETURN
      END      ! end DUMP_INFO_VERSION_PHOTOMETRY

C ==================================
+DECK,RDSNNML.
      SUBROUTINE RDSNNML(IERR)
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.

c
c Feb 27 2018: check CUTWIN_ZP
c Apr 07 2022; use function VALIDFILENAME
c
c ---------------

      INTEGER IERR   ! 0=>OK,  else error

c local ars

      integer i, ifilt, LL, ipar, NZPCUT, bit
      character nmlfile_default*40, FNAM*8

c function
      INTEGER PARSE_NML_STRINGLIST
      LOGICAL VALIDFILENAME

C -------------- BEGIN -----------
      IERR = 0

      CALL PRBANNER ( " READ SNLCINP NAMELIST. " )

      FNAM = 'RDSNNML'

c ----------------------------------------
c set namelist defaults

      VERSION_PHOTOMETRY_WILDCARD = 'NULL'
      DO i = 1, MXVERS
        VERSION_PHOTOMETRY(i) = 'NULL'
      ENDDO
      VERSION_REFORMAT_FITS = 'NULL'
      VERSION_REFORMAT_TEXT = 'NULL'

      PRIVATE_DATA_PATH  = ' '
      FILTER_UPDATE_PATH = ' '
      OPT_YAML              = 0
      OPT_REFORMAT_SALT2    = 0 
      OPT_REFORMAT_TEXT     = 0
      OPT_REFORMAT_FITS     = 0 
      OPT_REFORMAT_SPECTRA  = 0
      REFORMAT_SAVE_BADEPOCHS  = .FALSE.
      REFORMAT_BAND_NAME       = .FALSE.
      REFORMAT_SPECTRA_INCLUDE = .FALSE.
      REFORMAT_SPECTRA_ONLY    = .FALSE.
      REFORMAT_PRIVATE         = .TRUE.
      REFORMAT_SIMTRUTH        = .TRUE.
      REFORMAT_KEYS     = 'NULL'

      REDUCE_STDOUT_BATCH = .FALSE.
      FORCE_STDOUT_BATCH  = .FALSE.
      
      NONSURVEY_FILTERS = ''
      SNRMAX_FILTERS    = ''  ! blank -> use all filters
      FILTER_REPLACE    = ''
      FILTLIST_LAMSHIFT = '' 

      VPEC_ERR_OVERRIDE = 0.0 

      JOBSPLIT(1) = 1
      JOBSPLIT(2) = 1

      JOBSPLIT_EXTERNAL(1) = 1
      JOBSPLIT_EXTERNAL(2) = 1

      SIM_PRESCALE   = 1.0
      OPTSIM_LCWIDTH = 0

      MNFIT_PKMJD_LOGFILE = 'MNFIT_PKMJD.LOG'

      SNMJD_LIST_FILE = ' '
      SNMJD_OUT_FILE  = ' '

      CUTWIN_MJD_EXCLUDE(1) = 0.0 
      CUTWIN_MJD_EXCLUDE(2) = 0.0 

      CUTWIN_TOBS_PREDETECT(1) = -CUTVAL_OPEN
      CUTWIN_TOBS_PREDETECT(2) = +CUTVAL_OPEN

      CUTWIN_SNR_NODETECT(1) = -CUTVAL_OPEN
      CUTWIN_SNR_NODETECT(2) = +CUTVAL_OPEN

      SNCUT_HOST_SBFLUX = ''
      SNCUT_SNRMAX = '' 
      EPCUT_SNRMIN = ''
      EPCUT_SKYSIG = ''
      EPCUT_PSFSIG = ''

      CUTWIN_NFIELD(1) = 1.0
      CUTWIN_NFIELD(2) = 999.0

      CUTWIN_NFILT_SNRMAX(1) = 0.0
      CUTWIN_NFILT_SNRMAX(2) = 100.

      CUTWIN_NFILT_SNRMAX2(1) = 0.0
      CUTWIN_NFILT_SNRMAX2(2) = 100.

      CUTWIN_NFILT_TRESTMIN(1) =   1.
      CUTWIN_NFILT_TRESTMIN(2) = 100.
      CUTWIN_NFILT_TRESTMAX(1) =   1.
      CUTWIN_NFILT_TRESTMAX(2) = 100.
      CUTWIN_NFILT_TREST2(1)   =   1.
      CUTWIN_NFILT_TREST2(2)   = 100.

      CUTWIN_LAMREST(1)      =  2000.  ! Angstroms
      CUTWIN_LAMREST(2)      = 25000.
      CUTWIN_LAMOBS(1)       =  2000.
      CUTWIN_LAMOBS(2)       = 70000.  ! increase from 25k -> 70k, for JWST (May 2024)

      CUTWIN_NBAND_THRESH(1) = -9.0   !  obsolete as of Nov 15 2019
      CUTWIN_NBAND_THRESH(2) = -9.0

      do ifilt = 1, MXFILT_OBS
         CUTWIN_SNRMIN_FILT(1,ifilt) = -CUTVAL_OPEN
         CUTWIN_SNRMIN_FILT(2,ifilt) = +CUTVAL_OPEN
      enddo

      CUTWIN_TREST_TRUEFLUX(1)  = 999.0 ! user input
      CUTWIN_TREST_TRUEFLUX(2)  = 999.0
      CUTWIN_TREST_TRUEFLUX2(1) = 0.9  ! logical cutwin
      CUTWIN_TREST_TRUEFLUX2(2) = 1.1

c Setting ignore file to 'NONE' => do not read any file.
c Setting INGORE file to 'DEFAULT' is a flag to read
c epochs-to-ignore from $SNDATA_ROOT/lcmerge/[version].IGNORE

      EPOCH_IGNORE_FILE = 'DEFAULT' 
      OUT_EPOCH_IGNORE_FILE = ''

      CALIB_FILE    = 'NULL'
      KCOR_FILE     = 'NULL'
      OVERRIDE_RESTLAM_BOUNDARY = ''

      rootfile_out      = ' '
      textfile_prefix   = ' '
      MARZFILE_OUT      = ' '  ! May 2020

      SNCID_LIST_FILE   = ' '
      OPT_SNCID_LIST    = 0  ! default 0 => AND with other cuts
      OPT_VPEC_COR      = 1  ! default is to correct zHD with vpec
      
      MXEVT_PROCESS      = 999888777
      MXEVT_CUTS         = 999888777
      SIMLIB_OUT     = ''
      SIMLIB_OUTFILE = ''
      SIMLIB_ZPERR_LIST = ''
      OPT_SIMLIB_OUT    = 1
      SIMLIB_OUT_TMINFIX = 99999 ! large value -> not used

      NONLINEARITY_FILE = ''

      DO i = 1, MXLISTNML
         SNTYPE_LIST(i)    = 0
         SNTYPE_IGNORE(i)  = -9  ! note that type=0(no type) can be ignored
         CCDNUM_LIST(i)    = 0 
         SNCID_LIST(i)     = 0
         SNCID_IGNORE(i)   = 0
         SIM_TEMPLATE_INDEX_LIST(i) = 0 

         SNCCID_LIST(i)    = ''
         SNCCID_IGNORE(i)  = ''        
         SNCCID_PLOT(i)    = ''

         SNFIELD_LIST(i)     = ''
         IDFIELD_LIST(i)     = -9
      ENDDO

c set default field to ALL
      SNFIELD_LIST(1)   = 'ALL'

      NSNTYPE_LIST = 0
      NCCDNUM_LIST = 0
      NSNTYPE_IGNORE = 0

      NIDFIELD_LIST = 0
      NCCID_LIST = 0
      NCID_LIST  = 0

      SNCID_IGNORE_FILE = ''

c set photometry-flag bits to reject;
c default is to reject nothing (accept everything)

      PHOTFLAG_MSKREJ(1) = -1  ! negative -> not set
      PHOTFLAG_MSKREJ(2) = 0
      PHOTFLAG_MSKREJ(3) = 0
      PHOTFLAG_MSKREJ(4) = 0
      PHOTFLAG_MSKREJ(5) = 0

      do i = 1, MXBIT_PHOTFLAG
         PHOTFLAG_BITLIST_REJECT(i) = -9 ! beware that 0 is valid bit
      enddo

      SNCID_IGNORE(1)    = 0 

      MAGOBS_SHIFT_PRIMARY  = ''
      MAGOBS_SHIFT_ZP       = ''
      MAGREST_SHIFT_PRIMARY = ''
      MAGREST_SHIFT_ZP      = ''
      FILTER_LAMSHIFT       = '' 

      DO i = 1, 3
        MAGOBS_SHIFT_PRIMARY_PARAMS(i) = 0.0
        MAGOBS_SHIFT_ZP_PARAMS(i)      = 0.0
      ENDDO

      FUDGE_FLUXCAL_OFFSET = ''
      FUDGE_FLUXCAL_ERROR  = ''
      FUDGE_FLUXCAL_ERRPIX = ''
      FUDGE_FLUXERR_SCALE  = ''
      FUDGE_MAG_ERROR      = ''
      FUDGE_MAG_COVERR     = ''
      FUDGE_HOSTNOISE_FILE = ''
      SIM_FUDGE_MAG_ERROR  = ''
      FLUXERRMODEL_FILE    = ''
      SIM_FLUXERRMODEL_FILE = ''
      FLUXERRMODEL_OPTMASK = 0 
      MAGCOR_FILE          = ''
      SIM_MAGCOR_FILE      = ''

      MWEBV_SCALE    = 1.0
      MWEBV_SHIFT    = 0.0
      MWEBV_FORCE    = -9.0
      OPT_MWCOLORLAW = -9   ! use default if not specified in &SNLCINP
      OPT_MWEBV      = -9   ! idem
      RV_MWCOLORLAW  = -9.0 ! idem

      DO i = 1, 10
         PARLIST_MWCOLORLAW(i) = 0.0
      ENDDO
	
      HOSTGAL_ZPHOT_SHIFT  = 0.0 
      HOSTGAL_ZSPEC_SHIFT  = 0.0
      HOSTGAL_PHOTOZ_SHIFT = LEGACY_INIT_VAL
      HOSTGAL_SPECZ_SHIFT  = LEGACY_INIT_VAL
      REDSHIFT_FINAL_SHIFT = 0.0
      FLUXERRCALC_ZPTERR  = -9.9

      NFIT_ITERATION     = 0
      MINUIT_PRINT_LEVEL = -1  ! default is no MINUIT printing
      INTERP_OPT     = INTERP_LINEAR
      USE_MINOS      = .FALSE.  ! change from T to F, Jan 27 2017

      MXLC_FIT         = 999888777 
      MXLC_PLOT        = 5    ! 100->5  (Apr 19 2022)      
      NCCID_PLOT       = 0
      DTOBS_MODEL_PLOT = 2.0  ! 2 day binning
      MJDPERIOD_PLOT   = 0.0
      MJDSHIFT_PLOT    = 0.0 

      OPT_SETPKMJD      = 0
      SNRCUT_SETPKMJD   =  5.0  ! only for FLUXMAX2 option (Fmax-clump)
      MJDWIN_SETPKMJD   = 60.0  ! only for FLUXMAX2 option (Fmax-clump)
      SHIFT_SETPKMJD    =  0.0  ! for systematic test only

      DEBUG_FLAG          =  0
      LDMP_SNFAIL         = .FALSE.
      LDMP_SNANA_VERSION  = .FALSE.
      LDMP_SATURATE       = .FALSE.

      LSIM_SEARCH_SPEC    = .FALSE.
      LSIM_SEARCH_ZHOST   = .FALSE.

      USESIM_SNIA      = .TRUE. 
      USESIM_NONIA     = .TRUE.
      USESIM_TRUEFLUX  = .FALSE.

      LPROB_TRUEFLUX     = .FALSE.  
      RESTORE_WRONG_VPEC = .FALSE.    ! Nov 3 2020
      RESTORE_OVERRIDE_ZBUG = .FALSE. ! Dec 12 2021
      RESTORE_MWEBV_ERR_BUG = .FALSE. ! Jul 2022
      REQUIRE_DOCANA     =  0       ! use integer to match sim usage

      USE_HOSTGAL_PHOTOZ = .FALSE.
      USE_SNHOST_ZPHOT   = .FALSE.
      USE_MWCOR          = .FALSE.  ! apply MWCOR to fit-model

c by default do NOT check for multiseason activity (Oct 2014)
      MULTISEASON_TGAP               = 1.0E9 
      MULTISEASON_NREJECT_OUTLIER    = 0
      MULTISEASON_CHI2RED_ACTIVE     = 5.0

      PHOTFLAG_DETECT   = 0 
      PHOTFLAG_TRIGGER  = 0

      CUTWIN_NSEASON_ACTIVE(1) = -99.
      CUTWIN_NSEASON_ACTIVE(2) = +99.

      CUTWIN_CUTFLAG_REQEP(1) = 0.99
      CUTWIN_CUTFLAG_REQEP(2) = 1.01
   
c hard-wire cut on private cut-flag (Nov 4 2014)
      CUTWIN_CUTFLAG_PRIVATE(1) = 0.99
      CUTWIN_CUTFLAG_PRIVATE(2) = 1.01

      CUTWIN_CUTFLAG_SIMVAR(1) = 0.99
      CUTWIN_CUTFLAG_SIMVAR(2) = 1.01

c set reference cosmo params to defaults.
      H0_REF(1)   = H0_DEFAULT
      H0_REF(2)   = H0ERR_DEFAULT
      OMAT_REF(1) = OMAT_DEFAULT
      OMAT_REF(2) = OMATERR_DEFAULT
      OLAM_REF(1) = OLAM_DEFAULT
      OLAM_REF(2) = OLAMERR_DEFAULT
      ORAD_REF(1) = ORAD_DEFAULT
      ORAD_REF(2) = 0.0
      W0_REF(1)   = W0_DEFAULT
      W0_REF(2)   = W0ERR_DEFAULT
      DWDA_REF(1) = DWDA_DEFAULT
      DWDA_REF(2) = DWDAERR_DEFAULT

      zTOL_HELIO2CMB   = 0.02   ! tolerance on dzHELIO/zHELIO
      QUANTILE_ZERRMIN = 0.00   ! 0 -> always use quantiles

c set LTEST logicals to false.

      LTEST_KCOR    = .FALSE.
      LTEST_INTERP  = .FALSE.
      LTEST_U3BAND  = .FALSE.
      LTEST_MAG     = .FALSE.

      ABORT_ON_NOEPOCHS  = .TRUE.
      ABORT_ON_BADAVWARP = .TRUE.
      ABORT_ON_BADZ      = .TRUE.
      ABORT_ON_BADKCOR   = .TRUE.
      ABORT_ON_BADSURVEY = .TRUE.
      ABORT_ON_BADFILTER = .TRUE.
      ABORT_ON_MARGPDF0  = .TRUE.
      ABORT_ON_TRESTCUT  = .TRUE. ! for photo-z fits only
      ABORT_ON_DUPLCID   = .TRUE.
      ABORT_ON_DUPLMJD   = .FALSE.  ! Jun 2017
      ABORT_ON_NOPKMJD   = .TRUE.

      SNTABLE_LIST          = 'DEFAULT'  ! Sep 08 2014
      SNTABLE_FILTER_REMAP  = ''
      WRTABLEFILE_SIMVAR    = .TRUE.     ! Jul 17 2016
      WRTABLEFILE_ZPHOT     = .TRUE.     ! Mar 19 2018
      WRTABLEFILE_HOST_TEXT  = .FALSE.    ! May 23 2019
      WRTABLEFILE_HOST2_TEXT = .FALSE.    ! Sep 2023
      WRTABLEFILE_ERRCALC_TEXT = .FALSE. ! Oct 30 2019

      SNTABLE_APPEND_VARNAME = ''
      SNTABLE_APPEND_VALUE   = -9.0

c ----------------------------------------
c check command line arg for namelist file;

       CALL GETARG(1, nmlfile )
       if ( nmlFile(1:6) .EQ. 'NOFILE' ) GOTO 400  ! Jan 5 2016


c ------------------------
c read the nml

300   CONTINUE

      LL = INDEX(nmlfile,' ' ) - 1
      print*,'   Read namelist file: ', nmlfile(1:LL)

      OPEN (
     &    UNIT   = LUNNML
     &   ,file   = nmlfile
     &   ,status = 'OLD'
     &   ,ERR    = 900 
     &       )

      READ(LUNNML, NML=SNLCINP, ERR=901, END=902 )      
          
      CLOSE ( UNIT = LUNNML ) 

400   CONTINUE

c check for namelist over-rides from command line.    
      CALL SNLCINP_OVERRIDE()  ! refact with MATCH_NMLKEY (Enable 8.19.2020)

c check for cut on simulated search eff;
c if set, then require SEARCHEFF_MASK = 3 =>
c bits 1 & 2 are set.

      IF ( LSIM_SEARCH_SPEC ) THEN
        cutwin_searcheff_mask(1) = 2.9
        cutwin_searcheff_mask(2) = 3.1
      ENDIF

      IF ( LSIM_SEARCH_ZHOST ) THEN  ! Jun 19 2018
        cutwin_searcheff_mask(1) = 4.9
        cutwin_searcheff_mask(2) = 5.1
      ENDIF

c Mar 31 2021: check PHOTFLAG_BITLIST (LSB=0) and compute PHOTFLAG_MSKREJ
      IF ( PHOTFLAG_BITLIST_REJECT(1) .GE. 0 ) THEN
         PHOTFLAG_MSKREJ(1) = 0
         i = 1
         DO WHILE ( PHOTFLAG_BITLIST_REJECT(i) .GE. 0 ) 
            bit = PHOTFLAG_BITLIST_REJECT(i) 
            PHOTFLAG_MSKREJ(1) = IBSET(PHOTFLAG_MSKREJ(1),BIT)
            i = i + 1
         END DO
      ENDIF


+SELF,IF=SNANA.
      NFIT_ITERATION = 0
+SELF.

      IF ( .not. REDUCE_STDOUT_BATCH ) THEN
        WRITE ( 6 , NML = SNLCINP )
        CALL FLUSH(6)
      ENDIF

+SELF,IF=SNFIT.
      IF ( NFIT_ITERATION .LE. 0 ) THEN
         write(c1err,821) NFIT_ITERATION
821      format('NFIT_ITERATION = ', I3 )
         C2ERR = 'NFIT_ITERATION must be > 0 (see &SNLCINP namelist).'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF
+SELF.

c -----------------------------------------
c Compute useful variables from namelist

      NIDFIELD_LIST = PARSE_NML_STRINGLIST(SNFIELD_LIST,60)
      DOALL_SNFIELD = ( SNFIELD_LIST(1) .EQ. 'ALL' )

      i = 1 ; NSNTYPE_LIST=0
      DO WHILE ( SNTYPE_LIST(i) .GE. MNTYPE ) 
          NSNTYPE_LIST = NSNTYPE_LIST + 1
          i = i + 1
      END DO
      if ( NSNTYPE_LIST .GT. MXLISTNML ) then
          write(c1err,678) 'SNTYPE_LIST', NSNTYPE_LIST, MXLISTNML
678       format(A,2x,I3,' elements exceeds bound.')
          CALL  MADABORT(FNAM, C1ERR, ' ') 
      endif

      i = 1 ; NCCDNUM_LIST=0
      DO WHILE ( CCDNUM_LIST(i) > 0 ) 
          NCCDNUM_LIST = NCCDNUM_LIST + 1
          i = i + 1
      END DO

      i = 1 ; NSIM_TEMPLATE_INDEX_LIST=0
      DO WHILE ( SIM_TEMPLATE_INDEX_LIST(i) > 0 ) 
          NSIM_TEMPLATE_INDEX_LIST = NSIM_TEMPLATE_INDEX_LIST+1
          i = i + 1
      END DO

      i = 1 ; NSNTYPE_IGNORE=0
      DO WHILE ( SNTYPE_IGNORE(i) .GE. 0 ) 
          NSNTYPE_IGNORE = NSNTYPE_IGNORE + 1
          i = i + 1
      END DO
      if ( NSNTYPE_IGNORE .GT. MXLISTNML ) then
          write(c1err,678) 'SNTYPE_IGNORE',NSNTYPE_IGNORE,MXLISTNML
          CALL  MADABORT(FNAM, C1ERR, ' ') 
      endif

c ------------------------
c count number of photometry versions

      CALL PREP_VERSION_PHOTOMETRY()

c Feb 27 2018: check ZP cut
      NZPCUT = 0
      if ( CUTWIN_ZPADU(1) > 0. ) then
         CUTWIN_ZP(1) = CUTWIN_ZPADU(1)
         CUTWIN_ZP(2) = CUTWIN_ZPADU(2)
         NZPCUT = NZPCUT+1
      endif
      if ( CUTWIN_ZPNPE(1) > 0. ) then
         CUTWIN_ZP(1) = CUTWIN_ZPNPE(1)
         CUTWIN_ZP(2) = CUTWIN_ZPNPE(2)
         NZPCUT = NZPCUT+1
      endif
      IF ( NZPCUT > 1 ) THEN
         C1ERR = 'Cannot specify both CUTWIN_ZPADU and CUTWIN_ZPNPE'
         C2ERR = 'Pick one of these CUTWIN_ZP options.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

c -----------------------------

      DO_FIT = NFIT_ITERATION .GT. 0

c init some INIXXX parameter for fit
      IF ( DO_FIT ) THEN
         do ipar = 1, MXFITPAR
            INIBND(1,ipar) =  -1.0E4  ! avoid crazy MINUIT excursions
            INIBND(2,ipar) =  +1.0E4
            INIVAL(ipar)   =  -9.0
            INISTP(ipar)   =   0.0
         enddo
      ENDIF

      IF ( MWEBV_SCALE .NE. 1.0 .or. MWEBV_SHIFT .NE. 0.0 ) THEN
         GLOBAL_BANNER = ''
         write(GLOBAL_BANNER,541) MWEBV_SCALE, MWEBV_SHIFT
541      format('Galactic MWEBV -> MWEBV *', F6.3,'  +  ', F6.3 )
        CALL PRBANNER ( GLOBAL_BANNER )
      ENDIF

      IF ( MWEBV_FORCE > -0.01 ) THEN
         GLOBAL_BANNER = ''
         write(GLOBAL_BANNER,542) MWEBV_FORCE
542      format('Force Galactic MWEBV -> ', F6.3 )
        CALL PRBANNER ( GLOBAL_BANNER )
      ENDIF

      IF ( CUTWIN_PHOTPROB(1) > -0.001 .and. 
     &     PHOTFLAG_DETECT==0) THEN         
         C1ERR = 'Cannot define CUTWIN_PHOTPROB without also'
         C2ERR = 'defining PHOTFLAG_DETECT'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF 

c ---------------------------
      IF ( VALIDFILENAME(VERSION_REFORMAT_FITS) ) THEN
        OPT_REFORMAT_FITS = IBSET(OPT_REFORMAT_FITS,0) ! set 1st bit
      ENDIF
      IF ( VALIDFILENAME(VERSION_REFORMAT_TEXT) ) THEN    ! Feb 2021
        OPT_REFORMAT_TEXT = IBSET(OPT_REFORMAT_TEXT,0) ! set 1st bit
      ENDIF

c - - - - -
      IF ( SIMLIB_OUT .NE. '' ) SIMLIB_OUTFILE = SIMLIB_OUT

c ---------------------------
c if ENV is in path, make substitution
      CALL ENVreplace(PRIVATE_DATA_PATH) 

c check 'pwd' option, which is meant to run split_and_fit on 
c different clusters using private data in your `pwd' .
c If interactive, replace invalid pwd/ with a valid './' path.

      IF ( PRIVATE_DATA_PATH .EQ. 'pwd' ) THEN
         PRIVATE_DATA_PATH = '.'
      ENDIF

c if PRIVATE_DATA_PATH points to public $SNDATA_ROOT/lcmerge,
c disalbe PRIVATE_DATA_PATH.
      LL = INDEX(SNDATA_ROOT,' ' ) - 1
      IF ( PRIVATE_DATA_PATH.EQ.SNDATA_ROOT(1:LL)//'/lcmerge')THEN
          PRIVATE_DATA_PATH = ' '
      ENDIF

c Jan 2025; set global flags for reading SNIDs from separate file
      USE_SNCID_FILE        = BTEST(OPT_SNCID_LIST,0) ! use CIDs from file
      USE_INIVAL_SNCID_FILE = BTEST(OPT_SNCID_LIST,1) ! set each INIVAL = FITPAR from file
      USE_PRIOR_SNCID_FILE  = BTEST(OPT_SNCID_LIST,2) ! use each FITPAR & ERR as prior


c Nov 15 2019: abort on obsolete key
      IF ( CUTWIN_NBAND_THRESH(1) > -1.0 .or. 
     &     CUTWIN_NBAND_THRESH(2) > -1.0 ) then
         
         C1ERR = 'Remove obsolete CUTWIN_NBAND_THRESH from &SNLCINP.'
         C2ERR = 'Sorry for the inconvenience.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

C #################################################

               RETURN

C #################################################

900   c1err = 'Could not open namelist file: '
      c2err = nmlfile(1:80)
      CALL  MADABORT(FNAM, C1ERR, C2ERR)
      GOTO 990

901   C1ERR = 'could not read &SNLCINP namelist'
      c2err = "Check input-namelist file."
      CALL  MADABORT(FNAM, C1ERR, C2ERR )
      GOTO 990

902   C1ERR = 'could not find &SNLCINP namelist'
      c2err = "Check input-namelist file."
      CALL  MADABORT(FNAM, C1ERR, C2ERR )
      GOTO 990

990   IERR = -1
      RETURN
      END  ! end of RDSNNML

C =======================================
+DECK,PREP_VERSION_PHOT.
      SUBROUTINE PREP_VERSION_PHOTOMETRY()

c Created Mar 2022 by R.Kessler
c Check wildcard option to get photometry folders using glob.
c Abort if too many versions.
c
c Aug 2022: set abort trap on VERSION string length

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER i, index_C, LENV, LENF, JSLASH,  NVERS, langFlag
      CHARACTER 
     &   FNAM*24
     &  ,cSTRING*(MXCHAR_FILENAME), cFILE*(MXCHAR_FILENAME)
     &  ,VERSION*(2*MXCHAR_VERSION)
      LOGICAL  IGNOREFILE_fortran, IGNORE
      INTEGER  STORE_GLOB_FILE_LIST
      EXTERNAL STORE_GLOB_FILE_LIST
      EXTERNAL GET_GLOB_FILE, RESET_GLOB_FILE_LIST

c ---------- BEGIN -------------

      FNAM = 'PREP_VERSION_PHOTOMETRY'

c check for wild card; e.g., 

      CALL ENVreplace(VERSION_PHOTOMETRY_WILDCARD)
      LENV    = INDEX(VERSION_PHOTOMETRY_WILDCARD,' ') - 1

      IGNORE  = IGNOREFILE_fortran(VERSION_PHOTOMETRY_WILDCARD)

      IF ( .NOT. IGNORE ) THEN
         print*,' '
         print*,' Use glob to find data folders for'
         print*,'     ', VERSION_PHOTOMETRY_WILDCARD(1:LENV)
         call flush(6)

         cSTRING = VERSION_PHOTOMETRY_WILDCARD(1:LENV) // char(0) 
         NVERS = STORE_GLOB_FILE_LIST(cSTRING,LENV)

         if ( NVERS == 0 ) then
	    C1ERR = 'Found zero data versions matching wildcard'
	    C2ERR = 'Check &SNLCINP  VERSION_PHOTOMETRY_WILDCARD'
            CALL MADABORT(FNAM, C1ERR, C2ERR)
 	 endif
	 
         langFlag = 1 ! fortran
         DO i = 1, NVERS
            index_C = i - 1  ! C index
            CALL GET_GLOB_FILE(langFlag, index_C, cFILE, LENF)

c  strip off base name after last slash
            JSLASH = INDEX(cFILE,'/', BACK=.TRUE.)
            LENF   = INDEX(cFILE,' ') - 1
            VERSION_PHOTOMETRY(i) = cFILE(JSLASH+1:LENF)

            LENV = INDEX(VERSION_PHOTOMETRY(i),' ') - 1
            print*,' Found ', VERSION_PHOTOMETRY(i)(1:LENV)
         ENDDO
         call flush(6)
         CALL RESET_GLOB_FILE_LIST()
c           STOP ! xxx
      ENDIF

c - - - - -
c Count number of versions, and check string length

      i = 1
      DO WHILE ( VERSION_PHOTOMETRY(i) .NE. 'NULL' )           
        N_VERSION = i
        VERSION = VERSION_PHOTOMETRY(i)
        LENV = INDEX(VERSION,' ') - 1
        IF ( LENV .LE. 0 .or. LENV .GE. MXCHAR_VERSION ) THEN
          CALL PRINT_PREABORT_BANNER(FNAM//char(0),40)
          print*,' VERSION = ', VERSION
          print*,' LEN(VERSION) = ', LENV
          print*,' Beware that MXCHAR_VERSION = ', MXCHAR_VERSION
          C1ERR = 'Invalid string len for VERSION'
          write(c2err,17) MXCHAR_VERSION
17        format('VERSION is either blank, or exceeds ',I3,' chars')
          CALL MADABORT(FNAM, C1err, C2err)
        ENDIF


        if ( N_VERSION .GT. MXVERS ) then
          write(C1ERR,61) N_VERSION, MXVERS
61        format('N_VERSION=',I3,' exceeds MXVERS=',I3)
          C2ERR = 'Reduce number of data versions or increase MXVERS'
          CALL  MADABORT(FNAM, C1ERR, C2ERR )
        endif
        i = i + 1
      END DO

      RETURN
      END   ! end PREP_VERSION_PHOTOMETRY

C ======================================
+DECK,CHKBOUND.
      SUBROUTINE CHKARRBOUND(i,MIN,MAX, VARNAME, COMMENT, FUNNAME)

c Nov 2013
c One-line array bound check.
c Abort if index i is outside range MIN to MAX.
c Char input args are used for abort message.

      IMPLICIT NONE

      INTEGER i, MIN, MAX  ! (I) index, MIN,MAX of array
      CHARACTER 
     &   VARNAME*(*)  ! (I) name of variable
     &  ,COMMENT*(*)  ! (I) comment string
     &  ,FUNNAME*(*)  ! (I) name of calling function

c local var

      CHARACTER MSG1*80, MSG2*80

C ------------------- BEGIN ------------------

      IF ( i .GE. MIN .and. i .LE. MAX ) RETURN

      write(MSG1,61) VARNAME, i, MIN, MAX, FUNNAME
 61   format(A,'-index ',I4,' outside valid range ',I2,'-',I5, 3x,
     &          '(FUN=',A,')'  )

      MSG2 = COMMENT

      CALL  MADABORT("CHKARRBOUND", MSG1, MSG2)
 
      RETURN
      END

C ===================================
+DECK,CHKCCID.
      SUBROUTINE NMLCHECK_SNCCID(NMLVARNAME, CCID)

C Apr 26 2013
C Abort if CCID string contains a comma or blank space between
C strings. 
C For example, abort on strings such as
C  '04D46,05D446' ,  '04D46 05D446' 
C
C NMLVARNAME is the name of the namelist variable, 
C for error message only.
C
C ---------------- BEGIN --------------

      IMPLICIT NONE

      CHARACTER NMLVARNAME*(*)  ! (I) name of namelist variable
      CHARACTER CCID*(*)        ! (I) SN CID name
 
c local variables

+CDE,SNPAR.

      INTEGER   JCOMMA, NWD, LEN, MSKOPT
      CHARACTER MSG1*72, MSG2*72, FNAM*30

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN -----------------

      FNAM = 'NMLCHECK_SNCCID'
      JCOMMA   = INDEX(CCID,',')

      LEN      = INDEX(CCID,' ' ) - 1
      MSKOPT   = MSKOPT_PARSE_WORDS_STRING
      NWD      = STORE_PARSE_WORDS(MSKOPT,CCID(1:LEN)//char(0),
     &               FNAM//char(0), LEN, 30)

      IF ( JCOMMA > 0 .or. NWD > 1 ) THEN
         MSG1 = 'Invalid nml variable ' 
     &           // NMLVARNAME // ' = ' // CCID
         MSG2 = 'No blanks or commas allowed.'
         CALL  MADABORT("NMLCHECK_SNCCID", MSG1, MSG2)
      ENDIF

      RETURN
      END


C ========================================
+DECK,INIT_OUTFILES.
      SUBROUTINE  INIT_OUTFILES(NFIT_PER_SN)


c Created Feb 2012
c
c Call appropriate init function for  root, etc ...
c Note that multiple output files can be initialized
c corresponding to different formats.
c If no files are opened, print warning message but do not abort.
c
c Note that NFIT_PER_SN is the max number of expected fits per SN.
c
c Apr 26 2014: replace HFILE_OPEN and ROOTFILE_OPEN with generic
c              wrapper TABLEFILE_OPEN.
c
c May  3, 2014: call SNLCPAK_INIT only if NFIT_PER_SN > 0
c May 12, 2014: overhaul the ascii format; see TEXTFILE_PREFIX.
c               rename SNFILE_OUT_INIT -> INIT_OUTFILES
c
c Sep 07, 2014: pass TEXTFORMAT to SNLCPAK_INIT()
c
c Dec 10 2017: if NFILT_REMAP_TABLE>0, pass REMAP list of filters
c              to SNLCPAK_INIT
c
c Dec 19 2019: pass SIMFLAG to SNLCPAK_INIT.
c
c Apr 03 2020: add call to  ENVreplace(TEXTFILE_PREFIX)
c
c May 02 2020: begin MARZFILE_OUT (to store WFIRST host spectra for MARZ)
c
c Mar 19 2021: use IGNOREFILE to check usage; e.g., allows
c                ROOTFILE_OUT NONE
c
c Sep 21 2023: fix mistaken 1:40 truncation of VER_PHOT_forC
c
c ------------------------------------------------------

      IMPLICIT NONE

      INTEGER NFIT_PER_SN ! (I) max number of fits to plot per SN

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LENFILE,  IFILETYPE, SIMFLAG

      CHARACTER 
     &   FNAM*16
     &  ,COPT*20
     &  ,CFILE*(MXCHAR_FILENAME)
     &  ,TEXTFMT*20

      INTEGER LENV1, LENV2, LENSRVY, LENFILT, LENFMT, LENC
      CHARACTER 
     &   SURVEY_forC*(MXCHAR_SURVEY)
     &  ,VER_PHOT_forC*(MXCHAR_VERSION)
     &  ,VER_SNANA_forC*40
     &  ,FILTERS_forC*(MXFILT_OBS)
     &  ,TEXTFMT_forC*20
     &  ,COMMENT_forC*(MXCHAR_VERSION)

c function
      INTEGER  IGNOREFILE, TABLEFILE_OPEN
      EXTERNAL IGNOREFILE, TABLEFILE_OPEN
      
C --------------- BEGIN -------------

      FNAM = 'INIT_OUTFILES'

      CALL TABLEFILE_INIT();  ! 4/26/2014

c -----------------------------------------
c set strings needed for the SNLCPAK_INIT functio
 
      LENSRVY      = INDEX(SURVEY_NAME,' ') - 1
      SURVEY_forC  = SURVEY_NAME(1:LENSRVY) // char(0)

      LENV1         = INDEX(VERSION_PHOTOMETRY(1),' ') - 1
      VER_PHOT_forC = VERSION_PHOTOMETRY(1)(1:LENV1) // char(0)

      LENV2         = INDEX(SNANA_VERSION,' ') - 1
      VER_SNANA_forC = SNANA_VERSION(1:LENV2) // char(0)

      LENFILT      = INDEX(SURVEY_FILTERS,' ') - 1
      FILTERS_forC = SURVEY_FILTERS(1:LENFILT) // char(0)
      if ( NFILT_REMAP_TABLE > 0 ) then  ! Dec 2017
         LENFILT      = INDEX(FILTLIST_REMAP_TABLE,' ') - 1
         FILTERS_forC = FILTLIST_REMAP_TABLE(1:LENFILT) // char(0)
      endif

      TEXTFMT      = TEXTFORMAT_TABLE(ITABLE_SNLCPAK)
      LENFMT       = INDEX(TEXTFMT,' ') - 1
      TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)

      IF ( OPT_TABLE(ITABLE_SNLCPAK) > 0 ) THEN
         SIMFLAG = 0
         IF ( ISJOB_SIM ) SIMFLAG=1
         CALL SNLCPAK_INIT(SURVEY_forC, VER_PHOT_forC, VER_SNANA_forC,
     &        FILTERS_forC, SIMFLAG, NFIT_PER_SN, TEXTFMT_forC,
     &        LENSRVY, LENV1, LENV2, LENFILT, LENFMT )
      ENDIF

      IF ( OPT_TABLE(ITABLE_SPECPAK) > 0 ) THEN
         TEXTFMT      = TEXTFORMAT_TABLE(ITABLE_SPECPAK)
         LENFMT       = INDEX(TEXTFMT,' ') - 1
         TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)     
         CALL SPECPAK_INIT(SURVEY_forC, VER_PHOT_forC, TEXTFMT_forC,
     &          LENSRVY, LENV1, LENFMT )
      ENDIF

c -------------------------------------------

      USE_TABLEFILE        = .FALSE.
      USE_TABLEFILE_ROOT   = .FALSE.      
      USE_TABLEFILE_TEXT   = .FALSE.     ! May 2 2020 (forgot init earlier)
      USE_TABLEFILE_MARZ   = .FALSE.     ! May 2 2020 (new table)

c MARZ (host spectra only)

      LENFILE   = INDEX(MARZFILE_OUT,' ') - 1
      CFILE     = MARZFILE_OUT(1:LENFILE) // char(0)
      IF ( IGNOREFILE(cFILE,LENFILE) == 0 ) THEN
         COPT          = "new" // char(0)
         CALL ENVreplace(MARZFILE_OUT)
         IFILETYPE = TABLEFILE_OPEN(CFILE, COPT, LENFILE, 20)

         USE_TABLEFILE_MARZ = .TRUE. 
         USE_TABLEFILE      = .TRUE.

         IF ( IFILETYPE < 0 ) THEN
            C1ERR = 'Could not open MARZ fits-file'
            C2ERR = MARZFILE_OUT(1:LENFILE)
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         ENDIF
      ENDIF


      LENFILE   = INDEX(ROOTFILE_OUT,' ') - 1
      CFILE     = ROOTFILE_OUT(1:LENFILE) // char(0)
      IF ( IGNOREFILE(cFILE,LENFILE) == 0 ) THEN
         COPT          = "new root" // char(0)
         USE_TABLEFILE_ROOT = .TRUE. 
         USE_TABLEFILE      = .TRUE.
         IFILETYPE = TABLEFILE_OPEN(CFILE, COPT, LENFILE, 20)

         IF ( IFILETYPE < 0 ) THEN
            C1ERR = 'Could not open ROOT table-file'
            C2ERR = ROOTFILE_OUT(1:LENFILE)
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         ENDIF
      ENDIF


      LENFILE   = INDEX(TEXTFILE_PREFIX,' ') - 1
      CFILE     = TEXTFILE_PREFIX(1:LENFILE) // char(0)
      IF ( IGNOREFILE(cFILE,LENFILE) == 0 ) THEN
         CALL ENVreplace(TEXTFILE_PREFIX)
         COPT          = "new text" // char(0)
         USE_TABLEFILE_TEXT = .TRUE. 
         USE_TABLEFILE      = .TRUE.
         IFILETYPE = TABLEFILE_OPEN(CFILE, COPT, LENFILE, 20)

         IF ( IFILETYPE < 0 ) THEN
            C1ERR = 'Could not open TEXT table-files with PREFIX='
            C2ERR = TEXTFILE_PREFIX(1:LENFILE)
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         ENDIF
      ENDIF

c ----------------------------------------
c Oct 23, 2014: store global comments

      LENC = MXCHAR_VERSION

      COMMENT_forC = 'VERSION_PHOTOMETRY:  '//VER_PHOT_forC(1:LENC)
      CALL STORE_TABLEFILE_COMMENT(COMMENT_forC, LENC)

c ----------------------------------------
c     print warning message if there is no table file
      IF ( .not. USE_TABLEFILE ) THEN
         print*,' '
         write(6,60) 
         write(6,61) 
     &     'no table-file specified for tables and light curves'
         write(6,60) 
         print*,' '
 60      format(T3, 'WARNING: ', 30('<>') )
 61      format(T3, 'WARNING: ', A)
      ENDIF
      
      RETURN
      END   ! end of INIT_OUTFILES


C ================================================
+DECK,INIT_SNTABLE_OPT.
      SUBROUTINE INIT_SNTABLE_OPTIONS()
c
c Created May 2014 by R.Kessler
c
c Analyze user input string SNTABLE_LIST (&SNLCINP) and set the 
c following arrays vs. sparse ITABLE index:
c
c   OPT_TABLE         ! 0,1 --> on,off;  >1 --> other option
c   TEXTFORMAT_TABLE  ! key, csv, col, none
c
c This input string controls which tables are produced
c (SNANA, FITRES, SNLCPAK) and what text formats if 
c TEXTFILE_PREFIX is given. 
c
c
c Apr 26 2017: check pre-scale option: e.g.  'SNANA(ps:100)'
c Mar 19 2018: check nozphot option
c Jan 29 2019: serach for last non-null char in SNTABLE_LIST to get LENTB
c Jan 30 2019: MXTYPE -> 1000 (was 400)
c May 09 2019: 
c  + ITABLE_SPECTRA renamed to ITABLE_MODELSPEC (for SALT2 only)
c       (to avoid confusion with ITABLE_SPECPAK
c  + fix bug parsing options with comma; see new MSKOPT argument
c    to store_PARSE_WORDS()
c
c May 23 2019: add text:host    option ; see WRTABLEFILE_HOST_TEXT
c Oct 30 2019: add text:errcalc option ; see WRTABLEFILE_ERRCALC_TEXT
c Jul 13 2020: no default SNTABLEs if writing rejected epochs
c Mar 17 2021: begin OUTLIER table
c Apr 25 2021: OUTLIER table is automatically disabled for large BIASCOR sim
c Apr 19 2022: disable LCPLOT table for sims in batch mode
c                (to avoid excessive output)
c
c -------------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,OUTLIERCOM.

      INTEGER   
     &   itab, iwd, LENS, LENTB, LENOPT, LEN1,LEN2, NOPT, iopt, 
     &   PS, NWD, i, MSKOPT, j_colon

      CHARACTER USERSTRING*60, locase_STRING*60, TBNAME*60
      CHARACTER COPT_LIST(10)*20, COPT*40, FNAM*22, C_ARG*100
      CHARACTER cTMPOPT*60
      LOGICAL   MATCH, USEOPT, DO_SNTABLE, DISABLE

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

c ---------------- BEGIN ----------------

      FNAM = 'INIT_SNTABLE_OPTIONS'

c if reformating option is set, turn off all table output
      IF ( OPT_REFORMAT_SALT2 > 0 ) SNTABLE_LIST = ' '
      IF ( OPT_REFORMAT_FITS  > 0 ) SNTABLE_LIST = ' '
      IF ( OPT_REFORMAT_TEXT  > 0 ) SNTABLE_LIST = ' '

c init options to nothing created.

      DO itab = 1, MXTABLE
         OPT_TABLE(itab)          = 0
         PRESCALE_TABLE(itab)     = 1.0
      ENDDO

c Set default text format to output text-table for FITRES only:
c with default SNTABLE_LIST = 'SNANA  FITRES  LCPLOT' ,
c setting TEXTFILE_PREFIX  results in an ascii table for the 
c FITRES table only ... just as before. To get ascii table for 
c SNANA or LC, user must explicitly request it in the &SNLCINP
c namelist, SNTABLE_LIST = 'SNANA(text:[format])' and SNANA->LCPLOT.

c xxx mark delete      TEXTFORMAT_TABLE(ITABLE_SNANA)     = 'none'
      TEXTFORMAT_TABLE(ITABLE_SNANA)     = 'key'  ! Mar 2025
      TEXTFORMAT_TABLE(ITABLE_FITRES)    = 'key'
      TEXTFORMAT_TABLE(ITABLE_OUTLIER)   = 'key'
      TEXTFORMAT_TABLE(ITABLE_SNLCPAK)   = 'key'  ! xxx 'none'
      TEXTFORMAT_TABLE(ITABLE_SPECPAK)   = 'none' ! Apr 2019
      TEXTFORMAT_TABLE(ITABLE_MODELSPEC) = 'none' 
      TEXTFORMAT_TABLE(ITABLE_MARZ)      = 'none' 


+SELF,IF=SNANA.
c  ISJOB_SNANA isn't set yet, so use preproc flag
      TEXTFORMAT_TABLE(ITABLE_SNANA) = 'key' ! Mar 2021
+SELF.

      CUTMASK_SNANA_TABLE = 63  ! default is to add everything in snana table

c -------------------------
      CALL PRBANNER(FNAM)
c ----------------------------------------------
c If using default, replace 'DEFAULT' with actual default value.

      IF ( SNTABLE_LIST .EQ. 'DEFAULT' ) THEN
         SNTABLE_LIST = SNTABLE_LIST_DEFAULT

c  No default SNTABLEs if writing rejected epochs
         IF ( OUT_EPOCH_IGNORE_FILE .NE. ''  ) SNTABLE_LIST = ' '

c  No default SNTABLEs if there is no NML file (Feb 2021)
         IF ( nmlFile(1:6) .EQ. 'NOFILE' ) SNTABLE_LIST = ' '
      ENDIF

c by default the SNID is written out as is
      WRTABLEFILE_IAUC = .FALSE.

c by default, SIM_XXX (truth) values are included for simulation
      WRTABLEFILE_SIMVAR = .TRUE.

c by default, ZPHOT[ERR] and ZPHOT-covariances are included
      WRTABLEFILE_ZPHOT  = .TRUE.

c for TEXT format, exclude HOSTGAL info by default
      WRTABLEFILE_HOST_TEXT  = .FALSE.
      WRTABLEFILE_HOST2_TEXT = .FALSE.

c --------------------------------------
c bail of there is nothing to do.
      DO_SNTABLE = .TRUE.
      IF ( SNTABLE_LIST      .EQ. ' '    ) DO_SNTABLE = .FALSE.
      IF ( SNTABLE_LIST(1:4) .EQ. 'NONE' ) DO_SNTABLE = .FALSE.

      IF ( .NOT. DO_SNTABLE    ) RETURN   

c ---------------------------------------
c parse SNTABLE_LIST string
  
      LENTB = 0
      DO i = 1, MXCHAR_FILENAME
        if ( SNTABLE_LIST(i:i) .NE. ' ' ) LENTB=i  ! last non-null char
      ENDDO
      C_ARG = SNTABLE_LIST(1:LENTB) // char(0)

      MSKOPT = MSKOPT_PARSE_WORDS_STRING+MSKOPT_PARSE_WORDS_IGNORECOMMA
      NWD   = STORE_PARSE_WORDS(MSKOPT, C_ARG, 
     &            FNAM//char(0), MXCHAR_FILENAME, 30) 

      DO 100 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd, USERSTRING, LENS);

c convert everything to lower case for parsing so that
c the input is case-insensitive
         CALL loCase(USERSTRING, locase_STRING)

c split string into table name and optional option inside ().
c STRING is of the form "tbName(copt_list)".

         CALL PARSE_SNTABLE_LIST(locase_STRING, TBNAME, NOPT, COPT_LIST)

c check MARZ outpout option (May 2020)
         if ( MARZFILE_OUT .NE. ' ' ) OPT_TABLE(ITABLE_SPECPAK)=2

c - - - - - - - - - - - - - - - - - - 
c check table-names

         if ( TBname(1:5) .EQ. 'snana' ) then
            ITAB = ITABLE_SNANA
            OPT_TABLE(ITAB) = 1
            if ( TBname(1:11) .EQ. 'snana+epoch' ) then
               OPT_TABLE(ITAB) = 2     ! include epoch info (Mar 2015)
            endif
            if ( TBname(1:16) .EQ. 'snana+sim_magobs' 
     &           .and. LSIM_SNANA) then
               OPT_TABLE(ITAB) = 4     ! include SIM_MAGOBS vs. MJD (1/2019)
            endif

         else if ( TBname(1:6) .EQ. 'fitres' ) then
            ITAB = ITABLE_FITRES
            OPT_TABLE(ITAB) = 1
            if ( TBname(1:15) .EQ. 'fitres+residual' ) then
               OPT_TABLE(ITAB) = 2     ! include epoch fit resids
            endif

         else if ( TBname(1:7) .EQ. 'outlier' ) then
c           OUTLIER table is automatically disabled for large BIASCOR sim
            if ( SIM_BIASCOR_MASK == 0 ) then 
              ITAB = ITABLE_OUTLIER
              OPT_TABLE(ITAB) = 1
              NSIGCUT_OUTLIER   = 3.0   ! default outlier def is 3sigma
              FTRUECUT_OUTLIER  = 0.01  ! default requires Ftrue > 0
              SBMAGCUT_OUTLIER  = 999.  ! default is no SBMAG cut (Aug 2021)
            endif
         else if ( TBname(1:6) .EQ. 'lcplot' ) then 
            ITAB = ITABLE_SNLCPAK
            DISABLE = ( ISJOB_BATCH .and. ISJOB_SIM ) 
            IF ( DISABLE ) THEN
               NOPT = 0 
               print*,
     &           '  WARNING: disable LCPLOT table for sim-data in batch'
               call flush(6)
            ELSE
               OPT_TABLE(ITAB) = 1
            ENDIF
         else if ( TBname(1:8) .EQ. 'specplot' ) then  
            ITAB = ITABLE_SPECPAK  ! spectra in the data files
            OPT_TABLE(ITAB) = 1

         else if ( TBname(1:9) .EQ. 'modelspec' ) then 
            ITAB = ITABLE_MODELSPEC  ! SALT2 model spec
            OPT_TABLE(ITAB) = 1
         else if ( TBname(1:7) .EQ. 'spectra' ) then 
            ITAB = ITABLE_MODELSPEC  ! legacy key for SALT2 model spec
            OPT_TABLE(ITAB) = 1

         else if ( TBname(1:8) .EQ. 'nosimvar' ) then ! option, not a table
            WRTABLEFILE_SIMVAR = .FALSE.  ! July 2016

         else if ( TBname(1:7) .EQ. 'nozphot' ) then ! option, not a table
            WRTABLEFILE_ZPHOT = .FALSE.  ! Mar 2018

         else
            C1ERR = 'Unrecognized table name : ' // TBname(1:20)
            C2ERR = 'Check manual'
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         endif

c check for options inside ()
         DO 200 iopt = 1, NOPT
            COPT     = COPT_LIST(iopt)
            LENOPT   = index(COPT,' ') - 1
            USEOPT   = .FALSE.
            j_colon  = INDEX(copt,':')

            MATCH= ( copt(1:5) .EQ. 'text:' )
            if ( MATCH ) then
               cTMPOPT = copt(6:LENOPT) // ' '
               if( cTMPOPT(1:5) .EQ. 'host2' ) then
                  WRTABLEFILE_HOST2_TEXT = .TRUE.  ! for SNANA table  
               else if( cTMPOPT(1:4) .EQ. 'host' ) then
                  WRTABLEFILE_HOST_TEXT = .TRUE.  ! for SNANA table  
               else if ( cTMPOPT(1:7) .EQ. 'errcalc' ) then
                  WRTABLEFILE_ERRCALC_TEXT = .TRUE.  ! for LCPLOT table
               else
                  TEXTFORMAT_TABLE(itab) = cTMPOPT(1:8) ! format
               endif
               USEOPT = .TRUE.
            endif

            MATCH = (copt(1:5) .EQ. 'mxlc:' )
            if ( MATCH  .and. ITAB .EQ. ITABLE_SNLCPAK) then
               read(copt(6:LENOPT),*) MXLC_PLOT
               USEOPT = .TRUE.
            endif

            MATCH = ( copt(1:8) .EQ. 'cutmask:' )
            if ( MATCH  .and. ITAB .EQ. ITABLE_SNANA ) then
               read(copt(9:LENOPT),*) CUTMASK_SNANA_TABLE
               USEOPT = .TRUE.
            endif

            MATCH = ( copt(1:4) .EQ. 'iauc' )
            if ( MATCH ) then
               WRTABLEFILE_IAUC = .TRUE.
               USEOPT           = .TRUE.
            endif

            MATCH = ( copt(1:3) .EQ. 'ps:' ) 
            if ( MATCH ) then
               read(copt(4:LENOPT),*) PS
               PRESCALE_TABLE(itab) = PS
               USEOPT           = .TRUE.
            endif
          
            MATCH = copt(1:5) .EQ. 'nsig:'
            IF ( MATCH ) THEN
               read(copt(6:LENOPT),*) NSIGCUT_OUTLIER
               USEOPT = .TRUE.
            ENDIF
            MATCH = copt(1:6) .EQ. 'ftrue:'
            IF ( MATCH ) THEN
               read(copt(7:LENOPT),*) FTRUECUT_OUTLIER
               USEOPT = .TRUE.
            ENDIF
            MATCH = copt(1:6) .EQ. 'sbmag:'
            IF ( MATCH ) THEN
               read(copt(7:LENOPT),*) SBMAGCUT_OUTLIER
               USEOPT = .TRUE.
            ENDIF

            if ( .NOT. USEOPT ) then
               LENTB = index(TBNAME,' ') - 1
               C1ERR = 'Invalid option: ' // COPT(1:LENOPT)
               C2ERR = 'for Table = ' // TBNAME(1:LENTB)
               CALL  MADABORT(FNAM, C1ERR, C2ERR)               
            endif

 200     CONTINUE

 100  CONTINUE  ! end loop over table names

c ------------
c if LCPLOT is not specified, set MXLC_PLOT to zero.
      IF  ( OPT_TABLE(ITABLE_SNLCPAK) == 0 .and.
     &      OPT_TABLE(ITABLE_SPECPAK) == 0  )    MXLC_PLOT = 0

c -------------
c summarize 

      ITAB = ITABLE_SNANA
      write(6,40) 'SNANA',  OPT_TABLE(ITAB), TEXTFORMAT_TABLE(ITAB)

      ITAB = ITABLE_FITRES
      write(6,40) 'FITRES', OPT_TABLE(ITAB), TEXTFORMAT_TABLE(ITAB)

      ITAB = ITABLE_SNLCPAK
      write(6,41) 'SNLCPAK', MXLC_PLOT, TEXTFORMAT_TABLE(ITAB)
      ITAB = ITABLE_SPECPAK
      write(6,41) 'SPECPAK', MXLC_PLOT, TEXTFORMAT_TABLE(ITAB)

      ITAB = ITABLE_MODELSPEC
      write(6,40) 'MODELSPEC', OPT_TABLE(ITAB),TEXTFORMAT_TABLE(ITAB)

      ITAB = ITABLE_MARZ
      write(6,40) 'MARZ', OPT_TABLE(ITAB),TEXTFORMAT_TABLE(ITAB)

 40   format(T5,A9,'-table: USE=',I1,       3x, 'TEXTFORMAT=',A4 )
 41   format(T5,A9,'-table: MXLC_PLOT=',I6, 3x, 'TEXTFORMAT=',A4 )

      write(6,51) 'SNANA', CUTMASK_SNANA_TABLE
51    format(T5,A9,'-table: select CUTFLAG_SNANA & ', I3 )

      if ( WRTABLEFILE_HOST_TEXT ) then
         print*,'   Include best-match HOSTGAL info in TEXT tables.'
      endif
      if ( WRTABLEFILE_HOST2_TEXT ) then
         print*,'   Include  HOSTGAL & HOSTGAL2 info in TEXT tables.'
      endif

      if ( WRTABLEFILE_IAUC ) then
         print*,'    All tables: write CID=IAUC name instead of SNID '
      endif

      call flush(6)

c --------

c check option to remap filters for table output.
c e..g, multiple V-bands that are similar in different
c subsurveys can be combined into a single V band.
c See manual explanation of SNTABLE_FILTER_REMAP
      
      IF ( SNTABLE_FILTER_REMAP .EQ. '' ) THEN
        LEN1 = 0
      ELSE
        LEN1 = INDEX(SNTABLE_FILTER_REMAP,'->', BACK=.TRUE.) + 3
      ENDIF

      LEN2 = INDEX(SURVEY_FILTERS,' ') - 1

      CALL  FILTER_REMAP_INIT(
     &     SNTABLE_FILTER_REMAP(1:LEN1)//char(0),   ! (I) user-input string
     &     SURVEY_FILTERS(1:LEN2)//char(0),         ! (I) valid filters
     &     NFILT_REMAP_TABLE,           ! (O) number of remapped bands
     &     IFILTLIST_REMAP_TABLE,       ! (O) index list of remapped bands
     &     FILTLIST_REMAP_TABLE,        ! (O) string list of ...
     &     LEN1, LEN2, MXFILT_ALL )

      FILTLIST_REMAP_TABLE = 
     &  FILTLIST_REMAP_TABLE(1:NFILT_REMAP_TABLE) // ' ' 

c option to compute width variables
      CALL GET_SIM_LCWIDTH(0)

      RETURN
      END     ! end of INIT_SNTABLE_OPTIONS

C =================================
+DECK,GET_SIM_LCWIDTH.
      SUBROUTINE GET_SIM_LCWIDTH(MODE)

c Feb 2019
c For each filter, compute and store SIM_LCWIDTH(ifilt)
c
      IMPLICIT NONE
      INTEGER MODE  ! (I) 0=init, 1=get width

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER MXEP_LCWIDTH
      PARAMETER ( MXEP_LCWIDTH = 200)

      REAL*8  SIM_MAGOBS(MXEP_LCWIDTH), SIM_MJD(MXEP_LCWIDTH)
      REAL*8  WIDTH
      INTEGER 
     &  IFILT, IFILT_OBS, EP, EPMIN, EPMAX, NEWMJD, NOBS, ERRFLAG

      CHARACTER FNAM*16
c functions
      REAL*8   get_lightCurveWidth
      EXTERNAL INIT_LIGHTCURVEWIDTH, get_lightCurveWidth

C -------- BEGIN ----------
     
      FNAM = 'GET_SIM_LCWIDTH'
      IF ( OPTSIM_LCWIDTH == 0 ) RETURN
      IF ( .NOT. LSIM_SNANA    ) RETURN

      IF (MODE == 0 ) THEN
c  init only         
         CALL INIT_LIGHTCURVEWIDTH()
         RETURN
      ENDIF

c loop over each filter and strip off MJD and true MAG into
c separate array to pass to get_lightCurveWidth function.

      DO 100 ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         NOBS = 0
         DO 150  NEWMJD = 1, ISNLC_NEWMJD_STORE
            EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
            EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
            DO 151 EP = EPMIN, EPMAX
               if ( ISNLC_IFILT_OBS(ep) .NE. ifilt_obs ) goto 151
               NOBS = NOBS + 1
               SIM_MJD(NOBS)    = SNLC8_MJD(ep)
               SIM_MAGOBS(NOBS) = SIM_EPMAGOBS(ep)
151        CONTINUE
150      CONTINUE
        
         WIDTH = get_lightCurveWidth(OPTSIM_LCWIDTH,
     &               NOBS,SIM_MJD, SIM_MAGOBS, ERRFLAG, FNAM,16)
         SIM_LCWIDTH(ifilt) = SNGL(WIDTH)

c         print*,' xxx WIDTH: ', ifilt, ifilt_obs, WIDTH
 100  CONTINUE ! end IFILT loop

      RETURN
      END

C =============================================
+DECK,PROB_TRUEFLUX_CALC.
      SUBROUTINE PROB_TRUEFLUX_CALC(ep)

c Created Apr 6 2021
c For fakes or SIM, compute chi2 = \Sum[F-Ftrue]/sigma_F^2 per band.
c Compute PROB(chi2,NDOF) for each band.
c
c  ep = 0  -> init sums to zero
c  ep > 0  -> increment chi2
c  ep = -1 -> compute prob(chi2,Ndof)
c --------------

      INTEGER EP  ! (I) 

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,TRUECHI2COM.

      INTEGER IFILT_OBS, IFILT, NDOF
      REAL CHI2
      REAL*8 CHI8, PROB8

      REAL*8 PROB_CHI2NDOF
      EXTERNAL PROB_CHI2NDOF
C ------------- BEGIN -------------

      IF ( .NOT. LPROB_TRUEFLUX ) RETURN
      IF ( .NOT. ISJOB_SIM      ) RETURN ! fakes or SNANA sim

      IF ( ep == 0 ) THEN        
         DO IFILT = 0, NFILTDEF_SURVEY
            NDOF_TRUEFLUX(ifilt) =   -1
            CHI2_TRUEFLUX(ifilt) =  0.0
            PROB_TRUEFLUX(ifilt) = -9.0
         ENDDO
         RETURN
      ENDIF

c - - - - -
      IF ( EP > 0 ) THEN
         IF ( SIM_EPFLUXCAL(ep) > 0.1 ) THEN
         ! increment chi2
            IFILT_OBS = ISNLC_IFILT_OBS(ep)
            IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
            CHI2      = SIM_EPCHI2FLUX(ep) 
            CHI2_TRUEFLUX(ifilt) = CHI2_TRUEFLUX(ifilt) + CHI2
            NDOF_TRUEFLUX(ifilt) = NDOF_TRUEFLUX(ifilt) + 1

            CHI2_TRUEFLUX(0) = CHI2_TRUEFLUX(0) + CHI2
            NDOF_TRUEFLUX(0) = NDOF_TRUEFLUX(0) + 1
         ENDIF
      ELSE
         ! compute FITPROB per band
         DO ifilt    = 1, NFILTDEF_SURVEY
            CHI8     = DBLE( CHI2_TRUEFLUX(ifilt) )
            NDOF     = NDOF_TRUEFLUX(ifilt)
            if ( NDOF > 2 ) then
               PROB8    = PROB_CHI2NDOF(CHI8,NDOF)            
               PROB_TRUEFLUX(ifilt) = SNGL(PROB8)
            endif

c global with all filters
            CHI8     = DBLE( CHI2_TRUEFLUX(0) )
            NDOF     = NDOF_TRUEFLUX(0)
            if ( NDOF > 2 ) then
               PROB8    = PROB_CHI2NDOF(CHI8,NDOF)            
               PROB_TRUEFLUX(0) = SNGL(PROB8)
            endif

        ENDDO
      ENDIF

      RETURN
      END        ! end PROB_TRUEFLUX_CALC


C =============================================
+DECK,PARSE_SNTABLE_LIST.
      SUBROUTINE PARSE_SNTABLE_LIST(USERSTRING, TABLENAME, NOPT, COPT)

c parse USERSTRING from SNTABLE_LIST;
c rdturn name of table and string of options.

      IMPLICIT NONE

      CHARACTER  
     &   USERSTRING*(*)  ! (I) user-input string from SNTABLE_LIST
     &  ,TABLENAME*20    ! (O) name of table
     &  ,COPT(10)*20     ! (O) list of options

      INTEGER NOPT       ! (O) numbef of COPT options
  
      LOGICAL DONEXT

c local args

      INTEGER jp1, jp2, j, i, LENOPT
      CHARACTER COPT_LIST*60, CTMP*60 ! comma-separated list

C ----------------- BEGIN ----------------

c init output args
      TABLENAME = 'UNKNOWN'
      NOPT = 0
      do i = 1, 10
        COPT(i) = ''
      enddo

c ---------------------

      jp1  = index(USERSTRING,'(')
      jp2  = index(USERSTRING,')')
      if ( jp1 > 0 ) then
         TABLENAME  = USERSTRING(1:jp1-1)
         COPT_LIST  = USERSTRING(jp1+1:jp2-1)
      else
         TABLENAME  = USERSTRING
         RETURN
      endif
      
c if we get here then parse comma-separated list of options
c in COPT_LIST

      LENOPT = index(COPT_LIST,' ' ) - 1
      DONEXT = .TRUE.
      CTMP   = COPT_LIST

      DO 100 WHILE ( DONEXT ) 
         NOPT  = NOPT + 1
         j     = index(CTMP,',')
         if ( j .LE. 0  ) j = LENOPT + 1
         COPT(NOPT) = CTMP(1:j-1)
         DONEXT     = j < LENOPT
         CTMP       = CTMP(j+1:LENOPT)

         if ( NOPT > 10 ) then
            CALL  MADABORT("PARSE_SNTABLE_LIST", 
     &               'NOPT > 10 ???          ', 
     &               'Something is wrong     ' )
         endif
 100  CONTINUE

      RETURN
      END   ! end of PARSE_SNTABLE_LIST


C ================================================
+DECK,SNLCINP_OVERRIDE.
      SUBROUTINE SNLCINP_OVERRIDE()
c
c Created July 2020 by R.Kessler [refactored]
c Check command-line args for user-option to override
c namelist values. Check for two styles of override:
c
c Legacy style is space-sparated such as    CUTWIN_SNRMAX 5 999
c New style has equal sign and no spaces,   CUTWIN_SNRMAX=5,999
c
c Beware that some arguments are comma-sep lists, so need
c to be careful about when to split by comma, and when 
c not so split by comma.
c
c Oct 22 2020: 
c   + double string length for LINE_ARGS and ARGLIST to allow for
c     long comma-sep strings.
c
c Nov 23 2020: read OPT_YAML
c
c Dec 08 2020: 
c   + fix bug setting USE_LINE_ARGS(iuse) to trap bad args.
c     last few months we were vulnerable to bad args that were
c     ignored instead of causing abort.
c
c Aug 14 2024
c   call new function FOUND_MATCH_NMLKEY that has logic to figure out
c   valid key with space sep or '=' delimeter. The old refactor code
c   had never been properly integrated until now. Advantage is that
c   FITNML_OVERRIDE can use the same function.
c
c ----------

      IMPLICIT  NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

c local var

      INTEGER iArg, LL, ilast, iuse, NVERLOC
      CHARACTER STRING_LIST*60
      CHARACTER ARG*(MXCHAR_ARG), ARGLIST(MXKEY_ARGS)*(MXCHAR_ARG)
      LOGICAL LSNIGNORE, DO_STOP, FOUND_MATCH_LEGACY, FOUND_MATCH_REFAC
      LOGICAL FOUND_MATCH, LDMP

c functions
      LOGICAL MATCH_NMLKEY, FOUND_MATCH_NMLKEY
      INTEGER PARSE_INTLIST

c ------------- BEGIN -------------

      LDMP = .FALSE. 
      iArg = 2 ;   ilast = 2 ;      NVERLOC = 0

      DO 4444 WHILE ( iArg .LE. NLINE_ARGS )

        CALL GETARG(iArg, ARG)
        LL = INDEX (ARG, ' ' ) - 1

        print*,'     PROCESS COMMAND LINE ARG: ', ARG(1:LL)

        if ( LDMP ) then
          print*,' xxx ===================================== '
          print*,' xxx iArg,ARG = ', iArg, ARG(1:40)
        endif

        CALL FLUSH(6)
        ARGLIST(1) = ''

         if ( MATCH_NMLKEY('VERSION_PHOTOMETRY',1,iArg,ARGLIST) ) then
            CALL PARSE_COMMASEP_LIST('VERSION_PHOTOMETRY',
     &                                 ARGLIST(1))

         else if(MATCH_NMLKEY('VERSION_PHOTOMETRY_WILDCARD',
     &                1, iArg, ARGLIST) ) then
            VERSION_PHOTOMETRY_WILDCARD = ARGLIST(1)(1:MXCHAR_VERSION)
         else if(MATCH_NMLKEY('VERSION_REFORMAT_FITS',
     &                1, iArg, ARGLIST) ) then
            VERSION_REFORMAT_FITS = ARGLIST(1)(1:MXCHAR_VERSION)
         else if(MATCH_NMLKEY('VERSION_REFORMAT_TEXT',
     &                1, iArg, ARGLIST) ) then
            VERSION_REFORMAT_TEXT = ARGLIST(1)(1:MXCHAR_VERSION)

         else if ( MATCH_NMLKEY('OPT_YAML',
     &             1, iArg, ARGLIST) ) then
             READ(ARGLIST(1),*) OPT_YAML

         else if ( MATCH_NMLKEY('OPT_REFORMAT_FITS',
     &             1, iArg, ARGLIST) ) then
             READ(ARGLIST(1),*) OPT_REFORMAT_FITS

         else if ( MATCH_NMLKEY('OPT_REFORMAT_TEXT',
     &              1, iArg, ARGLIST) ) then
             READ(ARGLIST(1),*) OPT_REFORMAT_TEXT

         else if ( MATCH_NMLKEY('OPT_REFORMAT_SPECTRA',
     &             1, iArg, ARGLIST) ) then
             READ(ARGLIST(1),*) OPT_REFORMAT_SPECTRA

         else if ( MATCH_NMLKEY('OPT_REFORMAT_SALT2',
     &              1, iArg, ARGLIST) ) then
             READ(ARGLIST(1),*) OPT_REFORMAT_SALT2

         else if ( MATCH_NMLKEY('REFORMAT_KEYS',
     &              1, iArg, ARGLIST) ) then
             REFORMAT_KEYS = ARGLIST(1)(1:100)

         else if ( MATCH_NMLKEY('PRIVATE_DATA_PATH',
     &               1, iArg, ARGLIST) ) then 
            PRIVATE_DATA_PATH = ARGLIST(1)(1:MXCHAR_PATH)

         else if ( MATCH_NMLKEY('PRIVATE_CUTWIN_STRING',
     &            1, iArg, ARGLIST) ) then 
            PRIVATE_CUTWIN_STRING = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('PRIVATE_VARNAME_READLIST',
     &            1, iArg, ARGLIST) ) then 
            PRIVATE_VARNAME_READLIST = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('EARLYLC_STRING',
     &             1, iArg, ARGLIST) ) then 
           EARLYLC_STRING = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('REQUIRE_EPOCHS_STRING',
     &             1, iArg, ARGLIST) ) then 
           REQUIRE_EPOCHS_STRING = ARGLIST(1)(1:100)

         else if ( MATCH_NMLKEY('DUMP_STRING',
     &             1, iArg, ARGLIST) ) then 
           DUMP_STRING = ARGLIST(1)(1:100)

         else if ( MATCH_NMLKEY('FILTER_UPDATE_PATH',
     &             1,iArg, ARGLIST) ) then 
           FILTER_UPDATE_PATH = ARGLIST(1)(1:MXCHAR_PATH)

         else if ( MATCH_NMLKEY('NONSURVEY_FILTERS',
     &             1, iArg, ARGLIST) ) then 
           NONSURVEY_FILTERS = ARGLIST(1)(1:MXFILT_ALL)

         else if ( MATCH_NMLKEY('FILTER_REPLACE',
     &             1, iArg, ARGLIST) ) then 
           FILTER_REPLACE = ARGLIST(1)(1:MXFILT_ALL)

         else if ( MATCH_NMLKEY('FILTLIST_LAMSHIFT',
     &             1, iArg, ARGLIST) ) then 
           FILTLIST_LAMSHIFT = ARGLIST(1)(1:MXFILT_ALL)

         else if ( MATCH_NMLKEY('USERTAGS_FILE',
     &             1, iArg, ARGLIST) ) then 
           USERTAGS_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('VPEC_FILE',
     &             1, iArg, ARGLIST) ) then 
           VPEC_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('CALIB_FILE',
     &             1, iArg, ARGLIST) ) then 
           CALIB_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('KCOR_FILE',  ! legacy key for CALIB_FILE
     &             1, iArg, ARGLIST) ) then 
           CALIB_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('OVERRIDE_RESTLAM_BOUNDARY',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) OVERRIDE_RESTLAM_BOUNDARY 

         else if ( MATCH_NMLKEY('HEADER_OVERRIDE_FILE',
     &             1, iArg, ARGLIST) ) then 
           HEADER_OVERRIDE_FILE = ARGLIST(1)
         else if ( MATCH_NMLKEY('SIM_HEADER_OVERRIDE_FILE',
     &             1, iArg, ARGLIST) ) then 
           SIM_HEADER_OVERRIDE_FILE = ARGLIST(1)

c LSNIGNORE 

         else if ( MATCH_NMLKEY('INTERP_OPT', 
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) INTERP_OPT

         else if ( MATCH_NMLKEY('ROOTFILE_OUT',
     &             1, iArg, ARGLIST) ) then 
           ROOTFILE_OUT = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('TEXTFILE_PREFIX',
     &             1, iArg, ARGLIST) ) then 
           TEXTFILE_PREFIX = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('MARZFILE_OUT',
     &             1, iArg, ARGLIST) ) then 
           MARZFILE_OUT = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('SNTABLE_LIST',
     &             1, iArg, ARGLIST) ) then 
           SNTABLE_LIST = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('SNTABLE_FILTER_REMAP',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) SNTABLE_FILTER_REMAP

         else if ( MATCH_NMLKEY('SNTABLE_APPEND',
     &             2, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) SNTABLE_APPEND_VARNAME
           READ(ARGLIST(2),*) SNTABLE_APPEND_VALUE

         else if ( MATCH_NMLKEY('OPTSIM_LCWIDTH',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) OPTSIM_LCWIDTH

         else if ( MATCH_NMLKEY('SNCID_IGNORE_FILE',
     &             1, iArg, ARGLIST) ) then 
           SNCID_IGNORE_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('SNCID_IGNORE',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) SNCID_IGNORE(1)

         else if ( MATCH_NMLKEY('SNMJD_OUT_FILE',
     &             1, iArg, ARGLIST) ) then 
           SNMJD_LIST_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('SNMJD_OUT_FILE',
     &             1, iArg, ARGLIST) ) then 
           SNMJD_LIST_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('EPOCH_IGNORE_FILE',
     &             1, iArg, ARGLIST) ) then 
           EPOCH_IGNORE_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('OUT_EPOCH_IGNORE_FILE',
     &             1, iArg, ARGLIST) ) then 
           OUT_EPOCH_IGNORE_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('NFIT_ITERATION',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) NFIT_ITERATION

         else if ( MATCH_NMLKEY('USE_MINOS',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) USE_MINOS

         else if ( MATCH_NMLKEY('MINUIT_PRINT_LEVEL',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MINUIT_PRINT_LEVEL

         else if ( MATCH_NMLKEY('MXLC_PLOT',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MXLC_PLOT

         else if ( MATCH_NMLKEY('MJDPERIOD_PLOT',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MJDPERIOD_PLOT

         else if ( MATCH_NMLKEY('MJDSHIFT_PLOT',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MJDSHIFT_PLOT

         else if ( MATCH_NMLKEY('DTOBS_MODEL_PLOT',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) DTOBS_MODEL_PLOT

         else if ( MATCH_NMLKEY('PHOTFLAG_MSKREJ',
     &             2, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) PHOTFLAG_MSKREJ(1)
           READ(ARGLIST(2),*) PHOTFLAG_MSKREJ(2)

         else if ( MATCH_NMLKEY('PHOTFLAG_BITLIST_REJECT',
     &             1, iArg, ARGLIST) ) then 
           if ( ARGLIST(1) .NE. 'NONE' ) then
              CALL PARSE_COMMASEP_LIST('PHOTFLAG_BITLIST',ARGLIST(1))
           endif

         else if ( MATCH_NMLKEY('PHOTFLAG_DETECT',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) PHOTFLAG_DETECT

         else if ( MATCH_NMLKEY('PHOTFLAG_TRIGGER',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) PHOTFLAG_TRIGGER
c - - - - - -
         else if ( MATCH_NMLKEY('MULTISEASON_OPTMASK',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MULTISEASON_OPTMASK

         else if ( MATCH_NMLKEY('MULTISEASON_TGAP',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MULTISEASON_TGAP

         else if ( MATCH_NMLKEY('MULTISEASON_NREJECT_OUTLIER',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MULTISEASON_NREJECT_OUTLIER

         else if ( MATCH_NMLKEY('MULTISEASON_CHI2RED_ACTIVE',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MULTISEASON_CHI2RED_ACTIVE

         else if ( MATCH_NMLKEY('CUTWIN_NSEASON_ACTIVE',
     &             2, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) CUTWIN_NSEASON_ACTIVE(1)
           READ(ARGLIST(2),*) CUTWIN_NSEASON_ACTIVE(2)

c - - - - -
         else if ( MATCH_NMLKEY('LSIM_SEARCH_SPEC',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LSIM_SEARCH_SPEC

         else if ( MATCH_NMLKEY('LSIM_SEARCH_ZHOST',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LSIM_SEARCH_ZHOST
         else if ( MATCH_NMLKEY('LSIM_SEARCH_zHOST',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LSIM_SEARCH_ZHOST

         else if ( MATCH_NMLKEY('DEBUG_FLAG',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) DEBUG_FLAG

         else if ( MATCH_NMLKEY('LPROB_TRUEFLUX',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LPROB_TRUEFLUX

         else if ( MATCH_NMLKEY('LDMP_SNFAIL',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LDMP_SNFAIL

         else if ( MATCH_NMLKEY('LDMP_SATURATE',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LDMP_SATURATE

         else if ( MATCH_NMLKEY('USESIM_SNIA',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) USESIM_SNIA
         else if ( MATCH_NMLKEY('USESIM_NONIA',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) USESIM_NONIA

         else if ( MATCH_NMLKEY('USE_SNHOST_ZPHOT',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) USE_SNHOST_ZPHOT

         else if ( MATCH_NMLKEY('USE_HOSTGAL_PHOTOZ',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) USE_HOSTGAL_PHOTOZ

         else if ( MATCH_NMLKEY('USESIM_TRUEFLUX',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) USESIM_TRUEFLUX

         else if ( MATCH_NMLKEY('RESTORE_MWEBV_ERR_BUG',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) RESTORE_MWEBV_ERR_BUG

         else if ( MATCH_NMLKEY('RESTORE_WRONG_VPEC',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) RESTORE_WRONG_VPEC

         else if ( MATCH_NMLKEY('RESTORE_OVERRIDE_ZBUG',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) RESTORE_OVERRIDE_ZBUG

         else if ( MATCH_NMLKEY('REQUIRE_DOCANA',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) REQUIRE_DOCANA

         else if ( MATCH_NMLKEY('USE_MWCOR',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) USE_MWCOR

c - - - - 
         else if ( MATCH_NMLKEY('LTEST_U3BAND',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LTEST_U3BAND
         else if ( MATCH_NMLKEY('LTEST_MAG',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LTEST_MAG
         else if ( MATCH_NMLKEY('LTEST_INTERP',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LTEST_INTERP
         else if ( MATCH_NMLKEY('LTEST_KCOR',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) LTEST_KCOR

c - - - -
         else if ( MATCH_NMLKEY('OPT_SETPKMJD',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) OPT_SETPKMJD

         else if ( MATCH_NMLKEY('MJDWIN_SETPKMJD',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MJDWIN_SETPKMJD

         else if ( MATCH_NMLKEY('SNRCUT_SETPKMJD',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) SNRCUT_SETPKMJD

         else if ( MATCH_NMLKEY('SHIFT_SETPKMJD',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) SHIFT_SETPKMJD

         else if ( MATCH_NMLKEY('SNCCID_LIST',
     &             1, iArg, ARGLIST) ) then 
           if ( ARGLIST(1) .NE. 'NONE' ) then
              CALL PARSE_COMMASEP_LIST('SNCCID_LIST', ARGLIST(1))
              CUTWIN_CID(1) = 0;  CUTWIN_CID(2)=0
           endif

         else if ( MATCH_NMLKEY('SNCCID_IGNORE',  ! July 2023
     &             1, iArg, ARGLIST) ) then 
           if ( ARGLIST(1) .NE. 'NONE' ) then
              CALL PARSE_COMMASEP_LIST('SNCCID_IGNORE', ARGLIST(1))
           endif

         else if ( MATCH_NMLKEY('SNCID_LIST_FILE',
     &             1, iArg, ARGLIST) ) then 
           SNCID_LIST_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)
           CUTWIN_CID(1) = 0;  CUTWIN_CID(2)=0

         else if ( MATCH_NMLKEY('OPT_SNCID_LIST',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) OPT_SNCID_LIST


         else if ( MATCH_NMLKEY('MXEVT_PROCESS',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MXEVT_PROCESS

         else if ( MATCH_NMLKEY('MXEVT_CUTS',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MXEVT_CUTS

         else if ( MATCH_NMLKEY('MXLC_FIT',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) MXLC_FIT

         else if ( MATCH_NMLKEY('SIM_TEMPLATE_INDEX_LIST',
     &             1, iArg, ARGLIST) ) then 
           STRING_LIST = ARGLIST(1)(1:60)
           NSIM_TEMPLATE_INDEX_LIST =  ! select SIM_TEMPLATE INDICE
     &        PARSE_INTLIST(STRING_LIST,SIM_TEMPLATE_INDEX_LIST)

         else if ( MATCH_NMLKEY('SIMLIB_OUT',
     &             1, iArg, ARGLIST) ) then 
           SIMLIB_OUT = ARGLIST(1)(1:MXCHAR_FILENAME)
         else if ( MATCH_NMLKEY('SIMLIB_OUTFILE', ! same as SIMLIB_OUT
     &             1, iArg, ARGLIST) ) then 
           SIMLIB_OUTFILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('SIMLIB_ZPERR_LIST',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) SIMLIB_ZPERR_LIST

         else if ( MATCH_NMLKEY('OPT_SIMLIB_OUT',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) OPT_SIMLIB_OUT

         else if ( MATCH_NMLKEY('SIMLIB_OUT_TMINFIX',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) SIMLIB_OUT_TMINFIX

         else if ( MATCH_NMLKEY('NONLINEARITY_FILE',
     &             1, iArg, ARGLIST) ) then 
           NONLINEARITY_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('SNFIELD_LIST',
     &             1, iArg, ARGLIST) ) then 
           SNFIELD_LIST(1) = ARGLIST(1)(1:60)
           SNFIELD_LIST(2) = ''

         else if ( MATCH_NMLKEY('FORCE_STDOUT_BATCH',
     &             2, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) FORCE_STDOUT_BATCH

         else if ( MATCH_NMLKEY('JOBSPLIT',
     &             2, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) JOBSPLIT(1)
           READ(ARGLIST(2),*) JOBSPLIT(2)
           ISJOB_BATCH = .TRUE.
           REDUCE_STDOUT_BATCH = ( JOBSPLIT(1) .GT. 1 )

         else if ( MATCH_NMLKEY('JOBSPLIT_EXTERNAL',
     &             2, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) JOBSPLIT_EXTERNAL(1)
           READ(ARGLIST(2),*) JOBSPLIT_EXTERNAL(2)

         else if ( MATCH_NMLKEY('SIM_PRESCALE',
     &             1, iArg, ARGLIST) ) then 
           READ(ARGLIST(1),*) SIM_PRESCALE

        else if ( MATCH_NMLKEY('CUTWIN_CID',
     &            2, iArg, ARGLIST) ) then
             READ(ARGLIST(1),*) CUTWIN_CID(1)
             READ(ARGLIST(2),*) CUTWIN_CID(2)

        else if ( MATCH_NMLKEY('CUTWIN_SNTYPE',
     &            2, iArg, ARGLIST) ) then
             READ(ARGLIST(1),*) CUTWIN_SNTYPE(1)
             READ(ARGLIST(2),*) CUTWIN_SNTYPE(2)

c - - - -
         else if ( MATCH_NMLKEY('SNTYPE_LIST',
     &             1, iArg, ARGLIST) ) then 
           STRING_LIST = ARGLIST(1)(1:60)
           NSNTYPE_LIST = PARSE_INTLIST(STRING_LIST,SNTYPE_LIST)

         else if ( MATCH_NMLKEY('CCDNUM_LIST',
     &             1, iArg, ARGLIST) ) then 
           STRING_LIST = ARGLIST(1)(1:60)
           NCCDNUM_LIST = PARSE_INTLIST(STRING_LIST,CCDNUM_LIST)

         else if ( MATCH_NMLKEY('SNTYPE_IGNORE',
     &             1, iArg, ARGLIST) ) then 
           STRING_LIST    = ARGLIST(1)(1:60)
           NSNTYPE_IGNORE = PARSE_INTLIST(STRING_LIST,SNTYPE_IGNORE)

         else if ( MATCH_NMLKEY('SNCID_LIST',  ! Aug 18 2020
     &             1, iArg, ARGLIST) ) then 
           STRING_LIST = ARGLIST(1)(1:60)
           NCID_LIST   = PARSE_INTLIST(STRING_LIST,SNCID_LIST)
           if ( SNCID_LIST(1) > 0 ) then
               CUTWIN_CID(1) = 0;  CUTWIN_CID(2)=0 
           endif
c - - - -
        else if ( MATCH_NMLKEY('CUTWIN_NEPOCH',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_NEPOCH(1)
          READ(ARGLIST(2),*) CUTWIN_NEPOCH(2)

        else if ( MATCH_NMLKEY('CUTWIN_TRESTMIN',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TRESTMIN(1)
          READ(ARGLIST(2),*) CUTWIN_TRESTMIN(2)

        else if ( MATCH_NMLKEY('CUTWIN_TRESTMAX',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TRESTMAX(1)
          READ(ARGLIST(2),*) CUTWIN_TRESTMAX(2)

        else if ( MATCH_NMLKEY('CUTWIN_TRESTRANGE',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TRESTRANGE(1)
          READ(ARGLIST(2),*) CUTWIN_TRESTRANGE(2)

        else if ( MATCH_NMLKEY('CUTWIN_TREST2',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TREST2(1)
          READ(ARGLIST(2),*) CUTWIN_TREST2(2)

        else if ( MATCH_NMLKEY('CUTWIN_TGAPMAX',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TGAPMAX(1)
          READ(ARGLIST(2),*) CUTWIN_TGAPMAX(2)

        else if ( MATCH_NMLKEY('CUTWIN_T0GAPMAX',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_T0GAPMAX(1)
          READ(ARGLIST(2),*) CUTWIN_T0GAPMAX(2)

        else if ( MATCH_NMLKEY('CUTWIN_TREST',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TREST(1)
          READ(ARGLIST(2),*) CUTWIN_TREST(2)

        else if ( MATCH_NMLKEY('CUTWIN_TOBS',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TOBS(1)
          READ(ARGLIST(2),*) CUTWIN_TOBS(2)

        else if ( MATCH_NMLKEY('CUTWIN_TOBSMIN',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TOBSMIN(1)
          READ(ARGLIST(2),*) CUTWIN_TOBSMIN(2)

        else if ( MATCH_NMLKEY('CUTWIN_TOBSMAX',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TOBSMAX(1)
          READ(ARGLIST(2),*) CUTWIN_TOBSMAX(2)

        else if ( MATCH_NMLKEY('CUTWIN_RA',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_RA(1)
          READ(ARGLIST(2),*) CUTWIN_RA(2)

        else if ( MATCH_NMLKEY('CUTWIN_DEC',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_DEC(1)
          READ(ARGLIST(2),*) CUTWIN_DEC(2)

        else if ( MATCH_NMLKEY('CUTWIN_PEAKMJD',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_PEAKMJD(1)
          READ(ARGLIST(2),*) CUTWIN_PEAKMJD(2)

        else if ( MATCH_NMLKEY('CUTWIN_MJD',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_MJD(1)
          READ(ARGLIST(2),*) CUTWIN_MJD(2)

        else if ( MATCH_NMLKEY('CUTWIN_MJD_EXCLUDE',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_MJD_EXCLUDE(1)
          READ(ARGLIST(2),*) CUTWIN_MJD_EXCLUDE(2)

c - - -
        else if ( MATCH_NMLKEY('CUTWIN_NOBS_PREDETECT',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_NOBS_PREDETECT(1)
          READ(ARGLIST(2),*) CUTWIN_NOBS_PREDETECT(2)

        else if ( MATCH_NMLKEY('CUTWIN_TOBS_PREDETECT',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TOBS_PREDETECT(1)
          READ(ARGLIST(2),*) CUTWIN_TOBS_PREDETECT(2)

c - - -
        else if ( MATCH_NMLKEY('CUTWIN_REDSHIFT',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_REDSHIFT(1)
          READ(ARGLIST(2),*) CUTWIN_REDSHIFT(2)

        else if ( MATCH_NMLKEY('CUTWIN_REDSHIFT_ERR',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_REDSHIFT_ERR(1)
          READ(ARGLIST(2),*) CUTWIN_REDSHIFT_ERR(2)

        else if ( MATCH_NMLKEY('CUTWIN_HOSTSEP',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_HOSTSEP(1)
          READ(ARGLIST(2),*) CUTWIN_HOSTSEP(2)

        else if ( MATCH_NMLKEY('CUTWIN_NFILT_TRESTMIN',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_NFILT_TRESTMIN(1)
          READ(ARGLIST(2),*) CUTWIN_NFILT_TRESTMIN(2)

        else if ( MATCH_NMLKEY('CUTWIN_NFILT_TRESTMAX',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_NFILT_TRESTMAX(1)
          READ(ARGLIST(2),*) CUTWIN_NFILT_TRESTMAX(2)

        else if ( MATCH_NMLKEY('CUTWIN_NFILT_TREST2',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_NFILT_TREST2(1)
          READ(ARGLIST(2),*) CUTWIN_NFILT_TREST2(2)

        else if ( MATCH_NMLKEY('SNCUT_SNRMAX',
     &            1, iArg, ARGLIST) ) then
          SNCUT_SNRMAX = ARGLIST(1)(1:MXCHAR_CUTNAME)

        else if ( MATCH_NMLKEY('SNCUT_HOST_SBFLUX',
     &            1, iArg, ARGLIST) ) then
          SNCUT_HOST_SBFLUX = ARGLIST(1)(1:MXCHAR_CUTNAME)

        else if ( MATCH_NMLKEY('SIMVAR_CUTWIN_STRING',
     &            1, iArg, ARGLIST) ) then
          SIMVAR_CUTWIN_STRING = ARGLIST(1)(1:MXCHAR_CUTNAME)

        else if ( MATCH_NMLKEY('CUTWIN_NFILT_SNRMAX',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_NFILT_SNRMAX(1)
          READ(ARGLIST(2),*) CUTWIN_NFILT_SNRMAX(2)

        else if ( MATCH_NMLKEY('CUTWIN_NFILT_SNRMAX2',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_NFILT_SNRMAX2(1)
          READ(ARGLIST(2),*) CUTWIN_NFILT_SNRMAX2(2)

        else if ( MATCH_NMLKEY('CUTWIN_NFIELD',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_NFIELD(1)
          READ(ARGLIST(2),*) CUTWIN_NFIELD(2)

        else if ( MATCH_NMLKEY('CUTWIN_MWEBV',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_MWEBV(1)
          READ(ARGLIST(2),*) CUTWIN_MWEBV(2)

        else if ( MATCH_NMLKEY('CUTWIN_RESTLAM',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_RESTLAM(1)
          READ(ARGLIST(2),*) CUTWIN_RESTLAM(2)
        else if ( MATCH_NMLKEY('CUTWIN_LAMREST', ! same as CUVTIN_RESTLAM
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_LAMREST(1)
          READ(ARGLIST(2),*) CUTWIN_LAMREST(2)

        else if ( MATCH_NMLKEY('CUTWIN_LAMOBS',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_LAMOBS(1)
          READ(ARGLIST(2),*) CUTWIN_LAMOBS(2)

        else if ( MATCH_NMLKEY('EPCUT_SNRMIN',
     &            1, iArg, ARGLIST) ) then
          EPCUT_SNRMIN = ARGLIST(1)(1:MXCHAR_CUTNAME)

        else if ( MATCH_NMLKEY('SNRMAX_FILTERS',
     &            1, iArg, ARGLIST) ) then
          SNRMAX_FILTERS = ARGLIST(1)(1:MXFILT_ALL)

        else if ( MATCH_NMLKEY('CUTWIN_SNRMAX',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_SNRMAX(1)
          READ(ARGLIST(2),*) CUTWIN_SNRMAX(2)

        else if ( MATCH_NMLKEY('CUTWIN_SNRMAX2',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_SNRMAX2(1)
          READ(ARGLIST(2),*) CUTWIN_SNRMAX2(2)

        else if ( MATCH_NMLKEY('CUTWIN_SNRSUM',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_SNRSUM(1)
          READ(ARGLIST(2),*) CUTWIN_SNRSUM(2)

        else if ( MATCH_NMLKEY('CUTWIN_SNR_NODETECT',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_SNR_NODETECT(1)
          READ(ARGLIST(2),*) CUTWIN_SNR_NODETECT(2)

        else if ( MATCH_NMLKEY('CUTWIN_PSF',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_PSF(1)
          READ(ARGLIST(2),*) CUTWIN_PSF(2)

        else if ( MATCH_NMLKEY('CUTWIN_ZPERR',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_ZPERR(1)
          READ(ARGLIST(2),*) CUTWIN_ZPERR(2)

        else if ( MATCH_NMLKEY('CUTWIN_PHOTPROB',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_PHOTPROB(1)
          READ(ARGLIST(2),*) CUTWIN_PHOTPROB(2)

        else if ( MATCH_NMLKEY('CUTWIN_ZPADU',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_ZPADU(1)
          READ(ARGLIST(2),*) CUTWIN_ZPADU(2)

        else if ( MATCH_NMLKEY('CUTWIN_ZPNPE',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_ZPNPE(1)
          READ(ARGLIST(2),*) CUTWIN_ZPNPE(2)

        else if ( MATCH_NMLKEY('CUTWIN_ERRTEST',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_ERRTEST(1)
          READ(ARGLIST(2),*) CUTWIN_ERRTEST(2)

        else if ( MATCH_NMLKEY('CUTWIN_SIMPULL',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_SIMPULL(1)
          READ(ARGLIST(2),*) CUTWIN_SIMPULL(2)

        else if ( MATCH_NMLKEY('CUTWIN_TREST_TRUEFLUX',
     &            2, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) CUTWIN_TREST_TRUEFLUX(1)
          READ(ARGLIST(2),*) CUTWIN_TREST_TRUEFLUX(2)

c - - - - 
         else if ( MATCH_NMLKEY('MAGOBS_SHIFT_PRIMARY',
     &             1, iArg, ARGLIST) ) then 
           MAGOBS_SHIFT_PRIMARY = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('MAGOBS_SHIFT_ZP',
     &             1, iArg, ARGLIST) ) then 
           MAGOBS_SHIFT_ZP = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('MAGREST_SHIFT_PRIMARY',
     &             1, iArg, ARGLIST) ) then 
           MAGREST_SHIFT_PRIMARY = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('MAGREST_SHIFT_ZP',
     &             1, iArg, ARGLIST) ) then 
           MAGREST_SHIFT_ZP = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('FILTER_LAMSHIFT',
     &             1, iArg, ARGLIST) ) then 
           FILTER_LAMSHIFT = ARGLIST(1)(1:MXCHAR_CUTNAME)
c - - - - - - 
        else if ( MATCH_NMLKEY('MAGOBS_SHIFT_PRIMARY_PARAMS',
     &            3, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) MAGOBS_SHIFT_PRIMARY_PARAMS(1)
          READ(ARGLIST(2),*) MAGOBS_SHIFT_PRIMARY_PARAMS(2)
          READ(ARGLIST(3),*) MAGOBS_SHIFT_PRIMARY_PARAMS(3)

        else if ( MATCH_NMLKEY('MAGOBS_SHIFT_ZP_PARAMS',
     &            3, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) MAGOBS_SHIFT_ZP_PARAMS(1)
          READ(ARGLIST(2),*) MAGOBS_SHIFT_ZP_PARAMS(2)
          READ(ARGLIST(3),*) MAGOBS_SHIFT_ZP_PARAMS(3)
c - - - - - - - 
         else if ( MATCH_NMLKEY('FUDGE_FLUXCAL_OFFSET',
     &             1, iArg, ARGLIST) ) then 
           FUDGE_FLUXCAL_OFFSET = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('FUDGE_FLUXCAL_ERROR',
     &             1, iArg, ARGLIST) ) then 
           FUDGE_FLUXCAL_ERROR = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('FUDGE_FLUXCAL_ERRPIX',
     &             1, iArg, ARGLIST) ) then 
           FUDGE_FLUXCAL_ERRPIX = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('FUDGE_FLUXERR_SCALE',
     &             1, iArg, ARGLIST) ) then 
           FUDGE_FLUXERR_SCALE = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('FUDGE_MAG_ERROR',
     &             1, iArg, ARGLIST) ) then 
           FUDGE_MAG_ERROR = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('SIM_FUDGE_MAG_ERROR',
     &             1, iArg, ARGLIST) ) then 
           SIM_FUDGE_MAG_ERROR = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('FUDGE_MAG_COVERR',
     &             1, iArg, ARGLIST) ) then 
           FUDGE_MAG_COVERR = ARGLIST(1)(1:MXCHAR_CUTNAME)

         else if ( MATCH_NMLKEY('FUDGE_HOSTNOISE_FILE',
     &             1, iArg, ARGLIST) ) then 
           FUDGE_HOSTNOISE_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('FLUXERRMODEL_FILE',
     &             1, iArg, ARGLIST) ) then 
           FLUXERRMODEL_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)
         else if ( MATCH_NMLKEY('SIM_FLUXERRMODEL_FILE',
     &             1, iArg, ARGLIST) ) then 
           SIM_FLUXERRMODEL_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

        else if ( MATCH_NMLKEY('FLUXERRMODEL_OPTMASK',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) FLUXERRMODEL_OPTMASK

         else if ( MATCH_NMLKEY('MAGCOR_FILE',
     &             1, iArg, ARGLIST) ) then 
           MAGCOR_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

         else if ( MATCH_NMLKEY('SIM_MAGCOR_FILE',
     &             1, iArg, ARGLIST) ) then 
           SIM_MAGCOR_FILE = ARGLIST(1)(1:MXCHAR_FILENAME)

c - - - - - - - 
        else if ( MATCH_NMLKEY('RV_MWCOLORLAW',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) RV_MWCOLORLAW

        else if ( MATCH_NMLKEY('OPT_MWCOLORLAW',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) OPT_MWCOLORLAW

        else if ( MATCH_NMLKEY('PARLIST_MWCOLORLAW',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) PARLIST_MWCOLORLAW(1)  ! just read 1 param for now (Oct 2024)

        else if ( MATCH_NMLKEY('OPT_MWEBV',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) OPT_MWEBV

        else if ( MATCH_NMLKEY('MWEBV_SCALE',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) MWEBV_SCALE

        else if ( MATCH_NMLKEY('MWEBV_SHIFT',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) MWEBV_SHIFT

        else if ( MATCH_NMLKEY('MWEBV_FORCE',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) MWEBV_FORCE

        else if ( MATCH_NMLKEY('REDSHIFT_FINAL_SHIFT',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) REDSHIFT_FINAL_SHIFT

c - - - - 
        else if ( MATCH_NMLKEY('HOSTGAL_ZSPEC_SHIFT',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) HOSTGAL_ZSPEC_SHIFT

        else if ( MATCH_NMLKEY('HOSTGAL_ZPHOT_SHIFT',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) HOSTGAL_ZPHOT_SHIFT

c Dec 2024: obsolete/legacy keys
        else if ( MATCH_NMLKEY('HOSTGAL_SPECZ_SHIFT',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) HOSTGAL_ZSPEC_SHIFT

        else if ( MATCH_NMLKEY('HOSTGAL_PHOTOZ_SHIFT',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) HOSTGAL_ZPHOT_SHIFT

c - - - -

        else if ( MATCH_NMLKEY('VPEC_ERR_OVERRIDE',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) VPEC_ERR_OVERRIDE

        else if ( MATCH_NMLKEY('FLUXERRCALC_ZPTERR',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) FLUXERRCALC_ZPTERR

        else if ( MATCH_NMLKEY('H0_REF',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) H0_REF

        else if ( MATCH_NMLKEY('OLAM_REF',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) OLAM_REF

        else if ( MATCH_NMLKEY('OMAT_REF',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) OMAT_REF

        else if ( MATCH_NMLKEY('W0_REF',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) W0_REF

        else if ( MATCH_NMLKEY('ZTOL_HELIO2CMB',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ZTOL_HELIO2CMB
        else if ( MATCH_NMLKEY('zZTOL_HELIO2CMB', ! same, with 'z'
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ZTOL_HELIO2CMB
c - - - - 

        else if ( MATCH_NMLKEY('ABORT_ON_BADSURVEY',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_BADSURVEY

        else if ( MATCH_NMLKEY('ABORT_ON_BADFILTER',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_BADFILTER

        else if ( MATCH_NMLKEY('ABORT_ON_NOEPOCHS',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_NOEPOCHS

        else if ( MATCH_NMLKEY('ABORT_ON_NOPKMJD',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_NOPKMJD

        else if ( MATCH_NMLKEY('ABORT_ON_BADAVWARP',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_BADAVWARP

        else if ( MATCH_NMLKEY('ABORT_ON_BADKCOR',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_BADKCOR

        else if ( MATCH_NMLKEY('ABORT_ON_MARGPDF0',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_MARGPDF0

        else if ( MATCH_NMLKEY('ABORT_ON_TRESTCUT',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_TRESTCUT

        else if ( MATCH_NMLKEY('ABORT_ON_DUPLCID',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_DUPLCID

        else if ( MATCH_NMLKEY('ABORT_ON_DUPLMJD',
     &            1, iArg, ARGLIST) ) then
          READ(ARGLIST(1),*) ABORT_ON_DUPLMJD

c - - - 
        endif


+SELF,IF=REMOVE.
c ?????????????
c PROBLEM: for XYZ=5,999 iArg does not increment, and thus USE_LINE_ARGS
c          is NOT filled.
c ?????????????

c set logical flag for used LINE_ARGS 
c   _LEGACY is for "KEY VAL" (space separated)
c   _REFAC  is for "KEY=VAL" (single string)

        VALID_ARGLIST = .TRUE.
        if ( ARGLIST(1) .EQ. ''     ) VALID_ARGLIST = .FALSE.
        if ( ARGLIST(1) .EQ. 'NULL' ) VALID_ARGLIST = .FALSE.

        HAS_EQUAL = ( INDEX(ARG,'=') > 0 )
        FOUND_MATCH_LEGACY = 
     &    ( iArg .GT. ilast )
        FOUND_MATCH_REFAC  = 
     &    ( iArg .EQ. ilast .and. HAS_EQUAL .and. VALID_ARGLIST )

        if ( LDMP ) then
           print*,' xxx - - - - - - - - '
           print*,' xxx  LEGACY,REFAC = ', 
     &          FOUND_MATCH_LEGACY, FOUND_MATCH_REFAC
           print*,' xxx  ilast, iArg = ', ilast, iArg
           print*,' xxx  ARGLIST(1)  = ', ARGLIST(1)(1:40)
        endif
+SELF.

         FOUND_MATCH = FOUND_MATCH_NMLKEY(iArg,ilast,ARG,ARGLIST(1))
         IF ( FOUND_MATCH ) THEN
           DO iuse = ilast, iArg
              USE_LINE_ARGS(iuse) = .TRUE.
           ENDDO
         ENDIF
         iArg = iArg + 1 ;       ilast = iArg

4444  CONTINUE

      DO_STOP = .false.
      IF ( DO_STOP ) then
         print*,' '
         print*,' xxx ------------------------------------- '
         print*,' xxx CUTWIN_SNRMAX = ', CUTWIN_SNRMAX
         print*,' xxx DEBUG STOP '
         STOP
      ENDIF

      RETURN
      END  ! end SNLCINP_OVERRIDE


C ================================================
+DECK,MATCH_NMLKEY.
      LOGICAL FUNCTION MATCH_NMLKEY(KEYNAME,NARG,iArg,argList)

c Created July 25 2020
c 
c Example 1:
c   KEYNAME           = 'CUTWIN_SNRMAX'
c   LINE_ARGS(iArg)   = 'CUTWIN_SNRMAX'
c   LINE_ARGS(iArg+1) = '5'
c   LINE_ARGS(iArg+2) = '9999'
c   NARG    = 2
c   iArg    = iArg + 2     ! <== returned
c   ARGLIST = '5', '9999'  ! <== returned
c
c Example 2:
c   KEYNAME           = 'CUTWIN_SNRMAX'
c   LINE_ARGS(iArg)   = 'CUTWIN_SNRMAX=5,9999'
c   NARG    = 2
c   iArg    = iArg         ! <== returned unchanged
c   ARGLIST = '5', '9999'  ! <== returned
c
c ----------------------
c
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,SNCUTS.
c+CDE,CTRLCOM.
+CDE,SNLCINP.

c function args
c MXCHAR_FILENAME
      CHARACTER KEYNAME*(*)      ! (I) keyname to check
      INTEGER   NARG             ! (I) number of arguments to check
      INTEGER   iArg             ! (I) current index for LINE_ARGS(i)
      CHARACTER ARGLIST(*)*(*)   ! (O) 'NARG' string args for KEYNAME

c local args
      INTEGER LENKEY, LENARG1_EQ, LENARG1_TOT, i
      INTEGER jcomma, jlast
      LOGICAL KEYPLUSARG_ONESTRING, LDMP
      CHARACTER ARG*(MXCHAR_ARG), ARGSTRING*(MXCHAR_ARG)

C ------------- BEGIN ------------

      MATCH_NMLKEY = .false.
      DO i = 1, NARG
         ARGLIST(i) = 'NULL'
      ENDDO
      LDMP = .false.

      LENKEY = INDEX(KEYNAME//' ', ' ') - 1

      CALL GETARG(iArg,ARG)
      LENARG1_EQ  = INDEX(ARG,'=') - 1
      LENARG1_TOT = INDEX(ARG,' ') - 1

      IF ( LENARG1_EQ < 0 ) THEN
         LENARG1_EQ = LENARG1_TOT
         KEYPLUSARG_ONESTRING = .false. ! e.g., CUTWIN_SNRMAX 5 999
      ELSE
         KEYPLUSARG_ONESTRING = .true. ! e.g., CUTWIN_SNRMAX=5,999
      ENDIF

      if ( LDMP ) then
        print*,' xxx --------- MATCH_NMLKEY DUMP ------------- '
        print*,' xxx  LINE_ARG  = ', ARG(1:60)
        print*,' xxx  KEYNAME   = ', KEYNAME(1:LENKEY)
        print*,' xxx  iArg,NARG = ', iArg, NARG
        print*,' xxx  LENARG1   = ', LENARG1_EQ, LENARG1_TOT
        print*,' xxx  LENKEY    = ', LENKEY
        print*,' xxx  KEYPLUSARG_ONESTRING=',KEYPLUSARG_ONESTRING
      endif
      
      if ( LENARG1_EQ .NE. LENKEY ) RETURN

      MATCH_NMLKEY = ( ARG(1:LENARG1_EQ) .EQ. KEYNAME(1:LENKEY) )

      IF ( .NOT. MATCH_NMLKEY ) RETURN

      IF ( KEYPLUSARG_ONESTRING ) THEN        

c xxxx         ARGSTRING = LINE_ARGS(iArg)(LENARG1_EQ+2:LENARG1_TOT)
         ARGSTRING = ARG(LENARG1_EQ+2:LENARG1_TOT)

c break comma-sep ARGSTRING into sub strings
         jlast = 1
         DO i = 1, NARG
           if ( i .EQ. NARG ) then
               ARGLIST(i) = ARGSTRING(jlast:LENARG1_TOT)
            else
               jcomma     = INDEX(ARGSTRING,',') - 1
               ARGLIST(i) = ARGSTRING(jlast:jcomma)
               jlast      = jcomma + 2
            endif
         ENDDO
      ELSE      
         DO i = 1, NARG
           iArg = iArg + 1
           CALL GETARG(iArg, ARG)
           ARGLIST(i) = ARG   ! xxx LINE_ARGS(iArg)
         ENDDO
      ENDIF

      if ( LDMP ) then
        do i = 1, NARG
           write(6,38) i, arglist(i)(1:40)
38         format(T10,' xxx out argList(',I2,') = ', A )
        enddo
      endif

      RETURN
      END    ! end MATCH_NMLKEY

C ===================================
+DECK,FOUND_MATCH.
      LOGICAL FUNCTION FOUND_MATCH_NMLKEY(iArg,ilast,KEY,FIRSTARG)

c Created Aug 2024
c Handle logic to identify valid key+arg using space-separated
c delimeter (e.g., CUTWIN_TREST -20 80) or equal sign with
c no spaces (e.g., CUTWIN_TREST=-20,80).
c In the latter case, passed args should be
c
c   KEY=CUTWIN_TREST=-20,80 and FIRSTARG=-20
c
c Move code output SNLCINP_OVERRIDE so that it can be
c used for other NML overrides.

      IMPLICIT NONE

c arguments
      INTEGER iArg, ilast
      CHARACTER KEY*(*), FIRSTARG*(*)

c local args
      LOGICAL FOUND_MATCH_SPSEP, FOUND_MATCH_EQ
      LOGICAL LDMP, VALID_FIRSTARG, HAS_EQUAL
      
C ----------- BEGIN -----------
      FOUND_MATCH_NMLKEY = .FALSE.
      LDMP = .FALSE.

      VALID_FIRSTARG = .TRUE.
      if ( FIRSTARG .EQ. ''     ) VALID_FIRSTARG = .FALSE.
      if ( FIRSTARG .EQ. 'NULL' ) VALID_FIRSTARG = .FALSE.

      HAS_EQUAL = ( INDEX(KEY,'=') > 0 ) 
      FOUND_MATCH_SPSEP = 
     &    ( iArg .GT. ilast )   ! space seperated args
      FOUND_MATCH_EQ  =         ! key=arg
     &    ( iArg .EQ. ilast .and. HAS_EQUAL .and. VALID_FIRSTARG )

      FOUND_MATCH_NMLKEY = FOUND_MATCH_SPSEP .or. FOUND_MATCH_EQ
      
      if ( LDMP ) then
          print*,' xxx - - - - - - - - '
          print*,' xxx  ilast, iArg = ', ilast, iArg
          print*,' xxx  FIRSTARG    = ', FIRSTARG(1:40)	  
	  print*,' xxx  HAS_EQUAL = ', HAS_EQUAL
          print*,' xxx  FOUND_MATCH[SPSEP,EQ] = ', 
     &          FOUND_MATCH_SPSEP, FOUND_MATCH_EQ	  
      endif

      RETURN
      END
C ========================================
+DECK,MCMCINP_OVERRIDE.
      SUBROUTINE MCMCINP_OVERRIDE(IERR)

c Created Dec 4, 2009 R.Kessler
c
c Check command-line args for user-option to override
c &MCMCINP namelist values.
c
c ----------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,MCMCCOM.
      INTEGER IERR ! (O) 0 => OK
c local var
      INTEGER  i, ilast, iuse
C -------------- BEGIN --------------
      IERR = 0
      i = 2
      ilast = 2
      DO WHILE ( i .LT. NLINE_ARGS )
cc xxxxx

c set logical flag for used LINE_ARGS
         IF ( i .GT. ilast ) THEN
           DO iuse = ilast, i
              USE_LINE_ARGS(iuse) = .TRUE.
           ENDDO
         ENDIF
         i = i + 1
         ilast = i
      ENDDO

      RETURN
      END   ! end of MCMCINP_OVERRIDE




C ==================================
+DECK,PROCSNNML.
      SUBROUTINE PROCSNNML(IERR)
c
c Created May 17, 2008 by R.Kessler
c
c Translate namelist strings that depend on filters
c into cutwin_*filt(2,filt) variables.
c
c Must call after first event is read so that filters are defined.
c Note that RDKCOR is not called yet.
c
c
c Aug 31, 2010: 
c  - set new variables  NFILT_SNRMAX & IFILT_SNRMAX(i=1,NFILT_SNRMAX)
c  - CUTWIN_SNRMAX_FILT now depends on sparse ifilt_SNRMAX index
c
c Nov 15, 2011: new variables FUDGE_FLUXCAL_[OFFSET,ERROR]
c
c Mar 06, 2012: parse new variable SNCUT_HOST_SBFLUX
c Apr 02, 2014: parse SNRMAX_FILTERS, set LFILTDEF_SNRMAX
c Dec 16, 2018: parse SIMVAR_CUTWIN_STRING
c -----------------------------

      IMPLICIT NONE

      INTEGER IERR

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IAFILT(MXFILT_OBS)
      REAL    XAFILT(MXFILT_OBS)

      INTEGER ifiltdef, NF, i, ifilt, ifiltinv
      CHARACTER cfilt*2
      REAL TMP_ZP, TMP_PRIM
      LOGICAL LDMP, LTMP

c function
      INTEGER FILTINDX

C ---------------- BEGIN -------------

      IERR = 0
      CALL PARSE_FILTSTRING(1,SNCUT_SNRMAX, NF, iafilt, xafilt )
      NFILT_SNRMAX = NF
      if ( NFILT_SNRMAX .GT. MXFILT_SNRMAX ) then
         write(c1err,661) NFILT_SNRMAX, MXFILT_SNRMAX
661      format(I2,' SNRMAX cuts exceeds bound of MXFILT_SNRMAX=',I2)
         c2err = 'Check &SNLCINP variable SNCUT_SNRMAX'
         CALL  MADABORT("PROCSNNML", C1ERR, C2ERR)
      endif


      DO i = 1, NF
         ifiltdef = IAFILT(i)
         ifilt    = IFILTDEF_INVMAP_SURVEY(ifiltdef)
         cutwin_snrmax_filt(1,i) = xafilt(i) ! Aug 31, 2010
         ifilt_SNRMAX(i)         = ifiltdef  ! Aug 31, 2010
      ENDDO

c -------

      CALL PARSE_FILTSTRING(1,SNCUT_HOST_SBFLUX, NF, iafilt, xafilt )
      NFILT_HOST_SBFLUX = NF
      if ( NF .GT. MXFILT_SNRMAX ) then
         write(c1err,662) NFILT_HOST_SBFLUX, MXFILT_SNRMAX
662      format(I2,' HOST_SBFLUX cuts exceeds bound of ',I2)
         c2err = 'Check &SNLCINP variable SNCUT_SNRMAX'
         CALL  MADABORT("PROCSNNML", C1ERR, C2ERR)
      endif

      DO i = 1, NF
         ifiltdef = IAFILT(i)
         ifilt    = IFILTDEF_INVMAP_SURVEY(ifiltdef)
         cutwin_sbflux_filt(1,i) = xafilt(i) 
         ifilt_HOST_SBFLUX(i)    = ifiltdef
      ENDDO

c ----------

      CALL PARSE_FILTSTRING(1,EPCUT_SNRMIN, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         ifilt    = IFILTDEF_INVMAP_SURVEY(ifiltdef)
         cutwin_snrmin_filt(1,ifilt) = xafilt(i)
      ENDDO

c ------
      CALL PARSE_FILTSTRING(0, MAGOBS_SHIFT_PRIMARY, NF,iafilt,xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         magobs_shift_primary_filt(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,MAGOBS_SHIFT_ZP, NF, iafilt, xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         magobs_shift_zp_filt(ifiltdef) = xafilt(i) 
         magobs_shift_zp_user(ifiltdef) = xafilt(i)
      ENDDO

c ---
      CALL PARSE_FILTSTRING(1,FUDGE_FLUXCAL_OFFSET, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_FLUXCAL_OFFSET_FILT(ifiltdef) = xafilt(i)
      ENDDO

c - - - -
      CALL PARSE_FILTSTRING(1,FUDGE_FLUXCAL_ERROR, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_FLUXCAL_ERROR_FILT(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,FUDGE_FLUXCAL_ERRPIX, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_FLUXCAL_ERRPIX_FILT(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,FUDGE_FLUXERR_SCALE, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_FLUXERR_SCALE_FILT(ifiltdef) = xafilt(i)
      ENDDO

c - - - 

      CALL PARSE_FILTSTRING(1,FUDGE_MAG_ERROR, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_MAG_ERROR_FILT(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,SIM_FUDGE_MAG_ERROR,NF,iafilt,xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         SIM_FUDGE_MAG_ERROR_FILT(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,FUDGE_MAG_COVERR, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_MAG_COVERR_FILT(ifiltdef) = xafilt(i)
      ENDDO

c --- REST FRAME
      CALL PARSE_FILTSTRING(0, MAGREST_SHIFT_PRIMARY, NF,iafilt,xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         magrest_shift_primary_filt(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,MAGREST_SHIFT_ZP, NF, iafilt, xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         magrest_shift_zp_filt(ifiltdef) = xafilt(i)
         magrest_shift_zp_user(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,FILTER_LAMSHIFT, NF, iafilt, xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FILTER_LAMSHIFT_FILT(ifiltdef) = xafilt(i)
      ENDDO

c ------
      LDMP = .FALSE.

      do ifiltdef  = 1, MXFILT_ALL
         cfilt     = filtdef_string(ifiltdef:ifiltdef)
         tmp_zp    = MAGOBS_SHIFT_ZP_FILT(ifiltdef)
         tmp_prim  = MAGOBS_SHIFT_PRIMARY_FILT(ifiltdef)

         LTMP = ( tmp_zp .ne. 0.0 .or. tmp_prim .NE. 0.0 ) 
         if ( LDMP .and. LTMP ) then
           print*, 'DBUG: ', cfilt, ifiltdef
     &      , ' : MAGSHIFT_[ZP,PRIMARY] = ', tmp_zp, tmp_prim
         endif
      enddo

c -------
      NF = INDEX(SNRMAX_FILTERS,' ') - 1

      IF ( NF > 0 ) THEN
        
        do ifilt = 1, MXFILT_ALL
           LFILTDEF_SNRMAX(ifilt) = .FALSE.
        enddo
        do ifilt = 1, NF
           cfilt = SNRMAX_FILTERS(ifilt:ifilt)
           IFILTDEF = FILTINDX(cfilt)
           ifiltinv = IFILTDEF_INVMAP_SURVEY(ifiltdef)
           if ( ifiltinv < 1 ) then
              C1ERR = 'Invalid filter = ' // Cfilt
              C2err = 'Check &SNLCINP variable SNRMAX_FILTERS = ' 
     &                   // SNRMAX_FILTERS(1:NF)
              CALL  MADABORT("PROCSNNML", C1ERR, C2ERR)              
           endif
           LFILTDEF_SNRMAX(ifiltdef) = .TRUE.
        enddo

      ENDIF


c ------------------------------------------------------------
c Dec 2018: check for cuts on SIMVAR (e.g., SIM_c, SIM_ZCMB)

      CALL PARSE_SIMVAR_CUTS()

c Jan 12 2021: check option to fix sign VPEC for older data
      DOFIX_WRONG_SIGN_VPEC = (.not. RESTORE_WRONG_VPEC ) .and. 
     &                        (.not. ISCORRECT_SIGN_VPEC) 
      if ( DOFIX_WRONG_SIGN_VPEC ) then
         print*,' '
         print*,'    *** ALERT: VPEC sign will be flipped *** '
         print*,' '
      endif

      if ( RESTORE_WRONG_VPEC ) then
         print*,' '
         print*,'    *** ALERT: use wrong VPEC formula *** '
         print*,' '
      endif

         CALL FLUSH(6)

c set flag for systematic zshift (Jun 2021)
      CALL CHECK_LEGACY_INPUT(HOSTGAL_SPECZ_SHIFT,HOSTGAL_ZSPEC_SHIFT)
      CALL CHECK_LEGACY_INPUT(HOSTGAL_PHOTOZ_SHIFT,HOSTGAL_ZPHOT_SHIFT)      

      DOzSHIFT =  
     &    ( REDSHIFT_FINAL_SHIFT .NE. 0.0 ) .or.
     &    ( HOSTGAL_ZSPEC_SHIFT  .NE. 0.0 ) .or.
     &    ( HOSTGAL_ZPHOT_SHIFT  .NE. 0.0 )

      RETURN
      END  ! end PROCSNNML

C ========================================
+DECK,CHECK_LEGACY_INPUT.
      SUBROUTINE CHECK_LEGACY_INPUT(VAL_LEGACY, VAL_NOMINAL)

c Created Dec 29 2024
c If the legacy value has been set, transfer it to the VAL_NOMINAL

      IMPLICIT NONE
      REAL VAL_LEGACY   ! Input
      REAL VAL_NOMINAL  ! Output

+CDE,SNPAR.

      IF(VAL_LEGACY < .99*LEGACY_INIT_VAL ) THEN
         VAL_NOMINAL = VAL_LEGACY
      ENDIF
      
      RETURN
      END  ! end CHECK_LEGACY_INPUT
      
C ==================================
+DECK,RDSNIGNORE.
      SUBROUTINE RDSNIGNORE
c
c Nov 10, 2008
c Read file SNCID_IGNORE_FILE and load logical array LSNCID_IGNORE
c This is designed for the thousands of SDSS-II candidates,
c so that large numbers of candidates can be ignored from a 
c list file.
c
c Sep 2 2019: allow up to MXIGNORE_LIST=500 (instead of 52)
c Sep 10 2021: 
c   + fix to work properly with/without DOCANA
c   + ignore comments
c   + print first/last CID for visual crosscheck
c
c --------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER CCID*(MXCHAR_CCID), cFILE*(MXCHAR_FILENAME), FNAM*12
      CHARACTER WD1*40
      INTEGER MSKOPT, i, LENFILE, LENCID, NWD, FLAG_DOCANA
      INTEGER NSTORE, NCCID_IGNORE_ORIG
      LOGICAL FOUND_DOCANA, FOUND_DOCANA_END, LREQUIRE_DOCANA

      INTEGER  STORE_PARSE_WORDS, ISTAT_FILE_DOCANA
      EXTERNAL STORE_PARSE_WORDS, REACT_MISSING_DOCANA
C ------------- BEGIN ---------

      IF ( SNCID_IGNORE_FILE .EQ. ' ' ) RETURN

      FNAM = 'RDSNIGNORE'
      CALL ENVreplace(SNCID_IGNORE_FILE)
      LENFILE   = INDEX(SNCID_IGNORE_FILE,' ') - 1
      cFILE     = SNCID_IGNORE_FILE(1:LENFILE)//char(0)
      MSKOPT    = MSKOPT_PARSE_WORDS_FILE 
     &          + MSKOPT_PARSE_WORDS_IGNORECOMMENT 
      NWD = STORE_PARSE_WORDS(MSKOPT, cFILE, FNAM//char(0), LENFILE, 12) 

      LENCID = INDEX(CCID,' ')-1

c check if 1st word is DOCANA key
      CALL get_PARSE_WORD_fortran(1, WD1, LENCID)
      FOUND_DOCANA     = ( WD1 .EQ. 'DOCUMENTATION:' )
      FOUND_DOCANA_END = (.FALSE.)
      LREQUIRE_DOCANA  = (REQUIRE_DOCANA > 0 )

      if ( .NOT. FOUND_DOCANA ) then
         CALL REACT_MISSING_DOCANA(LREQUIRE_DOCANA,cFILE,LENFILE)
      endif

      NSTORE = 0
      NCCID_IGNORE_ORIG = NCCID_IGNORE !might include CIDs from elsewhere

c - - - - - -
      DO 200 i = 1, NWD
         CALL get_PARSE_WORD_fortran(i, CCID, LENCID)

         IF ( FOUND_DOCANA .and. .NOT. FOUND_DOCANA_END) THEN
            FLAG_DOCANA = ISTAT_FILE_DOCANA(i,CCID)
            IF ( FLAG_DOCANA==FLAG_DOCANA_END ) FOUND_DOCANA_END=.TRUE.
            goto 200
         ENDIF

         NSTORE       = NSTORE + 1
         NCCID_IGNORE = NCCID_IGNORE + 1
         SNCCID_IGNORE_ALL(NCCID_IGNORE) = CCID

         IF ( NCCID_IGNORE > MXIGNORE_LIST ) then
           write(c1err,661 ) NCCID_IGNORE
           write(c2err,662 ) MXIGNORE_LIST
           CALL  MADABORT(FNAM, C1ERR, C2ERR)
         endif
661        format('NCCID_IGNORE=',I4,' exceeds bound.')
662        format('Check limit MXIGNORE_LIST = ', I4 )
        
200   CONTINUE

      CALL PRBANNER(FNAM)
      print*,' Loaded ', NCCID_IGNORE,' IGNORE-candidates from '
      print*, '  ', SNCID_IGNORE_FILE(1:LENFILE)
      print*,'  First IGNORED CID: ', 
     &     SNCCID_IGNORE_ALL(NCCID_IGNORE_ORIG+1)
      if ( NSTORE > 1 ) then
        print*,'  Last  IGNORED CID: ', 
     &     SNCCID_IGNORE_ALL(NCCID_IGNORE)
      endif
      print*,' '

      RETURN
      END


C ====================================
+DECK,ISTAT_FILE_DOCANA.
      INTEGER FUNCTION ISTAT_FILE_DOCANA(iwd,string)

c use this utility for files where DOCANA keys break the
c file structure (e.g., SNCID_IGNORE_FILE). This utility
c easily enables skipping the DOCANA stuff.
c
c   Returns  1 if STRING = 'DOCUMENTATION:'
c   Returns  2 if STRING = 'DOCUMENTATION_END:'
c   Returns -1 if first word is not 'DOCUMENTATION:' 
c        (this flags calling function to abort)
c
c - - - - - 

      IMPLICIT NONE

+CDE,SNPAR.

      INTEGER   IWD          ! (I) word number in file
      CHARACTER STRING*(*)   ! (I)  string to check for DOCANA keys
c ---------- BEGIN -----------

      ISTAT_FILE_DOCANA = 0
      if ( STRING .EQ. 'DOCUMENTATION:'    ) then
         ISTAT_FILE_DOCANA = FLAG_DOCANA_START
       endif
       if ( STRING .EQ. 'DOCUMENTATION_END:'    ) then
          ISTAT_FILE_DOCANA = FLAG_DOCANA_END
       endif

      if (IWD==1 .and. ISTAT_FILE_DOCANA.NE.FLAG_DOCANA_START) then
         ISTAT_FILE_DOCANA = FLAG_DOCANA_ERROR
      endif

      RETURN
      END

C ====================================
+DECK,PRBANNER.
      SUBROUTINE PRBANNER ( banner )
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
      character banner*(*)

      if ( .NOT. REDUCE_STDOUT_BATCH ) print*,' '
      print*,
     &   ' ######################################################## '
      print*,'   ', BANNER

      print*,
     &   ' ######################################################## '

      if ( .NOT. REDUCE_STDOUT_BATCH ) print*,' '
      CALL FLUSH(6)

      RETURN
      END

C ========================================
+DECK,PR_SNSTATS.
      SUBROUTINE PRINT_SNSTATS   
c
c Print SN stats : reaad and passing cuts.
c If no SN pass cuts, list cut(s) that always fail.
c
c Get <z> and RMS from hid 11
c
c Apr 26, 2017: I6 -> I7 in format 48.

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

      integer icut, i,  JDIFF
      LOGICAL LTEST, LFAIL
     
      REAL Tsn, Ttot, f_dupl
      EXTERNAL PRINT_CPUTIME

C ------------ BEGIN --------------

      global_banner = 'Job Summary '
      CALL PRBANNER ( GLOBAL_BANNER )

c ----------------------------------------------
c Start with Npasscut vs. ICUT, and for each type.
      CALL PRINT_NPASSCUTS()

c Aug 7 2020: for batch job, write stats to separate YAML file for easy parsing
      CALL PRINT_JOBSPLIT_OUT()

c ------------------------
      write(6,48) N_SNLC_CUTS, N_SNLC_PROC
48    format(/,T5,'Finished processing ',I7,
     &   ' SN after snana  cuts',
     &    3x,'(',I7,' before cuts)'  )
      CALL FLUSH(6)

c Oct 21, 2010: skip other "NEVER FOUND" message if CID cut always fails
      IF ( NACCEPT_CID .EQ. 0 ) GOTO 600

c check for valid SNTYPES (Jul 2012)
      LFAIL = NSNTYPE_LIST .GT. 0 .and. NACCEPT_TYPE .LE. 0
      IF ( LFAIL ) THEN
         print*,' '
         print*,' WARNING-SNTYPE: ',
     &       'NEVER FOUND A VALID SNTYPE ?!?!?! '
         print*,' WARNING-SNTYPE: Check nml variable SNTYPE_LIST = ', 
     &        SNTYPE_LIST(1), SNTYPE_LIST(2)
         print*,' '
      ENDIF


+SELF,IF=CCDLATER.
c Need to define NACCEPT_CCDNUM, and increment it.
c check for valid CCDNUM
      LFAIL = NCCDNUM_LIST .GT. 0 .and. NACCEPT_CCDNUM .LE. 0
      IF ( LFAIL ) THEN
         print*,' '
         print*,' WARNING-CCDNUM: ',
     &       'NEVER FOUND A VALID CCDNUM ?!?!?! '
         print*,' WARNING-CCDNUM: Check nml variable CCDNUM_LIST = ', 
     &        CCDNUM_LIST(1), CCDNUM_LIST(2)
         print*,' '
      ENDIF
+SELF.

c print fit-cut stats
      if ( N_SNLC_FIT .GT. 0 ) then
        write(6,49) N_SNLC_FITCUTS
49      format(T5,'Finished processing ',I6,
     &   ' SN after fitter cuts' )
      endif

c if no supernova pass cuts, look for cuts that always fail.

         print*,' '

600   CONTINUE

      IF ( NACCEPT_CID .EQ. 0 ) THEN
         write(6,66)  CUTBIT_CID, 'CID'
         print*,'     check CUTWIN_CID and SNCID_LIST in &SNLCINP'

      ELSE IF  ( N_SNLC_CUTS .EQ. 0 ) THEN
        DO icut = 1, CUTBIT_MJD_MARKER          
          LTEST = BTEST ( CUTMASK8_SN_ALL , icut-1 )
          if ( LTEST .and. NACCEPT_CUT(icut) .EQ. 0 ) then
             i = INDEX(cutvar_name(icut), ':' )
             write(6,66) icut, cutvar_name(icut)(1:i-1)
          endif
        ENDDO
      ENDIF
66    FORMAT(T5,'** WARNING ** EVERY SN FAILS CUTBIT ', I3,
     &       ' :  ', A )

c -----------------------------------

cc      write(6,170) NEPOCH_BADPHOT_SUM, NEPOCH_USE
      write(6,170) NEPOCH_BADPHOT_SUM, NEPOCH_TOT
170   format(T5,'Bad PHOTOMETRY FLAG for ',I8,' of ', I8,' epochs')

      print*,' '
c -------------------------------------------------
c print out processing time, and process time per SN.


      CALL PRINT_CPUTIME(JTIME_LOOPSTART, 
     &        "CPUTIME_PROCESS_ALL"//char(0), 
     &        "minute"//char(0), 0,    20,20)

      CALL PRINT_CPUTIME(JTIME_LOOPSTART, 
     &        "CPUTIME_PROCESS_RATE"//char(0), 
     &        "second"//char(0), N_SNLC_CUTS,    20,20)

c --------------------------
c print DUPLICATE-CID WARNING

      IF ( N_DUPLICATE_CID > 0 ) THEN
         f_dupl = float(N_DUPLICATE_CID)/ float(N_SNLC_PROC)
         write(6,60)
         write(6,60)
         write(6,606) N_DUPLICATE_CID, 100.*f_dupl
         write(6,60)
         write(6,60)
 606     format(/, T5,'SEVERE WARNING: rejected ',I4,' Duplicate CIDs',
     &          3x,'(',F6.2,'%)', / )
      ENDIF

60      format(T2, 32('@-') )

c print DUPLICATE-MJD WARNING
      IF ( N_DUPLICATE_MJD > 0 ) THEN
         f_dupl = float(N_DUPLICATE_MJD)/ float(NEPOCH_USE)
         write(6,60)
         write(6,60)
         write(6,616) N_DUPLICATE_MJD, 100.*f_dupl
         write(6,617) NSTORE_DUPLICATE_MJD
         write(6,60)
         write(6,60)
         call flush(6)
 616     format(/,T5,'SEVERE WARNING: FOUND ',I4,' Duplicate MJD+BAND',
     &          3x,'(',F6.3,'%)' )
 617     format(T20,I4,' Duplicate MJDs are unique', /)
      ENDIF
      
      IF ( OPT_TABLE(ITABLE_OUTLIER) > 0 ) THEN
         CALL PRINT_OUTLIER_SUMMARY()  ! Mar 2021
      ENDIF

      RETURN
      END   ! end PRINT_SNSTATS


C =======================
+DECK,PRNCUTS.
      SUBROUTINE PRINT_NPASSCUTS()

c
c Jan 3, 2013
c
c Print Number of SN passing each incremental cut, and for each type.
c Table has up to 6 types, if more then make new table so that
c table does not exceed 80 columns.
c
c Feb 22, 2013: fix to work for TYPE=0
c
c For ITYPE=-1, write string 'ALL' to be more clear about meaning.
c
c Jun 19 2019: incluce ROWKEY = "CUTSTAT:" to make log file parsable.
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,CTRLCOM.
+CDE,SNLCINP.

      LOGICAL USETYPE(-1:MXTYPE), LPRIN

      INTEGER 
     &   ITYPE, NTYPE, ITYPE_LIST(MXTYPE)
     &  ,I1, I2, i, icut
     &  ,NTYPE_PER_TABLE
     &  ,N, NLAST, jcolon

      CHARACTER CUTNAME*28, ROWKEY*8

C ------------- BEGIN -------------

c first get list of used TYPES
      NTYPE = 0
      DO itype = -1, MXTYPE
        USETYPE(itype) = .FALSE.
        if (  NPASSCUT_INCREMENT(itype,1) .GT. 0 )  then
           USETYPE(itype) = .TRUE.
           NTYPE =  NTYPE + 1
           ITYPE_LIST(NTYPE) = ITYPE           
        endif
      ENDDO

c print table header

      ROWKEY = "CUTSTAT:"

      print*,'                         ', 
     &      'Number of SN passing incremental cut for'
 
      NTYPE_PER_TABLE = 6
      DO  777 I1 = 1, NTYPE, NTYPE_PER_TABLE

        write(6,20) ROWKEY, 'CUT-NAME      ITYPE='
20      format(A, 2x, A20, $)

        I2   = MIN(I1+NTYPE_PER_TABLE-1,NTYPE)
        DO i = I1, I2
           itype = ITYPE_LIST(i)

           if ( itype .EQ. -1 ) then
              write(6,27) 'ALL'
           else
              write(6,28) ITYPE
           endif
 27        format(A8,$)
 28        format(I8,$)
        ENDDO 
        print*,' '
        write(6,80)
80      format(T2,  72('-') )
      

        DO 888 ICUT = 1, NCUTBIT_SNLC 

           if(.NOT.LSIM_SNANA .and. icut.EQ.CUTBIT_SEARCH ) goto 888

c print line if any entry has a change in NPASSCUT
           LPRIN = .FALSE.
           IF ( ICUT .EQ. 1 ) THEN
              LPRIN = .TRUE.
           ELSE
              DO i = I1, I2
                itype = ITYPE_LIST(i)
                NLAST = NPASSCUT_INCREMENT(itype,icut-1)
                N     = NPASSCUT_INCREMENT(itype,icut)
                if ( N .LT. NLAST ) LPRIN = .TRUE.
              ENDDO
           ENDIF
           IF ( LPRIN ) THEN            
              jcolon    = INDEX(cutvar_name(icut), ':' )
              CUTNAME   = CUTVAR_NAME(icut)(1:jcolon-1) ! remove ':'
              write(6,20) ROWKEY, CUTNAME  
              DO i = I1, I2
                itype = ITYPE_LIST(i)
                write(6,28) NPASSCUT_INCREMENT(itype,icut)
              ENDDO
              print*,' '            
           ENDIF
888     CONTINUE

c for fit, write number passing fit cuts.

        IF ( NFIT_ITERATION > 0 ) THEN
            CUTNAME = 'FIT+CUTS'
            write(6,20) ROWKEY, CUTNAME            
            DO i = I1, I2
               itype = ITYPE_LIST(i)
               write(6,28) NPASSCUT_FIT(itype)
            ENDDO
        ENDIF
              print*,' '  
              print*,' '   
777   CONTINUE

      write(6,80)
      RETURN
      END

C =========================
+DECK,PR_CPU_REMAIN.
      SUBROUTINE PRINT_CPU_REMAIN(ISN)  
C
C Created Apr 4 2024
C Print fraction of total events processed, elapsed time,
C and estimate time remaining:
C 
C   Processed ~12% of events in mm minutes -> mm minutes remaining.
C
C Used only for BATCH mode.
C ----------------

      IMPLICIT NONE
      
      INTEGER ISN  ! (I) integer index (1-NSN)

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER NSN_TOT, JTIME, JTDIF, PERCENT
      REAL FRAC, T_ELAPSE, T_REMAIN
C ------------ BEGIN ---------

      if ( .NOT. STDOUT_UPDATE ) RETURN

c bail for subset option for which this update makes no sense
      if ( .NOT. ISJOB_BATCH     ) RETURN 
      if ( NCID_LIST > 0         ) RETURN 
      if ( MXEVT_PROCESS < 10000 ) RETURN
      
      NSN_TOT = N_SNLC_READ(1)
      FRAC = FLOAT(ISN) / FLOAT(NSN_TOT)
      PERCENT = INT(FRAC*100.0 + 0.5)
      
      JTIME = TIME()
      JTDIF = JTIME - JTIME_LOOPSTART 
      T_ELAPSE = FLOAT(JTDIF)/60.0
      T_REMAIN = T_ELAPSE * ( 1.0/FRAC - 1.0 )  ! prediction

      if ( T_ELAPSE < 1.0 ) RETURN  ! avoid printing crazy predictions 
      
      write(6,20) PERCENT, T_ELAPSE, T_REMAIN
20    format(T6,'Processed ', I3,'% of events in ',
     &     F6.1, ' minutes -> ', F6.1,' minutes remaining.')
      call flush(6)
      
      RETURN
      END   ! end of PRINT_CPU_REMAIN
      
C ==================================
+DECK,PRINT_JOBSPLIT_OUT.
      SUBROUTINE PRINT_JOBSPLIT_OUT()

c Created Aug 7 2020
c If snana job is submitted by batch job (i.e., JOBSPLIT is set), 
c create supplmental output file
c    [VERSION].YAML
c and write stats for batch process to read.
c This YAML file avoids submit_batch script having to parse 
c potentially large log files. Also note that ABORT_IF_ZERO
c is a standard key telling batch script to ABORT if its
c value is zero; this avoids the batch script having to know
c program-specific keys for NEVT_what?
c
c Oct 12 2020: check OPT_YAML 
c Jul 08 2021: write N_SNHOST_ZSPEC[ZPHOT]

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,FILTCOM.

      INTEGER LEN, JDIFF, AIZ
      REAL    T_CPU
      CHARACTER OUTFILE*(MXCHAR_FILENAME)

C ------------- BEGIN -------------

c if user does NOT request YAML file, then check default
c to create YAML file only if this is a batch job.

      IF ( OPT_YAML <= 0 ) THEN
        IF ( .NOT. ISJOB_BATCH       ) RETURN
        IF ( TEXTFILE_PREFIX .EQ. '' ) RETURN
      ENDIF

c write [REPFIX].YAML file...

      LEN     = INDEX(TEXTFILE_PREFIX,' ' ) - 1
      OUTFILE = TEXTFILE_PREFIX(1:LEN) // '.YAML'

c if TEXTFILE_PREFIX is not defined, then use VERSION_PHOTOMETRY
      if ( LEN == 0 ) then
         LEN = INDEX(VERSION_PHOTOMETRY(1),' ') - 1
         OUTFILE = VERSION_PHOTOMETRY(1)(1:LEN) // '.YAML'
      endif

      write(6,40) OUTFILE(1:LEN+5)
40    format(' Write stats to YAML output: ', A )

      OPEN(   UNIT   = LUNDAT 
     &      , FILE   = OUTFILE
     &      , STATUS = 'UNKNOWN'
     &           )

      JDIFF = JTIME_LOOPEND - JTIME_LOOPSTART
      T_CPU = float(JDIFF)/60. 

      write(LUNDAT,19) 'SURVEY:          ', SURVEY_NAME
      write(LUNDAT,19) 'FILTERS:         ', 
     &       SURVEY_FILTERS(1:NFILTDEF_SURVEY)
      write(LUNDAT,20) 'IDSURVEY:        ', IDSURVEY
      write(LUNDAT,20) 'NEVT_TOT:        ', N_SNLC_PROC
      write(LUNDAT,20) 'NEVT_LC_CUTS:    ', N_SNLC_CUTS 

      write(LUNDAT,20) 'NEVT_HOST_ZSPEC: ', N_SNHOST_ZSPEC
      write(LUNDAT,20) 'NEVT_HOST_ZPHOT: ', N_SNHOST_ZPHOT
      write(LUNDAT,20) 'NEVT_SPECTRA: ',    N_SNLC_SPEC ! nevt with spectra

      write(LUNDAT,20) 'NEVT_LCFIT_CUTS: ', N_SNLC_FITCUTS 

c write NEVT per redshift source
      CALL PRINT_JOBSPLIT_zSRC(LUNDAT, "LC_CUTS")
      CALL PRINT_JOBSPLIT_zSRC(LUNDAT, "LCFIT_CUTS")      

      write(LUNDAT,21) 'CPU_MINUTES:     ', T_CPU
19    format(A, A)
20    format(A, I8)
21    format(A, F8.2)


c check options for ABORT_IF_ZERO (AIZ)

+SELF,IF=SNANA.
      AIZ = N_SNLC_CUTS
+SELF,IF=SNFIT.
      AIZ = N_SNLC_FITCUTS
+SELF.
      IF ( MXEVT_CUTS < 10 ) AIZ = N_SNLC_CUTS


      write(LUNDAT,20) 'ABORT_IF_ZERO:   ', AIZ

      CLOSE ( UNIT = LUNDAT ) 

      RETURN
      END   ! end  PRINT_JOBSPLIT_OUT

C ==================================
+DECK,PRINT_JOBSPLIT_zSRC.
      SUBROUTINE PRINT_JOBSPLIT_zSRC(LUN, WHICH)

c Created Nov 26 2024
c write NEVT per redshift source to YAML file;
c intended to help figure out what redshift sources are
c in the data or sim.

      IMPLICIT NONE
      INTEGER LUN  ! (I)
      CHARACTER WHICH*(*)  ! LC_CUTS or LCFIT_CUTS
      
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT. 
+CDE,FILTCOM.

      INTEGER NEVT, NEVT2, MASK, MASK2, NEVT_or
      INTEGER N_MASK_LOCAL(0:MXMASK_zSOURCE)
      CHARACTER KEY*28
      
c ----------  BEGIN ------------

      IF ( WHICH(1:7) .EQ. 'LC_CUTS' ) THEN
         KEY = 'MASK_zSOURCE_LC_CUTS:'
	 DO mask = 0, MXMASK_zSOURCE
	     N_MASK_LOCAL(mask) = N_MASK_zSOURCE_LC_CUTS(mask)
	 ENDDO
      ELSE
         KEY = 'MASK_zSOURCE_LCFIT_CUTS:'
	 DO mask = 0, MXMASK_zSOURCE
	     N_MASK_LOCAL(mask) = N_MASK_zSOURCE_LCFIT_CUTS(mask)
	 ENDDO	 
      ENDIF
      
      write(LUN,28) ' '
      write(LUN,28) KEY // '   # redshift sources for ' // WHICH
      write(LUN,38) '   += 1 -> zSPEC_HOST'
      write(LUN,38) '   += 2 -> zSPEC_SN'
      write(LUN,38) '   += 4 -> zPHOT_HOST(mean+stdev or quantiles)'
      write(LUN,38) '   += 8 -> zPHOT_HOST(quantiles)'
      write(LUN,38)
     &   '    MASK:     NEVT(MASK=val)    NEVT(MASK&val)'
      DO 200 MASK = 0, MXMASK_zSOURCE
         NEVT    = N_MASK_LOCAL(MASK)
         NEVT_or = 0
         DO 202 MASK2 = 0, MXMASK_zSOURCE
	    NEVT2 = N_MASK_LOCAL(MASK2)
	    if ( NEVT2 == 0 ) GOTO 202
	    if ( IAND(MASK,MASK2) == MASK ) then
	        NEVT_or = NEVT_or + NEVT2
            endif
202	 CONTINUE
	 
	 if ( NEVT > 0 ) then
            write(LUNDAT,212) MASK, NEVT, NEVT_or
212	    format('  - ', I6,':', I10, 8x, I10 )
         endif	 
200   CONTINUE
      write(LUNDAT,28) ' '

28    format(A)
38    format('# ', A)

      RETURN
      END  ! end PRINT_JOBSPLIT_zSRC
      
      
C ======================================
+DECK,SNANA_DRIVER.
      SUBROUTINE SNANA_DRIVER(ISN_ALL, ISN_PROC)

c Created May 18, 2012 by R.Kessler
c
c Analysis driver for SN with
c   ISN_ALL  = absolute index for all events, regardless of cuts
c   ISN_PROC = sparse index of processed events (after cuts)
C
c Move code from MAIN to here so that each SN is fit
c right after it is read.
c
c Jun 21 2018:
c   if ERRFLAG_FIT > 0 on any iteraton, REJECT fit immediately
c   See REJECT_FIT logical.
c
c Dec 19 2024: print CPU time per event in stdout update
c ----------------------

      IMPLICIT NONE

      INTEGER ISN_ALL, ISN_PROC  ! (I) 

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

+SELF,IF=SNFIT.
      INTEGER NCALL_MNFIT, ITER
      LOGICAL LAST_ITER, REJECT_FIT
+SELF.

      INTEGER IERR, i
      REAL*8  PS8
      REAL t_start, t_end  ! Dec 2024
      LOGICAL REJECT_PRESCALE, USE_MINOS_LOCAL
      CHARACTER FNAM*14

c ----------------- BEGIN -------------

      FNAM = 'SNANA_DRIVER' 

      if ( STDOUT_UPDATE ) CALL CPU_TIME(t_start)
      
      if ( ISN_PROC > MXSNLC-1 ) THEN
        write(c1err,666) N_SNLC_PROC
666     format('ISN_PROC=',I8,' exceeds MXSNLC array bound.')
        c2err = 'Try splitting job into multiple jobs with CID-ranges'
        CALL MADABORT(FNAM, c1err, c2err)
      endif

      if ( LSIM_SNANA ) THEN
         PS8 = DBLE(SIM_PRESCALE)
         if ( REJECT_PRESCALE(N_SNLC_PROC,PS8) ) RETURN
      endif

c - - - - - - - - - - - 
      NCALL_SNANA_DRIVER  = NCALL_SNANA_DRIVER  + 1

c one-time init after first event is read.      

      IF ( NCALL_SNANA_DRIVER .EQ. 1 )  THEN

        CALL MON_SNANA(IFLAG_INI)     ! book 1d distributions    

+SELF,IF=SNFIT.
        CALL FITPAR_INI2(IERR)
+SELF.

+SELF,IF=PSNID.
        CALL PSNIDINI2(IERR)
+SELF.

        CALL USRINI2(IERR)        ! generic user function (Dec 2012)        

          if ( IERR .NE. 0 ) then
            c1err = 'Problem with 2nd init when NCALL_SNANA_DRIVER=1'
            c2err = 'CID = ' // SNLC_CCID
            CALL  MADABORT(FNAM, C1ERR, C2ERR ) 
          endif
      ENDIF


+SELF,IF=SNFIT.
c check for SN-dependent filter response
      CALL FILTER_UPDATE_DRIVER()
+SELF.

c compute quantities, apply AB offsets, set cut-mask
      CALL SNRECON()       ! compute variables, apply AB offsets

      CALL U3BAND()        ! special U-band test

      CALL SET_CUTMASK()   ! set cutmask 

+SELF,IF=SNFIT.
c check option to include IDEAL fit, after SNRECON (Aug 29 2017)
      CALL SIMFIT_IDEAL_PREP(0)
+SELF.

c set default to use minimized fitpar unless user calls MARG_DRIVER
      USEPDF_MARG = .FALSE.

c check dump-option for SN that fail cuts.

      IF ( .not. LSNCUTS ) THEN
         if ( STDOUT_UPDATE ) write(6,41) SNLC_CCID
41       format(T20,'SNANA cuts REJECT CID = ',A8, 2x,'=> SKIP ')
	 CALL FLUSH(6)
         IF ( LDMP_SNFAIL ) CALL DMP_SNFAIL()
         CALL MON_SNANA(IFLAG_ANA)       ! update tables for rejected SN
         RETURN  ! skip this SN
      ENDIF

      IF ( STDOUT_UPDATE ) THEN
        write(6,42) isn_proc
     &        , SNLC_CCID
     &        , ISNLC_NEWMJD_STORE
     &        , ISNLC_NEWMJD_CUTS
      ENDIF

      CALL EXEC_REFORMAT()

+SELF,IF=SNFIT.

c do the fit

       ITER          = 0
       LREPEAT_ITER  = .FALSE.
       LREPEAT_MINOS = .FALSE.
       REJECT_FIT    = .FALSE.
       NCALL_MNFIT   = 0
       
       N_SNLC_FIT = N_SNLC_FIT + 1
       DO i = 1, FCNFLAG_MAX
         NCALL_FCNFLAG(i) = 0
       ENDDO

       DO 410 WHILE( iter < NFIT_ITERATION .and. .NOT.REJECT_FIT)

          ITER = ITER + 1
          LAST_ITER = ( ITER .EQ. NFIT_ITERATION )

          IF ( ITER==1 ) THEN
              USE_MINOS_LOCAL = .FALSE.
          ELSE
              USE_MINOS_LOCAL = (USE_MINOS .or. LREPEAT_MINOS)
          ENDIF
      
          CALL FITPAR_PREP ( iter, IERR )  ! init fit params
          if ( IERR .NE. 0 ) then
            ERRFLAG_FIT = IERR
 	    REJECT_FIT = .TRUE.	    
            write(6,40) ITER, SNLC_CCID(1:ISNLC_LENCCID)
40          format(T5,'FITPAR_PREP PROBLEM => SKIP FIT-ITER=', 
     &              I2,'  for  CID=',A )
            GOTO 410          ! bad init => skip fit-iteration
          endif

          if ( STDOUT_UPDATE ) THEN
            WRITE(GLOBAL_BANNER,44) ISN_PROC,
     &         SNLC_CCID(1:ISNLC_LENCCID), NFITPAR_MN, ITER
            CALL PRBANNER(GLOBAL_BANNER)
44          format(T5,'CALL MNFIT_DRIVER for ISN_PROC=',I5,
     &           3x,'CID=',A, 3x, 'NFITPAR=',I3, 3x,'iter=',I1 )
          endif

c call main driver for fitter. 
c Note that all returned output from MNFIT_DRIVER goes to common blocks.

          CALL MNFIT_DRIVER ( 
     &       SNLC_CCID, NFITPAR_MN                ! (I)
     &      ,INIVAL, INISTP, INIBND               ! (I)
     &      ,PARNAME_STORE                        ! (I)
     &      ,USE_MINOS_LOCAL                      ! (I)
     &      ,MINUIT_PRINT_LEVEL                   ! (I)
     &      ,FITVAL(1,iter)                       ! (O)
     &      ,FITERR_PLUS(1,iter)                  ! (O)
     &      ,FITERR_MINUS(1,iter)                 ! (O)
     &      ,FITCHI2_MIN                          ! (O)
     &      ,NFIXPAR, ERRTYPE                     ! (O)
     &      ,MNSTAT_COV                           ! (O)
     &      ,IERR                                 ! (O)
     &            )   

c bail on error
         IF ( IERR > 90 ) THEN  ! May 2024
	   ERRFLAG_FIT = IERR
	   REJECT_FIT = .TRUE.
           GOTO 410
         ENDIF
	 
c avoid infinite loop with MNFIT calls ...
         NCALL_MNFIT = NCALL_MNFIT + 1
         IF  ( NCALL_MNFIT .GT. 2*MXITER ) THEN
            write(c1err,641) 2*MXITER, SNLC_CCID
            write(c2err,642) NFIT_ITERATION
641         format('MNFIT_DRIVER called > ',I3,' times for CID=',A) 
642         format('even though NFIT_ITERATION = ', I2 )
            CALL  MADABORT(FNAM, C1ERR, C2ERR ) 
         ENDIF

c  store fit results
         CALL MNFIT_STOREPAR(iter,IERR) 

c analyze results: returns ERRFLAG_FIT
c  =  0 => OK; keep SN
c  >  0 => discard fit
c  = -1 => decrement ITER and try again (e.g., for photoZ spike) 

          CALL FITPAR_ANA ( isn_proc, iter, ERRFLAG_FIT )

c check ERRFLAG_FIT
          CALL SNANA_ERRFLAG_FIT(iter,ERRFLAG_FIT)
          if ( ERRFLAG_FIT > 0 ) REJECT_FIT = .TRUE.
 
410     CONTINUE  ! end of iteration loop

        if ( STDOUT_UPDATE ) THEN
          CALL CPU_TIME(t_end)
	  write(6,450) SNLC_CCID(1:ISNLC_LENCCID), t_end-t_start
450       format(T5,'Finished fitting CID = ', A12,
     &           ' in ', F6.3,' seconds')
          CALL PRINT_CPU_REMAIN(ISN_ALL)     ! Apr 4 2024
          call flush(6)
        endif
+SELF.

+SELF,IF=PSNID.
      CALL PSNIDANA(IERR)
+SELF.


42    format(T8,'Analyze ISN_PROC=',I8, 2x,
     &    'for ',A14,'  NMJD(stored,cuts)=', I4, '->', I4 )
      CALL FLUSH(6)
      CALL USRANA(IERR)     ! call user-analysis routine


+SELF,IF=SNANA.
c pack the meta data 
      IF ( OPT_TABLE(ITABLE_SNLCPAK) > 0  ) THEN
        CALL SNLCPLOT()       ! prepare light curves for plotting
      ENDIF
+SELF.

      IF ( OPT_TABLE(ITABLE_SPECPAK) > 0  ) THEN
        CALL SPECPLOT()       ! prepare spectra for plotting (Apr 2019)
      ENDIF


c Beware that SNANA table gets filled after FITRES table.
      CALL MON_SNANA(IFLAG_ANA)     ! monitor-driver
	 
      CALL MAKE_SIMLIB_FILE(2)   ! update SIMLIB Feb 2016

+SELF,IF=TESTFUNS.
      CALL TEST_GET_SNFITSIO_INFO()
+SELF.

      RETURN
      END         ! end of SNANA_DRIVER

C =====================================================
+DECK,SNANA_ERRFLAG,IF=SNFIT.
      SUBROUTINE SNANA_ERRFLAG_FIT(ITER,ERRFLAG)

c Created May 24 2018
c Minor refactor: move some code out of SNANA_DRIVER for cleanup.

      IMPLICIT NONE

      INTEGER ITER, ERRFLAG ! (I)

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

      LOGICAL LAST_ITER, ALREADY_MINOS

C ------------ BEGIN ----------

      LAST_ITER = ( ITER .EQ. NFIT_ITERATION )

      if ( LAST_ITER ) then  
         if ( ERRFLAG == 0 ) then
            N_SNLC_FITCUTS = N_SNLC_FITCUTS + 1
            CUTFLAG_SNANA  = IBSET(CUTFLAG_SNANA,1) ! for SNANA ntuple
            NPASSCUT_FIT(ISNLC_TYPE) = NPASSCUT_FIT(ISNLC_TYPE)+1
            NPASSCUT_FIT(-1)         = NPASSCUT_FIT(-1)+1 ! all types
	    
            N_MASK_zSOURCE_LCFIT_CUTS(ISNLC_zSOURCE) =
     &      N_MASK_zSOURCE_LCFIT_CUTS(ISNLC_zSOURCE) + 1  ! Dec 2024
     
         endif

c check option to redo entire fit with MINUIT's MINOS option;
c this is a better fit, particularly for errors, but it is 
c much slower. So use this only when a serious fit problem is found.
         ALREADY_MINOS = LREPEAT_MINOS .or. USE_MINOS
         if ( ERRFLAG .EQ. -2 .and. (.NOT. ALREADY_MINOS) ) then
            ITER = 0
            LREPEAT_MINOS = .TRUE.
         endif

      endif

c check option to redo fit-iteration 
      if ( ERRFLAG .EQ. -1 ) then
         ITER         = ITER - 1 
         LREPEAT_ITER = .TRUE.
      else
         LREPEAT_ITER = .FALSE.
      endif
      
      RETURN
      END   ! end SNANA_ERRFLAG_FIT
+SELF.

C ======================================
+DECK,SNEND.
      SUBROUTINE SNANA_END

c Created MAy 2012 by R.Kessler
c
c Shell to call functions after all SN have been processed.
c
c Nov 10 2018: move call to PRINT_SNSTATS() to end of SNANA_END
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

      INTEGER IERR, LENF
      EXTERNAL write_epoch_list_summary

c ----------------- BEGIN -------------

c -----------------------------

+SELF,IF=SNFIT.
      CALL PRBANNER ( "CALL FITPAR_END" )
      CALL FITPAR_END(IERR)
+SELF.

+SELF,IF=PSNID.
      CALL PRBANNER ( "CALL PSNIDEND" )
      CALL PSNIDEND(IERR)
+SELF.

      CALL PRBANNER ( "CALL USREND" )
      CALL USREND ( IERR )

      IF ( USE_TABLEFILE_ROOT ) THEN
         LENF = index(ROOTFILE_OUT,' ') - 1
         CALL TABLEFILE_CLOSE(ROOTFILE_OUT(1:LENF)//char(0), LENF)
      ENDIF

      IF ( USE_TABLEFILE_TEXT ) THEN  ! April 2019

c Apr 18 2022: if no events were processed then there are no text files.      
c      In this case, create blank text-table file for each table
         IF ( N_SNLC_PROC == 0 ) CALL SNTABLE_CREATE_TEXT_EMPTY()
         CALL TABLEFILE_CLOSE("NULL"//char(0),10)
      ENDIF

      IF ( USE_TABLEFILE_MARZ ) THEN  ! April 2019
         LENF = index(MARZFILE_OUT,' ') - 1
         CALL TABLEFILE_CLOSE(MARZFILE_OUT(1:LENF)//char(0), LENF)
      ENDIF

      CALL MAKE_SIMLIB_FILE(3)  ! end optional SIMLIB FILE 

      CALL WARN_OLDINPUTS("list"//char(0), 0);

      CALL END_MAGCOR()  ! check for warnings

c - - - - - - 
      CALL PRINT_SNSTATS()

      IF ( OUT_EPOCH_IGNORE_FILE .NE. '' ) then
         CALL write_epoch_list_summary()
      ENDIF

      IF ( REFORMAT_SNANA )  THEN
         CALL END_REFORMAT()
      ENDIF

      call flush(6)
      print*,' ' 
      print*,'   ENDING PROGRAM GRACEFULLY. '

      RETURN
      END    ! end of SNANA_END


C ======================================
+DECK,SNTABLE_CREATE_EMPTY.
      SUBROUTINE SNTABLE_CREATE_TEXT_EMPTY()
c
c Created Apr 18 2022 by R.Kessler
c Goofy routine called at end of job if no events have been read;
c create empty TEXT table so that submit_batch_jobs finds all of
c the expected TEXT-table files. The underlying problem is that
c TEXT table file is not created until after 1st event is read ...
c so if there is no 1st event then there is no text table file.
c For ROOT, the file is created regardless of 1st event
c because these table formats hold multiple tables in one file.
c --------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

      INTEGER NTABLE_CHECK
      PARAMETER (NTABLE_CHECK = 2)
      INTEGER 
     &   ITABLE_LIST(NTABLE_CHECK)
     &  ,IDTABLE_LIST(NTABLE_CHECK)
     &  ,itab, ITABLE, IDTABLE, LENNAM, LENFMT
      CHARACTER 
     &    TBNAME_LIST(NTABLE_CHECK)*40
     &   ,TBNAME*40, TXTFMT*20
     &   ,cTBNAME*40, cTXTFMT*20

      EXTERNAL SNTABLE_CREATE_TEXT

c --------- BEGIN ----------

      write(6,20)
20    format(/,T3,'No events read -> create empty text-table file:')
      call flush(6)

c hard-wire list of table info to check

      ITABLE_LIST(1)  = ITABLE_SNANA
      ITABLE_LIST(2)  = ITABLE_FITRES

      IDTABLE_LIST(1) = IDTABLE_SNANA
      IDTABLE_LIST(2) = IDTABLE_FITRES

      TBNAME_LIST(1)  = 'SNANA'
      TBNAME_LIST(2)  = 'FITRES'

c - - - - - -
      DO 100 itab =1, NTABLE_CHECK
        ITABLE  = ITABLE_LIST(itab) 
        IDTABLE = IDTABLE_LIST(itab)
        TBNAME  = TBNAME_LIST(itab)
        TXTFMT  = 'key'

        IF ( OPT_TABLE(ITABLE) > 0 ) THEN
          LENNAM  = INDEX(TBNAME,' ') - 1
          LENFMT  = INDEX(TXTFMT,' ') -1
          cTBNAME = TBNAME(1:LENNAM) // char(0)
          cTXTFMT = TXTFMT(1:LENFMT) // char(0)
          CALL SNTABLE_CREATE_TEXT(IDTABLE, cTBNAME, cTXTFMT, 40,20)
        ENDIF
100   CONTINUE

      RETURN
      END


C ===========================================
+DECK,REJECTPS.
      LOGICAL FUNCTION  REJECT_PRESCALE(N,PRESCALE)

c Created Jan 2015
c Apply &SNLCINP SIM_PRESCALE (if >1) to randomly pre-scale
c the simulation. Use reproducible random numbers based
c on input integer N (incremental index) ,
c   RAN = mod(N,PI)/PI
c
c Apr 26 2017: pass PRESCALE as argument.

      IMPLICIT NONE

      INTEGER N           ! (I) use for pseudo-random pre-scale
      REAL*8  PRESCALE    ! (I) prescale
c local var

+CDE,SNPAR.
c +CDE,SNDATCOM.
c +CDE,SNLCINP.

      DOUBLE PRECISION XN, RAN, RANMAX

C ------------- BEGIN --------------

      REJECT_PRESCALE = .FALSE.

      IF ( PRESCALE < 1.000001 ) RETURN

      XN     = DBLE(N)
      RAN    = mod(XN,PI)/PI
      RANMAX = 1.0/PRESCALE
      IF ( RAN > RANMAX ) REJECT_PRESCALE = .TRUE.

      RETURN
      END

C =============================
+DECK,INIT_REFORMAT.
      SUBROUTINE INIT_REFORMAT(OPT)
c
c Create Feb 7 2021;
c Initialize option to reformat data
c Input OPT=1 -> Auto-set bits
c Input OPT=2 -> call INIT_REFORMAT_[FITS,TEXT,SPECTRA]
c
c Note that REFORMAT_FITS[TEXT] operates on all of the data: header, photometry,spectra;
c however, REFORMAT_SPECTRA operates only on the spectra and ignores header & photometry
c
c OPT_REFORMAT_FITS[TEXT] bits:
c  lsb   mask  comment
c   0     1    write fits; 
c   1     2    include rejected epochs
c   2     4     SPARE
c   3     8     SPARE
c   4    16     SPARE
c   5    32    rename band -> [SURVEY]-[band]
c   6    64    exclude private variables
c   7   128    include spectra
c   8   256    exclude SIM-truth so that output looks like real data
c   9   512     SPARE
c
c
c OPT_REFORMAT_SPECTRA bits:
c  lsb  mask 
c   0    1      3-column text format: lam, Flam, Flam_err
c   1    2      3-column text format: lam, Flux, Flux_err 
c   2    4      SNANA keyed format for plot_table ; include SIM_FLAM for sims
c
c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c
c       HISTORY
c July 2023: check OPT_REFORMAT_SPECTRA
c Dec  2024: new OPT_REFORMAT_SPECTRA = 4 for SNANA keyed format
c Apr  2025: new OPT += 32 to rename band -> [SURVEY]-band
c            Minor refactor using IAND and MASKs instead of BTEST
c -------------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.      

      INTEGER OPT

      INTEGER MASK_REFMT_INCLUDE_REJECT  /  2 /   ! include rejected epochs
      INTEGER MASK_REFMT_BAND_NAME       / 32 /   ! band -> [SURVEY]-[band]
      INTEGER MASK_REFMT_EXCLUDE_PRIVATE / 64 /   ! exclude private variables
      INTEGER MASK_REFMT_INCLUDE_SPECTRA / 128 /  ! include spectra
      INTEGER MASK_REFMT_EXCLUDE_SIM     / 256 /  ! exclude SIM truth to look like real data

      INTEGER LEN_VER, MASK_REFMT
      LOGICAL LEXIST, VALIDFILENAME, LMASK
      CHARACTER 
     &   FNAM*14
     &  ,LIST_FILE*(MXCHAR_FILENAME), IGNORE_FILE*(MXCHAR_FILENAME)
     &  ,CMD*(MXCHAR_FILENAME)
C ------------- BEGIN -------------

      FNAM = 'INIT_REFORMAT'

      IF ( OPT == 2 ) GOTO 500

      REFORMAT       = .FALSE.  ! any reformat option
c - - - - - - - - - 
c convert &SNLCINP strings and OPT_REFORMAT_TEXT[FITS] into logicals

      IF ( VALIDFILENAME(VERSION_REFORMAT_FITS) ) THEN
        OPT_REFORMAT_FITS = IBSET(OPT_REFORMAT_FITS,0) ! set 1st bit
      ENDIF
      IF ( VALIDFILENAME(VERSION_REFORMAT_TEXT) ) THEN  
        OPT_REFORMAT_TEXT = IBSET(OPT_REFORMAT_TEXT,0) ! set 1st bit
      ENDIF

c check option to save bad epochs for OPT_REFORMAT
      MASK_REFMT = MASK_REFMT_INCLUDE_REJECT
      LMASK = IAND(OPT_REFORMAT_FITS,MASK_REFMT) > 0 .or.
     &        IAND(OPT_REFORMAT_TEXT,MASK_REFMT) > 0
      REFORMAT_SAVE_BADEPOCHS = LMASK

c check option to alter band names
      MASK_REFMT = MASK_REFMT_BAND_NAME
      LMASK = IAND(OPT_REFORMAT_FITS,MASK_REFMT) > 0 .or.
     &        IAND(OPT_REFORMAT_TEXT,MASK_REFMT) > 0
      REFORMAT_BAND_NAME = LMASK

c check option to suppress PRIVATE variables: MASK+=64 or bit 6 (lsb=0)
      MASK_REFMT = MASK_REFMT_EXCLUDE_PRIVATE
      LMASK = IAND(OPT_REFORMAT_FITS,MASK_REFMT) > 0 .or.
     &        IAND(OPT_REFORMAT_TEXT,MASK_REFMT) > 0
      REFORMAT_PRIVATE = .NOT. LMASK

c check option to reformat spectra: note that for TEXT -> FITS,
c spectra may not appear in 1st text file, so user must explicitly
c request reformatting spectra. MASK=128 -> bit 7

      MASK_REFMT = MASK_REFMT_INCLUDE_SPECTRA
      LMASK = IAND(OPT_REFORMAT_FITS,MASK_REFMT) > 0 .or.
     &        IAND(OPT_REFORMAT_TEXT,MASK_REFMT) > 0
      REFORMAT_SPECTRA_INCLUDE = LMASK

c check option to exclude SIM truth; MASK += 256
      MASK_REFMT = MASK_REFMT_EXCLUDE_SIM
      LMASK = IAND(OPT_REFORMAT_FITS,MASK_REFMT) > 0 .or.
     &        IAND(OPT_REFORMAT_TEXT,MASK_REFMT) > 0
      REFORMAT_SIMTRUTH = .NOT. LMASK  

c - - - - - - - - - - - - - - - - - -
c check for reformat option using SNANA format

      REFORMAT_SNANA = (OPT_REFORMAT_FITS>0 .or. OPT_REFORMAT_TEXT>0)

      IF ( REFORMAT_SNANA ) THEN

         IF ( OPT_REFORMAT_FITS > 0 ) THEN
            REFORMAT_VERSION = VERSION_REFORMAT_FITS
         ELSE IF ( OPT_REFORMAT_TEXT > 0 ) THEN
            REFORMAT_VERSION = VERSION_REFORMAT_TEXT
         ENDIF

c check if reformat dir already exists
         LEN_VER = INDEX(REFORMAT_VERSION,' ')-1
         INQUIRE(FILE = REFORMAT_VERSION, EXIST = LEXIST)
         IF ( LEXIST ) THEN
            c1err = 'REFORMAT DIR already exists: ' 
     &           // REFORMAT_VERSION(1:LEN_VER)
            c2err = 'Remove it, or change name'
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         ENDIF

         ! create reformat directory
         CMD = 'mkdir ' // REFORMAT_VERSION(1:LEN_VER)
         CALL SYSTEM(CMD)

c open aux files and leave them open
         CALL OPEN_REFORMAT_FILE(LUNLIST2,   'LIST',   LIST_FILE)

         CALL OPEN_REFORMAT_FILE(LUNIGNORE2, 'IGNORE', IGNORE_FILE)
         write(LUNIGNORE2,420)     ! write header
 420     format(T10,'CID      MJD     FILTER')
         NEPOCH_IGNORE_WRFITS = 0
      ENDIF

      REFORMAT = OPT_REFORMAT_FITS>0 .or. OPT_REFORMAT_TEXT>0 
     &      .or. OPT_REFORMAT_SALT2>0

      REFORMAT_SPECTRA_ONLY = (OPT_REFORMAT_SPECTRA > 0 ) 

c - - - - -
c print info 
    
      IF ( REFORMAT ) THEN
         print*,' '
         print*,'   INIT_REFORMAT options: '
         print*,'     OPT_REFORMAT_[FITS,TEXT] = ',
     &              OPT_REFORMAT_FITS, OPT_REFORMAT_TEXT
         print*,'     REFORMAT_BADEPOCHS       = ', 
     &                 REFORMAT_SAVE_BADEPOCHS
         print*,'     REFORMAT_BAND_NAME       = ', 
     &                 REFORMAT_BAND_NAME
         print*,'     REFORMAT_SPECTRA_INCLUDE = ', 
     &                  REFORMAT_SPECTRA_INCLUDE
         print*,'     REFORMAT_PRIVATE         = ', 
     &                  REFORMAT_PRIVATE         
         print*,'     REFORMAT_SIMTRUTH        = ', 
     &                  REFORMAT_SIMTRUTH
      ENDIF

      IF ( REFORMAT_SPECTRA_ONLY ) THEN
         print*,' '
         print*,'   INIT_REFORMAT options: '
         print*,'     OPT_REFORMAT_SPECTRA  = ', OPT_REFORMAT_SPECTRA
      ENDIF

         call flush(6)

      RETURN
c - - - - - - - - - -

500   CONTINUE

      IF ( OPT_REFORMAT_FITS  >  0 ) THEN
         CALL INIT_REFORMAT_FITS()
      ENDIF

      IF ( OPT_REFORMAT_TEXT  > 0 ) THEN 
         CALL INIT_REFORMAT_TEXT()
      ENDIF        

      IF ( OPT_REFORMAT_SALT2 .EQ. 2 ) THEN
         CALL INIT_REFORMAT_SALT2()
      ENDIF

      IF ( OPT_REFORMAT_SPECTRA > 0 ) THEN
         CALL INIT_REFORMAT_SPECTRA_ONLY()
      ENDIF

      RETURN
      END     ! end INIT_REFORMAT

C ============================================
+DECK,INIT_REFORMAT_FITS.
      SUBROUTINE INIT_REFORMAT_FITS

c Prepare for translating text file format into FITS format.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      CHARACTER 
     &   cPATH*(MXCHAR_PATH)
     &  ,cVERSION*(MXCHAR_VERSION)
     &  ,cPREFIX*(MXCHAR_VERSION)
     &  ,cHEADFILE*(MXCHAR_FILENAME)
     &  ,LIST_FILE*(MXCHAR_FILENAME)
     &  ,IGNORE_FILE*(MXCHAR_FILENAME)

      INTEGER 
     &   WRITE_FLAG, LL, NMARK
     &  ,LEN_DIR
     &  ,LEN_SURVEY
     &  ,LEN_VERS
     &  ,LEN_HEAD
    
C ------------------ BEGIN ----------------

      LEN_SURVEY = INDEX(SURVEY_NAME,' ') - 1

      LEN_VERS = INDEX(VERSION_REFORMAT_FITS,' ') - 1
      cVERSION = VERSION_REFORMAT_FITS(1:LEN_VERS) // char(0)
      cPREFIX  = cVERSION

      LEN_DIR    = INDEX(REFORMAT_VERSION,' ') - 1 
      cPATH      = REFORMAT_VERSION(1:LEN_DIR) // char(0)

c to see flags in C code, "grep WRITE_MASK sndata.h"
      IF ( LSIM_MAGOBS ) THEN
         WRITE_FLAG = 8   ! Jan 23 2018
      ELSE IF ( LSIM_SNANA ) THEN 
         WRITE_FLAG = 4   ! Jan 23 2018
         if ( .NOT. REFORMAT_SIMTRUTH ) WRITE_FLAG = 2 ! Mar 2022
      ELSE
         WRITE_FLAG = 2
      ENDIF
      
      if ( REFORMAT_SPECTRA_INCLUDE ) WRITE_FLAG = WRITE_FLAG + 128
      if ( FOUND_ATMOS              ) WRITE_FLAG = WRITE_FLAG + 256

c -----------------------
      CALL WR_SNFITSIO_INIT(cPATH, cVERSION, cPREFIX, WRITE_FLAG
     &           , NMARK, cHEADFILE  ! output name
     &           , LEN_DIR, LEN_VERS, LEN_VERS, LEN_HEAD)     

c --- write name of HEAD file to already-opend LIST file 

      LL = INDEX(cHEADFILE, char(0) ) - 1
      WRITE(LUNLIST2,50) cHEADFILE(1:LL)
50    FORMAT(A)
      CLOSE(LUNLIST2)

      RETURN
      END  ! end  INIT_REFORMAT_FITS

C ===============================
+DECK,INIT_REFORMAT_TEXT.
      SUBROUTINE INIT_REFORMAT_TEXT()
      IMPLICIT NONE
cc      print*,'  INI_WRTEXT: placeholder -> do nothing ... yet'
      RETURN
      END

C ====================================
+DECK,INIT_REFORMAT_SALT2.
      SUBROUTINE INIT_REFORMAT_SALT2
c -----------------------------------------------
c Nov 2011 R.Kessler
c
c Initialization for translating SNANA formatted data
c into SALT2-formatted data. The input options are fed
c vis &SNLCINP namelist string  
c
c  &SNLCINP
c     ...
c   REFORMAT_KEYS = 
c   '@INSTRUMENT <instr> @MAGSYS <magsys> @PREFIX <prefix> @REPLACE <f1> <f2>
c     ...
c  &END 
c
c where @INSTRUMENT and @MAGSYS are required and the others are optional.
c Definition of above keys
c
c @INSTRUMENT = name of telescope or survey defined by SALT2
c @MAGSYS     = mag system defined by SALT2 (i.e, AB, VEGA ...)
c @PREFIX     = file-name prefix (default prefix is name of survey)
c @REPLACE    = replace filter list <f1> with <f2>. For example,
c               if f1 = UGRIZ and f2 = ugriz, then U -> u, G -> g,
c               etc in the output SALT2 files.
c
c
c ------------------------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,WRS2COM.

      INTEGER iwd, NWD, ifilt, NTMP, IFILT_OBS, IFILT_TMP(2) 
      INTEGER LL, LL0, LL1, LL2, MSKOPT
      character 
     &   cwd*(MXCHAR_FILEWORD-2)
     &  ,cwd1*(MXCHAR_FILEWORD-2)
     &  ,cwd2*(MXCHAR_FILEWORD-2)
     &  ,ctmp*(MXCHAR_FILEWORD-2)
     &  ,cfilt(2)*2, cfilt1*1
     &  ,cutvar_file*(MXCHAR_FILENAME)
     &  ,list_file*(MXCHAR_FILENAME)
     &  ,FNAM*30

c function
      INTEGER FILTINDX

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
C -------------------- BEGIN -------------------

      FNAM = 'INIT_REFORMAT_SALT2'
      CALL PRBANNER("INI_WRSALT2: Translate SNANA -> SALT2 format")

      LL = INDEX(REFORMAT_KEYS,' ') -1
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD = STORE_PARSE_WORDS(MSKOPT, REFORMAT_KEYS(1:LL)//char(0),
     &         FNAM//char(0), LL, 30)

      NAMEof_SURVEY        = 'NULL'      
      NAMEof_INSTRUMENT    = 'NULL'
      NAMEof_MAGSYS        = 'NULL'
      NAMEof_PREFIX        =  SURVEY_NAME
      NAMEof_REPLACE(1)    = 'NULL'
      NAMEof_REPLACE(2)    = 'NULL'

      NREPLACE = 0
      NEWKEY = 0

      DO ifilt = 1, MXFILT_ALL
           IMAP_REPLACE(IFILT) = -9
      ENDDO

      DO iwd = 1, NWD

        CALL get_PARSE_WORD_fortran(iwd+0, cwd,  LL0 )
        CALL get_PARSE_WORD_fortran(iwd+1, cwd1, LL1 )

        if ( cwd(1:LL0) .EQ. '@SURVEY' ) then
          NAMEof_SURVEY = cwd1

        else if ( cwd(1:LL0) .EQ. '@INSTRUMENT' ) then
          NAMEof_INSTRUMENT = cwd1

        else if ( cwd(1:LL0) .EQ. '@MAGSYS' ) then
          NAMEof_MAGSYS = cwd1

        else if ( cwd(1:LL0) .EQ. '@PREFIX' ) then
          NAMEof_PREFIX = cwd1

        else if ( cwd(1:LL0) .EQ. '@REPLACE' ) then
           CALL get_PARSE_WORD_fortran(iwd+2, cwd2, LL2 )
          NAMEof_REPLACE(1) = cwd1
          NAMEof_REPLACE(2) = cwd2
          NREPLACE    = INDEX(NAMEof_REPLACE(1), ' ' ) - 1
        else if ( cwd(1:1) .EQ. '@' ) then
          NEWKEY = NEWKEY + 1
          NEWKEY_NAME(NEWKEY)(1:LL0-1) = cwd(2:LL0)
          NEWKEY_ARG(NEWKEY)           = cwd1
        endif

      ENDDO

      LEN_SURVEY  = INDEX(NAMEof_SURVEY,    ' ' ) - 1
      LEN_INST    = INDEX(NAMEof_INSTRUMENT,' ' ) - 1
      LEN_MAGSYS  = INDEX(NAMEof_MAGSYS,    ' ' ) - 1
      LEN_PREFIX  = INDEX(NAMEof_PREFIX,    ' ' ) - 1

c make sure that required keys are specified.

      if ( NAMEof_INSTRUMENT .EQ. 'NULL' ) then
        c1err = 'MUST specify @INSTRUMENT <instrument> in '
        c2err = '&SNLCINP namelist string REFORMAT_KEYS'
        CALL  MADABORT("WRSALT2_2", C1ERR, C2ERR)
      endif
      if ( NAMEof_MAGSYS .EQ. 'NULL' ) then
        c1err = 'MUST specify @MAGSYS <magsys> in '
        c2err = '&SNLCINP namelist string REFORMAT_KEYS'
        CALL  MADABORT("WRSALT2_2", C1ERR, C2ERR)
      endif

c ----------
c Check for filter-name substitutions;
c i.e., UGRIZ -> ugriz for the SDSS
  
      IF ( NREPLACE .GT. 0  ) THEN

c abort if filter-strings have different length
        NTMP   = INDEX(NAMEof_REPLACE(2), ' ' ) - 1
        IF ( NREPLACE .NE. NTMP ) THEN
          c1err = 'Filter @REPALCE strings have different length'
          c2err = 'Cannot replace ' // 
     &              NAMEof_REPLACE(1)(1:NREPLACE) // ' with ' //
     &              NAMEof_REPLACE(2)(1:NTMP)
          CALL  MADABORT("WRSALT2_2", C1ERR, C2ERR)
        ENDIF

c create map between original filter and subst. filter

        DO 55 ifilt = 1, NREPLACE
           cfilt(1) = NAMEof_REPLACE(1)(ifilt:ifilt)
           cfilt(2) = NAMEof_REPLACE(2)(ifilt:ifilt)
           IFILT_TMP(1) = FILTINDX ( cfilt(1) )
           IFILT_TMP(2) = FILTINDX ( cfilt(2) )
           IMAP_REPLACE(IFILT_TMP(1)) = IFILT_TMP(2)
           
           write(6,56) cfilt, IFILT_TMP
56         format(t10,'Prepare @REPLACE map for ' , A2,' -> ', A2,
     &       '(', I2,' -> ', I2, ')' )

55      CONTINUE
      ENDIF

c ----------------------------
c  open list-file and leave it open.

      LIST_FILE = NAMEof_PREFIX(1:LEN_PREFIX) // '.LIST'
      print*,'   Open list-file: ', LIST_FILE(1:LEN_PREFIX+12)

      OPEN( UNIT   = LUNSALT2
     &    , FILE   = LIST_FILE
     &    , STATUS = 'UNKNOWN'
     &           )

c ----------------------------
c write cut-def file, then close it.

      CUTVAR_FILE = NAMEof_PREFIX(1:LEN_PREFIX) // '_CUTVAR.LOG'
      print*,'   Write cut-definitions to ' // 
     &    CUTVAR_FILE(1:LEN_PREFIX+12)

      OPEN( UNIT   = LUNTMP
     &    , FILE   = CUTVAR_FILE
     &    , STATUS = 'UNKNOWN'
     &           )

      write(LUNTMP,111) 'Z_HELIO   ', 
     &       'heliocentric redshift'
      write(LUNTMP,111) 'MWEBV     ', 
     &       'Galactic E(B-V)'
      write(LUNTMP,111) 'MWEBV_ERR     ', 
     &       'error on Galactic E(B-V)'

        write(ctmp,401) int(cutwin_trest(1)), int(cutwin_trest(2))
401     format(I3,'<Trest<' , I3,' days')
        write(LUNTMP,111) 'NOBS      ', 
     &       'Nobs total with any S/N and ' // ctmp(1:20)
        write(LUNTMP,111) 'TRESTMIN  ', 
     &       'min Trest(days) relative to peak (any S/N)' 
        write(LUNTMP,111) 'TRESTMAX  ', 
     &       'max Trest(days) relative to peak (any S/N)'

        write(LUNTMP,111) 'T0GAPMAX  ', 
     &       'max rest-frame gap (days) that overlaps peak epoch'

        write(LUNTMP,111) 'SNRMAX    ', 
     &       'max S/N among all observations'
        write(LUNTMP,111) 'SNRMAX2   ', 
     &       'max S/N excluding filter with SNRMAX'

        write(LUNTMP,111) 'SNRMAX3   ', 
     &       'max S/N excluding filters with SNRMAX & SNRMAX2'


        write(LUNTMP,600) ' '
        DO IFILT     = 1, NFILTDEF_SURVEY
           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
           cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
           ctmp      = 'SNRMAX_' // cfilt1
           LL        = INDEX(ctmp,' ') - 1
           write(LUNTMP,111) ctmp(1:10),
     &       'max S/N for indicated filter'
        ENDDO

      IF ( OPT_SETPKMJD > 0 ) THEN
        write(LUNTMP,600) ' '
        DO IFILT     = 1, NFILTDEF_SURVEY
           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
           cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
           ctmp      = 'ERRT0_' // cfilt1
           LL        = INDEX(ctmp,' ') - 1
           write(LUNTMP,111) ctmp(1:10),
     &       'fitted T0 error (days) for indicated filter'
        ENDDO

        write(LUNTMP,600) ' '
        DO IFILT     = 1, NFILTDEF_SURVEY
           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
           cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
           ctmp      = 'ERRF0_' // cfilt1
           LL        = INDEX(ctmp,' ') - 1
           write(LUNTMP,111) ctmp(1:10),
     &       'ERR(F0)/F0 for indicated filter'
        ENDDO

      ENDIF

111     format('@', A, ' : ', A)
600     format(A)
        CLOSE(UNIT=LUNTMP)

      print*,' -----------------------------------------------' 
      print*,' '
      RETURN
      END    ! end INIT_REFORMAT_SALT2

C ====================================
+DECK,INIT_REFORMAT_SPECTRA.
      SUBROUTINE INIT_REFORMAT_SPECTRA_ONLY()

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

C --------------- BEGIN ------------

c  For now do nothing (no new folder) and write spec files in cwd.
c  The idea is that organization of folders is done by code calling
c  snana.exe with OPT_REFORMAT_SPECTRA option.
c
c  file name = [version]_snid[snid]-mjd[mjd].spec

      RETURN
      END   ! end INIT_REFORMAT_SPECTRA_ONLY


C ================================================
+DECK,OPEN_REFORMAT_FILE.
      SUBROUTINE OPEN_REFORMAT_FILE(LUN, SUFFIX, REFORMAT_FILE)
c Open text file name REFORMAT_VERSION/REFORMAT_VERSION.SUFFIX
c use imput LUN 
      IMPLICIT NONE
      INTEGER   LUN          ! (I) open with this logical unit
      CHARACTER SUFFIX*(*)   ! (I) open with this suffix
      CHARACTER REFORMAT_FILE*(*)  ! (O) name of file opened

+CDE,SNDATCOM.
      INTEGER   LEN_VER

C ------------ BEGIN -----------
      LEN_VER = INDEX(REFORMAT_VERSION,' ') - 1
      REFORMAT_FILE = 
     &   REFORMAT_VERSION(1:LEN_VER) // '/' //
     &   REFORMAT_VERSION(1:LEN_VER) // '.' // SUFFIX

      OPEN (LUN, FILE = REFORMAT_FILE, status='UNKNOWN' )

      RETURN
      END      ! OPEN_REFORMAT_FILE

C =============================
+DECK,EXEC_REFORMAT.
      SUBROUTINE EXEC_REFORMAT()
c
c Create Feb 7 2021;
c Update reformat output:
c  + append FITS files for FITS output
c  + write new TEXT file for TEXT output
c
c Jan 20 2022: move copy_SNDATA_MISC() to work for either TEXT for FITS.
c Jul 18 2023: check OPT_REFORMAT_SPECTRA
c Apr 19 2025: check new option for BAND_NAME
c
c -------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER MXWR_TEXT
      PARAMETER (MXWR_TEXT = 400)

      LOGICAL    NOT_TOO_MANY
      CHARACTER  CCID*(MXCHAR_CCID), TEXTFILE*100, TEXTFILE_FULL*100
      INTEGER    LEN_VER, LEN_TXT, LEN_S
      EXTERNAL   WR_SNTEXTIO_DATAFILE
      
C ---------- BEGIN ----------

      if ( .NOT. ( REFORMAT .or. REFORMAT_SPECTRA_ONLY)  ) RETURN

      IF ( REFORMAT_SNANA ) THEN 
         CALL WRITE_REFORMAT_IGNORE()  ! update ignore file
      ENDIF

      CALL copy_SNDATA_MISC() ! update SNDATA structure 

      IF ( OPT_REFORMAT_FITS > 0 )  THEN
         CALL WR_SNFITSIO_UPDATE() 
      ENDIF

      NOT_TOO_MANY = (N_SNLC_CUTS .LE. MXWR_TEXT) 
      IF ( OPT_REFORMAT_TEXT > 0  .and. NOT_TOO_MANY ) THEN
c        prepare name of text file         
         CCID    = SNLC_CCID(1:ISNLC_LENCCID) 
         LEN_VER = INDEX(REFORMAT_VERSION,' ') - 1
         LEN_S   = INDEX(SURVEY_NAME,' ') - 1
         textFile = 
cc xxx     &       REFORMAT_VERSION(1:LEN_VER) // '_' //
     &       SURVEY_NAME(1:LEN_S) // '_' //
     &       SNLC_CCID(1:ISNLC_LENCCID) // '.DAT'
         LEN_TXT = INDEX(textfile,' ') - 1
         TEXTFILE_FULL = REFORMAT_VERSION(1:LEN_VER) // '/'  //
     &       textfile(1:len_txt) // char(0)

         CALL WR_SNTEXTIO_DATAFILE(TEXTFILE_FULL, 100)
         write(LUNLIST2, '(A)' ) TEXTFILE(1:len_txt)

         if ( N_SNLC_CUTS == MXWR_TEXT ) then
            print*,' '
            print*,'  WARNING: wrote max number of TEXT files: ', 
     &                N_SNLC_CUTS
            print*,' '
         endif
      ENDIF

c check Julien's original SALT2 format (not SNANA format)
      IF ( OPT_REFORMAT_SALT2 .EQ. 2 ) THEN
         CALL WRSALT2_2()
      ENDIF

      IF ( REFORMAT_SPECTRA_ONLY ) THEN
        CALL WR_SPECTRA()
      ENDIF

      RETURN
      END     ! end EXEC_REFORMAT

C =====================================
+DECK,copy_SNDATA_MISC.
      SUBROUTINE copy_SNDATA_MISC()

c Created Mar 14 2021
c Update the following SNDATA struct variables for FITS or TEXT format:
c
c   + PEAKMJD                ( if OPT_SETPKMJD > 0)
c   + MWEBV[_ERR]            ( if OPT_MWEBV    > 0)
c   + REDSHIFT_CMB[_ERR]
c   + REDSHIFT_HELIO[_ERR]
c   + VPEC[_ERR]
c   + NPRIVATE               set to 0 OPT_REFORMAT_PRIVATE=F (Jan 2022)
c   + HOSTGAL_LOGMASS[_ERR]  ??? TO DO (how to handle mutliple hosts?)
c   + HOSTGAL_sSFR[_ERR]     ??? TO DO (idem)
c 
c   + FLUXCAL      # if MAGCOR_INFILE is set  (Dec 2021)
c   + FLUXCALERR   # if FLUXMODELERR_FILE is set (Dec 2021)
c
c   + MJD_TRIGGER        # if PHOTFLAG_TRIGGER > 0
c   + MJD_DETECT_FIRST   # if PHOTFLAG_DETECT > 0
c   + MJD_DETECT_LAST    # idem
c   
c   + MWMAGCOR_[band]  # Nov 2023
c   + BAND name        # Apr 2025
c -------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.
+CDE,FILTCOM.
+CDE,FITSCOM.

      INTEGER COPYFLAG, NARG, NOBS, LEN_KEY, LEN_STR, o
      INTEGER IFILT, IFILT_OBS, LEN_SURVEY
      REAL*8 DVAL(MXEPOCH)
      CHARACTER cKEY*20, cSTRING*20, cfilt*2
      EXTERNAL COPY_SNDATA_HEAD

C -------------- BEGIN ----------

      NARG     =  1
      NOBS     =  ISNLC_NEWMJD_FOUND
      COPYFLAG = +1
      LEN_KEY  = 20
      LEN_STR  = 20
      cSTRING  = "DUMMY" // char(0)
      
      IF ( OPT_SETPKMJD > 0 ) THEN
        cKEY     = "PEAKMJD" // char(0)
        DVAL(1)     = DBLE(SNLC_SEARCH_PEAKMJD)
        CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)
      ENDIF

      IF ( OPT_MWEBV > 0 ) THEN
        cKEY     = "MWEBV" // char(0)
        DVAL(1)  = DBLE(SNLC_MWEBV)
        CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)

        cKEY     = "MWEBV_ERR" // char(0)
        DVAL(1)  = DBLE(SNLC_MWEBV_ERR)
        CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)

c write MWXT mag as diagnostic (not used)
        do ifilt     = 1, NFILTDEF_SURVEY
           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)        
           cfilt     = filtdef_string(ifilt_obs:ifilt_obs) 
           cKEY      = 'MWXT_MAG_' // cfilt(1:1) // char(0)
           DVAL(1)   = SNLC_MWXT_MAG(ifilt)
           CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &           cSTRING, DVAL, LEN_KEY, LEN_STR)
        end do

      ENDIF

c always update redshift and vpec info in case of header-override
c or other calculated update.

c zCMB
      cKEY     = "REDSHIFT_CMB" // char(0)
      DVAL(1)  = DBLE(SNLC_zCMB)
      CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)

      cKEY     = "REDSHIFT_CMB_ERR" // char(0)
      DVAL(1)  = DBLE(SNLC_zCMB_ERR)
      CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)

c zHELIO
      cKEY     = "REDSHIFT_HELIO" // char(0)
      DVAL(1)  = DBLE(SNLC_zHELIO)
      CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)

      cKEY     = "REDSHIFT_HELIO_ERR" // char(0)
      DVAL(1)  = DBLE(SNLC_zHELIO_ERR)
      CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)

c VPEC
      cKEY     = "VPEC" // char(0)
      DVAL(1)  = DBLE(SNLC_VPEC)
      CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)

      cKEY     = "VPEC_ERR" // char(0)
      DVAL(1)  = DBLE(SNLC_VPEC_ERR)
      CALL copy_SNDATA_HEAD(COPYFLAG, cKEY, NARG, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)

c check option to exclude PRIVATE variables from output.
c Do NOT modify NVAR_PRIVATE.
      IF ( .NOT. REFORMAT_PRIVATE .and. NVAR_PRIVATE > 0 ) then
        cKEY     = "NVAR_PRIVATE"  // char(0)        
        DVAL(1)  = -1.0   ! -1 means disable to avoid abort on NVAR change
        CALL copy_SNDATA_GLOBAL(COPYFLAG, cKEY, NARG, 
     &          cSTRING, DVAL, LEN_KEY, LEN_STR)
      ENDIF

c ----
c update flux[err] if modified
c ------
      IF ( DOFUDGE_FLUXERRMODEL .or. FUDGE_MAG_ERROR.NE.'') THEN 
         cKEY  = "FLUXCALERR" // char(0)
         DO o=1,NOBS; DVAL(o)=SNLC_FLUXCAL_ERRTOT(o) ; END DO
         CALL copy_SNDATA_OBS(copyFlag, cKEY, NOBS, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)
      ENDIF

      IF ( NSTORE_MAGCOR > 0 ) THEN
         cKEY  = "FLUXCAL" // char(0)
         DO o=1,NOBS; DVAL(o)=SNLC_FLUXCAL(o) ; END DO
         CALL copy_SNDATA_OBS(copyFlag, cKEY, NOBS, 
     &        cSTRING, DVAL, LEN_KEY, LEN_STR)
      ENDIF
 
c Apr 19 2025: check modifying band name
      IF ( REFORMAT_BAND_NAME ) THEN
         cKEY = "BAND" // char(0)
         LEN_SURVEY = INDEX(SURVEY_NAME,' ') - 1
         STRFITS = ''
         LEN_STR = 0
         DO o=1,NOBS
            IFILT_OBS  = ISNLC_IFILT_OBS(o)
            cfilt      = filtdef_string(ifilt_obs:ifilt_obs) 
            cSTRING    = SURVEY_NAME(1:LEN_SURVEY) // '-' // cfilt(1:1)
            STRFITS    = STRFITS(1:LEN_STR) // ' ' // cSTRING
            LEN_STR    = LEN_STR + LEN_SURVEY + 3
         ENDDO  

         CALL copy_SNDATA_OBS(copyFlag, cKEY, NOBS, 
     &        STRFITS(1:LEN_STR)//char(0), DVAL, LEN_KEY, LEN_STR)
         LEN_STR = 20
      ENDIF


c Sep 2023: update MJD_TRIGGER and MJD_DETECT_XYZ variables
c           if they have been computed from PHOTFLAG .

      if ( PHOTFLAG_TRIGGER > 0 ) then
         cKEY = "MJD_TRIGGER" // char(0)
         DVAL(1) = SNLC8_MJD_TRIGGER
         CALL copy_SNDATA_HEAD(copyFlag, cKEY, NARG,
     &         cSTRING, DVAL, LEN_KEY, LEN_STR)
      endif

      if ( PHOTFLAG_DETECT > 0 ) then
         cKEY = "MJD_DETECT_FIRST" // char(0)
         DVAL(1) = SNLC8_MJD_DETECT_FIRST
         CALL copy_SNDATA_HEAD(copyFlag, cKEY, NARG,
     &         cSTRING, DVAL, LEN_KEY, LEN_STR)

         cKEY = "MJD_DETECT_LAST" // char(0)
         DVAL(1) = SNLC8_MJD_DETECT_LAST
         CALL copy_SNDATA_HEAD(copyFlag, cKEY, NARG,
     &         cSTRING, DVAL, LEN_KEY, LEN_STR)
      endif

c - - - - - 
      
      RETURN 
      END  ! end copy_SNDATA_MISC

C =========================================
+DECK,WR_REFORMAT_IGNORE.
      SUBROUTINE WRITE_REFORMAT_IGNORE()

c Open and write IGNORE file

      IMPLICIT NONE
+CDE,SNDATCOM.
      INTEGER i, LEN1_CCID, LEN2_CCID
      CHARACTER CCID*(MXCHAR_CCID)
C ----------- BEGIN ----------

      LEN1_CCID = INDEX(SNLC_CCID,' ') - 1
      DO 400 i = 1, NEPOCH_IGNORE
         CCID = EPOCH_IGNORE_CCID(i)   
         LEN2_CCID = INDEX(CCID,' ') - 1
         IF( LEN1_CCID .NE. LEN2_CCID ) GOTO 400
         IF ( CCID(1:LEN1_CCID) .EQ. SNLC_CCID(1:LEN1_CCID) ) THEN
            write(LUNIGNORE2,410) 
     &      CCID(1:LEN1_CCID), EPOCH_IGNORE_MJD(i), EPOCH_IGNORE_FILT(i)
 410        format('IGNORE:  ', A, 3x, F9.3, 3x, A1)
            call flush(LUNIGNORE2)
            NEPOCH_IGNORE_WRFITS = NEPOCH_IGNORE_WRFITS + 1
         ENDIF
 400  CONTINUE

      RETURN
      END  ! end of WRITE_REFORMAT_IGNORE


C ===============================
+DECK,WR_SPECTRA.
      SUBROUTINE WR_SPECTRA()

c Created July 2023
c For each spectrum, re-write using format based on OPT_REFORMAT_SPECTRA.
c File name is
c   [version]-snid[snid]-mjd[mjd].spec
c
c Iniitial code writes only one format, but later this could be expanded
c to write different formats.
c
c Mar 20 2025: update output to include SIM_FLAM for all options
c              (instead of only KEY option)
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SPECCOM.
  
      INTEGER LENV, LENC, LENROW, ispec, NLAMBIN, ilam
      REAL*8  MJD, LAM, LAMBIN, F, FERR, FSIM, TOBS, z
      CHARACTER SPEC_FILE*(MXCHAR_FILENAME), MSG*80
      LOGICAL WR_FLAM, WR_FLUX, WR_KEY
C ------------- BEGIN -----------

      LENV = INDEX(VERSION_PHOTOMETRY(1),' ') - 1
      LENC = ISNLC_LENCCID

      WR_FLAM = BTEST(OPT_REFORMAT_SPECTRA,0)
      WR_FLUX = BTEST(OPT_REFORMAT_SPECTRA,1)
      WR_KEY  = BTEST(OPT_REFORMAT_SPECTRA,2)      

      z       = SNLC_REDSHIFT
      
      DO 400 ispec = 1, NSPECTRUM

         CALL RDSPEC_DRIVER(ispec)  ! load LAM and FLAM arrays

         MJD     = MJD_SPECTRUM(ispec)
	 TOBS    = TOBS_SPECTRUM(ispec)
         NLAMBIN = NLAMBIN_SPECTRUM(ispec)

         if ( MJD > 0.0 ) THEN
             WRITE(SPEC_FILE,40) 
     &       VERSION_PHOTOMETRY(1)(1:LENV), SNLC_CCID(1:LENC), MJD
40          format(A,'_',A,'_', F9.3, '.SPEC' )
         ELSE
             WRITE(SPEC_FILE,41) 
     &       VERSION_PHOTOMETRY(1)(1:LENV), SNLC_CCID(1:LENC), "HOST"
41          format(A,'_',A,'_', A, '.SPEC' )
         ENDIF

         OPEN(UNIT= LUNTMP, FILE=SPEC_FILE, STATUS='UNKNOWN' )

c write comments

         MSG = 'VERSION_PHOTOMETRY: ' // VERSION_PHOTOMETRY(1)(1:LENV)
	 write(LUNTMP,350) MSG

         write(MSG,301) 'MJD:      ', MJD
	 write(LUNTMP,350) MSG

         write(MSG,301) 'TOBS:     ', TOBS
	 write(LUNTMP,350) MSG

         write(MSG,301) 'REDSHIFT: ', z
	 write(LUNTMP,350) MSG
	 
301      format(A, 3x, F9.3)

         write(MSG,302) 'NLAMBIN:  ', NLAMBIN
302      format(A, 3x, I5)
	 write(LUNTMP,350) MSG

         write(LUNTMP,350) ' ' 

         if ( WR_FLAM ) then
     	      write(MSG,360) 'WAVE FLAM FLAMERR'
         else if ( WR_FLUX ) then
              write(MSG,360)	'WAVE FLUX FLUXERR'
	 else if ( WR_KEY ) then
              write(MSG,351)	'ROW WAVE FLAM FLAMERR' 
c xxx mark Mar 21 2025	if ( LSIM_SNANA ) MSG = MSG(1:35) // '  SIM_FLAM  '
         endif

         if ( LSIM_SNANA ) MSG = MSG(1:35) // '  SIM_FLAM  '
         write(LUNTMP,360) MSG(1:50)

350      format('# ', A)
351      format('VARNAMES: ', A)
360      format(A)

c write spectrum
         DO 401 ilam = 1, NLAMBIN
           LAM = 0.5* ( LAMMIN_SPECTRUM(ilam) + LAMMAX_SPECTRUM(ilam) )
           LAMBIN = LAMMAX_SPECTRUM(ilam) - LAMMIN_SPECTRUM(ilam)
           F      = FLAM_SPECTRUM(ilam)
           FERR   = FLAMERR_SPECTRUM(ilam)
           if ( WR_FLUX ) then
              F    = F * LAMBIN
              FERR = FERR * LAMBIN
           endif

           if ( WR_FLAM .or. WR_FLUX ) THEN
              WRITE(MSG,440) '', LAM, F, FERR
440           format(A, F8.2, 3x, 2E14.5 )  
              LENROW = 42
           else if ( WR_KEY ) THEN
              WRITE(MSG,442) 'ROW: ', ilam, LAM, F, FERR
442           format(A, I5, 2x, F8.2, 3x, 2E14.5 )
              LENROW = 60
           endif
	
	   if ( LSIM_SNANA) then
	      FSIM = SIM_FLAM_SPECTRUM(ilam)
	      write(MSG,446) MSG(1:LENROW), FSIM
446           format(A,E14.5)
           endif
   
	   write(LUNTMP,360) MSG

401      CONTINUE         
         
         CLOSE(LUNTMP)  ! close spec file
400   CONTINUE

      RETURN
      END   ! end WR_SPECTRA

C ===============================
+DECK,END_REFORMAT.
      SUBROUTINE END_REFORMAT

c
c Close FITS files and create README file.
c
c Jul 6 2021: don't write anything else to README so that 
c             original DOCUMENTATION block appears at the top.
c             (maybe later, call function to append yaml format)
c
c Mar 7 2022: do explicit gzip 
c
c -------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER LEN_VERS, iver, OPTMASK
      CHARACTER 
     &   README_FILE*(MXCHAR_FILENAME)
     &  ,CMD*(2*MXCHAR_FILENAME)

C ----------------- BEGIN ----------------

c call C function to close out the FITS files.
      IF ( OPT_REFORMAT_FITS > 0 ) THEN
         OPTMASK = 0  ! don't gzip because gzip logic doesn't work
         CALL wr_snfitsio_end(OPTMASK)

         LEN_VERS  = INDEX(VERSION_REFORMAT_FITS,' ' ) - 1
         CMD = 'cd ' // VERSION_REFORMAT_FITS(1:LEN_VERS) // 
     &        ' ; gzip *.FITS'
         print*,'   gzip output FITS files in ', 
     &        VERSION_REFORMAT_FITS(1:LEN_VERS)
         call flush(6)
         CALL SYSTEM(CMD)
      ENDIF  


c create README blank readme file
      CALL OPEN_REFORMAT_FILE(LUNTMP, 'README', README_FILE)
      CLOSE(LUNTMP)  ! close README file

c --- catenate original README contents for each version --------

      DO iver = 1, N_VERSION

c now just catenate the final readme with the original readme file.

         LEN_VERS  = INDEX(SNREADME_FILE(iver),' ' ) - 1
         CMD = 'cat ' // SNREADME_FILE(iver)(1:LEN_VERS) 
     &         // ' >> ' // README_FILE
         
         CALL SYSTEM(CMD)

      ENDDO

c ---- update IGNORE file with comment on total number of IGNORE epochs
      write(LUNIGNORE2,430) NEPOCH_IGNORE_WRFITS
 430  format(/,'Total number of IGNORE epochs: ', I5)
      close(LUNIGNORE2)

      IF ( OPT_REFORMAT_FITS > 0 ) then
         print*,' Done writing reformatted FITS version: ', 
     &        VERSION_REFORMAT_FITS
      ELSE
         print*,' Done writing reformatted TEXT version: ', 
     &        VERSION_REFORMAT_TEXT
      ENDIF

      RETURN
      END    ! END_REFORMAT


C =========================================
+DECK,WRS2_2.
      SUBROUTINE WRSALT2_2()
c
c Created July 30, 2010 by R.Kessler
c Re-write SN data files into new SALT2 format with
c one file per SN.
c Output used by J. Guy's SALT2 'snfit' and 'pcafit' programs,
c version 2.3.0 and higher.
c Mainly used for SDSS data, and for simulations.
c
c
c See &SNLCINP namelist variables
c  OPT_REFORMAT_SALT2 = 2
c
c so that arbitray keys can be specified.
c
c
c Jan 25, 2013: use REAL*8 MJD8 instead of REAL*4 MJD to avoid
c               round-off error.
c
c May 20 2013: include RA and DEC in SALT2 files.
c
c Jul 8 2013: write name of ascii SNDATA file ONLY for FORMAT_TEXT=T
c
c Jul 17, 2013: write @FIELD  <list of fields>
c
c Feb 25, 2014: remove logic with ITERSE_FLUXZPT
c -----------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,WRS2COM.
+CDE,PKMJDCOM.

      INTEGER 
     &   EPMIN, EPMAX, EP, NEWMJD
     &  ,IFILT, IFILT_OBS, IFILT_REPLACE
     &  ,LENCID, LS, IERR, CID, ikey, L1, L2, LL, i
    
      REAL 
     &   PEAKMJD, FLUX, FLUXERR
     &  ,ZP, ZPOFF, arg, Fscale, TMP, ERR

  
      REAL*8  MJD8

      LOGICAL LWR_FILT(MXFILT_OBS)

      CHARACTER 
     &   cfilt1*1,  ccid*(MXCHAR_CCID)
     &  ,salt2_file*(MXCHAR_FILENAME)
     &  ,SURVEY_NAME_LOCAL*(MXCHAR_FILEWORD)
     &  ,SIMFILE*(MXCHAR_FILENAME)
     &  ,ctmp*60

C ------------ BEGIN -------------

      CCID   = SNLC_CCID

c if CCID is an integer, write in I6.6 (or I8.8) format
      read( ccid, 25 , iostat = IERR ) CID
25    format(I9)
      
      IF ( IERR .EQ. 0  ) THEN
         CALL CIDSTRING(CID,CCID,LENCID)
      ENDIF

c  ----------------------

      LS  = INDEX(SURVEY_NAME,' ' ) - 1
      LENCID = INDEX(CCID,' ' ) - 1

      SALT2_FILE = NAMEof_PREFIX(1:LEN_PREFIX) // '_' // 
     &             CCID(1:LENCID) // '.DAT'

       LL = INDEX(SALT2_FILE,' ') - 1
       WRITE(LUNSALT2,700) SALT2_FILE(1:LL)
700    FORMAT(A)

      IF ( LSIM_SNANA ) THEN
          PEAKMJD = SIM_PEAKMJD
      ELSE
          PEAKMJD = SNLC_SEARCH_PEAKMJD
      ENDIF

      OPEN(   UNIT   = LUNDAT 
     &      , FILE   = SALT2_FILE
     &      , STATUS = 'UNKNOWN'
     &           )

      IF ( NAMEof_SURVEY(1:4) .EQ.  'NULL' ) then
        SURVEY_NAME_LOCAL = SURVEY_NAME  ! SNANA survey name
      ELSE
        SURVEY_NAME_LOCAL = NAMEof_SURVEY ! user-specified survey name
      ENDIF


      ctmp = 'Translated into SALT2 format by SNANA ' // SNANA_VERSION
      write(LUNDAT,120) ctmp
      write(LUNDAT,120) ' '

      write(LUNDAT,120) 'Required variables'
      write(LUNDAT,11) 'SURVEY',   SURVEY_NAME_LOCAL
      write(LUNDAT,11) 'SN',       CCID(1:LENCID)

      write(LUNDAT,126) 'RA',    SNLC8_RA
      write(LUNDAT,126) 'DEC',   SNLC8_DEC

c ---- write field(s) - include all overlapping fields for this SN -----
      write(LUNDAT,1220) 
      DO  i = 1, ISNLC_NFIELD_OVP
         LL = INDEX( SNLC_FIELD_OVPLIST(i), ' ') - 1
         write(LUNDAT,1230) SNLC_FIELD_OVPLIST(i)(1:LL)
      ENDDO
      write(LUNDAT,1240)

 1220 FORMAT('@FIELD  ', $)
 1230 FORMAT(A, '  ', $)
 1240 FORMAT(' ')

c ------------------------------------

      write(LUNDAT,12) 'Z_HELIO',  SNLC_ZHELIO
      write(LUNDAT,12) 'Z_CMB  ',  SNLC_ZCMB

      write(LUNDAT,12) 'MWEBV  ',  SNLC_MWEBV
      write(LUNDAT,12) 'MWEBV_ERR ',SNLC_MWEBV_ERR
      write(LUNDAT,13) 'DayMax  ', PEAKMJD

c --------------------------------------
c add new keys, if any are given (Dec 2010)

      DO 22 ikey = 1, NEWKEY
         L1 = INDEX(NEWKEY_NAME(ikey),' ') - 1
         L2 = INDEX(NEWKEY_ARG(ikey),' ') - 1
         write(LUNDAT,11) 
     &      NEWKEY_NAME(ikey)(1:L1), NEWKEY_ARG(ikey)(1:L2)
22    CONTINUE


c Set LWR_FILT logical array for filters to write out.
c Use SNRMAX_FILT to determine if a filter is used.

      DO IFILT     = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)        
         TMP       = SNLC_SNRMAX_FILT(ifilt) 
         if ( TMP .NE. -9.0 ) then          
            LWR_FILT(IFILT_OBS) = .TRUE.
         else
            LWR_FILT(IFILT_OBS) = .FALSE.
         endif
      ENDDO
      
c --------------------------------------
c add extra cut variables (Sep 29 2010)

      write(LUNDAT,120) ' '
      write(LUNDAT,120) 'Analysis variables'
      write(LUNDAT,30) 'SNTYPE   ',  ISNLC_TYPE
      write(LUNDAT,30) 'NOBS     ',  ISNLC_NEPOCH_USE
      write(LUNDAT,14) 'TRESTMIN ',  SNLC_TRESTMIN
      write(LUNDAT,14) 'TRESTMAX ',  SNLC_TRESTMAX
      write(LUNDAT,14) 'T0GAPMAX ',  SNLC_T0GAPMAX
      write(LUNDAT,14) 'SNRMAX   ',  SNLC_SNRMAX_SORT(1)
      write(LUNDAT,14) 'SNRMAX2  ',  SNLC_SNRMAX_SORT(2)
      write(LUNDAT,14) 'SNRMAX3  ',  SNLC_SNRMAX_SORT(3)

c write SNRMAX for each filter.
      DO IFILT     = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)        
         cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)         
         TMP       = SNLC_SNRMAX_FILT(ifilt) 
         if ( LWR_FILT(ifilt_obs) ) then          
            write(LUNDAT,114) 'SNRMAX_', cfilt1, TMP
         endif

      ENDDO

114   format('@', A, A, 2x, F8.3)

c to quanititative FoM, write error on flux and T0 for each band 
      IF ( OPT_SETPKMJD > 0 ) THEN

        write(LUNDAT,120) ' '
        write(LUNDAT,120) 'Fitted errors => exp(dT/T1)/[1+exp(dT/T2)]'
        write(LUNDAT,120) 'ERRT0 => error on peak MJD'
        write(LUNDAT,120) 'ERRF0 => ERROR(F0)/F0 where F0 = peak flux'


        DO IFILT    = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
          if ( LWR_FILT(ifilt_obs) ) then
            ERR       = PKMJD_ERR(ifilt_obs) 
            write(LUNDAT,114) 'ERRT0_', cfilt1, ERR
          endif
        ENDDO         
          write(LUNDAT,12) 'ERRT0_MIN', PKMJD_ERRMIN
          write(LUNDAT,12) 'ERRT0_WGT', PKMJD_ERRWGT

        DO IFILT    = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)          
          cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
          if ( LWR_FILT(ifilt_obs) ) then
            ERR       = PKFLUX_ERR(ifilt_obs)/PKFLUX_FIT(ifilt_obs)
            write(LUNDAT,114) 'ERRF0_', cfilt1, ERR
          endif
        ENDDO 
          write(LUNDAT,12) 'ERRF0_MIN', PKFLUX_ERRMIN
          write(LUNDAT,12) 'ERRF0_WGT', PKFLUX_ERRWGT

      ENDIF  ! end of OPT_SETPKMJD


      IF ( LSIM_SNANA ) THEN
        write(LUNDAT,120) ' '
        write(LUNDAT,120) 'SIMULATION Parameters'

c start with the exact name of the SNANA file that was translated
        IF ( FORMAT_TEXT ) THEN
          L1 = INDEX(VERSION_PHOTOMETRY(1),' ' ) - 1
          L2 = INDEX(SNDATA_FILE_CURRENT,' ' ) - 1
          SIMFILE = '$SNDATA_ROOT/SIM/' // 
     &        VERSION_PHOTOMETRY(1)(1:L1) // '/' //
     &        SNDATA_FILE_CURRENT(1:L2)
          LL = INDEX(SIMFILE,' ') - 1
          WRITE(LUNDAT,11) 'SIM_SNANAFILE' , SIMFILE(1:LL)
        ENDIF

        write(LUNDAT,30)  'SIM_SNTYPE   ', SIM_GENTYPE
        write(LUNDAT,30)  'SIM_TEMPLATE_INDEX  ', SIM_TEMPLATE_INDEX
        write(LUNDAT,93)  'SIM_PEAKMJD  ', SIM_PEAKMJD
        write(LUNDAT,12)  'SIM_MWEBV    ', SIM_MWEBV
        write(LUNDAT,12)  'SIM_REDSHIFT ', SIM_REDSHIFT_CMB
        write(LUNDAT,12)  'SIM_MU       ', SIM_DLMAG

        IF ( SIM_TEMPLATE_INDEX .EQ. 0 ) THEN
          write(LUNDAT,12)  'SIM_x0 ',    SIM_SALT2x0
          write(LUNDAT,12)  'SIM_mb ',    SIM_SALT2mb
          write(LUNDAT,12)  'SIM_x1 ',    SIM_SHAPEPAR
          write(LUNDAT,12)  'SIM_c  ',    SIM_COLORPAR
          write(LUNDAT,12)  'SIM_alpha ', SIM_SHAPELAW
          write(LUNDAT,12)  'SIM_beta  ', SIM_COLORLAW
        ENDIF

        DO IFILT    = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
          TMP       = SIM_PEAKMAG(ifilt) 
          write(LUNDAT,114) 'SIM_PEAKMAG_', cfilt1, TMP
        ENDDO

      ENDIF  ! end of LSIM_SNANA 

      write(LUNDAT,120) ' '
      write(LUNDAT,120) '--------------------------------------'
      write(LUNDAT,120) ' '

c ---------------------------------------
c define data columns
      write(LUNDAT,20) 'Date'
      write(LUNDAT,20) 'Flux'
      write(LUNDAT,20) 'Fluxerr'
      write(LUNDAT,20) 'ZP'
      write(LUNDAT,20) 'Filter'
      write(LUNDAT,20) 'MagSys'
      write(LUNDAT,20) 'end'

11    format('@', A, 2x, A)
12    format('@', A, 2x, F8.5)
13    format('@', A, 2x, F9.3, 2x, '1')
14    format('@', A, 2x, F7.2)
20    format('#', A, ' : ' )
30    format('@', A, 2x, I5)
93    format('@', A, 2x, F9.3)
126   format('@', A, 2x, F12.6)

120   format('# ! ', A )

c write observations.

      DO 301 NEWMJD = 1, ISNLC_NEWMJD_STORE
          EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
          EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

          DO 302 EP = EPMIN, EPMAX

            IFILT_OBS     = ISNLC_IFILT_OBS(ep)
            IFILT_REPLACE = IMAP_REPLACE(IFILT_OBS)

c  skip obs that are cut in SNRECON (Jan 2, 2012)
            if ( .not. LWR_FILT(ifilt_obs) ) GOTO 302


            IF ( IFILT_REPLACE .GT. 0 ) THEN
               cfilt1 = filtdef_string(ifilt_replace:ifilt_replace)
            ELSE
               cfilt1 = filtdef_string(ifilt_obs:ifilt_obs)
            ENDIF

            ZPOFF   = MAGOBS_SHIFT_ZP_FILT(ifilt_obs)
            MJD8    = SNLC8_MJD(EP)

            ZP  = SNGL(ZEROPOINT_FLUXCAL_DEFAULT) + ZPOFF
            arg = 0.4*ZPOFF

            Fscale  = 10.0**ARG

c get fluxes in native system (i.e., undo AB offsets)
            Flux    = Fscale * SNLC_FLUXCAL(EP)
            Fluxerr = Fscale * SNLC_FLUXCAL_ERRTOT(EP)
            WRITE(LUNDAT,330) MJD8, FLUX, FLUXERR, ZP
     &          , NAMEof_INSTRUMENT(1:LEN_INST)
     &          , cfilt1
     &          , NAMEof_MAGSYS(1:LEN_MAGSYS)

302      CONTINUE  ! EP
301   CONTINUE  ! NEWMJD

330   FORMAT(F9.3, 2x, 2G14.6, 1x, F7.3, 3x,A,'::',A,1x,A )

      CLOSE ( LUNDAT )

      RETURN
      END  ! end of WRSALT2_2


C ============================
+DECK,MADABORT.
      SUBROUTINE MADABORT(funname,c1err,c2err)
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
      character funname*(*)  ! name of function calling MADABORT
      character c1err*(*), c2err*(*) ! two error messages
      INTEGER ISEV_FATAL, IPROMPT, LENF, LEN1, LEN2
      PARAMETER ( ISEV_FATAL = 4, IPROMPT=0 )

      EXTERNAL ERRMSG
      INTEGER  LENSTR
c ----------------- BEGIN --------------
      LENF = LENSTR(funname//' ')
      LEN1 = LENSTR(c1err)
      LEN2 = LENSTR(c2err)
      call errmsg(ISEV_FATAL, IPROMPT, 
     &     funname(1:LENF)//char(0), 
     &     c1err(1:LEN1)//char(0),
     &     c2err(1:LEN2)//char(0),
     &     LENF, LEN1, LEN2 )

      RETURN
      END

C =============================
+DECK,LENSTR.
      INTEGER FUNCTION LENSTR(string)
c Created Dec 17 2019
c STRING = 'Hi, what is this.' --> LENSTR = 17
c 
      IMPLICIT NONE
      CHARACTER STRING*(*)
      INTEGER LENTOT, LEN, i
C ---------- BEGIN -------------
      LENTOT = index(string,' ', back = .TRUE. ) - 1
      DO i = 1, LENTOT
        IF ( STRING(i:i) .NE. ' ' ) LEN=i
      ENDDO
      LENSTR = LEN
      RETURN
      END


C ======================================
+DECK,CHCKLINE_ARGS.
      SUBROUTINE CHECK_LINE_ARGS()
c
c Feb 7, 2007
c Check that all NLINE_ARG command-line args
c were used. If any were not used, then give
c error message and abort.
c 
c Aug 2020: use MADABORT for consistent error messaging
c

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i, LL, NBAD
      CHARACTER FNAM*16, ARG*(MXCHAR_ARG)
C ------------------ BEGIN --------------

      NBAD = 0
      FNAM = 'CHECK_LINE_ARGS'

      DO i = 2, NLINE_ARGS
         
         if ( .NOT. USE_LINE_ARGS(i) ) then
            NBAD = NBAD + 1

            if ( NBAD .EQ. 1 ) then
              CALL PRINT_PREABORT_BANNER(FNAM//char(0),20)
            endif
            CALL GETARG(i,ARG)
            LL = INDEX(ARG, ' ' ) - 1         
            print*,' ERROR: Detected un-used command-line argument: ',
     &                 '"' , ARG(1:LL), '"'
         endif
      ENDDO

      IF ( NBAD .GT. 0 ) THEN
         write(C1ERR,61) NBAD
61       format('Detected ', I3,' unknown command line arguments')
         C2ERR = 'Check args ERROR messages above'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

      RETURN
      END


C ================================================
+DECK,INIT_SNVAR.
      SUBROUTINE INIT_SNVAR()
c
c Init some SN variables.
c Called once at beginning of program.
c See INIT_SNLC to initilaize each SN.
c
c Feb 19 2014: abort if SNDATA_ROOT is not defined.
c Jan 16 2019: init EXIT_ERRCODE
c ---------------------------------------------------
 
      IMPLICIT NONE

c include everything except the memory hogging SNLCCOM

+CDE,SNPAR.
+CDE,SNFILECOM.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,SNHOSTCOM.
c +CDE,PARSECOM.
+CDE,SNSIMCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.
+CDE,PKMJDCOM.
+CDE,PRIVCOM.
+CDE,EARLYCOM.
+CDE,SPECCOM.

      INTEGER icut, i, ibit, itype, ipar, ifilt, LM,istat
      INTEGER LL, LL_SNANA, NWD, LL_HOST
      CHARACTER ENVtemp*400, MACH*40, FNAM*12

c function
      INTEGER FILTINDX, EXEC_CIDMASK, STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS, SET_EXIT_ERRCODE

C ---------------- BEGIN ------------

      FNAM = 'INIT_SNVAR'

+SELF,IF=SNANA.
      EXIT_ERRCODE = EXIT_ERRCODE_SNANA
+SELF,IF=SNFIT.
      EXIT_ERRCODE = EXIT_ERRCODE_SNFIT
+SELF,IF=PSNID.
      EXIT_ERRCODE = EXIT_ERRCODE_PSNID
+SELF.
      CALL SET_EXIT_ERRCODE(EXIT_ERRCODE) ! for C function aborts

      IDSURVEY = -9 ;  IDSUBSURVEY=-9
      NCALL_SNANA_DRIVER  = 0 
 
      CALL PRBANNER ( " INIT_SNVAR: Init variables." )

      FORMAT_TEXT    = .FALSE.
      FORMAT_FITS    = .FALSE.

      ISJOB_SNANA = .FALSE.
      ISJOB_SNFIT = .FALSE.
      ISJOB_PSNID = .FALSE.
      ISJOB_BATCH = .FALSE.

      NEPOCH_TOT = 0
      NEPOCH_USE = 0
      NEPOCH_CUT = 0
      NEPOCH_BADPHOT     = 0
      NEPOCH_BADPHOT_SUM = 0

      INTERP_OPT  = INTERP_LINEAR  ! used by simulation

c define filter indices for Legacy filters
      IFILT_SDSS_u = FILTINDX("u ")
      IFILT_SDSS_g = FILTINDX("g ")
      IFILT_SDSS_r = FILTINDX("r ")
      IFILT_SDSS_i = FILTINDX("i ")
      IFILT_SDSS_z = FILTINDX("z ")
      IFILT_BESS_U = FILTINDX("U ")
      IFILT_BESS_B = FILTINDX("B ")
      IFILT_BESS_V = FILTINDX("V ")
      IFILT_BESS_R = FILTINDX("R ")
      IFILT_BESS_I = FILTINDX("I ")
      IFILT_BESS_BX = FILTINDX("X ")
      IFILT_Y = FILTINDX("Y ")
      IFILT_J = FILTINDX("J ")
      IFILT_H = FILTINDX("H ")
      IFILT_K = FILTINDX("K ")

      SURVEY_NAME    = ''
      SUBSURVEY_NAME = ''
      SUBSURVEY_NAME_LIST=''

      SURVEY_FILTERS = ''
      FREEZE_SURVEY_FILTERS = .FALSE.
      EXIST_BXFILT_OBS      = .FALSE.
      EXIST_BXFILT_REST     = .FALSE.

      NFILTDEF_SURVEY = 0
      NFILTDEF_READ   = 0
      NFILTDEF_REST   = 0
      
      NFILTDEF_IGNORE_REST = 0

      DO ifilt = 1, MXFILT_OBS
          IFILTDEF_MAP_SURVEY(ifilt) = -9
          IFILTDEF_MAP_REST(ifilt)   = -9
          IFILTDEF_IGNORE_REST(ifilt) = -9
      ENDDO

      DO ifilt = 1, MXFILT_ALL

          IFILTDEF_INVMAP_SURVEY(ifilt)  = -9
          IFILTDEF_INVMAP_REST(ifilt)    = -9

          MAGOBS_SHIFT_PRIMARY_FILT(ifilt)  = 0.0
          MAGOBS_SHIFT_ZP_FILT(ifilt)       = 0.0
          MAGOBS_SHIFT_ZP_USER(ifilt)       = 0.0
          MAGREST_SHIFT_PRIMARY_FILT(ifilt) = 0.0
          MAGREST_SHIFT_ZP_FILT(ifilt)      = 0.0
          MAGREST_SHIFT_ZP_USER(ifilt)      = 0.0
          FILTOBS_ZPOFF_SNPHOT(ifilt)       = 0.0

          FILTOBS_TRANSMAX(ifilt)         =  0.0
          FILTOBS_LAMAVG(ifilt)           = -9.0
          FILTOBS_LAMRMS(ifilt)           = -9.0
          FILTOBS_LAMRANGE(1,ifilt)       = -9.0
          FILTOBS_LAMRANGE(2,ifilt)       = -9.0
c xxx mark           FILTOBS_LAMSHIFT(ifilt)         =  0.0
          NLAMBIN_FILTOBS(ifilt)          =  0

          FILTREST_TRANSMAX(ifilt)         =  0.0
          FILTREST_LAMAVG(ifilt)           = -9.0
          NLAMBIN_FILTREST(ifilt)          =  0
          FILTREST_LAMRANGE(1,ifilt)       = -9.0
          FILTREST_LAMRANGE(2,ifilt)       = -9.0

          FILTOBS_NAME(ifilt)       = ''
          SURVEY_FILT_NAME(ifilt)   = 'NONE'
          LFILTDEF_OBS(ifilt)       = .FALSE.
          LFILTDEF_REST(ifilt)      = .FALSE.
          LFILTDEF_NONSURVEY(ifilt) = .FALSE.
          LFILTDEF_SNRMAX(ifilt)    = .TRUE.  ! use all filters by default

          FUDGE_FLUXCAL_ERROR_FILT(ifilt)   =  0.0 
          FUDGE_FLUXCAL_ERRPIX_FILT(ifilt)  =  0.0 
          FUDGE_FLUXCAL_OFFSET_FILT(ifilt)  =  0.0 
          FUDGE_FLUXERR_SCALE_FILT(ifilt)   =  1.0 ! Feb 2020
          FUDGE_MAG_ERROR_FILT(ifilt)       =  0.0 
          FUDGE_MAG_COVERR_FILT(ifilt)      =  0.0
          SIM_FUDGE_MAG_ERROR_FILT(ifilt)   =  0.0

      END DO

c extract SNDATA_ROOT and SNANA_DIR  env variables
      
      CALL GETENV ( 'HOST',     ENVtemp )
      LL = INDEX ( ENVtemp , ' ' ) - 1
      HOST_MACHINE = ENVtemp(1:LL)

      CALL GETENV ( 'MACHTYPE', ENVtemp )     
      LM = INDEX ( ENVtemp , ' ' ) - 1
      MACH = ENVtemp(1:LM)

      print*,'  HOST MACHINE = ', HOST_MACHINE(1:LL), 
     &      '   (',MACH(1:LM),')'

      CALL GETENV ( 'SNDATA_ROOT', ENVtemp )
      LL = INDEX ( ENVtemp , ' ' ) - 1

      IF ( LL > MXCHAR_PATH ) then
         write(C1ERR,61) 'SNDATA_ROOT', LL
         write(C2ERR,62) MXCHAR_PATH
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF
61       FORMAT('LEN($', A, ') = ',I3,' is too long')
62       format('MXCHAR_PATH = ', I3)
      if ( LL .EQ. 0 ) then
         C1ERR = 'SNDATA_ROOT is not defined.'
         C2ERR = 'Check your snana setup.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      SNDATA_ROOT = ENVtemp(1:LL)
      print*,'  SNDATA_ROOT = ', SNDATA_ROOT(1:LL)

c - - - - - 
      CALL GETENV ( 'SNANA_DIR', ENVtemp )
      LL = INDEX ( ENVtemp , ' ' ) - 1
      IF ( LL > MXCHAR_PATH ) then
         write(C1ERR,61) 'SNANA_DIR', LL
         write(C2ERR,62) MXCHAR_PATH
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

      SNANA_DIR = ENVtemp(1:LL)
      print*,'  SNANA_DIR = ', SNANA_DIR(1:LL)


      N_SNFILE      = 0
      N_SNFILE_LAST = 0

      N_SNLC_PROC     = 0
      N_SNLC_CUTS     = 0
      N_SNLC_SPEC     = 0
      N_SNLC_FIT      = 0
      N_SNLC_FITCUTS  = 0
      N_SNLC_COVFIX   = 0
      N_SNLC_PLOT     = 0
      N_SNHOST_ZSPEC  = 0  
      N_SNHOST_ZPHOT  = 0
      N_DUPLICATE_CID = 0
      N_DUPLICATE_MJD = 0
      NSTORE_DUPLICATE_MJD = 0

      do i = 0, MXMASK_zSOURCE
        N_MASK_zSOURCE_LC_CUTS(i)    = 0
        N_MASK_zSOURCE_LCFIT_CUTS(i) = 0	
      enddo
      
      ABSO_OFFSET = 0
      ABSO_INDEX  = 0

      DO itype = -1, MXTYPE
        NPASSCUT_FIT(itype) = 0
      DO ibit  = 1, NCUTBIT_SNLC+1
        NPASSCUT_INCREMENT(itype,ibit) = 0
      ENDDO
      ENDDO

      LSIM_SNANA   = .FALSE.  ! snana sim  
      LSIM_MAGOBS  = .FALSE.  
      ISJOB_SIM    = .FALSE.

      NACCEPT_Z    = 0
      NACCEPT_ZERR = 0
      NACCEPT_CID  = 0
      NACCEPT_TYPE = 0
      DO icut = 1, NCUTBIT
        NACCEPT_CUT(icut) = 0
      ENDDO

c init HIDKCOR array to 0

      ISTAT = EXEC_CIDMASK(0,MXCID_CHECK)  ! init CID bit-mask

      DO IPAR = 1, MXFITPAR
         ERRMAX_BAD(ipar) = 1.0E-4  ! err < ERRMAX_BAD is labelled bad
      ENDDO

      SIMNAME_MODEL        = 'SIMNULL0'
      SIMNAME_SHAPEPAR     = 'SIM_SHAPE'  ! changed from SIMSHAPE (4/11/2017)
      SIMNAME_SHAPELAW     = 'SIMNULL1'  ! each SIMNULL has unique name
      SIMNAME_COLORPAR     = 'SIMNULL2'
      SIMNAME_COLORLAW     = 'SIMNULL3'
      SIMNAME_SNRMON       = 'NONE'

      SIMOPT_MWCOLORLAW = -9
      SIMOPT_MWEBV      = -9

      DO ifilt = 1, MXFILT_OBS
         SIM_EXPOSURE_TIME(ifilt)  = 1.0
      ENDDO
      
      SIMLIB_FILENAME = ""
      SIMLIB_MSKOPT   = 0

      DO ibit = 1, NCUTBIT
         CUTWIN_VAR(1,ibit) = -CUTVAL_OPEN
         CUTWIN_VAR(2,ibit) = +CUTVAL_OPEN
      ENDDO    
              
      NEPOCH_IGNORE =  0
      EPOCH_IGNORE_LASTFILE = ''

cc      ZPOFF_FILE    = 'NULL'  ! NULL => use offsets in hid 292
      USERTAGS_FILE = ''
      VPEC_FILE            = ''
      HEADER_OVERRIDE_FILE = ''
      SIM_HEADER_OVERRIDE_FILE = ''


      NPAR_SIMSED      = 0
      NPAR_PySEDMODEL  = 0
      NPAR_LCLIB       = 0
 
      NPAR_SIM_HOSTLIB = 0

      C1ERR = ' '
      C2ERR = ' '
 
      DO_FLUXERRCALC = .FALSE.

      NFIT_PKMJD = 0
 
      NVAR_PRIVATE = 0
      DO i = 1, MXVAR_PRIVATE
        PRIVATE_KEYWORD(i)  = 'UNKNOWN'
        PRIVATE_VARNAME(i)  = 'UNKNOWN'
        PRIVATE_VALUE(i)    = PRIVATE_NULL
        PRIVATE_CUTWIN(1,i) = -CUTVAL_OPEN
        PRIVATE_CUTWIN(2,i) = +CUTVAL_OPEN
      ENDDO
    
      NCUT_PRIVATE = 0
      DO i = 1, MXCUT_PRIVATE
         PRIVATE_CUTWIN_STRING(i) = ''
         USE_PRIVATE_CUTWIN(i)    = 0
      ENDDO
      PRIVATE_VARNAME_READLIST = ''

      SIMVAR_CUTWIN_STRING  = ''
      NSIMVAR_CUTWIN        = 0 

      EARLYLC_STRING        = ''
      REQUIRE_EPOCHS_STRING =  ''
      DUMP_STRING           = ''

c init HOST logicals
      EXIST_SNHOST_ZPHOT    = .FALSE.
      EXIST_SNHOST_LOGMASS  = .FALSE.
      EXIST_SNHOST_LOGSFR   = .FALSE.
      EXIST_SNHOST_LOGsSFR  = .FALSE.
      EXIST_SNHOST_COLOR    = .FALSE.
      EXIST_SNHOST_MAGOBS   = .FALSE.
      EXIST_SNHOST_SB       = .FALSE.
      EXIST_SNHOST_ANGSEP   = .FALSE.
      EXIST_SNHOST_DDLR     = .FALSE.
      EXIST_SNHOST_CONFUSION= .FALSE.

c misc.
      NONSURVEY_FILTERS = ''
      FILTER_REPLACE    = ''
      FILTLIST_LAMSHIFT = ''

      DO i = 1, MXFITSTORE
         PARNAME_STORE(i) = ''
         PAROPT_STORE(i)  = 0
      ENDDO

      CALL FLUSH(6)

      NWD = STORE_PARSE_WORDS(-1, ""//char(0), FNAM//char(0), 2, 12);

      RDFLAG_SPECTRUM = .FALSE.

      RETURN
      END   ! end of INIT_SNVAR


C =======================================
+DECK,INIT_SNCID_LISTS.
      SUBROUTINE INIT_SNCID_LISTS()

c Created Jun 9 2021
c Check CID lists from:
c   + integer list in NML (use and ignore)
c   + char list in NML    (use and ignore)
c   + list in separate file
c
c For string lists that can be very long (from list file),
c use match_cidlist_init[exec] utility in sntools.c[h];
c this match utility uses hash table for faster access.

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i, LENF, LENV, LENC, NCCID_TMP, NCCID_FILE, OPTMASK
      CHARACTER FNAM*20, cFILE*(MXCHAR_FILENAME)
      CHARACTER CCID*(MXCHAR_CCID), cCCID*(MXCHAR_CCID)
      CHARACTER cBLANK*4, cVARLIST_STORE*60
      LOGICAL IS_CCID_LIST, IS_CIDINT_LIST, IS_FILE

      LOGICAL  VALIDFILENAME
      INTEGER  MATCH_CIDLIST_INIT, PARSE_NML_STRINGLIST
      EXTERNAL MATCH_CIDLIST_INIT

C ----------- BEGIN ------------     

      IF ( SNCID_LIST_FILE(1:20) .EQ. 'HEADER_OVERRIDE_FILE' ) THEN
          SNCID_LIST_FILE = HEADER_OVERRIDE_FILE
      ENDIF

      cBLANK = ""//char(0)

      CALL ENVreplace(SNCID_LIST_FILE)  ! Mar 30 2025

      LENF    = INDEX(SNCID_LIST_FILE,' ') - 1
      cFILE   = SNCID_LIST_FILE(1:LENF) // char(0)

      IS_FILE = VALIDFILENAME(SNCID_LIST_FILE)

      NCID_LIST = 0; NCCID_LIST = 0; NCCID_FILE = 0

c check input methods to specify list of CID strings
      IS_CCID_LIST =
     &   ( SNCCID_LIST(1) .NE. ' ' )  .or.  ! char strings in NML
     &   ( IS_FILE )                        ! separate file list

      IS_CIDINT_LIST = SNCID_LIST(1) > 0

c - - - - - - -
      
      FNAM    = 'INIT_SNCID_LISTS'
      CALL PRBANNER(FNAM)

      IF ( IS_CIDINT_LIST .or. IS_CCID_LIST ) THEN
         CUTWIN_CID(1) = 0;  CUTWIN_CID(2) = 0
	 SIM_PRESCALE = 1  ! disable prescale Dec 11 2024
      ENDIF

c      print*,' xxx IS_CID/FILE/INT = ', 
c     &    IS_CCID_LIST, IS_FILE, IS_CIDINT_LIST

c - - - - - - - 
c check integer lists the old way
      IF ( IS_CIDINT_LIST ) THEN
         i = 1
         DO WHILE ( SNCID_LIST(i) .GE. 1 ) 
            i = i + 1
         END DO
         NCID_LIST = i - 1
         write(6,21) NCID_LIST
 21      format(T5,'Store ',I6,' integer CIDs from SNCID_LIST')
      ENDIF

      OPTMASK = 0

      IF ( IS_CCID_LIST ) THEN
         NCCID_TMP = MATCH_CIDLIST_INIT(cBLANK,OPTMASK,cBLANK, 4,4)
     
c  check SNCCID_LIST in &SNLCINP ... 
         i = 1; CCID = SNCCID_LIST(i) 
         DO WHILE( CCID .NE. ' ' )
            CALL NMLCHECK_SNCCID("SNCCID_LIST",CCID)
            LENC = INDEX(CCID,' ') - 1
            cCCID = CCID(1:LENC) // char(0)
            NCCID_TMP = MATCH_CIDLIST_INIT(cCCID,OPTMASK,cBLANK,LENC,4)
            i = i + 1 ; CCID = SNCCID_LIST(i)
         END DO
         NCCID_LIST = i - 1

c check CIDs from separate file (table format, or unformatted)
         IF ( IS_FILE ) THEN
            if ( NFIT_ITERATION > 0 .and. OPT_SNCID_LIST>1 ) then
           ! store SALT2 fit pars for INIVAL in snlc_fit evt sync
              cVARLIST_STORE = 'BANDLIST,zHD,PKMJD,x0,x1,c' // ',' //
     & 	              'zHDERR,PKMJDERR,x0ERR,x1ERR,cERR' // char(0) 
            else
              cVARLIST_STORE = cBLANK
            endif
            OPTMASK = 8 ! send reset for AUTOSTORE
            NCCID_FILE = 
     &        MATCH_CIDLIST_INIT(cFILE,OPTMASK,cVARLIST_STORE, LENF, 60)
         ENDIF

         write(6,31) NCCID_LIST, 'SNCCID_LIST'
         write(6,31) NCCID_FILE, 'SNCID_LIST_FILE'
 31      format(T5,'Store ',I6,  ' string  CIDs from ', A)

      ENDIF   ! end IS_CCID_LIST

      CALL FLUSH(6)

c - - - - - -
c Check ignore lists, and use brute-force matching since
c these lists should be small.

      i = 1 ; NCID_IGNORE=0
      DO WHILE ( SNCID_IGNORE(i) .GE. 1 ) 
         i = i + 1
      END DO
      NCID_IGNORE = i - 1
         
      i = 1
      DO WHILE ( SNCCID_IGNORE(i) .NE. ' ' ) 
         CALL NMLCHECK_SNCCID("SNCCID_IGNORE",SNCCID_IGNORE(i))
         i = i + 1
         SNCCID_IGNORE_ALL(i) = SNCCID_IGNORE(i)
      END DO
      NCCID_IGNORE = i - 1

c - - - - 
      CALL  RDSNIGNORE          ! read IGNORE-list from user file
      NCCID_PLOT = PARSE_NML_STRINGLIST(SNCCID_PLOT,MXCHAR_CCID)

      if ( NCID_IGNORE > 0 .or. NCCID_IGNORE>0 ) then
         write(6,61) NCID_IGNORE,  'SNCID_IGNORE'
         write(6,61) NCCID_IGNORE, 'SNCCID_IGNORE'
 61      format(T5,'IGNORE ',I4,  ' CIDs from ', A)
      endif

c      print*,' xxx DEBUG STOP xxx'
c      STOP ! xxxx

      CALL FLUSH(6)

      
      RETURN
      END   ! end INIT_SNCID_LISTS


C =======================================
+DECK,RD_SNMJDLIST.
      SUBROUTINE RDFILE_SNMJDLIST
c
c Created May 2008 by R.Kessler
c
c Read list of "SNID MJD" to process SNID list,
c so that fitter can interpolate flux at MJD.
c Initial use is for Ryan Foley's analysis with
c KECK spectra for SDSS-discovered SN.
c Second usage is comparing CSP-vs-SDSS photometry (J.Mosher)
c
c May 28, 2008: 
c   add screen-dump to see what's going on.
c 
c Jan 2012: 
c   check 'ALL' option to interpolate ALL SN at a MJD
c   After SN are read, a call to UPDSNMJDLIST checks the 
c   ALL option.
c
c May 18, 2012: complete re-write

c ---------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,INTERPCM.

      INTEGER   iwd, NWD, LEN, N, j, LL0, LL1
      CHARACTER CCID*(MXCHAR_CCID), NAME_forC*(MXCHAR_FILENAME)
      CHARACTER CTMP0*40, CTMP1*40, FNAM*18
      REAL*8  MJD8
      LOGICAL LOK

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

c ---------- BEGIN ----------

      N_INTERP_MJDLIST    = 0

      
      IF ( SNMJD_LIST_FILE .EQ. ' ' ) RETURN

      FNAM = 'RDFILE_SNMJDLIST'
      N_INTERP_MJDLIST_DONE = 0
c init arrays
      N_INTERP_MJDLIST       = 0
      DO j = 1, MXINTERP
         INTERP8_MJDLIST(j)  = 0.0 
         INTERP_CCIDLIST(j)  = ''
         INTERP_MJDLIST_DONE(j) = .FALSE.
      ENDDO

      CALL PRBANNER(FNAM)

      LEN = INDEX(SNMJD_LIST_FILE,' ') - 1
      print*,' '
      print*,'  Read flux-interpolation instructions from '
      print*,'  ', SNMJD_LIST_FILE(1:LEN)

 
      NAME_ForC = SNMJD_LIST_FILE(1:LEN)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,
     &         FNAM//char(0), LEN, 18 ) 

      DO 100 iwd = 1, NWD-1, 2
 
         CALL get_PARSE_WORD_fortran(iwd+0, CTMP0, LL0 )
         CALL get_PARSE_WORD_fortran(iwd+1, CTMP1, LL1 )

         READ ( CTMP0, *) CCID
         READ ( CTMP1, *) MJD8

         N_INTERP_MJDLIST  = N_INTERP_MJDLIST + 1
         N = N_INTERP_MJDLIST

         INTERP_CCIDLIST(N) = CCID
         INTERP8_MJDLIST(N) = MJD8

         LEN = INDEX(CCID,' ') - 1
         write(6,70) CCID, MJD8
70       format(T6,'Will interpolate flux for SN ', A12,
     &        ' at MJD=', F10.3)

c --- error checking

         LOK = ( MJD8 .EQ. 0.0) .or.
     &         ( MJD8 .GT. 40000. .and. MJD8 .LT. 70000. ) 
         if ( .NOT. LOK ) then
            write(c1err,61) MJD8
61          format('Read Invalid MJD = ', F12.3,' from ' ) 
            c2err = SNMJD_LIST_FILE(1:80)
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         endif

c abort if we exceed array bound
         IF ( N_INTERP_MJDLIST .GT. MXINTERP ) THEN
            CALL PRINT_PREABORT_BANNER("RDFILE_SNMJDLIST"//char(0),40)
            print*,'   SNMJD_LIST_FILE = ', SNMJD_LIST_FILE
            write(c1err,161) CCID, MJD8
161         format('N_INTERP_MJDLIST exceeds bound at CID=',A8, 2x,
     &          'MJD=',F9.3)
            write(c2err,162) MXINTERP
162         format('Check MXINTERP=',I5,' and SNMJD_LIST_FILE above.')

           CALL  MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

100   CONTINUE  ! iwd

      RETURN
      END   ! end of RDFILE_SNMJDLIST

C =============================
+DECK,GTINTLIST.
      SUBROUTINE GET_INTERP_MJDLIST(CCID, NMJD, MJDLIST, ADDFLAG)
c
c Return NMJD and MJDLIST to interpolate for this CID.
c ADDFLAG = T if this CCID is specifically listed;
c ADDFLAG = F if this CCID is added because of the ALL option.
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,INTERPCM.

c subroutine args
      CHARACTER CCID*(*)  ! (I) SN character id
      INTEGER NMJD        ! (O) number of MJDs to interpolate
      LOGICAL ADDFLAG     ! (O) T => add to process list
      REAL*8  
     &   MJDLIST(MXINTERP) ! (O) list of MJDs

c local var

      LOGICAL LMATCH, LALL
      INTEGER i, L0, L1
      character CCID_tmp*(MXCHAR_CCID)

c --------------- BEGIN --------------

      NMJD    = 0
      ADDFLAG = .FALSE.

      L0   = INDEX(CCID,' ') - 1

      DO 100 i = 1, N_INTERP_MJDLIST
         CCID_tmp = INTERP_CCIDLIST(i)
         L1 = INDEX(CCID_tmp,' ') - 1

         LMATCH = ( L0 .EQ. L1 ) .and. 
     &            ( CCID(1:L0) .EQ. CCID_tmp(1:L1) )
         LALL    = CCID_tmp(1:3) .EQ. 'ALL' 

         IF ( LMATCH ) ADDFLAG = .TRUE.  ! set return arg

c         print*,' xxx compare ', CCID,'  to ', CCID_tmp,
c     &     '  L0,L1=',L0,L1

         if ( LALL .or. LMATCH )then
           NMJD = NMJD + 1
           MJDLIST(NMJD) = INTERP8_MJDLIST(i)

c keep track of which ones are DONE to help know when to quit reading
           if ( .not. INTERP_MJDLIST_DONE(i) ) then
              N_INTERP_MJDLIST_DONE  = N_INTERP_MJDLIST_DONE + 1
              INTERP_MJDLIST_DONE(i) = .TRUE.
           endif

         endif
100   CONTINUE

      RETURN
      END

C =========================================
+DECK,ENVreplace.
      SUBROUTINE ENVreplace(STRING) 

c If input STRING starts with '$' then evaluate ENV
c with GETENV and return STRING with substitution.
c
c There is a C version of this function in sntools.c,
c but passing back the return string to fortran is not 
c so easy, so safer to write this one in fortran too.

      IMPLICIT NONE
      CHARACTER STRING*(*)  ! I/O

c local args
+CDE,SNPAR.

      INTEGER jslash, LTOT, LENV, LENS
      CHARACTER ENVname*200, ENV*400, SUFFIX*400
      CHARACTER C1ERR*72, C2ERR*72
      CHARACTER FNAM*12

C -------------- BEGIN -------------

      IF ( STRING(1:1) .NE. '$' ) RETURN

      FNAM = 'ENVreplace'

      LTOT    = INDEX(STRING,' ' ) - 1
      IF (LTOT <= 0 ) THEN
        CALL PRINT_PREABORT_BANNER(FNAM(1:10)//char(0), 40)
        print*,' STRING=', STRING
        write(c1err,31) LTOT
        c2err = 'STRING could be too long or zero length'
31      format( 'LEN(STRING)=', I3, ' ???' )
        CALL MADABORT(FNAM, C1ERR, C2ERR)        
      ENDIF

      JSLASH  = INDEX(STRING,'/') - 1
      IF ( JSLASH <= 0 ) JSLASH = LTOT
      SUFFIX  = STRING(JSLASH+1:LTOT)
      LENS    = INDEX(SUFFIX,' ') - 1

      ENVname = STRING(2:JSLASH)
      CALL GETENV(ENVname, ENV) ! return ENV
      LENV    = INDEX(ENV,' ')-1
 
      if ( LENV > MXCHAR_PATH ) then
         write(C1ERR,61) ENVname(1:JSLASH-1), LENV
61       format('LEN($', A, ') = ',I3,' is too long.')
         write(C2ERR,62) MXCHAR_PATH
62       format('MXCHAR_PATH = ', I3 )
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      if ( LENV+LENS > MXCHAR_FILENAME ) then
         write(C1ERR,161) STRING(1:LTOT), LENV+LENS
161       format('Decoded LEN($', A, ') = ',I3,' is too long.')
         write(C2ERR,162) MXCHAR_FILENAME
162       format('MXCHAR_FILENAME = ', I3 )
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      if ( LENV .EQ. 0 ) then
         C1ERR = 'ENV = $' // ENVname(1:JSLASH) // ' is not defined.'
         C2ERR = 'Check your input namelists.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      STRING = ENV(1:LENV) // SUFFIX

      RETURN
      END     ! end of ENVreplace

C ==============================
+DECK,IGNOREFILE_fortran.
      LOGICAL FUNCTION IGNOREFILE_fortran(fileName)

c Created Apri 2022
c Wrapper to call IGNOREFILE C-utility to return True if
c file = 'NULL' or 'NONE' or 'BLANK' or ''

+CDE,SNPAR.
      CHARACTER FILENAME*(*), cFILE*(MXCHAR_FILENAME)
      INTEGER LENF, IGNORE

      INTEGER  IGNOREFILE
      EXTERNAL IGNOREFILE
C --------- BEGIN -------------

      LENF = INDEX(FILENAME//' ',' ') - 1
      cFILE = FILENAME(1:LENF) // char(0)
      IGNORE = IGNOREFILE(cFILE,LENF) 

c xxxxxxxx
c      print*,' xxx ------------------------------- '
c      print*,' xxx FILENAME = ', FILENAME(1:LENF)
c      print*,' xxx LENF = ', LENF
c      print*,' xxx IGNORE = ', IGNORE
c xxxxxxxxxx

      IGNOREFILE_fortran = (IGNORE .NE. 0 )

      RETURN
      END  ! end of IGNOREFILE_fortran

+DECK,VALIDFILENAME.
      LOGICAL FUNCTION VALIDFILENAME(fileName)
      CHARACTER FILENAME*(*)
      LOGICAL   IGNOREFILE_fortran
      VALIDFILENAME = ( .NOT. IGNOREFILE_fortran(FILENAME) ) 
      RETURN
      END

C =======================================
+DECK,get_PARSE_WORD_fortran.
      SUBROUTINE get_PARSE_WORD_fortran(iwd,WORD,LEN) 
c
c Jan 2018
c Wrapper to call C-function get_PARSE_WORD to retrieve
c iwd word stored.
c
c Jan 2019: use MXCHAR_FILEWORD for char array abound.
c Jul 2020: extend WORD_C size to 4*MXCHAR_FILENAME
c
      IMPLICIT NONE

+CDE,SNPAR.

c subroutine args
      INTEGER   IWD           ! (I) word index to fetch
      CHARACTER WORD*(*)      ! (O) stored word
      INTEGER   LEN           ! (O) length of word

c local args
      INTEGER  iwd_C
      CHARACTER WORD_C*(4*MXCHAR_FILENAME)
      EXTERNAL GET_PARSE_WORD

C ------------- BEGIN -----------
      iwd_C = iwd-1
      CALL GET_PARSE_WORD(ONE, iwd_C, WORD_C, LEN)
      LEN  = INDEX(WORD_C, ' ' ) - 1
      WORD = WORD_C(1:LEN)
      RETURN
      END


C ======================
+DECK,UPCASE.
      SUBROUTINE UPCASE(strin, strupper)
      character strin*(*), strupper*(*)
      integer  j, LL

      strupper = ''
      LL = INDEX(strin,' ') - 1
      do j = 1, LL
       if(strin(j:j) >= "a" .and. strin(j:j) <= "z") then
         strupper(j:j) = achar(iachar(strin(j:j)) - 32)
       else
         strupper(j:j) = strin(j:j)
       end if
      end do
      END

C ======================
+DECK,LOCASE.
      SUBROUTINE LOCASE(strin, strlower)
c return strlower.
      character strin*(*), strlower*(*)
      integer  j, LL

      strlower = ''
      LL = INDEX(strin,' ') - 1
      do j = 1, LL
       if(strin(j:j) >= "A" .and. strin(j:j) <= "Z") then
         strlower(j:j) = achar(iachar(strin(j:j)) + 32)
       else
         strlower(j:j) = strin(j:j)
       end if
      end do
      END

C ===========================================
+DECK,RDNINT.
      SUBROUTINE RDNINT( cwords, NINT, IARRAY )
      IMPLICIT NONE
c ---------------------------------------------------
c Read NINT consecutive integers from cwords array
c Store results in IARRAY.
c --------------------------------------------------
      INTEGER   NINT
      character cwords(NINT)*60  ! (I) list of char words
      INTEGER   IARRAY(NINT)     ! (O) array of parsed integers
c local args
      INTEGER i
C ------------ BEGIN -----------
      DO i = 1, NINT
          read ( cwords(i), * ) IARRAY(i)
      ENDDO
      RETURN
      END

C ===========================================
+DECK,RDNFLOAT.
      SUBROUTINE RDNFLOAT ( CWORDS, NFLOAT, FARRAY )
      IMPLICIT NONE
c ---------------------------------------------------
c Read NFLOAT consecutive floats from CWORDS array
c Store results in FARRAY.
c
c Jul 2008: ABORT on 'nan'.
c Sep 2010: increase cwords bytes from 40 to 60
c
c --------------------------------------------------
      INTEGER NFLOAT
      character cwords(NFLOAT)*60  ! (I) list of char words
      REAL      FARRAY(NFLOAT)     ! (O) array of parsed floats
c local args
      INTEGER i
      character c1err*60, c2err*60
C ------------ BEGIN -----------
      DO i = 1, NFLOAT
          if ( cwords(i) .EQ. 'nan' ) then
             print*,' '
             c1err = "Found 'nan' instead of float. "
             c2err = "Use grep to find the nan in this version. "
             CALL MADABORT("RDNFLOAT", c1err, c2err )
          endif
          read ( cwords(i), * ) FARRAY(i)

      ENDDO
      RETURN
      END

C ===========================================
+DECK,RDNDBLE.
      SUBROUTINE RDNDBLE ( CWORDS, NDBLE, DARRAY )
      IMPLICIT NONE
c ---------------------------------------------------
c Created Jun 20, 2011
c Read NDBLE consecutive doubles from CWORDS array
c Store results in DARRAY.
c
c --------------------------------------------------
      INTEGER NDBLE
      character cwords(NDBLE)*60  ! (I) list of char words
      REAL*8    DARRAY(NDBLE)     ! (O) array of parsed floats
c local args
      INTEGER i
      character c1err*60, c2err*60
C ------------ BEGIN -----------
      DO i = 1, NDBLE
          if ( cwords(i) .EQ. 'nan' ) then
             print*,' '
             c1err = "Found 'nan' instead of dble. "
             c2err = "Use grep to find the nan in this version. "
             CALL MADABORT("RDNDBLE", c1err, c2err )
          endif
          read ( cwords(i), * ) DARRAY(i)
cc          read ( cwords(i), "(D20.10)" ) DARRAY(i)
      ENDDO
      RETURN
      END

C ==============================================
+DECK,RDSTRING.
      CHARACTER*80 FUNCTION RDSTRING( OPT, FILE )
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

c Read single-word STRING from FILE
c OPT=0 => read from file
c OPT=1 => read from $SNDATA_ROOT/file

      INTEGER OPT
      CHARACTER FILE*(*)
    
c local var

      INTEGER LL
      CHARACTER LOCFILE*(MXCHAR_FILENAME), string*80

C -----------

      IF ( OPT .EQ. 0 ) THEN
         LOCFILE = FILE
      ELSE
         LL = INDEX(SNDATA_ROOT,' ') - 1
         LOCFILE = SNDATA_ROOT(1:LL) // '/' // FILE
      ENDIF

      OPEN (UNIT=LUNTMP, FILE = LOCFILE, STATUS='OLD', ERR=666 )
      READ(LUNTMP,*) string
      CLOSE ( UNIT = LUNTMP )

      RDSTRING = STRING
      RETURN

c --------------------
666   CONTINUE
      LL = INDEX(FILE,' ') - 1
      C1ERR = 'Cannot open file: ' // file(1:LL)
      CALL MADABORT("RDSTRING", C1ERR, "")

      RETURN
      END

      

C ================================================
+DECK,INITSURVEY.
      SUBROUTINE INIT_SURVEY(NSN_VERS)
c
c Created Jun 2011
c [re-named from RDSURVEY, and read-part moved to RDSURVEY_TEXT]
c
c Process a few things from the global survey variables
c read from RDSURVEY_TEXT[FITS]
c 
c May 26, 2012: remove BX check; moved to LANDOLT_PREP.
c
c Jun 15, 2013: check FILTER_REPLACE option
c
c Aug 08, 2013: read and fill SURVEY_FIELD(i) for each survey field;
c               needed to sort overlapping fields so that
c               E2+E1 gets written as E1+E2
c
c Dec 16 2014: fix string logic checking SURVEY; see L1.
c
c Dec 09 2020: fix index bug setting SURVEY_TMP
c -------------

      IMPLICIT NONE

c subroutine args

      INTEGER NSN_VERS

c local variables.

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER 
     &   iwd, NWD, IFILT_OBS, LL, L1, L2, LNAM,  i, IDTMP
     &  ,IDFIELD, NFILT_NONSURVEY, NFILT_ADD, iadd, jtmp
     &  ,LWD0, LWD1, LWD2, LWD3

      character 
     &   FNAM*12, cwd*60, cwd_next*60, cwd_next2*60, cwd_next3*60
     &  ,cfilt1*2, SURVEY_TMP*(MXCHAR_SURVEY)
     &  ,SURVEYFILE*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)
     &  ,upper*60, ctel*60, cfield*60
     &  ,SURVEY_FILTERS_ORIG*(MXFILT_ALL)

      LOGICAL LTMP, LKEY, LSRVY

c functions
      INTEGER FILTINDX
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------------- BEGIN --------------

      FNAM            = 'INIT_SURVEY'
      IDSURVEY        = 0
      NFIELD_SURVEY   = 0
      NSURVEY_LIST    = 0 

      LNAM  = INDEX ( SURVEY_NAME,    ' ' ) - 1
      L2    = 0
      
      IF ( FREEZE_SURVEY_FILTERS ) THEN
c        leave SURVEY_FILTERS and NFILTDEF_XXX alone
      ELSE
        L2  = INDEX ( SURVEY_FILTERS, ' ' ) - 1
        NFILTDEF_SURVEY = L2
        NFILTDEF_READ   = L2
      ENDIF

c ----------------------------------------
c Apr 2013: check user-option to add non-survey filters.
c           These extra filters must be defined in the kcor/calib file,
c           otherwise RDKCOR will abort.
c Jun 1 2013:
c  Only add NONSURVEY filter if it's NOT already defined. For example, 
c  consider SDSS ugrizUGRIZ, but the simulations are done only with ugriz.  
c  Thus we can define NONSURVEY_FILTERS ='UGRIZ' which are added to the 
c  simulation list to avoid a KCOR-abort, but for data these NONSURVEY_FILTERS
c  are ignored since they are already defined.

      NFILT_NONSURVEY = INDEX(NONSURVEY_FILTERS,' ') - 1
      SURVEY_FILTERS_ORIG = SURVEY_FILTERS
      NFILT_ADD = 0
      NONSURVEY_FILTERS_ADD = '' 

      DO 601 iadd = 1, NFILT_NONSURVEY
        cfilt1 = NONSURVEY_FILTERS(iadd:iadd)
        jtmp   = INDEX(SURVEY_FILTERS_ORIG,cfilt1(1:1))

        if ( jtmp .LE. 0 ) then
           NFILT_ADD = NFILT_ADD + 1
           NONSURVEY_FILTERS_ADD = 
     &     NONSURVEY_FILTERS_ADD(1:NFILT_ADD-1) // cfilt1(1:1)
        endif

601   CONTINUE

      IF ( NFILT_ADD > 0 ) THEN
           NONSURVEY_FILTERS_ADD = 
     &     NONSURVEY_FILTERS_ADD(1:NFILT_ADD) // '  '  ! add padding

         print*,'   Add NON-SURVEY FILTERS = ', 
     &              NONSURVEY_FILTERS_ADD(1:NFILT_ADD)
         call flush(6)
         SURVEY_FILTERS  = SURVEY_FILTERS(1:NFILTDEF_SURVEY) // 
     &                     NONSURVEY_FILTERS_ADD(1:NFILT_ADD)
         NFILTDEF_SURVEY = NFILTDEF_SURVEY + NFILT_ADD
         L2 = NFILTDEF_SURVEY
      ENDIF

c ----------------------------------------
c create IFILTDEF_MAP_SURVEY


       do i = 1, NFILTDEF_SURVEY
          cfilt1    = SURVEY_FILTERS(i:i)
          IFILT_OBS = FILTINDX(cfilt1) 

          IFILTDEF_MAP_SURVEY(i)    = IFILT_OBS
          IFILTDEF_INVMAP_SURVEY(ifilt_obs) = i

          if ( IFILT_OBS .LE. 0 ) then
            CALL PRINT_PREABORT_BANNER("INIT_SURVEY"//char(0),40)
            print*,'   i = ', i,' of NFILTDEF_SURVEY=', NFILTDEF_SURVEY
            print*,'   IFILT_OBS = ', IFILT_OBS
            print*,'   CFILT1    = ', cfilt1

            c1err = 'FILTER = ' // cfilt1 // 
     &         ' is invalid for SURVEY=' // SURVEY_NAME(1:LNAM)
            c2err = 'SURVEY_FILTERS = |' // 
     &              SURVEY_FILTERS(1:NFILTDEF_SURVEY) // '|'
            CALL MADABORT(FNAM, c1err, c2err )
          endif

       enddo

c ------------
c Now open SURVEY.DEF file to get 
c  IDSURVEY
c  IDFIELD

      LL = INDEX ( SNDATA_ROOT , ' ' ) - 1
      SURVEYFILE = SNDATA_ROOT(1:LL) // '/SURVEY.DEF'

      LL        = INDEX(SURVEYFILE,' ')-1
      NAME_forC = SURVEYFILE(1:LL)//char(0)
      NWD  = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,
     &           FNAM//char(0), LL, 12)

      DO 110 iwd = 1, NWD-3

         CALL get_PARSE_WORD_fortran(iwd+0, cwd,       LWD0 )
         CALL get_PARSE_WORD_fortran(iwd+1, cwd_next,  LWD1 )
         CALL get_PARSE_WORD_fortran(iwd+2, cwd_next2, LWD2 )
         CALL get_PARSE_WORD_fortran(iwd+3, cwd_next3, LWD3 )
         if ( cwd .EQ. ' ' ) goto 110

         if ( cwd(1:7) .EQ. 'SURVEY:' ) then
            L1 = index(cwd_next,' ') - 1
            SURVEY_TMP  = cwd_next(1:L1)
            read(cwd_next2,*) IDTMP

c    store all survey names in case there are subSurveys
c    such as LOWZ(CFA3)
            NSURVEY_LIST = NSURVEY_LIST + 1
            SURVEY_NAME_LIST(NSURVEY_LIST) = SURVEY_TMP
            IDSURVEY_LIST(NSURVEY_LIST)    = IDTMP

            if ( SURVEY_TMP(1:L1) .EQ. SURVEY_NAME(1:LNAM) ) then
c     IDSURVEY should never change, but IDSUBSURVEY can change
               IDSURVEY=IDTMP ; IDSUBSURVEY=IDTMP
            endif
         endif

c ------------
c check SN field
   
         LKEY   = cwd .EQ. 'FIELD:'
         LSRVY  = .FALSE.
         IF ( LKEY ) THEN
            read(cwd_next3,*) SURVEY_TMP      
            LSRVY  = SURVEY_TMP .EQ. SURVEY_NAME ! field for this survey 
         ENDIF

         if ( LKEY .and. LSRVY ) then

          call UPCASE(cwd_next, upper)       
          cfield = upper  ! FIELD in SURVEY.DEF file  

          read(cwd_next2,*) IDFIELD

          IF ( IDFIELD > 0 ) THEN
             NFIELD_SURVEY = NFIELD_SURVEY + 1
             SURVEY_FIELDNAME(NFIELD_SURVEY)= cfield(1:MXCHAR_FIELDNAME)
             SURVEY_IDFIELD(NFIELD_SURVEY)  = IDFIELD
          ENDIF
       
          IF ( NFIELD_SURVEY > MXIDFIELD ) THEN
             write(c1err,681) MXIDFIELD
 681         format('NSURVEY_FIELD exceeds bound of ', I4)
             c2err = 'Check MXIDFIELD and SURVEY.DEF file.'
             CALL MADABORT(FNAM, c1err, c2err )
          ENDIF

c now compare with user request, and convert everything to upper case

           DO i = 1, NIDFIELD_LIST
c convert user name to uppercase
             CALL UPCASE(SNFIELD_LIST(i), upper) 
             SNFIELD_LIST(i) = upper   ! user-specified field
             LL = INDEX( cfield, ' ' ) - 1

             if ( cfield(1:LL) .EQ. SNFIELD_LIST(i)(1:LL) ) then
               SNFIELD_LIST(i) = cfield  ! truncate extra characters
               IDFIELD_LIST(i) = IDFIELD               
               write(6,206) CFIELD(1:LL), IDFIELD
206            format(T5,'Found requested FIELD=',A,2x, 
     &               'with IDFIELD=', I3 )
             endif
            END DO

         endif  ! end of FIELD: if-block
      
110   CONTINUE
     
c ------------------------
c print some info to stdout

      IF ( IDSURVEY .LE. 0 .and. SUBSURVEY_NAME .EQ. '' ) then
        c1err = 'Could not find IDSURVEY for SURVEY=' 
     &        // SURVEY_NAME(1:LNAM)
        c2err = 'Check ' // SURVEYFILE(1:72)
        CALL MADABORT(FNAM, c1err, c2err )
      endif

      if ( DO_GETINFO ) return ! Apr 2021

      write(6,201) SURVEY_NAME(1:LNAM), IDSURVEY
201   format(T5,'Found SURVEY  = ',A, 3x, '(IDSURVEY=',I3,')' )

      write(6,202) SURVEY_FILTERS(1:L2), NFILTDEF_SURVEY
202   format(T5,'Found FILTERS = ',A, 3x, '(NFILTDEF=',I3,')' )

      write(6,204) NSN_VERS
204   format(T5,'Found ',I7,' SN Candidates to Process.')

      print*,' '
      call flush(6)

c --------------------------------------------------------

      IF ( .NOT. DOALL_SNFIELD ) THEN
        DO i    = 1, NIDFIELD_LIST
          cfield  = SNFIELD_LIST(i)
          idfield = IDFIELD_LIST(i)
          if ( idfield .LT. 0 ) then
             LL = index( cfield, ' ' ) - 1
             c1err = 'Unknown FIELD: ' // cfield(1:LL)
             c2err = 'Check namelist variable SNFIELD_LIST '
             CALL MADABORT(FNAM, c1err, c2err )
          endif
        ENDDO
      ENDIF


c ---------------------------------
c check for FILTER_REPLACE option

      CALL INIT_FILTER_REPLACE()

c Apr 2021: check option to use survey name for TEXTFILE_PREFIX 
      if ( TEXTFILE_PREFIX(1:6) == 'SURVEY' ) then
          TEXTFILE_PREFIX = SURVEY_NAME
      endif

      RETURN
      END      ! end of INIT_SURVEY

C ===================================
+DECK,INIFLTREPLACE.
      SUBROUTINE INIT_FILTER_REPLACE()

C Created Jun 2013 by R.K.
C Initialize IFILTOBS_REPLACE array based on user input 
c string FILTER_REPLACE read from &SNLCINP namelist.
C After this init, can use FILTINDX_REPLACE function.
c
c Example:  FILTER_REPLACE = 'UGRIZ -> ugriz' will 
c internally replace UGRIZ with ugriz so that we can
c analyze 'ugriz' (intead of ugrizUGRIZ) and get 
c all of the epochs. This is intended for cases in 
c which UGRIZ and ugriz bands are very similar.
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER 
     &  IFILTOBS, NF1, NF2, NFARROW, IFILT, NWD, LF
     & ,IFILTOBS_ORIG

      CHARACTER 
     &   ARROW*60
     &  ,FILTLIST1*(MXFILT_ALL)
     &  ,FILTLIST2*(MXFILT_ALL)
     &  ,NAME_forC*(MXFILT_ALL)
     &  ,FNAM*20
     &  ,CFILT_ORIG*2
     &  ,CFILT_REPLACE*2

c function
      INTEGER FILTINDX
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN ------------

      NFILT_REPLACE = 0
      DO IFILTOBS = 1, MXFILT_ALL
        IFILTOBS_REPLACE(IFILTOBS) = IFILTOBS  ! default is 1-to-1 map
      ENDDO

      FNAM = 'INIT_FILTER_REPLACE'

      IF ( FILTER_REPLACE .NE. ' ' ) THEN

        LF        = INDEX(FILTER_REPLACE,' ', BACK=.TRUE.) - 1
        NAME_forC = FILTER_REPLACE(1:LF) // char(0)
        NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_STRING,NAME_forC,
     &             FNAM//char(0), LF, 20)
        
        CALL get_PARSE_WORD_fortran(1, FILTLIST1, NF1)
        CALL get_PARSE_WORD_fortran(2, ARROW,     NFARROW)
        CALL get_PARSE_WORD_fortran(3, FILTLIST2, NF2)

c idiot checks

        if ( NF1 .NE. NF2 ) THEN
           c1err = 'Cannot use FILTER_REPLACE with ' // 
     &              'different size lists.'
           c2err = 'N(' // FILTLIST1(1:NF1) // ')' //
     &         ' != N(' // FILTLIST2(1:NF2) // ')'
           CALL MADABORT(FNAM, c1err, c2err )
        ENDIF
        IF ( ARROW(1:2) .NE. '->' ) THEN
           c1err = 'Second string of FILTER_REPLACE must by  ->'
           c2err = 'Check &SNLCINP namelist.'
           CALL MADABORT(FNAM, c1err, c2err )
        ENDIF

        NFILT_REPLACE = NF1
        DO IFILT = 1, NFILT_REPLACE
           CFILT_ORIG    = FILTLIST1(IFILT:IFILT)
           CFILT_REPLACE = FILTLIST2(IFILT:IFILT)

           IFILTOBS_ORIG                 = FILTINDX(CFILT_ORIG)
           IFILTOBS_REPLACE(IFILTOBS_ORIG) = FILTINDX(CFILT_REPLACE)

           write(6,20) CFILT_ORIG, CFILT_REPLACE, IFILTOBS_ORIG,
     &                    IFILTOBS_REPLACE(IFILTOBS_ORIG) 
 20        format(T10,'FILTER_REPLACE:  ', A, ' -> ', A, 3x,
     &        '(',I3,' -> ', I3, ')' )         
           CALL FLUSH(6)
        ENDDO
        print*,' '

c        print*,' xxx FILTLIST1 = ', FILTLIST1(1:12), NF1
c        print*,' xxx FILTLIST2 = ', FILTLIST2(1:12), NF2
c        print*,' xxx ARROW = ', ARROW
c        print*,' xxx REPLACE ', NFILT_REPLACE,'  filters '


      ENDIF

      RETURN
      END

C =============================
+DECK,SETSURVEY.
      SUBROUTINE SET_SURVEY(NAME, NFILTDEF, IFILTDEF, LAMSHIFT )
c
c May 18, 2008
c
c Set survey and IFILTDEF_[INV]MAP_SURVEY variables 
c by passing them (i.e., from simulation) rather than 
c by calling RDSURVEY. 
c 
c Jun 20 2017: pass LAMSHIFT as argument.
c
c ---------

      IMPLICIT NONE
c subroutine args

      CHARACTER NAME*(*)         ! (I) name of survey

      INTEGER
     &    NFILTDEF            ! (I) number of survey filters
     &   ,IFILTDEF(NFILTDEF)  ! (I) absolute filter indices

      REAL LAMSHIFT(NFILTDEF) ! (I) LAMSHIFT for each band
 
c local args

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,FILTCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.

      INTEGER ifilt, ifilt_obs

c ---------------- BEGIN ------------

      SURVEY_NAME     = NAME
      NFILTDEF_SURVEY = NFILTDEF


      DO ifilt    = 1, NFILTDEF
        ifilt_obs = IFILTDEF(ifilt)
        IFILTDEF_MAP_SURVEY(ifilt)        = ifilt_obs
        IFILTDEF_INVMAP_SURVEY(ifilt_obs) = ifilt
        FILTER_LAMSHIFT_FILT(ifilt_obs)   = LAMSHIFT(IFILT)
      ENDDO


c Apr 2013: make sure to abort on bad kcor redshift.
      ABORT_ON_BADZ = .TRUE.

      RETURN
      END

C ================================================
+DECK,ABTREST.
      SUBROUTINE ABORT_ON_CUTWIN_TREST()

C Feb 2014
C Utility called by photo-z fitting program to abort
C if any of the SNANA-Trest cuts are set ... because
c for photo-z fit we cannot make an a-priori cut that
c depends on redsfhit. Try CUTWIN_TOBSMIN, CUTWIN_TOBSMAX,
c and other cuts that do NOT depend on the fitted photo-z.
c
c  To override this abort, set
c  &SNLCINP
c    ABORT_ON_TRESTCUT = F
c -------------------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,SNLCINP.

    
      INTEGER NCUT, i, icut, ICUTLIST(20)
      INTEGER NCUT_USE, LEN
      LOGICAL LLO, LHI
      REAL    VLO, VHI

      CHARACTER c1err*76, C2err*76

C --------------- BEGIN --------------
      NCUT = 0

      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_TREST
      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_TRESTMIN
      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_TRESTMAX
      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_TGAPMAX
      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_T0GAPMAX

      NCUT_USE = 0
      Do 100 i = 1, NCUT
         icut  = ICUTLIST(i)
         VLO   = CUTWIN_VAR(1,icut) 
         VHI   = CUTWIN_VAR(2,icut) 

         LLO   = ( VLO > -.99*CUTVAL_OPEN ) 
         LHI   = ( VHI < +.99*CUTVAL_OPEN  ) 
         if ( LLO .or. LHI ) THEN
            NCUT_USE = NCUT_USE + 1
            LEN = INDEX(CUTVAR_NAME(icut),' ') - 1
            write(6,60) CUTVAR_NAME(icut), VLO, VHI
 60         format(T5,'WARNING: should not use CUTWIN_', A15,
     &            2x, F10.3,' - ', F10.3 )
            call flush(6)
         endif
 100  CONTINUE

      IF ( NCUT_USE > 0 .and. ABORT_ON_TRESTCUT ) THEN
         write(c1err,160) NCUT_USE
 160     format(I3,' Trest &SNLCINP cuts above are forbidden.' )
         c2err = 'Can override abort with &SNLCINP ABORT_ON_TRESTCUT=F'
         CALL MADABORT('ABORT_ON_CUTWIN_TREST', c1err, c2err )
      ENDIF

      RETURN
      END    ! end ABORT_ON_CUTWIN_TREST

C ================================================
+DECK,RDEPIG.
      SUBROUTINE READ_EPIGNORE_FILE ( IVERS  )
c
c Created May 6, 2008 by R.Kessler
c Read list of epochs to ignore.
c 
c Use namelist variable EPOCH_IGNORE_FILE:
c if 'DEFAULT', then read [SNDATA_PREFIX].IGNORE.
c
c Fill variables in common EPXCOM
c
c File syntax is
c
c  IGNORE:  <CID1>  <MJD1>  <FILTER1>
c  IGNORE:  <CID2>  <MJD2>  <FILTER2>
c  etc ...
c
c  where <FILTER> is 'g' or 'r' or 'i' etc ...
c
c  and/or
c 
c PHOTFLAG_MSKREJ:  <mask>  ! apply to PHOTFLAG
c    or
c PHOTFLAG_BITLIST_REJECT: 2,3,4  ! convert bits to mask
c
c PRIORITY for setting PHOTFLAG_MSKREJ
c   + user input via &SNLCINP -> top priority
c   + [VERSION].IGNORE file   -> next priority
c
c Strategy is that PHOTFLAG_MSKREJ is initialized to -1 before
c reading &SNLCINP ... which is before calling this function.
c If PHOTFLAG_MSKREJ >=0 here, then it picked up a value from &SNLCINP
c and it is NOT allowed to be modified here.
c If PHOTFLAG_MSKREJ < 0 here, then it can be updated by contents
c    of [VERSION].IGNORE file.
c
c Aug 27 2020: for externally supplied .IGNORE  file, make DOCANA check.
c Feb 06 2021: IGNORE file is now optional ! No longer required !
c May 13 2021: check for PHOTFLAG_MSKREJ in IGNORE file
c
c ----------------------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   
     &    IVERS        ! (I) use this version index

c local var

      INTEGER LL, LL1, LL2, LL3, LV, LF, BIT
      INTEGER iwd, NWD, N, LUN, NREAD_IGNORE
      LOGICAL LEXIST, FOUND_EPIGNORE, NOTSET
      REAL*8 MJD8
      CHARACTER 
     &   LOCAL_FILENAME*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)
     &  ,VERSION*(MXCHAR_VERSION)
     &  ,cwd*(MXCHAR_FILEWORD), cflt*4
     &  ,cwd_tmp*(MXCHAR_FILEWORD)
     &  ,ccid*(MXCHAR_CCID)
     &  ,ccid_last*(MXCHAR_CCID)
     &  ,STRING_BITLIST*60
     &  ,FNAM*30

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN ----------

      FNAM = 'READ_EPIGNORE_FILE'

      LUN = LUNTMP

      VERSION  = VERSION_PHOTOMETRY(ivers) 
      LV       = index(VERSION,' ') - 1

      FOUND_EPIGNORE = .FALSE.
      STRING_BITLIST = ''

      CALL PRBANNER ( "READ_EPIGNORE_FILE:" )

      if ( EPOCH_IGNORE_FILE(1:4) .EQ. 'NONE' ) GOTO 8000
      if ( EPOCH_IGNORE_FILE(1:4) .EQ. 'NULL' ) GOTO 8000

c check if file is default, or if provided by user.
      
      IF ( EPOCH_IGNORE_FILE(1:7) .EQ. 'DEFAULT' ) THEN
        LL = INDEX( SNDATA_PREFIX, ' ' ) - 1
        LOCAL_FILENAME = SNDATA_PREFIX(1:LL) // '.IGNORE'

c       bail if default file does not exist (Feb 2021)
        inquire (file=LOCAL_FILENAME, exist=LEXIST)
        if ( .NOT. LEXIST ) THEN
           print*,'    Default IGNORE file does not exist -> skip read.'
           call flush(6)
           GOTO 8000
        endif 
      ELSE
        LOCAL_FILENAME = EPOCH_IGNORE_FILE
      ENDIF

c for multiple versions, don't bother re-reading  the same
c IGNORE file
      IF ( IVERS > 1 ) then
        LF  = INDEX(LOCAL_FILENAME,' ') - 1
        IF ( LOCAL_FILENAME(1:LF) .EQ. 
     &       EPOCH_IGNORE_LASTFILE(1:LF) ) THEN
             RETURN
        ENDIF
      ENDIF

c -----------
c Now start reading file

      LL = INDEX( LOCAL_FILENAME, ' ' ) - 1
      NAME_forC = LOCAL_FILENAME(1:LL)//char(0)

      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,
     &         FNAM//char(0), LL, 30)
      
      write(6,50) LOCAL_FILENAME(1:LL)
50    format(T5,'Read epochs to ignore from: ', /, T5, A)

      NREAD_IGNORE = 0
      CCID_LAST    = EPOCH_IGNORE_CCID(1)

      DO 200 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd,cwd,LL)

         if ( cwd .EQ. 'IGNORE:' ) then
 
           NREAD_IGNORE = NREAD_IGNORE + 1
           CALL get_PARSE_WORD_fortran(iwd+1,CCID,LL1)
           if ( IVERS .GT. 1 .and. ccid .EQ. CCID_LAST ) then
             print*,'   IGNORE file already read -> SKIP re-reading. '
             return
           endif

           NEPOCH_IGNORE = NEPOCH_IGNORE + 1
           N = NEPOCH_IGNORE

           if ( N .GT. MXEPOCH_IGNORE ) then
              write(c1err,661) N
661           format('NEPOCH_IGNORE=',I4,' exceeds array bound.')
              c2err = 'Check file: ' // LOCAL_FILENAME(1:LL)
              CALL MADABORT("READ_EPIGNORE", c1err, c2err )
           endif

           CALL get_PARSE_WORD_fortran(iwd+2,CWD_TMP,LL2)
           read(cwd_tmp,*) MJD8

           CALL get_PARSE_WORD_fortran(iwd+3,CWD_TMP,LL3)
           cflt =  CWD_TMP(1:4)
           EPOCH_IGNORE_CCID(N)  = CCID
           EPOCH_IGNORE_FILT(N)  = cflt
           EPOCH_IGNORE_MJD(N)   = MJD8

           LL = INDEX(CCID,' ' ) - 1
           IF ( LL .LE. 0 ) LL = MXCHAR_CCID

c           write(6,55) N, CCID(1:LL), MJD8, cflt
c55         format(T4,I3,': Add ignore-epoch to list for CID=',A, 
c     &         3x,'MJD=',F9.3, 2x,'FILT=',A)

         endif

c May 2021: check for PHOTFLAGs to reject epochs
         NOTSET = (PHOTFLAG_MSKREJ(1) < 0)
         if ( cwd .EQ. 'PHOTFLAG_MSKREJ:' .and. NOTSET ) then
            CALL get_PARSE_WORD_fortran(iwd+1,cwd_tmp,LL1)
            read(cwd_tmp,*) PHOTFLAG_MSKREJ(1)
         endif

         if ( cwd .EQ. 'PHOTFLAG_BITLIST_REJECT:' ) then
            CALL get_PARSE_WORD_fortran(iwd+1,STRING_BITLIST,LL1)
         endif

200   ENDDO

      EPOCH_IGNORE_LASTFILE = LOCAL_FILENAME
      call FLUSH(6)

C -------------------------------------------
8000  CONTINUE

c parse BITLIST after reading IGNORE file to avoid parse_WORD conflicts
      NOTSET = (PHOTFLAG_MSKREJ(1) < 0)
      IF ( STRING_BITLIST .NE. ' ' .and. NOTSET ) THEN
         PHOTFLAG_MSKREJ(1) = 0 
         LL = INDEX(STRING_BITLIST,' ') - 1
         NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_STRING,
     &            STRING_BITLIST(1:LL)//char(0), FNAM//char(0), LL, 30)
         do iwd = 1, NWD
            CALL get_PARSE_WORD_fortran(iwd,cwd_tmp,LL1)
            read(cwd_tmp,*) BIT
            PHOTFLAG_BITLIST_REJECT(iwd) = BIT
            PHOTFLAG_MSKREJ(1) = IBSET(PHOTFLAG_MSKREJ(1),BIT)
         enddo
      ENDIF

c if PHOTFLAG_MSKREJ is still negative, then it has not been set;
c in this case, set it to zero so that it doesn't reject anything.
      IF ( PHOTFLAG_MSKREJ(1) < 0 ) PHOTFLAG_MSKREJ(1) = 0 

      if ( NEPOCH_IGNORE > 0 ) then
         FOUND_EPIGNORE = .TRUE.
         write(6,801) NEPOCH_IGNORE
 801     format(T5,'EPOCH_IGNORE: Found ', I5,' epochs to IGNORE')
      endif

      if ( PHOTFLAG_MSKREJ(1) > 0 ) then
         write(6,802) PHOTFLAG_MSKREJ(1) 
         FOUND_EPIGNORE = .TRUE.
 802     format(T5,'EPOCH_IGNORE: ignore epochs with PHOTFLAG & ', I8 )
      endif

      if ( .NOT. FOUND_EPIGNORE ) then
         print*,'   EPOCH_IGNORE: ' // 
     &          'No epochs are ignored => use all epochs. '
      endif
      print*,' '

      CALL FLUSH(6)

      RETURN
      END  ! end of READ_EPIGNORE_FILE

C =============================
+DECK,PASS_EPIGNORE_FILE.
      LOGICAL FUNCTION PASS_EPIGNORE_FILE(EP)

c Created Feb 2021
c Returns True if this epoch (EP) is NOT listed in the 
c epoch IGNORE file associated with VERSION.IGNORE,
c or with user input EPOCH_IGNORE_FILE.
c Note that cuts are NOT applied here; this function simply
c checks against an already existing list of epochs to ignore.
c       

      IMPLICIT NONE
      
      INTEGER EP ! (I) epoch index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER  i, LL, ifilt_obs
      LOGICAL  LFILT, IGNORE, LMJD, LCID
      REAL*8    MJD8
      CHARACTER CFILT*2, CCID*(MXCHAR_CCID)

C --------------- BEGIN ----------

      IGNORE = .FALSE.

      DO 100 i = 1, NEPOCH_IGNORE

        CCID = SNLC_CCID
        LL   = ISNLC_LENCCID
        LCID = EPOCH_IGNORE_CCID(i)(1:LL) .EQ. CCID(1:LL)
        IF ( .NOT. LCID ) GOTO 100

c leave big margin for MJD check (.002 days) in case IGNORE 
c file has round-off errors for the MJD.
        MJD8 = SNLC8_MJD(ep)
        LMJD = ( ABS(EPOCH_IGNORE_MJD(i)-MJD8) < 0.002 )
        IF ( .NOT. LMJD ) GOTO 100

        ifilt_obs = ISNLC_IFILT_OBS(ep)
        cfilt     = filtdef_string(ifilt_obs:ifilt_obs)
        LFILT     = EPOCH_IGNORE_FILT(i)(1:1) .EQ. CFILT(1:1)
        IF ( .NOT. LFILT ) GOTO 100

c if we get here, then give message to ignore epoch 
c and skip down to over-write part.

        IGNORE = .TRUE.

        IF ( STDOUT_UPDATE ) THEN
          write(6,101) CCID, MJD8, cfilt
        ENDIF
101     format(T8,'IGNORE EPOCH FOR: CID=',A8, 
     &         3x,'MJD=',F9.3, 3x,'FILT=',A )

100   CONTINUE

      PASS_EPIGNORE_FILE = (.NOT. IGNORE)

      RETURN
      END    ! PASS_EPIGNORE_FILE

C ================================================
+DECK,CHKFMT.
      SUBROUTINE CHECK_FORMAT()

c Created Jun 15, 2011 by R.Kessler
c Check if format is FITS or TEXT; 
c set global logical FORMAT_FITS or FORMAT_TEXT
c
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITSCOM.

      INTEGER    IVERS, OPT, ISTAT, LEN_VERS, LEN_PATH
      CHARACTER  VERSION*(MXCHAR_VERSION), PATH*(MXCHAR_PATH)

C ------------ BEGIN -----------

c check for subfolder; e.g., VERSION_PHOTOMETRY = 'JLA2014/JLA2014_CSP'
      CALL PREP_VERSION_SUBFOLDER()

c use first version on list since all versions must have same format
      IVERS    =  1  
      VERSION  = VERSION_PHOTOMETRY(ivers)
      LEN_VERS = INDEX(VERSION,' ') - 1
      VERSION  = VERSION(1:LEN_VERS) // char(0)

      LEN_PATH = INDEX(PRIVATE_DATA_PATH,' ') - 1
      PATH     = PRIVATE_DATA_PATH(1:LEN_PATH) // char(0)

      OPT      = 1  ! option to check format and return 
      ISTAT    = RD_SNFITSIO_PREP(OPT, PATH, VERSION, 
     &     LEN_PATH, LEN_VERS)

      IF ( ISTAT .GT. 0 ) THEN
         FORMAT_FITS = .TRUE.
      ELSE
         FORMAT_TEXT = .TRUE.
      ENDIF

      RETURN
      END      ! end CHECK_FORMAT


C ================================================
+DECK,SELEP_DRIVER.
      SUBROUTINE SELECT_EPOCH_DRIVER(OPT)

c Created Feb 2021 (used by REFAC_READ_DATA)
c
c OPT += 1 -> Apply all epoch cuts except for Trest 
c                 (e..g, before calling SET_PEAKMJD
c
c OPT += 2 -> Apply only Trest cut (e.g, after SET_PEAKMJD)
c
c OPT  = 3 -> apply all obs/epoch cuts

      IMPLICIT NONE

      INTEGER OPT  ! (I)

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PKMJDCOM.

      REAL*8    MJD8, MJD8_LAST
      INTEGER   NMJD_STORE_NEW, NMJD_STORE_ORIG, NEWMJD
      INTEGER   EPMIN, EPMAX, ep_orig, ep_new, IMJD
      INTEGER   IFILT, IFILT_OBS
      REAL      PEAKMJD, MJD, TOBS, TREST, z1, z
      LOGICAL   APPLY_CUTS, APPLY_TREST
      LOGICAL   PASS_CUTS, PASS_TREST, PASS
      CHARACTER FNAM*20

c function
      LOGICAL PASS_EPOCH_CUTS, PASS_EPOCH_TREST

c ------------------- BEGIN -------------------

      FNAM = 'SELECT_EPOCH_DRIVER'
      NMJD_STORE_NEW  = 0
      NMJD_STORE_ORIG = ISNLC_NEWMJD_STORE
      EP_NEW          = 0 
      MJD8_LAST       = -9.0

      APPLY_CUTS  = BTEST(OPT,0)
      APPLY_TREST = BTEST(OPT,1)

      DO 101 NEWMJD = 1, ISNLC_NEWMJD_STORE
         EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
         EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

         PASS_CUTS  = .TRUE.
         PASS_TREST = .TRUE.

         if ( APPLY_CUTS ) then
            PASS_CUTS = PASS_EPOCH_CUTS(1,EPMIN)
         endif

         if ( APPLY_TREST ) then
            PEAKMJD = SNLC_SEARCH_PEAKMJD
            z       = SNLC_REDSHIFT
            PASS_TREST = PASS_EPOCH_TREST(z,PEAKMJD,EPMIN)
         endif

         PASS = PASS_CUTS .and. PASS_TREST

         if ( .NOT. PASS ) goto 101

         NMJD_STORE_NEW = NMJD_STORE_NEW + 1
         IMJD           = NMJD_STORE_NEW
         ISNLC_NFILT_NEWMJD(IMJD) = ISNLC_NFILT_NEWMJD(NEWMJD)

c overwrite EPOCH-dependent arrays to exclude rejected epochs

        DO 102 EP_ORIG = EPMIN, EPMAX

         EP_NEW = EP_NEW + 1

         MJD8  = SNLC8_MJD(EP_ORIG)
         if ( MJD8 > MJD8_LAST ) then
            if ( EP_ORIG == EPMIN ) then
              ISNLC_EPOCH_RANGE_NEWMJD(1,IMJD) = EP_NEW
            endif
              ISNLC_EPOCH_RANGE_NEWMJD(2,IMJD) = EP_NEW
         endif
         MJD8_LAST = MJD8          

         if ( EP_NEW > EP_ORIG ) then
            CALL PRINT_PREABORT_BANNER(FNAM//char(0),40)
            print*,'    OPT = ', OPT
            print*,'    EPMIN, EPMAX = ', EPMIN, EPMAX
            print*,'    NEWMJD(ORIG,NEW) = ', NEWMJD, IMJD
            write(c1err,61) EP_NEW, EP_ORIG
61          format('Invalid EP_NEW=',I4, ' > EP_ORIG=',I4)
            c2err = 'Something is messed up.'
            CALL MADABORT(FNAM, c1err, c2err)
         endif

         CALL MOVE_SNLC_ARRAYS(EP_NEW,EP_ORIG)

102     CONTINUE
101     CONTINUE

      ISNLC_NEWMJD_STORE = NMJD_STORE_NEW

      RETURN
      END    ! end SELECT_EPOCH_DRIVER


C ===========================================
+DECK,PASS_EP_CUTS.
      LOGICAL FUNCTION PASS_EPOCH_CUTS(OPTMASK,EP)

C Created Feb 2021
C Return TRUE if epoch passes explicit epoch cuts such as 
c PSF, PHOTFLAG, etc ..
c   (no implicit cuts such as TREST)
c
c Mar 25 2021: init BADPHOT=F (bug fix)
c -----------------

      IMPLICIT NONE

c input args
      INTEGER OPTMASK, EP  ! (I)

c local args

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PKMJDCOM.

      INTEGER PHOTFLAG, OV, i, IFILT, IFILT_OBS, IDFIELD
      LOGICAL BADPHOT, REJECT, LXMJD, LTMP, NO_DETECT
      REAL    ZP, PSF, MJD, SNR
c functions
      LOGICAL PASS_EPIGNORE_FILE, SELECT_EARLYLC

C ----------- BEGIN ------------

      PASS_EPOCH_CUTS = .TRUE.  ! init return arg
      REJECT          = .FALSE.

      IFILT_OBS = ISNLC_IFILT_OBS(EP)
      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs)
      IDFIELD   = ISNLC_IDFIELD(EP)  
      PHOTFLAG  = ISNLC_PHOTFLAG(ep)
      ZP        = SNLC_ZEROPT_forCUT(ep) 
      PSF       = SNLC_PSF_FWHM_ARCSEC(EP)
      MJD       = SNGL(SNLC8_MJD(ep))

c Jul 2020: check option to write list of rejected epochs
+SELF,IF=SNANA.
      CALL WRITE_EPOCH_IGNORE_EXEC(ep)
+SELF.

      if ( .NOT. PASS_EPIGNORE_FILE(EP) ) then
         PASS_EPOCH_CUTS = .FALSE.
         return
      endif

c ----------------------------------------------
c now check PHOTFLAG mask.

      BADPHOT = .FALSE.  

c check OR-logic 
c ==> reject epoch if any PHOTFLAG_MSKREJ bit is set
      OV   = IAND ( PHOTFLAG_MSKREJ(1), PHOTFLAG )
      IF ( OV > 0 ) THEN
         BADPHOT = .TRUE.  ;  REJECT  = .TRUE.
      ENDIF

c Now check AND logic 
c ==> reject epoch if all PHOTFLAG_MSKREJ(2:5) bits are set

      do i = 2, 5
        OV   = IAND ( PHOTFLAG_MSKREJ(i), PHOTFLAG )
        IF ( OV > 0 .and. OV == PHOTFLAG_MSKREJ(i) ) THEN
             BADPHOT = .TRUE. ; REJECT  = .TRUE.
        ENDIF
      enddo

c ----------------------
c Check EARLY-epoch select logic (Mar 2015)

      IF ( .not. SELECT_EARLYLC(ep) ) REJECT = .TRUE.

c -------------------------------------
c July 11 2020
c  Check cuts on PSF and ZP ... doesn't change analysis,
c  but allows new OUT_EPOCH_IGNORE_FILE option to work properly.

c xxx      IF( RESTORE_DES3YR ) GOTO 600 ! skip ZP and PSF cut for DES3YR

      IF ( ZP < CUTWIN_ZP(1)   ) REJECT = .TRUE.
      IF ( ZP > CUTWIN_ZP(2)   ) REJECT = .TRUE.

      IF ( PSF < CUTWIN_PSF(1) ) REJECT = .TRUE.
      IF ( PSF > CUTWIN_PSF(2) ) REJECT = .TRUE.

c MJD cut 
      LXMJD = ( MJD > CUTWIN_MJD_EXCLUDE(1) .and.
     &          MJD < CUTWIN_MJD_EXCLUDE(2) )
      IF ( LXMJD ) REJECT = .TRUE.

      IF ( MJD < CUTWIN_MJD(1) ) REJECT = .TRUE.
      IF ( MJD > CUTWIN_MJD(2) ) REJECT = .TRUE.

c - - - - - - - - - - - - 
c reject epochs for filter band that has SNRMIN > 99
      if ( IFILT < 900 ) then
        if ( CUTWIN_SNRMIN_FILT(1,IFILT) > 99.9999 ) REJECT = .TRUE.
      endif

c check selected field.
      LTMP = DOALL_SNFIELD .or. (IDFIELD > 0)
      IF ( .NOT. LTMP ) REJECT = .TRUE.

c Sep 2020: apply SNR cut for non-detections - to reject crazy fluxes.
      IF ( PHOTFLAG_DETECT > 0 ) THEN
         NO_DETECT = ( IAND(PHOTFLAG,PHOTFLAG_DETECT) == 0 )
         SNR       = SNLC_FLUXCAL(EP) / SNLC_FLUXCAL_ERRTOT(EP)
         if ( NO_DETECT ) then
            if ( SNR < CUTWIN_SNR_NODETECT(1)  ) REJECT = .TRUE.
            if ( SNR > CUTWIN_SNR_NODETECT(2)  ) REJECT = .TRUE.
         endif
      ENDIF

c ----------------------------
 600  CONTINUE

c set return-function value
      PASS_EPOCH_CUTS = ( .not. REJECT)

c check option to count BAD PHOTOMETRY epochs based on PHOTFLAG
      IF ( BTEST(OPTMASK,0) ) THEN
         NEPOCH_TOT = NEPOCH_TOT + 1
         IF ( .NOT. REJECT)  NEPOCH_USE = NEPOCH_USE + 1
         IF ( BADPHOT ) THEN
            NEPOCH_BADPHOT     = NEPOCH_BADPHOT     + 1
            NEPOCH_BADPHOT_SUM = NEPOCH_BADPHOT_SUM + 1
         ENDIF
      ENDIF


      RETURN
      END     ! end PASS_EPOCH_CUTS

C = = = = = = = = = = = = = = = = =
+DECK,PASS_EP_TREST.
      LOGICAL FUNCTION PASS_EPOCH_TREST(z,PEAKMJD,EP)

C Created Feb 2021
C Return TRUE if epoch passes TREST cut
     
      IMPLICIT NONE

c input args
      REAL z, PEAKMJD  ! (I) redshift and peak MJD
      INTEGER EP       ! (I) epoch index to check Trest cut

c local args

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PKMJDCOM.

      REAL MJD, ZZ, Trest
      LOGICAL VALID_PEAKMJD

C ----------- BEGIN ------------

      PASS_EPOCH_TREST = .TRUE.

      VALID_PEAKMJD = ( PEAKMJD > 40000.  )  ! valid PEAKMJD

c evaluate epoch cut in rest-frame
      IF ( VALID_PEAKMJD ) THEN
         ZZ = 1.0                       ! if no valid z
         IF ( z > 0.0 ) ZZ  = 1.0 + z   ! valid z
         MJD   = SNGL( SNLC8_MJD(EP) )
         Trest = (MJD - PEAKMJD) / ZZ

         PASS_EPOCH_TREST = 
     &        ( Trest .GE. cutwin_Trest(1) .and. 
     &          TRest .LE. cutwin_Trest(2) )
      ENDIF

      RETURN
      END     ! end PASS_EPOCH_TREST


C =============================
+DECK,PASS_SNTYPE.
      LOGICAL FUNCTION PASS_SNTYPE(itype)
c
c Created Feb 22 2021 [modified from SNTYPESTAT]
c
c Returns True if ITYPE passes cuts; returns false otherwise.
c Also increments global NACCEPT_TYPE if ITYPE is valid.
c
c Jul 12 2021: abort if ITYPE < 0
c Mar 08 2022: apply CUTWIN_SNTYPE
c -------------------------

      IMPLICIT NONE

c function args

      INTEGER  ITYPE  ! SN-integer type from data header

c local args

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER FNAM*12
      INTEGER i
      REAL RTYPE

C -------------- BEGIN --------------

      FNAM = 'PASS_SNTYPE'
      PASS_SNTYPE = .FALSE.

      IF ( ITYPE < 0 ) THEN 
         write(c1err,61) ITYPE, SNLC_CCID
         write(c2err,62) MXTYPE
61       format('Invalid data header TYPE = ', I6, ' for CID=',A )
62       format('Valid TYPE range is 0 to ', I5)
         CALL MADABORT(FNAM, c1err, c2err)
      ENDIF

      do i = 1, NSNTYPE_IGNORE
        if ( SNTYPE_IGNORE(i) .EQ. ITYPE ) then
           PASS_SNTYPE = .FALSE.
           RETURN
        endif
      enddo

      RTYPE = float(ITYPE)
      IF ( RTYPE < CUTWIN_SNTYPE(1) ) RETURN
      IF ( RTYPE > CUTWIN_SNTYPE(2) ) RETURN

      IF ( NSNTYPE_LIST .LE. 0 ) THEN  
         ! don't check  anything
         PASS_SNTYPE = .TRUE.
         RETURN
      ENDIF


      do i = 1, NSNTYPE_LIST
        if ( SNTYPE_LIST(i) .EQ. ITYPE ) PASS_SNTYPE = .TRUE.
      enddo

      IF ( PASS_SNTYPE ) THEN
         NACCEPT_TYPE = NACCEPT_TYPE + 1
      ELSE 
         IF ( LDMP_SNFAIL ) then
              print*,'  ** WARNING ** CID= ',snlc_ccid,
     &       ' (TYPE=',itype,')  FAILS TYPE CUT '
         endif
      endif

      RETURN
      END  ! end PASS_SNTYPE


C ======================================
+DECK,UNPSTR.
      SUBROUTINE UNPACK_SNFITSIO_STR(NVAL,KEYNAME,STRING)

c
c  Created Jun 2011
c  Following a call to RD_SNFITSIO_STR(IROW, KEYNAME, STRING ..)
c  this routine unpacks and decodes the retured STRING and fills 
c  the following arrays,
c
c  KEYNAME    filled array
c   FLT       ISNLC_IFILT_OBS
c   FIELD     ISNLC_IDFIELD & SNLC_FIELD
c
c Feb 11 2021: fix computation of LENS (length of STRING)
c -----------------------------

      IMPLICIT NONE

      INTEGER 
     &   NVAL    ! (I) expect number of values to extract from STRING

      CHARACTER 
     &   KEYNAME*(*)  ! (I) table par name read from fits file
     &  ,STRING*(*)   ! (I) string returned from RD_SNFITSIO_STR

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER iwd, LWD, NWD, LK, LENS, MSKOPT
      CHARACTER  CWD*80, FNAM*30
      LOGICAL LVAR_FLT, LVAR_FIELD

c functions
      INTEGER  FILTINDX_REPLACE, GET_IDFIELD

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ----------------- BEGIN --------------

      IF ( NVAL .LT. 0 ) RETURN  ! all epochs fail cut (May 16, 2012)

      FNAM = 'UNPACK_SNFITSIO_STR'

c determine variable type from KEYNAME

      LVAR_FLT   = .FALSE.
      LVAR_FIELD = .FALSE.

      IF ( KEYNAME(1:3) .EQ. 'FLT' ) THEN
        LVAR_FLT = .TRUE.
      ELSE IF ( KEYNAME(1:5) .EQ. 'FIELD' ) THEN
        LVAR_FIELD = .TRUE.
      ELSE
        c1err = 'Unrecognized KEYNAME = ' // KEYNAME
        c2err = 'Check FITS table.'
        CALL MADABORT('UNPACK_SNFITSIO_STR', c1err,c2err)
      ENDIF

c break up STRING into substrings 
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      LENS   = INDEX(STRING//' ',' ' ) - 1  ! Feb 2021

cc      print*,' xxx UNPACK: ', LENS, '|', STRING, '|'
      NWD    = STORE_PARSE_WORDS(MSKOPT, STRING(1:LENS)//char(0),
     &            FNAM//char(0), LENS, 30 )

      IF  ( NWD .NE. NVAL ) THEN
        LK = INDEX(KEYNAME//' ' ,' ') -1 
        CALL PRINT_PREABORT_BANNER("UNPACK_SNFITSIO_STR"//char(0),40)
        print*,'   NWD, NVAL = ', NWD, NVAL
        print*,'   SNLC_CCID = ', SNLC_CCID
        print*,'   KEYNAME   = ', KEYNAME,'      LENKEY=', LK
	print*,'   ISVAR_[FLT,FIELD] = ', 
     &         LVAR_FLT, LVAR_FIELD
        print*,'   LEN(STRING) = ', LENS
        print*,'   STRING = ', STRING(1:1000)
        call flush(6)

        write(c1err,61) NWD, NVAL
     &                  
        write(c2err,62) 
     &       SNLC_CCID(1:ISNLC_LENCCID)
     &      ,KEYNAME(1:LK)

61      format('NWD=',I5,' substrings, but expected NVAL=',I6)
62      format('CID=',A, 2x, 'KEYNAME=',A )
        CALL MADABORT('UNPACK_SNFITSIO_STR', c1err,c2err)

      ENDIF

      DO 100 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd,CWD,LWD)

         if ( LVAR_FLT ) then
            ISNLC_IFILT_OBS(iwd) = FILTINDX_REPLACE(CWD)
         else if ( LVAR_FIELD ) then
            SNLC_FIELD(iwd)    = CWD(1:LWD)
            ISNLC_IDFIELD(iwd) = GET_IDFIELD(CWD)       
         endif

+SELF,IF=DEBUG.
         if ( LVAR_FLT .and. isn .EQ. 1 .and. iwd .lt. 5 ) then
           print*,' xxx iwd=',iwd,'  IFILT_OBS=',ISNLC_IFILT_OBS(iwd)
         endif

         if ( LVAR_FIELD .and. isn .EQ. 1 .and. iwd .lt. 5 ) then
           print*,' xxx iwd=',iwd,
     &         '  FIELD=',SNLC_FIELD(iwd), ISNLC_IDFIELD(iwd)
         endif
+SELF.

100   CONTINUE

      RETURN
      END
C ========================================
+DECK,FITSABORT.
      SUBROUTINE CHECK_FITSABORT(IVERS,NRD,KEY)

c Created Jun 16, 2011
c ABORT if NRD = 0 or of NRD exceeds bound of MXEPOCH
c Call this routine after each fits-read for a REQIURED key.
c
c Note that NRD = -9 is OK because this means that
c all epochs failed the epoch-MASK  cuts.

      IMPLICIT NONE

      INTEGER 
     &  IVERS   ! (I) version index
     & ,NRD     ! (I) Number of elements returned for fits key

      CHARACTER KEY*(*)  ! (I) name of fits key

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER VERSION*100
      INTEGER LK, LV

C ---------- BEGIN ----------


      IF ( NRD .EQ. 0 .or. NRD .GT. MXEPOCH ) THEN

         print*,' ERROR: NRD = ', NRD

         LK = INDEX(KEY,' ') - 1
         c1err = 'Non-existent FITS parameter: ' // KEY(1:LK)
     &           // ' for CID='// SNLC_CCID(1:ISNLC_LENCCID)

         VERSION  = VERSION_PHOTOMETRY(ivers) 
         LV = INDEX(VERSION,' ') - 1
         c2err = 'Check fits files for version ' // VERSION(1:LV)

         CALL MADABORT("CHECK_FITSABORT",c1err, c2err)
      ENDIF

      RETURN
      END



C ==================================
+DECK,PRINT_RDSN.
      SUBROUTINE PRINT_RDSN()

C Called before SNANA_DRIVER, print one-line summary of SN that has 
c been read/parsed.
C
C Apr 19 2022: replace REJECT_PRESCALE with MOD function to have
c              more predictable prints.
C
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER N_UPDATE_PS1, N_UPDATE_PS10, PS_UPDATE

C ------------- BEGIN -----------

c determine STDOUT_UPDATE logical to dump info

      N_UPDATE_PS1  = 50 ! update first 50 events
      N_UPDATE_PS10 = 300
      if ( REDUCE_STDOUT_BATCH ) then
         N_UPDATE_PS1  = 5
         N_UPDATE_PS10 = 100
      endif

      IF ( N_SNLC_PROC < N_UPDATE_PS1 ) THEN
         PS_UPDATE = 1
      ELSE IF ( N_SNLC_PROC < N_UPDATE_PS10 ) THEN
         PS_UPDATE = 10
      ELSE
         PS_UPDATE = 100
      ENDIF

      IF ( FORCE_STDOUT_BATCH ) THEN
         STDOUT_UPDATE = .TRUE.  ! for interactive debug only
      ELSE
         STDOUT_UPDATE = (MOD(N_SNLC_PROC,PS_UPDATE) .EQ. 0)
      ENDIF


      if ( .NOT. STDOUT_UPDATE ) RETURN

      print*,' *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-' //
     &       '*-*-*-*-*-*-*-*-*-*-*-*-*-*-'

      IF ( SNLC_CASTCID .EQ. 'CHAR' ) then
          write(6,30) SNLC_CID, SNLC_CCID(1:ISNLC_LENCCID)
30        format(T4,'Assign integer CID=',I6,' for ', A)
      endif

      write(6,200)
     &      SNLC_CCID
     &    , ISNLC_NEWMJD_FOUND
     &    , ISNLC_NEWMJD_STORE

200   format(T5,' Done Reading CID ', A16, 
     &       2x, 'NMJD(found,stored)=', I4,1x,I4 )

      CALL FLUSH(6)
      RETURN
      END      ! end PRINT_RDSN

C =================================
+DECK,SET_HOSTGAL_PREFIX.
      SUBROUTINE SET_HOSTGAL_PREFIX(IGAL,PREFIX,LENPRE)

c Feb 2019
c For inoput IGAL, return PREFIX = 'HOSTGAL' or 'HOSTGAL2', etc ..,
c along with LENPRE = length of PREFIX string.
c The output is used for parsing and writing output.
      IMPLICIT NONE
      INTEGER IGAL         ! (I) 1,2 ... host-match index
      CHARACTER PREFIX*20  ! (O) key prefix
      INTEGER LENPRE       ! (O) length of prefix string

      IF ( IGAL == 1 ) THEN
         PREFIX = 'HOSTGAL'; LENPRE=7
      ELSE
         write(PREFIX,20) IGAL
 20      format('HOSTGAL',I1.1)
         LENPRE = 8
      ENDIF
      RETURN
      END

C ==================================
+DECK,SET_EPVAR_MISC.
      SUBROUTINE SET_EPVAR_MISC(ep)
c Created Jul 11 2020: 
c Compute a few misc variables from those read from data files
c   + SNLC_ZEROPT_forCUT(ep) based on cut in ADU or Npe
c   + SNLC_PSF_FWHM_ARCSEC(ep)

      IMPLICIT NONE
      INTEGER ep      ! (I) epoch index

+CDE,SNDATCOM.
+CDE,SNLCINP.
      REAL   ZPADD_pe, GAIN
      REAL*8 PSFSIG1, PSFSIG2, PSFRAT, NEA

      EXTERNAL NoiseEquivAperture
      REAL*8   NoiseEquivAperture

c -------------- BEGIN ------------

      SNLC_ZEROPT_forCUT(ep) = SNLC_ZEROPT(ep) ! default is ADU
      
      if ( cutwin_zpNPE(1) > 0. ) then
         GAIN     = SNLC_GAIN(ep)

         if ( GAIN < 0.01 ) then
            GAIN = 0.001  ! -> results in very low ZP that should fail cut
         endif

         ZPADD_pe = 2.5*log10(GAIN)
         SNLC_ZEROPT_forCUT(ep) = SNLC_ZEROPT(ep) + ZPADD_pe
      endif

c if PSF unit is NEA, convert back to effected PSF-sigma;
c otherwise compute and store NEA
      IF ( UNIT_PSF_NEA ) then
         NEA     = DBLE(SNLC_PSF_NEA(ep))
         PSFSIG1 = SQRT(NEA/(4.0*PI))
         SNLC_PSF_SIG1(ep)  = SNGL(PSFSIG1)
         SNLC_PSF_SIG2(ep)  = 0.0
         SNLC_PSF_RATIO(ep) = 0.0
      else
         PSFSIG1 = DBLE(SNLC_PSF_SIG1(ep))
         PSFSIG2 = DBLE(SNLC_PSF_SIG2(ep))
         PSFRAT  = DBLE(SNLC_PSF_RATIO(ep))
         NEA     = NoiseEquivAperture(PSFSIG1,PSFSIG2,PSFRAT)
         SNLC_PSF_NEA(ep) = SNGL(NEA)
      endif

      SNLC_PSF_FWHM_ARCSEC(ep) = 
     &   SNLC_PSF_SIG1(ep) * (SNLC_PIXSIZE * 2.355)

      RETURN 
      END        ! end SET_EPVAR_MISC

C =================================
+DECK,CHECKSTRING_CCID.
      SUBROUTINE CHECKSTRING_CCID(CCID)

c  Jun 2016: abort if illegal char in SNLC_CCID

      IMPLICIT NONE
      CHARACTER CCID*(*)
       
c local
      INTEGER NBADCHAR, ichar
      PARAMETER  (NBADCHAR = 14)
      CHARACTER  BADCHAR_LIST*(NBADCHAR)
      CHARACTER  c1err*44, c2err*44, c1*2
C ----------- BEGIN ---------------

      BADCHAR_LIST = ':;!@#$%^&*()=?'

      DO 100 ichar = 1, NBADCHAR
         C1 = BADCHAR_LIST(ichar:ichar)
         IF ( INDEX(CCID,C1) > 0 ) THEN
            c1err = 'Invalid CCID name = ' // CCID
            c2err = 'because it contains invalid char = ' // c1
            CALL MADABORT('CHECKSTRING_CCID', c1err, c2err)
         ENDIF
100   CONTINUE

      RETURN
      END

C ==============================
+DECK,CHKFLTKEY.
      SUBROUTINE CHECK_FILTERS_KEY(FILTERS)

C Apr 2013  [code moved from PARSE_HEAD]
C Called from PARSE_HEAD for text files to check that
C FILTERS argument is always the same. Abort if the
C FILTERS argument ever changes.
C
C -------------

      IMPLICIT NONE

      CHARACTER FILTERS*(*)  ! (I) argument of "FILTERS:" key

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER   NFILT, IFILT, itmp, IFILT_OBS
      CHARACTER cfilt1*2

c functions
      INTEGER FILTINDX

C ---------------- BEGIN ----------------

      NFILT     = INDEX ( FILTERS//' ', ' ' ) - 1

      DO itmp       = 1, NFILT
         cfilt1     = FILTERS(itmp:itmp)
         ifilt_obs  = FILTINDX(cfilt1)
         IFILT      = IFILTDEF_INVMAP_SURVEY(ifilt_obs)              
         
c check if sparse index is valid.
c Apr 2013: better error messaging.

         if ( ifilt .LE. 0 ) then                      
            CALL PRINT_PREABORT_BANNER("PARSE_HEAD"//char(0),40)
            print*,' FILTERS  defined in 1st data file:'
            print*,'      ', SURVEY_FILTERS(1:NFILTDEF_SURVEY)
            print*,' FILTERS  defined for ' 
     &           // SNLC_CCID(1:ISNLC_LENCCID), ' : '
            print*,'      ', FILTERS(1:NFILT)
            print*,'  --> FILTERS argument must be the same ',
     &                'in each data file. '
            
            c1err = 'Filter ' // cfilt1 // ' is unrecognized '
     &           // ' for CID=' // SNLC_CCID(1:ISNLC_LENCCID) // ' ; '
            
            c2err = 'see PRE-ABORT comments above.'
            CALL MADABORT("PARSE_HEAD", c1err, c2err)
         endif
         
      ENDDO                     ! end of ITMP loop

      RETURN
      END


C ===================================
+DECK,PRSPAREN.
      SUBROUTINE PARSE_PARENTHESES(INKEY,OUTSTR)

c Parse inKey to extract varName from ().
c Example:
c   Input : INKEY   = SIMSED_PARAM(COSANGLE)
c  -->
c   Ouptut: OUTSTR = COSANGLE
c
c ---------------------
      IMPLICIT NONE

c subroutine args
      CHARACTER INKEY*(*)   ! (I) input key with varname in ()
      CHARACTER OUTSTR*(*)  ! (O) string in ()


c local args
      INTEGER J1, J2, LK
      CHARACTER C1ERR*72, C2ERR*72
c -------------- BEGIN ---------------

      J1 = INDEX( INKEY , '(' ) 
      J2 = INDEX( INKEY , ')' ) 

      IF ( J1 .EQ. 0 .or. J2 .EQ. 0 ) THEN
         LK = INDEX( INKEY, ' ' ) - 1
         c1err = 'Invalid INKEY = ' // INKEY(1:LK)
         c2err = 'Expecting to find key-string  SIMSED_XXX(PARNAME)'
         CALL MADABORT("PARSE_PARENTHESES", c1err,c2err)
      ENDIF

      OUTSTR = INKEY(j1+1:j2-1)

      RETURN
      END    ! end of PARSE_PARENTHESES


C ====================================
+DECK,PARSE_CID.
      SUBROUTINE PARSE_CID ( ccid, iauc, cid, USECID )
c
c Convert character string CCID into integer CID.
c Returns logical USECID=T if this CID should be processed.
c
c
c Jul 28 2014; allow ABORT_ON_DUPLCID=F to count duplicates without aborting
c
c Jul 31 2015: move GET_INTERP_MJDLIST call before LCIDSELECT call
c
c Dec 2 2015: pass IAUC arg.
c
c ---------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,INTERPCM.

      CHARACTER  CCID*(*)  ! (I) character string for CID
      CHARACTER  IAUC*(*)  ! (I) char string for IAUC name
      INTEGER    CID       ! (O) integer CID
      LOGICAL    USECID    ! (O) T => process this CID

c local var

      INTEGER LCHAR, NMJD, ISTAT
      LOGICAL  USECID_LOCAL, ADDFLAG, LDUPL

      REAL*8  MJD8LIST(MXINTERP)

c function
      INTEGER CIDASSIGN, EXEC_CIDMASK
      LOGICAL LCIDSELECT

C --------------- BEGIN --------------

      CID = 0
      USECID = .FALSE.

c check if this CID should be processed.
      LCHAR = INDEX ( CCID, ' ' ) - 1
      LCHAR = MIN(MXCHAR_CCID,LCHAR) ! check limit on Number of chars

c convert char-string to integer CID
      CID = CIDASSIGN(CCID)

      IF ( CID .LE. 0 ) THEN
        c1err = 'Cannot determine integer CID for: ' // CCID
        write(c2err,602)  LCHAR
602     format('LEN(CCID) = ', I5 )
        CALL MADABORT("PARSE_CID", c1err, c2err)
      ENDIF

      IF ( CID > MXCID ) THEN
        write(c1err,611) CID, MXCID
        C2err = '   '
611     format('CID=',I9,' exceeds MXCID=',I9 )
        CALL MADABORT("PARSE_CID", c1err, c2err)
      ENDIF


c check for CIDs to interpolate (May 18, 2012)
      CALL GET_INTERP_MJDLIST(CCID, NMJD, MJD8LIST, ADDFLAG)
      IF ( ADDFLAG ) THEN
          NCCID_LIST = NCCID_LIST + 1
          SNCCID_LIST(NCCID_LIST) = CCID  ! Dec 4 2012
          USECID_LOCAL = .TRUE.
          GOTO 800
      ENDIF

c ----------------------------------------------------
      IF ( .NOT. LCIDSELECT(cid,ccid,iauc) ) RETURN
      SNLC_CCID      = CCID    ! in case CCID -> IAUC (Dec 3, 2015)
      ISNLC_LENCCID  = INDEX(CCID,' ') - 1  ! Mar 20 2016
      USECID_LOCAL   = .TRUE.
      GOTO 800

c ---------------------------
800   CONTINUE

      IF ( CID < MXCID_CHECK ) THEN
        ISTAT = EXEC_CIDMASK(2,CID)  ! returns 1 if CID bit is set
        LDUPL = (ISTAT > 0 )
      ELSE
        LDUPL = .FALSE. ! cannot check duplicates for very large CID
      ENDIF

      IF ( USECID_LOCAL ) THEN

c if this CID has already been used (found), abort.

        if ( LDUPL  ) THEN 

          IF ( ABORT_ON_DUPLCID ) then
            write(c1err,801) CID, CCID(1:LCHAR)
801         format('CID= ',I9, ' (',A, ') appears more than once; ' )
            c2err = 'each CID can appear only once.'
            CALL MADABORT("PARSE_CID", c1err, c2err)
          ELSE
             print*,' *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-' //
     &            '*-*-*-*-*-*-*-*-*-*-*-*-*-*-'             
             write(6,866) CCID
 866         format(T10,'!!! DUPLICATE WARNING: reject CID=',A)
             call flush(6)
             N_DUPLICATE_CID = N_DUPLICATE_CID + 1
             return  ! return with USECID=F
          endif
        endif

        IF ( CID < MXCID_CHECK ) THEN
           ISTAT = EXEC_CIDMASK(1,CID)  ! set CID bit
        ENDIF

        NACCEPT_CID = NACCEPT_CID + 1
        USECID      = .TRUE.

      ELSE

        if ( LDMP_SNFAIL ) then
           print*,'  ** WARNING ** CID ',cid,' FAILS CID CUT '
           CALL FLUSH(6)
        endif

      ENDIF

      RETURN
      END  ! end of PARSE_CID


C ============================================
+DECK,GET_IDSURVEY.
      INTEGER FUNCTION GET_IDSURVEY(SURVEY)

      CHARACTER SURVEY*(*)  ! (I) name of survey

c local var
+CDE,SNPAR.
+CDE,CTRLCOM.  

      INTEGER ID, j1, j2
      LOGICAL LMATCH
C ---------- BEGIN ------------

      ID = -9 ; GET_IDSURVEY=-9

      DO 101 i = 1, NSURVEY_LIST
         j1 = index(SURVEY,' ') - 1
         j2 = index(SURVEY_NAME_LIST(i),' ') - 1
         if ( j1 .NE. j2 ) goto 101
         LMATCH = ( SURVEY(1:j1) .EQ. SURVEY_NAME_LIST(i)(1:j2) )
         if ( LMATCH )  ID = IDSURVEY_LIST(i)
101   CONTINUE

      GET_IDSURVEY = ID

      RETURN
      END    ! end GET_IDSURVEY



C =============================================
+DECK,CIDASSIGN.
      INTEGER FUNCTION CIDASSIGN(CCID)
c
c Created May 28, 2008 by R.Kessler
c Assign integer CID to character string CCID
c If CCID is already an integer, then CID = CCID;
c otherwise set CID = IFILE.
c
c Note that if a string-named SN appears in 
c multiple PHOTOMETRY version, it can have
c a different CID in each case. For integer
c CIDs (like SDSS), the CID is always the same.
c
c
c ---------------------

      IMPLICIT NONE
      CHARACTER CCID*(*)  ! (I) 

c local var
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER IERR, CID, LCHAR 

c ----------- BEGIN -------------

      CID = -1 ; IERR=0
      read( ccid, 20 , iostat = IERR ) CID
20    format(I10)    ! was I8

      IF ( IERR .EQ. 0 ) THEN  ! CCID is an integer
         SNLC_CASTCID = 'INT'
      ELSE 
         LCHAR = INDEX ( CCID, ' ' ) - 1
         CID   = ABSO_INDEX
         SNLC_CASTCID = 'CHAR' 
      ENDIF

      CIDASSIGN = CID

      RETURN
      END



C ==============================
+DECK,PARSE_FILTERSTRING.
      SUBROUTINE PARSE_FILTSTRING(OPT,string, NFILT, IFILTDEF, XFILTVAL)

c -------------------------------
c Created May 2008 by R.Kessler
c
c Translate input STRING into filter indices
c and values. Assume STRING is of the form
c
c  STRING = 'cfilt1 xval1  cfilt2  xval2 cfilt2 xval2 ...'
c
c where a float-value follows each single-char
c filter-string.
c
c Oct 26 2015: replace MXFILT_OBS arg with NFILT
c Dec 27 2015: fix bug initializing IFILTDEF and XFILTVAL
c              Loop 1-NFILT instead of 1-MXFILT_OBS
c
c May 20 2016: declare output arrays (MXFILT_OBS) instead of (NFILT)
c
c Feb 20 2017: update to allow multiple bands gluded together.
c              'gri .01'  is equivalent to  'g .01  r .01  i .01'
c
c Feb 4 2020: 
c   + check 'ALL' or 'all' to set same mag for all bands.
c   + fix bug parsing  'abcd 0.02' ; last band value wasn't set.
c
c --------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

c subroutine args
      CHARACTER string*(*)  ! (I) string to parse

      INTEGER  
     &   OPT                  ! (I) 1=> error check obs filter
     &  ,NFILT                ! (O) number of filters in string
     &  ,IFILTDEF(MXFILT_OBS) ! (O) absolute filter indices
     
      REAL  
     &   XFILTVAL(MXFILT_OBS)   ! (O) float values

c local var

      INTEGER iwd, NWD, ifilt_tmp, LEN, NFILT_TMP, NFILT_LAST, i
      INTEGER MSKOPT
      CHARACTER cwd*(MXCHAR_FILEWORD), band*2, FNAM*30
      REAL VAL
      LOGICAL LERR

c function
      INTEGER FILTINDX
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
c --------------- BEGIN ------------

      NFILT = 0
      IFILT_TMP = 0
     
      FNAM = 'PARSE_FILTSTRING'
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD = STORE_PARSE_WORDS(MSKOPT,STRING//char(0), 
     &          FNAM//char(0), 80, 30)

      DO i = 1, MXFILT_OBS
        IFILTDEF(i) = 0
        XFILTVAL(i) = 0.  ! init output to zero
      ENDDO

c - - - - - - - - - - - - -
c Feb 2020: check 'all' option to set same mag error for all filters
      IF ( STRING(1:3) .EQ. 'ALL' .or. STRING(1:3).EQ. 'all' ) then
         iwd = 2
         CALL get_PARSE_WORD_fortran(iwd,cwd,LEN) ! read mag_err
         read(cwd,*) VAL
         do ifilt_tmp = 1, NFILTDEF_SURVEY
           IFILTDEF(ifilt_tmp) = IFILTDEF_MAP_SURVEY(ifilt_tmp)
           XFILTVAL(ifilt_tmp) = VAL
         enddo
         NFILT = NFILTDEF_SURVEY
         RETURN
      ENDIF

c - - - - - - - - - 

      NFILT_LAST = 0
      DO 200 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd,cwd,LEN)

         if ( IFILT_TMP == 0 ) then     
            NFILT_LAST = NFILT
            NFILT_TMP  = LEN
            do i = 1, NFILT_TMP
              BAND            = cwd(i:i)
              NFILT           = NFILT + 1      
              IFILT_TMP       = FILTINDX(BAND)
              IFILTDEF(NFILT) = IFILT_TMP

c require valid observer-filter if OPT=1
              LERR = IFILTDEF_INVMAP_SURVEY(IFILT_TMP) .LE. 0
              if ( LERR .and. OPT==1 ) then
                print*,'  SURVEY_FILTERS = ', SURVEY_FILTERS
                LEN = index(cwd,' ') - 1
                c1err = 'Invalid obs-frame filter = '''
     &             // BAND // ''' from nml string'
                c2err = '= ''' // string(1:60) // '''  '
                CALL MADABORT('PARSE_FILTSTRING', c1err, c2err )
              endif
           enddo
         else
            read(cwd,*) VAL
            do i = NFILT_LAST+1, NFILT_LAST+NFILT_TMP
               XFILTVAL(i) = VAL
            enddo
            ifilt_tmp = 0
         endif
200   CONTINUE


      RETURN
      END   ! PARSE_FILTSTRING


C ====================================================
+DECK,PARSE_INTLIST.
      INTEGER FUNCTION PARSE_INTLIST(STRING_INLIST,OUTLIST)

c Created Jan 25 2018
c Translate comma-separated list of integers in STRING_LIST
c into array of integers (OUTLIST).
c Function returns number of integers in OUTLIST array.
c
      IMPLICIT NONE 

+CDE,SNPAR.
      INTEGER   MXINT
      PARAMETER (MXINT=10)

      CHARACTER STRING_INLIST*60    ! (I) comma-separated list of integers
      INTEGER   OUTLIST(MXINT)      ! (O) output array of integers
     
c local arg

      INTEGER iwd, NWD, LEN, MSKOPT
      CHARACTER CWD*60, C1ERR*72, C2ERR*72, FNAM*30
C function
      INTEGER STORE_PARSE_WORDS

C ---------------- BEGIN ----------------
      FNAM   = 'PARSE_INTLIST'
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      LEN    = INDEX(STRING_INLIST,' ') - 1
      NWD    = STORE_PARSE_WORDS(MSKOPT,STRING_INLIST//char(0),
     &            FNAM//char(0), LEN, 30)

      IF ( NWD > MXINT ) THEN
         write(c1err,61) NWD, MXINT
 61      format('NWD=',I2,' exceeds bound of MXINT=',I2)
         write(c2err,62) STRING_INLIST(1:LEN)
 62      format('STRING_INLIST=',A)
         CALL MADABORT("PARSE_INTLIST", c1err, c2err )
      ENDIF

      DO 200 iwd = 1, NWD
         CALL get_PARSE_WORD_fortran(iwd,cwd,LEN)
         READ(cwd,*) OUTLIST(iwd)
ccc         print*,' xxx ', iwd, OUTLIST(iwd)
 200  CONTINUE

      OUTLIST(NWD+1) = 0

      PARSE_INTLIST = NWD
      RETURN
      END

C ===========================================
+DECK,PARSE_COMMASEP_LIST.
      SUBROUTINE PARSE_COMMASEP_LIST(KEY,LINE) 

c Created May 30 2019
c Parse command LINE argument and load global array
c based on KEY value.
c E.g., KEY = 'SNCCID_LIST and  LINE = '2004hq,2006ab' ->
c    SNCCID_LIST = '2004hq', '2006ab'
c 

      IMPLICIT NONE     
      CHARACTER KEY*(*), LINE*(*)

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER  MSKOPT, NWD, iwd, LL
      INTEGER  STORE_PARSE_WORDS
      CHARACTER WDTMP*60, FNAM*30
      EXTERNAL STORE_PARSE_WORDS

C --------------- BEGIN ------------

      FNAM = 'PARSE_COMMASEP_LIST'
      LL = INDEX(LINE,' ') - 1  
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD    = STORE_PARSE_WORDS(MSKOPT,LINE(1:LL)//char(0),
     &             FNAM//char(0), LL, 30)

      DO iwd = 1, NWD

         if ( KEY .EQ. 'SNCCID_LIST' ) then
            CALL get_PARSE_WORD_fortran(iwd,
     &                   SNCCID_LIST(iwd), LL)

         else if ( KEY .EQ. 'SNCCID_IGNORE' ) then
            CALL get_PARSE_WORD_fortran(iwd,
     &                   SNCCID_IGNORE(iwd), LL)

         else if ( KEY .EQ. 'VERSION_PHOTOMETRY' ) then
            CALL get_PARSE_WORD_fortran(iwd,
     &                   VERSION_PHOTOMETRY(iwd), LL)

         else if ( KEY .EQ. 'PHOTFLAG_BITLIST' ) then
            CALL get_PARSE_WORD_fortran(iwd, WDTMP, LL)
            read(WDTMP,*) PHOTFLAG_BITLIST_REJECT(iwd)
         endif

c        LL = INDEX(SNCCID_LIST(iwd),' ') - 1
c        print*,' xxx SNCCID = |', SNCCID_LIST(iwd)(1:LL), '|'
      ENDDO
 
      RETURN
      END    ! PARSE_COMMASEP_LIST

C ====================================================
+DECK,PARSE_NML_STRLIST.
      INTEGER FUNCTION PARSE_NML_STRINGLIST(STRLIST,NCHAR)

c Created Mar 12 2015 by R.Kessler
c Function returns number of non-null elements,
c and parses strings separated by blanks.
c
c The following inputs all produce the same output
c
c Input: 
c      STRLIST = 'E1', 'E2', 'S1', 'S2'
c          or
c      STRLIST = 'E1 E2 S1 S2'
c          or
c      STRLIST = 'E1 E2',  'S1 S2'

c all produce  Output:  
c    STRLIST = 'E1', 'E2', 'S1', 'S2'  
c    and FUN=4
c
c ------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
c +CDE,PARSECOM.

      INTEGER NCHAR   ! (I)
      CHARACTER STRLIST(MXLISTNML)*(NCHAR) ! (I,O)

c local var

      CHARACTER STRLIST_LOCAL(MXLISTNML)*(NCHAR), FNAM*30
      INTEGER i, j, NLIST, iwd, NWD, LL, MSKOPT

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
      
C ------------- BEGIN ------------

      FNAM = 'PARSE_NML_STRINGLIST'

      NLIST = 0 
      MSKOPT = MSKOPT_PARSE_WORDS_STRING

c transfer input string to local string
      DO i = 1, MXLISTNML
         STRLIST_LOCAL(i) = STRLIST(i)
      ENDDO

      i = 1
      DO WHILE ( STRLIST_LOCAL(i) .NE. '' ) 

c remove optional '+' symbols between strings, and substitute blank.
         DO j = 1, NCHAR
           IF ( STRLIST_LOCAL(i)(j:j) .EQ. '+' ) then
              STRLIST_LOCAL(i)(j:j) = ' '
           endif
         ENDDO
         
         NWD = STORE_PARSE_WORDS(MSKOPT,STRLIST_LOCAL(i)//char(0),
     &            FNAM//char(0), 100, 30 )
       
         DO iwd = 1, NWD
            NLIST = NLIST + 1
            CALL get_PARSE_WORD_fortran(iwd,STRLIST(NLIST),LL)
         ENDDO

         i = i + 1

      END DO  ! end while

      PARSE_NML_STRINGLIST = NLIST

      RETURN
      END  ! end of PARSE_NML_STRINGLIST

C ====================================================
+DECK,CIDSTR.
      SUBROUTINE CIDSTRING(CID,CCID,LENCCID)
c
c Created Jan 15, 2011
c If integer CID < 1 million, return 6-char CCID and LENCCID=6;
c otherwise return 8-char CCID and LENCCID=8.
c   
      IMPLICIT NONE
+CDE,SNPAR.

      INTEGER   CID                ! (I) integer cand. id
      CHARACTER CCID*(MXCHAR_CCID)  ! (O) char-string for CCID
      INTEGER   LENCCID            ! (O) length of string

c local
      CHARACTER C1ERR*72, C2ERR*72

c ----------- BEGIN -----------

      IF ( CID .LT. 1000000 ) THEN    ! 1 million
         write(ccid,26) CID
26       format(I6.6)
         LENCCID = 6
      ELSE IF ( CID < 100000000 ) THEN  ! 100 million
         write(ccid,28) CID
28       format(I8.8)
         LENCCID = 8
      ELSE IF ( CID < MXCID ) THEN
         write(ccid,29) CID
29       format(I9.9)
         LENCCID = 9
      ELSE
         write(C1ERR,66) CID, MXCID
66       format('CID=',I9,' exceeds bound (MXCID=', I9,')' )
         C2err = '   '
         CALL MADABORT("CIDSTRING", c1err, c2err )
      ENDIF
      
      RETURN
      END

C ===============================================
+DECK,FILTREPLACE.
      INTEGER FUNCTION FILTINDX_REPLACE ( cfilt )

c Created Jun 2013 by RK.
c Same as FILTINDX, but apply FILTER_REPLACE (see INIT_FILTER_REPLACE)
c Examples:
c   FILTER_REPLACE = ''       : do exactly the same thing as FILTINDX.
c   FILTER_REPLACE = 'U -> u' : for U filter, return index for 'u'
c
c ------

      IMPLICIT NONE
      character cfilt*(*)  ! (I) filter name to parse

c local args
+CDE,SNPAR.
+CDE,FILTCOM.

      INTEGER   IFILTDEF_ORIG
c  function
      INTEGER FILTINDX

C ---------------- BEGIN ---------------
      IFILTDEF_ORIG    =  FILTINDX(CFILT)
      FILTINDX_REPLACE =  IFILTOBS_REPLACE(IFILTDEF_ORIG)

      RETURN
      END

C ===============================================
+DECK,FILTINDX.
      INTEGER FUNCTION FILTINDX ( cfilt )
c
c May 2008 R.Kessler
c Returns absolute integer filter-index 1:MXFLT_ALL by
c parsing character name "cfilt".
c Assumes that last character is the 1-char symbol;
c i.e, SDSS-g => g,  CTIO4m-R => R, etc ...

      IMPLICIT NONE
      character cfilt*(*)  ! (I) filter name to parse

+CDE,SNPAR.
+CDE,FILTCOM.


      integer LL, ifilt
      character cfilt1*1, ctest*1


c ----------- BEGIN -----------

      FILTINDX = 0

      LL  = index(CFILT//' ',' ' ) - 1     
      cfilt1 = CFILT(LL:LL)

      DO ifilt = 1, MXFILT_ALL
        ctest = filtdef_string(ifilt:ifilt)
        if ( ctest(1:1) .eq. cfilt1(1:1) ) then
           FILTINDX = ifilt
           return
        endif
      ENDDO

      RETURN
      END

C ==============================
+DECK,ISBXFILT.
      LOGICAL FUNCTION ISBXFILT(IFILT,NAME,FRAME)

c Created May 2012
c Set global locical EXIST_BXFILT_OBS[REST]=T if this
c X-filter contains 'BX'.
c

      IMPLICIT NONE

c function args

      INTEGER IFILT  ! absolute filter index
      CHARACTER
     &   NAME*(*)    ! full name of filter
     &  ,FRAME*(*)   ! 'OBS' or 'REST'

+CDE,SNPAR.
+CDE,FILTCOM.

      INTEGER JX
      CHARACTER C2*2

C ----------------- BEGIN ----------------

      ISBXFILT = .FALSE.
      IF ( IFILT .NE. IFILT_BESS_BX ) RETURN

      JX = INDEX(NAME,'X')

      IF ( JX .GT. 1 ) THEN
          C2 = NAME(JX-1:JX)
          IF( C2 .EQ. 'BX' ) then
             ISBXFILT = .TRUE.
          else
             return
          endif

c now that ISBXFILT=T  set global logical 
          IF ( FRAME .EQ. 'OBS'  ) EXIST_BXFILT_OBS  = .TRUE.
          IF ( FRAME .EQ. 'REST' ) EXIST_BXFILT_REST = .TRUE.

      ELSE

          IF ( FRAME .EQ. 'OBS'   ) ISBXFILT = EXIST_BXFILT_OBS 
          IF ( FRAME .EQ. 'REST'  ) ISBXFILT = EXIST_BXFILT_REST

      ENDIF

      RETURN
      END



C ================================================      
+DECK,GET_IDFIELD.
      INTEGER FUNCTION GET_IDFIELD ( field_name )
c
c May 2009
c Return integer ID for this FIELD.
c IDFIELD is defined $SNDATA_ROOT/SURVEY.DEF
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      character field_name*(*)  ! name of telescope

c local
      character field_upper*60
      INTEGER LL, i
c --------------- BEGIN -----------------

      GET_IDFIELD = -9

      CALL UPCASE(field_name, field_upper) ! returns field_upper

      if ( field_upper(1:3) .EQ. 'ALL' ) then
        GET_IDFIELD = 0
        return
      endif

      DO i = 1, NIDFIELD_LIST  ! user-list of fields
        LL = INDEX(SNFIELD_LIST(i),' ' ) - 1 
        IF ( FIELD_UPPER(1:LL) .EQ. SNFIELD_LIST(i)(1:LL) ) THEN
          GET_IDFIELD = IDFIELD_LIST(i)
        ENDIF
      END DO

      RETURN
      END         ! end of GET_IDFIELD

C ==================================
+DECK,ENDMJD_PROC.
      SUBROUTINE ENDMJD_PROC(NEWMJD)
c
c Aug 2007, R.Kessler
c
c Erase bad mesaurements.
c If all measurements (filters) are erased, then erase
c this MJD.
c
c May 9 2016: modify IGNORE logic
c
c ---------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

c input args
      INTEGER NEWMJD  ! index for SN and MJD

c local args

      INTEGER 
     &   EPMIN, EPMAX, ep, ep2
     &  ,ifilt_obs, ifilt_obs2, ifilt
     &  ,NEPSKIP, NFILT, EPMAX_OLD, NMOVED

      REAL FLUXCAL, FLUXCAL_ERR
      
      LOGICAL 
     &   LVALID(MXFILT_ALL)
     &  ,LMOVED(MXFILT_ALL)
     &  ,LTMP, IGNORE

      character cfilt1

C ------------- BEGIN -------------

      NFILT = ISNLC_NFILT_NEWMJD(NEWMJD) 

c for this NEWMJD, erase NULL measurements to save
c memory for old files with 5 filters per _line even
c when only 1 filter has data.
c Note that valid measurements are re-sorted
c and EPMAX is lowered.

      EPMIN  =  ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
      EPMAX  =  ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

      do ifilt_obs = 1, MXFILT_ALL
          LVALID(ifilt_obs) = .FALSE.
          LMOVED(ifilt_obs) = .FALSE.
      enddo

      NEPSKIP = 0

      DO 100 ep      = EPMIN, EPMAX
         ifilt_obs   = ISNLC_IFILT_OBS(ep)
         fluxcal     = SNLC_FLUXCAL(ep)
         fluxcal_err = SNLC_FLUXCAL_ERRTOT(ep)
cc         mag         = SNLC_MAG(ep)
         IGNORE      = (fluxcal_err < 0.0 ) .and. 
     &         (.not. REFORMAT_SAVE_BADEPOCHS )

c make sure filter is valid by checking that 
c the flux-error is non-negative.

         IFILT = IFILTDEF_INVMAP_SURVEY(IFILT_OBS)
         if ( IFILT .LT. 1 .or. IFILT .GT. NFILTDEF_SURVEY ) then
                         
            cfilt1 = FILTDEF_STRING(ifilt_obs:ifilt_obs)

            write(c1err,650) 
     &         ifilt_obs, cfilt1, SNLC8_MJD(EPMIN), SNLC_CCID
650         format('Invalid IFILT_OBS=',I3, '(',A,')' ,
     &          '  at MJD=',F9.3, 3x,'CID=',A)

            write(c2err,651) SURVEY_FILTERS(1:NFILTDEF_SURVEY)
651         format('Valid IFILT_OBS  are ', A )

            CALL MADABORT("ENDMJD_PROC", c1err, c2err )
         endif

         LMOVED(ifilt_obs) = .FALSE.
       
c check for valid measure.
c Set LSORT=T for any invalid measurement

         LTMP  =  (.not. IGNORE ) 
     &     .and.  (CUTWIN_SNRMIN_FILT(1,ifilt) < 100.0)

         if ( LTMP ) then
            LVALID(ifilt_obs) = .TRUE.
         else
           NEPSKIP =  NEPSKIP + 1
           LVALID(ifilt_obs) = .FALSE.
         endif
100   CONTINUE
   
cc      print*,' xxx LVALID = ', LVALID

c -------------------------------------------------------
c increment NEWMJD and NEPOCH if we have not erased
c all measurements

      if ( NEPSKIP .EQ. NFILT ) RETURN ! erase entire MJD

c ----------------

      ISNLC_NEWMJD_STORE = NEWMJD  ! increment new MJD

      ISNLC_NEPOCH_STORE = ISNLC_NEPOCH_STORE + 
     &   ISNLC_NFILT_NEWMJD(NEWMJD) 

      if ( NEPSKIP .EQ. 0 ) RETURN  ! all OK => bail
      
c if we get here, then there is at least one invalid
c measurement (epoch) for this NEWMJD; re-sort
c epochs to skip bad epochs.

      EPMAX_OLD = EPMAX
      EPMAX     = EPMAX_OLD - NEPSKIP 

      IF ( EPMAX .LT. EPMIN ) then

        write(c1err,660) EPMIN,EPMAX_OLD, EPMIN, EPMAX, 
     &       NFILT, NEPSKIP
660     format('EPMIN,MAX=',2I4, ' -> ', 2I4, 3x, 
     &       'NEPFILT=',I2, 2x,  'NEPSKIP=',I2  )
        write(c2err,661) SNLC8_MJD(EPMIN), SNLC_CCID
661     format('at MJD = ', F9.3, 4x, 'CID=', A )

        CALL MADABORT("ENDMJD_PROC", c1err, c2err )

      ENDIF


c loop over epochs and re-sort with NULL measurements removed.
c Logic is tricky.

      DO 200 ep = EPMIN, EPMAX_OLD

         ifilt_obs   = ISNLC_IFILT_OBS(ep)
         if ( LVALID(ifilt_obs) ) goto 200
   
c here we have invalid measure at epoch EP ...
c copy next valid epoch here.

         NMOVED = 0
         DO 202 ep2 = ep+1, EPMAX_OLD 
           ifilt_obs2   = ISNLC_IFILT_OBS(ep2)          
           LTMP = .NOT. LMOVED(ifilt_obs2) .and. NMOVED.EQ.0
           if ( LVALID(ifilt_obs2) .and. LTMP ) then
              CALL MOVE_SNLC_ARRAYS(ep,ep2)  ! move ep2 -> ep
              LMOVED(ifilt_obs2) = .TRUE.
              LVALID(ifilt_obs2) = .FALSE.
              NMOVED = NMOVED + 1
           endif

202      CONTINUE

200   CONTINUE  ! end of 'ep' loop

c ---------------------------------------
c adjust global variables that depend on NEPSKIP or EPMAX

       ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD) = EPMIN
       ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD) = EPMAX 

       ISNLC_NEPOCH_STORE = 
     & ISNLC_NEPOCH_STORE - NEPSKIP 

       ISNLC_NEPOCH_FOUND = 
     & ISNLC_NEPOCH_FOUND - NEPSKIP 

       ISNLC_NFILT_NEWMJD(NEWMJD) = 
     & ISNLC_NFILT_NEWMJD(NEWMJD) - NEPSKIP

      RETURN
      END

C ===================================
+DECK,MOVE_SNLC_ARRAYS.
      SUBROUTINE MOVE_SNLC_ARRAYS(ep1,ep2)
c
c
c Jun 25 2019: include SIM_XXX arrays
c Nov 12 2019: check LSIM_MAGOBS to set SIM_EPMAGOBS(ep)
c Feb 17 2021: 
c   for I/O refactor, include SNLC_ZEROPT_forCUTS and SNLC_PSF_FWHM
c Mar 01 2021: include SNLC_PSF_NEA

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER ep1, ep2  ! (I)
 
C ------------- BEGIN ------------

      SNLC8_MJD(ep1)           = SNLC8_MJD(ep2)
      ISNLC_IDFIELD(ep1)       = ISNLC_IDFIELD(ep2)
      SNLC_FIELD(ep1)          = SNLC_FIELD(ep2) 
      ISNLC_IFILT_OBS(ep1)     = ISNLC_IFILT_OBS(ep2)
      SNLC_FLUXCAL(ep1)        = SNLC_FLUXCAL(ep2)
      SNLC_FLUXCAL_ERRTOT(ep1) = SNLC_FLUXCAL_ERRTOT(ep2)
      ISNLC_PHOTFLAG(ep1)      = ISNLC_PHOTFLAG(ep2)
      SNLC_PHOTPROB(ep1)       = SNLC_PHOTPROB(ep2)
      SNLC_PSF_SIG1(ep1)       = SNLC_PSF_SIG1(ep2)
      SNLC_PSF_SIG2(ep1)       = SNLC_PSF_SIG2(ep2)
      SNLC_PSF_RATIO(ep1)      = SNLC_PSF_RATIO(ep2)
      SNLC_PSF_NEA(ep1)        = SNLC_PSF_NEA(ep2)
      SNLC_SKYSIG(ep1)         = SNLC_SKYSIG(ep2)
      SNLC_SKYSIG_T(ep1)       = SNLC_SKYSIG_T(ep2)
      SNLC_RDNOISE(ep1)        = SNLC_RDNOISE(ep2)
      SNLC_ZEROPT(ep1)         = SNLC_ZEROPT(ep2)
      SNLC_ZEROPT_ERR(ep1)     = SNLC_ZEROPT_ERR(ep2)
      SNLC_TEXPOSE(ep1)        = SNLC_TEXPOSE(ep2)      
      SNLC_GAIN(ep1)           = SNLC_GAIN(ep2)
      SNLC_XPIX(ep1)           = SNLC_XPIX(ep2)
      SNLC_YPIX(ep1)           = SNLC_YPIX(ep2)

      SNLC_ZEROPT_forCUT(ep1)   = SNLC_ZEROPT_forCUT(ep2)
      SNLC_PSF_FWHM_ARCSEC(ep1) = SNLC_PSF_FWHM_ARCSEC(ep2)

c beware that CCDNUM is read from header, and also from 
c PHOT section of TEXT format ... but not read from PHOT-FITS file
      ISNLC_CCDNUM(EP1)        = ISNLC_CCDNUM(EP2)
      ISNLC_IMGNUM(EP1)        = ISNLC_IMGNUM(EP2)

      IF ( ISJOB_SIM ) THEN
        SIM_EPMAGOBS(EP1)          = SIM_EPMAGOBS(EP2)
        SIM_EPFLUXCAL(EP1)         = SIM_EPFLUXCAL(EP2)
        SIM_EPCHI2FLUX(EP1)        = SIM_EPCHI2FLUX(EP2)
        SIM_EPPULL(EP1)            = SIM_EPPULL(EP2)
      ENDIF

      IF ( LSIM_SNANA ) THEN
        SIM_EPFLUXCAL_HOSTERR(EP1) = SIM_EPFLUXCAL_HOSTERR(EP2)
        SIM_EPSNRMON(EP1)          = SIM_EPSNRMON(EP2)
      ENDIF

c - - - 
      SNLC_MAG(ep1)            = SNLC_MAG(ep2)
      SNLC_MAG_ERRPLUS(ep1)    = SNLC_MAG_ERRPLUS(ep2)
      SNLC_MAG_ERRMINUS(ep1)   = SNLC_MAG_ERRMINUS(ep2)

      RETURN
      END    ! end MOVE_SNLC_ARRAYS

C ===================================
+DECK,INIT_SNLC.
      SUBROUTINE INIT_SNLC()
c
c Init SNLC_XXX arrays for this SN
c Called for each SN.
c
c Nov 22 2017: use NEP_RESET to reduce CPU time for init
c Feb 07 2021: rename INIT_SNDATA -> INIT_SNLC to avoid confusion
c               with INIT_SNDATA in sntools.c
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,PRIVCOM.
+CDE,EARLYCOM.
+CDE,SPECCOM.

c local

      INTEGER iep, ifilt, ipar, i, NEP_RESET, igal

c ------------- BEGIN -------------
      
      FOUND_SURVEY = .FALSE.

      SNLC_CID    = -9
      SNLC_CCID   = ''
      SNLC_NAME_IAUC       = 'NONE'   ! Aug 31 2017 (don't write blank to FITS file)
      SNLC_NAME_TRANSIENT  = 'NONE'   ! Jul 26 2024
      
      NSPECTRUM   = 0    ! for reading spectra for plot-table
      NLAMBIN_READ = 0 

      ISNLC_NEWMJD_HEAD   =  0
      ISNLC_NEWMJD_FOUND  =  0
      ISNLC_NEWMJD_STORE  =  0
      ISNLC_NEWMJD_CUTS   =  0
      ISNLC_NEPOCH_FOUND  =  0
      ISNLC_NEPOCH_STORE  =  0
      ISNLC_NEPOCH_PHOTPROB = 0  ! NEPOCH with PHOTPROB >= 0
      ISNLC_NFILT_SNRMAX  =  0
      ISNLC_NFILT_SNRMAX2 =  0
      ISNLC_NFIELD_OVP    =  0

      ISNLC_NFILT_TRESTMIN =  0
      ISNLC_NFILT_TRESTMAX =  0
      ISNLC_NFILT_TREST2   =  0  

      ISNLC_NOBS_PREDETECT   =  0
      ISNLC_NOBS_DETECT      =  0 
      SNLC_TLIVE_DETECT      = -9.0
      SNLC8_MJD_TRIGGER      = -99.0
      SNLC8_MJD_DETECT_FIRST = -99.0 
      SNLC8_MJD_DETECT_LAST  = -99.0

      NEPOCH_BADPHOT      =   0
      ISNLC_FAKE          =   0  ! Feb 2021: default is real data
      ISNLC_CCDNUM(1)     =  -9
      ISNLC_IMGNUM(1)     =  -9

      SNLC8_RA            =  -9.0
      SNLC8_DEC           =  -9.0
  
      SNLC_ZHELIO        =  -9.0
      SNLC_ZHELIO_ERR    =   0.0
      SNLC_ZCMB          =  -9.0
      SNLC_ZCMB_ERR      =   0.0
      SNLC_ZSN           =  -9.0 
      SNLC_ZSN_ERR       =   0.0
      SNLC_REDSHIFT      =  -9.0
      SNLC_REDSHIFT_ERR  =   0.0
      SNLC_VPEC          =   0.0
      SNLC_VPEC_ERR      =   0.0
      ISNLC_zFLAG        =  -999  

      SNLC_PIXSIZE       =  -9.0
      SNLC_NXPIX         =  -9.0
      SNLC_NYPIX         =  -9.0

      SNLC_MWEBV         =   0.0
      SNLC_MWEBV_ERR     =   0.0
      SNLC_SEARCH_PEAKMJD    =  -9.0
      SNLC_SNANAFIT_PEAKMJD = -9.0
      ISNLC_TYPE         =  0

      SNLC_PHOTPROB_MIN = 1.0

      SNLC_AREAFRAC_AVG = -9.0

c init a few SNHOST arrays

      SNHOST_NMATCH            =  0
      SNHOST_NMATCH2           =  0
      SNHOST_CONFUSION         = -9.0
      do igal = 1, MXSNHOST 
         SNHOST_FLAG(igal)        = 0
         SNHOST_OBJID(igal)       = -9
        DSNHOST_OBJID(igal)       = -9.0
         SNHOST8_RA(igal)         = -999.0
         SNHOST8_DEC(igal)        = -999.0
         SNHOST_ANGSEP(igal)      = -9.0
         SNHOST_DDLR(igal)        = -9.0
         SNHOST_ZPHOT(igal)       = -9.0
         SNHOST_ZPHOT_ERR(igal)   = -9.0
         SNHOST_ZSPEC(igal)       = -9.0
         SNHOST_ZSPEC_ERR(igal)   = -9.0

         SNHOST_LOGMASS(igal)       = -9999.0
         SNHOST_LOGMASS_ERR(igal)   = -9999.0
         SNHOST_LOGSFR(igal)        = -9999.0
         SNHOST_LOGSFR_ERR(igal)    = -9999.0
         SNHOST_LOGsSFR(igal)       = -9999.0
         SNHOST_LOGsSFR_ERR(igal)   = -9999.0
         SNHOST_COLOR(igal)         = -9999.0
         SNHOST_COLOR_ERR(igal)     = -9999.0
      enddo
c --------
      
      SNLC_SNRMAX_FILT(0) = -9.
      SNLC_SNRSUM         = 0.0
      
      DO ifilt = 1, MXFILT_OBS
         ISNLC_NEPOCH_FILT(ifilt)    =   0
         EXIST_FILT(ifilt)          = .FALSE.
         SNLC_FLUXCALMAX(ifilt)     = -9.
         SNLC_FLUXCALMAX_ERR(ifilt) = -9.
         SNLC_MWXT_MAG(ifilt)       = 0.0
         SNLC_MWXT_MAGERR(ifilt)    = 0.0
         SNLC_MWXT_FLUXFRAC(ifilt)  = 0.0

         SNHOST_SBFLUXCAL(ifilt)      = -999.9
         SNHOST_SBFLUXCAL_ERR(ifilt)  = -999.9
         SNHOST_SBMAG(ifilt)          = -999.9
         do igal = 1, MXSNHOST
            SNHOST_MAGOBS(ifilt,igal)         = +99.0
            SNHOST_MAGOBS_ERR(ifilt,igal)     = +99.0
         enddo
         SNLC_SNRMAX_FILT(ifilt)     = -9.
         SNLC_SNRMAX_SORT(ifilt)     = -9.
         SNLC_FLUXCAL_OFF(ifilt)     = 0.0 

         SNLC_FIELDLIST = 'VOID'

         DO ipar = 1, NPAR_ANYLC
           SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar) = -99.0
           SNLC_SNANAFIT_PEAKMJD_FITERR(ifilt,ipar) = -99.0
         ENDDO
         
         SIM_TEMPLATEMAG(ifilt) = 99.0 
         SIM_LCWIDTH(ifilt)     = 0.0 
      ENDDO

      LSIM_TRUE_SNIa  = .FALSE.
      SIM_MODEL_INDEX = -9
      SIM_COLORPAR    = -9.
      SIM_COLORLAW    = -9.
      SIM_DLMAG       = -9.
      SIM_LENSDMU     =  0.
      SIM_MUSHIFT     =  0.

      SIM_WGT_POPULATION = 1.0
      SIM_SHAPEPAR    = -9.
      SIM_SHAPELAW    = -9.
      SIM_COLORPAR    = -9.
      SIM_COLORLAW    = -9.
      SIM_SALT2x0     = -9.
      SIM_SALT2mb     = -9.
      SIM_AV          = -9.    ! July 2016
      SIM_RV          = -9.    ! idem
      SIM_TEMPLATE_INDEX    = -9 
      SIM_SEARCHEFF_MASK = 0
      SIM_MAGSMEAR_COH   = 0.0 
      SIM_SALT2gammaDM   = 0.0

      SIM_NGEN_LIBID = 0
      SIM_NOBS_UNDEFINED  = 0 
      SIM_SUBSAMPLE_INDEX = -9

      IF ( NCALL_SNANA_DRIVER < 2 ) then
         NEP_RESET = MXEPOCH
      ELSE
         NEP_RESET = ISNLC_NEPOCH_STORE
      ENDIF
c      print*,' xxx NCALL,NEP_RESET=', NCALL_SNANA_DRIVER, NEP_RESET

      DO iep = 1, NEP_RESET

        SNLC_FIELD(iep) = 'VOID'   ! avoid pandas issues with NULL

        ISNLC_NFILT_NEWMJD(iep)          =  0
        ISNLC_EPOCH_RANGE_NEWMJD(1,iep)  =  -9
        ISNLC_EPOCH_RANGE_NEWMJD(2,iep)  =  -9
        ISNLC_IFILT_OBS(iep)      =  -9

        ISNLC_IDFIELD(iep)        =  -9

        SNLC8_MJD(iep)           =  -9.0

        ISNLC_PHOTFLAG(iep)  = 0 
        SNLC_PHOTPROB(iep)   = 0.0

        SNLC_SKYSIG(iep)     = 0.0
        SNLC_SKYSIG_T(iep)   = 0.0  ! Mar 2018
        SNLC_PSF_SIG1(iep)   = 0.0
        SNLC_PSF_SIG2(iep)   = 0.0
        SNLC_PSF_RATIO(iep)  = 0.0
        SNLC_PSF_NEA(iep)    = 0.0
        SNLC_GAIN(iep)       = 0.0
        SNLC_RDNOISE(iep)    = 0.0

        SNLC_SNR(iep)             =  0.0
        SNLC_FLUXCAL_ERRCALC(iep) =  0.0
        SNLC_FLUXCAL_ERRTEST(iep) = -9.0
        SNLC_FLUXCAL_HOSTERRCALC(iep) = 0.0 
        SNLC_FLUXCAL(iep)         =  0.0
        SNLC_FLUXCAL_ERRTOT(iep)  = -9.0  ! Oct 8 2014
        SNLC_MAG(iep)             =  0.0
        SNLC_MAG_ERRPLUS(iep)     =  0.0
        SNLC_MAG_ERRMINUS(iep)    =  0.0
        
        SNLC_ZEROPT(iep)          =  0.0
        SNLC_ZEROPT_ERR(iep)      =  0.0
        SNLC_TEXPOSE(iep)         =  0.0	

        SNLC_XPIX(iep) = -9.0 
        SNLC_YPIX(iep) = -9.0 

        SNLC_DTOBS(iep)          = -9.0 
        SNLC_DTOBS_SAMEFILT(iep) = -9.0 

        SNLC_AREAFRAC(iep)  = -9.0

      END DO  ! end of epoch loop

c zero out the FITVAL_STORE array if fit-option is chosen

      IF ( DO_FIT ) THEN

           FITPROB_ITER1   = 0.0  ! July 2024
	   FITCHI2RED_INI  = 0.0
	   FITCHI2RED_INI2 = 0.0
	   
         do i = 1, 4
           FITCHI2_STORE(i)      = 0.0
           FITPROBCHI2_STORE(i)  = 0.0
           LCCHI2_STORE(i)       = 0.0
           LCPROBCHI2_STORE(i)   = 0.0

           NDOF_STORE(i)  = 0
         enddo

         NDOF_PRIOR = 0

         do ipar = 1, MXFITSTORE
            FITVAL_STORE(ipar) = 0.0
            FITERR_STORE(ipar) = 0.0

            LCVAL_STORE(ipar) = 0.0
            LCERR_STORE(ipar) = 0.0
            LCFRACERRDIF_STORE(ipar) = 0.0
         enddo
      ENDIF


      DO i   = 1, MXERRTYPE
         NERRTYPE(i) = 0
      ENDDO      

      DO i = 1, MXVAR_PRIVATE
        PRIVATE_VALUE(i)    = PRIVATE_NULL 
      ENDDO

      LSNCUTS       = .FALSE.
      PASS_PRIVCUTS = .TRUE.
      PASS_SIMCUTS  = .TRUE.
      CUTFLAG_SNANA =  0
      ERRFLAG_FIT   = -9  ! init to no fit

      MADE_LCPLOT = .FALSE.

      NSEASON_TOT      = 0
      NSEASON_ACTIVE    = 0

      ISNLC_CUTFLAG_REQEP    = 1
      ISNLC_CUTFLAG_PRIVATE  = 1
      ISNLC_CUTFLAG_SIMVAR   = 1
      ISNLC_WRMASK_FLUXCOR_SNANA = 0 
      ISNLC_RDMASK_FLUXCOR_SNANA = 0 

      NOBS_EARLYLC    = 0 
      NNIGHT_EARLYLC  = 0
      MJDLAST_EARLYLC = -999.
      MJDLAST_SELECT  = -999.
      NPHOTMASK_START_EARLYLC = 0 
      NSNR_START_EARLYLC      = 0 

      DO i = 1, NPAR_SIMSED
         SIMSED_PARVAL(i) = -999.0
      ENDDO
      DO i = 1, NPAR_LCLIB
         LCLIB_PARVAL(i) = -999.0
      ENDDO

      RETURN
      END   ! end of INIT_SNLC


C =======================================
+DECK,INIT_CUTMASK.
      SUBROUTINE INIT_CUTMASK ( IERR )
c
c Creatd Jan 31, 2006 by R.Kessler
c Initialize CUTMASK_ALL and CUTWIN_XXX
c
c Jan 4 2021:
c  + remove obsolete logic with !LSIM_SNANA && ibit==CUTBIT_SEARCH 
c  + check OPT_SNCID_LIST
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IERR ! (O)  0=> OK
      INTEGER ibit

C -------------- BEGIN -------------------
 
      IERR = 0  ! init output arg
     
      if ( NCUTBIT .GE. 64 ) then
         print*,' INIT_CUTBIT FATAL ERROR: NCUTBIT=', NCUTBIT
         print*,' ***** ABORT ***** '
         CALL EXIT(EXIT_ERRCODE)
      endif

      CUTMASK8_SN_ALL    = 0  ! init common block var
      CUTMASK8_MJD_ALL   = 0  ! init common block var

      DO 100 ibit = 1, NCUTBIT
         if ( ibit .LE. CUTBIT_MJD_MARKER ) then
           CUTMASK8_SN_ALL = IBSET ( CUTMASK8_SN_ALL, ibit-1 )
         else
           CUTMASK8_MJD_ALL = IBSET ( CUTMASK8_MJD_ALL, ibit-1 )
         endif
100   CONTINUE


c Jan 2021: check option to require ONLY CID-select.

      if ( USE_SNCID_FILE ) THEN
          CUTMASK8_SN_ALL = 0
          CUTMASK8_SN_ALL = IBSET(CUTMASK8_SN_ALL,CUTBIT_CID-1)
          print*,' '
          print*,'      **** APPLY ONLY CID-SELECT CUT **** '
          print*,' '
          CALL FLUSH(6)
      endif

      print*,' '
      print*,' INIT_CUTMASK: NCUTBIT          = ', NCUTBIT
      print*,' INIT_CUTMASK: CUTMASK8_SN_ALL  = ',CUTMASK8_SN_ALL
      print*,' INIT_CUTMASK: CUTMASK8_MJD_ALL = ',CUTMASK8_MJD_ALL

c - - - - - - - - -  -
c July 11 2020: 
c  check option to write list of rejected epochs 
c   (e.g., to pass to classifier)

      CALL WRITE_EPOCH_IGNORE_INIT()

      RETURN
      END  ! end INIT_CUTMASK

C =============================================
+DECK,WRITE_EPOCH_IGNORE_INIT.
      SUBROUTINE WRITE_EPOCH_IGNORE_INIT()

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LEN
      REAL*8  CUTWIN_TMP(2)
      CHARACTER CUTMODE*12, CUTVARNAME*20
      EXTERNAL write_epoch_list_init, write_epoch_list_addvar

C ---------- BEGIN --------

      LEN = INDEX(OUT_EPOCH_IGNORE_FILE,' ') - 1
      if ( LEN <= 0 ) RETURN

      CALL write_epoch_list_init(
     &     OUT_EPOCH_IGNORE_FILE(1:LEN)//char(0), LEN+1)

      CUTMODE = 'REJECT' // char(0)
c     start with PHOTFLAG cut
      CUTWIN_TMP(1)  = DBLE(PHOTFLAG_MSKREJ(1))
      CUTWIN_TMP(2)  = -9.0
      CUTVARNAME     = 'PHOTFLAG' // char(0)
      CALL write_epoch_list_addvar(CUTVARNAME, CUTWIN_TMP, CUTMODE,
     &     20, 12)
      
c next check PHOTPROB
      CUTWIN_TMP(1)  = CUTWIN_PHOTPROB(1)
      CUTWIN_TMP(2)  = CUTWIN_PHOTPROB(2)
      CUTVARNAME     = 'PHOTPROB' // char(0)
      CALL write_epoch_list_addvar(CUTVARNAME, CUTWIN_TMP, CUTMODE,
     &     20, 12)
      
c zero point
      CUTWIN_TMP(1)  = CUTWIN_ZP(1)
      CUTWIN_TMP(2)  = CUTWIN_ZP(2)
      CUTVARNAME     = 'ZP' // char(0)
      CALL write_epoch_list_addvar(CUTVARNAME, CUTWIN_TMP, CUTMODE,
     &     20, 12)
      
c PSF
      CUTWIN_TMP(1) = CUTWIN_PSF(1)
      CUTWIN_TMP(2) = CUTWIN_PSF(2)
      CUTVARNAME    = 'PSF' // char(0)
      CALL write_epoch_list_addvar(CUTVARNAME, CUTWIN_TMP, CUTMODE,
     &     20, 12)
      
c      print*,' '
c      print*,' xxx DEBUG STOP xxx '
c      STOP

      RETURN
      END  ! end WRITE_EPOCH_IGNORE_INIT

C =============================================
+DECK,WRITE_EPOCH_IGNORE_EXEC.
      SUBROUTINE WRITE_EPOCH_IGNORE_EXEC(ep)

      IMPLICIT NONE

      INTEGER ep ! index to process
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER   NVAR, IFILT_OBS
      CHARACTER CCID*(MXCHAR_CCID), BAND*2
      REAL*8  MJD, VALUES(20)
      EXTERNAL write_epoch_list_exec

C -------- BEGIN -----------
      IF ( OUT_EPOCH_IGNORE_FILE .EQ. '' ) RETURN

      NVAR = 0
      
      IFILT_OBS = ISNLC_IFILT_OBS(ep)
      CCID = SNLC_CCID(1:ISNLC_LENCCID) // char(0)
      MJD  = SNLC8_MJD(ep)
      BAND = FILTDEF_STRING(ifilt_obs:ifilt_obs) // char(0)

      NVAR=NVAR+1;  VALUES(NVAR) = DBLE( ISNLC_PHOTFLAG(ep) )
      NVAR=NVAR+1;  VALUES(NVAR) = DBLE( SNLC_PHOTPROB(ep)  )
      NVAR=NVAR+1;  VALUES(NVAR) = DBLE( SNLC_ZEROPT_forCUT(ep) )
      NVAR=NVAR+1;  VALUES(NVAR) = DBLE( SNLC_PSF_FWHM_ARCSEC(ep) )

      CALL write_epoch_list_exec(CCID, MJD, BAND, VALUES,
     &      MXCHAR_CCID, 2 )

      RETURN
      END  ! end WRITE_EPOCH_IGNORE_EXEC

C =======================================
+DECK,INIT_CUTNAMES.
      SUBROUTINE INIT_CUTNAMES ( IERR )
c
c Creatd Jan 31, 2007 by R.Kessler
c Initialize strings for cut names.
c
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IERR ! (O)  0=> OK
      INTEGER ibit, ifilt, ifilt_obs
      character cflt*1 

C -------------- BEGIN -------------------
 
      IERR = 0  ! init output arg

      do ibit = 1, NCUTBIT
        cutvar_name(ibit)  = 'UNDEFINED:'
      enddo

c hard-wire names of cut variables (maxchar = 28)

      cutvar_name(CUTBIT_CID)          = 'CID:'
      cutvar_name(CUTBIT_SNTYPE)       = 'TYPE:'
      cutvar_name(CUTBIT_RA)           = 'RA:'
      cutvar_name(CUTBIT_DEC)          = 'DEC:'
      cutvar_name(CUTBIT_HOSTSEP)      = 'HOST-SN sep:'
      cutvar_name(CUTBIT_TRESTMIN)     = 'Trestmin:'
      cutvar_name(CUTBIT_TRESTMAX)     = 'Trestmax:'
      cutvar_name(CUTBIT_TRESTRANGE)   = 'TrestRange:'
      cutvar_name(CUTBIT_TGAPMAX)      = 'TGAPmax:'
      cutvar_name(CUTBIT_T0GAPMAX)     = 'T0GAPmax:'
      cutvar_name(CUTBIT_TobsMIN)      = 'TobsMin:'
      cutvar_name(CUTBIT_TobsMAX)      = 'TobsMax:'
      cutvar_name(CUTBIT_PEAKMJD)      = 'PEAKMJD:'
      cutvar_name(CUTBIT_NOBS_PREDETECT) = 'NOBS_PREDETECT:'
      cutvar_name(CUTBIT_Nepoch)       = 'Nepoch:'
      cutvar_name(CUTBIT_REDSHIFT)     = 'Redshift:'
      cutvar_name(CUTBIT_REDSHIFT_ERR) = 'Redshift-ERROR:'
      cutvar_name(CUTBIT_PSF)          = 'PSF:'
      cutvar_name(CUTBIT_ZP)           = 'ZP:'
      cutvar_name(CUTBIT_ZPERR)        = 'ZPERR:'
      cutvar_name(CUTBIT_PHOTPROB)     = 'PHOTPROB:'
      cutvar_name(CUTBIT_MWEBV)        = 'MWEBV:'
      cutvar_name(CUTBIT_NSEASON_ACTIVE) = 'NSEASON_ACTIVE:'
      cutvar_name(CUTBIT_REQEP)        = 'REQEP_CUTFLAG:'
      cutvar_name(CUTBIT_PRIVATE)      = 'PRIVATEVAR_CUTS:'
      cutvar_name(CUTBIT_SIMVAR)       = 'SIMVAR_CUTS:'
      cutvar_name(CUTBIT_TREST)        = 'Trest:'
      cutvar_name(CUTBIT_TOBS)         = 'Tobs:'
      cutvar_name(CUTBIT_ERRTEST)      = 'ERR(CALC)/ERR(TRUE):'
      cutvar_name(CUTBIT_SIMPULL)      = '(F-Ftrue)/sigF:'
      cutvar_name(CUTBIT_TREST_TRUEFLUX2) = 'Trest_TRUEFLUX:'
      cutvar_name(CUTBIT_SNRMAX)       = 'SNRmax:'
      cutvar_name(CUTBIT_SNRMAX2)      = 'SNRmax2:'
      cutvar_name(CUTBIT_SNRSUM)       = 'SNRSUM:'  
      cutvar_name(CUTBIT_NFILT_SNRMAX) = 'NFILT_SNRmax:'
      cutvar_name(CUTBIT_NFILT_SNRMAX2)= 'NFILT_SNRmax2:'
      cutvar_name(CUTBIT_NFILT_TRESTMIN) = 'NFILT_Trestmin:'
      cutvar_name(CUTBIT_NFILT_TRESTMAX) = 'NFILT_Trestmax:'
      cutvar_name(CUTBIT_NFILT_TREST2)   = 'NFILT_Trest2:'
      cutvar_name(CUTBIT_NFIELD)         = 'NFIELD:'
      cutvar_name(CUTBIT_SEARCH)         = 'SEARCHEFF_MASK:'

      DO ifilt      = 1, NFILT_SNRMAX
          ifilt_obs = IFILT_SNRMAX(ifilt)
          cflt      = FILTDEF_STRING(ifilt_obs:ifilt_obs)
          ibit = CUTBIT_OFFSET_SNRMAX + ifilt
          cutvar_name(ibit)  = 'SNRMAX-' // cflt // ':'
      ENDDO

      DO ifilt      = 1, NFILT_HOST_SBFLUX  ! Aug 2021
          ifilt_obs = ifilt_HOST_SBFLUX(ifilt)
          cflt      = FILTDEF_STRING(ifilt_obs:ifilt_obs)
          ibit      = CUTBIT_OFFSET_SBFLUX + ifilt
          cutvar_name(ibit)  = 'SBFLUX-' // cflt // ':'
      ENDDO

      RETURN
      END   ! end INIT_CUTNAMES

C ======================================
+DECK,MWEBV_FLUXCOR.
      SUBROUTINE MWEBV_FLUXCOR()
c
c Compute MW extinction in each defined passband,
c and correct SNLC_FLUXCAL[_ERRTOT]
c
c
c Mar 06, 2025: make explicit check on <lam> for each SURVEY_FILTER
c --------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.

c local var

      INTEGER IFILT, IFILT_OBS, NEWMJD, EPMIN, EPMAX, ep, OPT, i

      REAL*8  
     &   XTMW8,  XTMW8_PLUSERR
     &  ,AVMW8,  AVMW8_PLUSERR
     &  ,MWEBV8, MWEBV8_PLUSERR, PARLIST_MWCOLORLAW8(10)
     &  ,LAM8, GALextinct, RV8

      REAL    XTMW_cor, arg
      CHARACTER CFILT*2, FNAM*14

      LOGICAL LDMP 

C ------------ BEGIN -------------

      LDMP = .FALSE.

      FNAM = 'MWEBV_FLUXCOR'
      IF ( USESIM_TRUEFLUX .and. LSIM_SNANA ) THEN
         SNLC_MWEBV     = SIM_MWEBV
         SNLC_MWEBV_ERR = 0.0
      ENDIF

      if ( .NOT. EXIST_CALIB_FILE ) RETURN ! Oct 2024
      
c determin MW extinction in each passband

       MWEBV8          = DBLE(SNLC_MWEBV )
       MWEBV8_PLUSERR  = DBLE(SNLC_MWEBV+SNLC_MWEBV_ERR)

       RV8             = DBLE(RV_MWCOLORLAW)
       AVMW8           = RV8 * MWEBV8
       AVMW8_PLUSERR   = RV8 * MWEBV8_PLUSERR
       
       OPT = OPT_MWCOLORLAW

       DO i = 1, 10
         PARLIST_MWCOLORLAW8(i) = DBLE(PARLIST_MWCOLORLAW(i))
       ENDDO
       
       if (  LDMP ) THEN
          write(6,122) SNLC_CCID(1:ISNLC_LENCCID), 
     &       SURVEY_FILTERS(1:NFILTDEF_SURVEY), MWEBV8, OPT
122       format(T5,'xxx --- XTMW(',A,'-', A,') for MWEBV=',F5.3,
     &         2x,'OPT=',I3 )
       endif


      DO ifilt = 1, NFILTDEF_SURVEY  
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          LAM8      = DBLE ( FILTOBS_LAMAVG(ifilt_obs) )
          CFILT     = FILTDEF_STRING(ifilt_obs:ifilt_obs)

          if ( LAM8 < 1.0 ) THEN
             write(c1err,601) cfilt, LAM8
601          format('SURVEY_FILTER ', A1,' has invalid <lam> = ', 
     &            F8.2, ' A' )
             c2err = 'Check if ' // CFILT(1:1) //
     &           '-band is defined in kcor/calib file.'
             CALL MADABORT(FNAM, c1err, c2err )
          endif

          XTMW8     = 
     &           GALextinct ( RV8, AVMW8, LAM8,
     &                OPT, PARLIST_MWCOLORLAW8, FNAM//char(0), 20 )
          XTMW8_PLUSERR  = 
     &           GALextinct ( RV8, AVMW8_PLUSERR, LAM8,
     &                OPT, PARLIST_MWCOLORLAW8, FNAM//char(0), 20 )

          SNLC_MWXT_MAG(ifilt)    = SNGL(XTMW8)
          SNLC_MWXT_MAGERR(ifilt) = SNGL(XTMW8_PLUSERR-XTMW8)

          if ( LDMP ) then
            write(6,123) CFILT, LAM8, XTMW8
123         format(T5,'xxx ', A,' : <LAM>=',F7.0, 2x, 'XTMW=',F6.4)
            call flush(6)
          endif

c store extinction in flux-fraction units.
c FLUXFRAC = Flux(Extincted)/flux(top-of-Galaxy)
          arg = SNGL(-0.4 * XTMW8)
          SNLC_MWXT_FLUXFRAC(ifilt) = 10.0**arg  ! <= 1.0
         
      END DO  ! end of ifilt loop


c correct data fluxes if USE_MWCOR=T
      IF ( .NOT.  USE_MWCOR )  RETURN

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE  
 
          EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
          EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
 
          DO EP = EPMIN, EPMAX

            IFILT_OBS = ISNLC_IFILT_OBS(ep)
            IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
            XTMW_cor  = 1.0 - SNLC_MWXT_FLUXFRAC(ifilt)

            SNLC_FLUXCAL(ep) = 
     &      SNLC_FLUXCAL(ep) / XTMW_cor

            SNLC_FLUXCAL_ERRTOT(ep) = 
     &      SNLC_FLUXCAL_ERRTOT(ep) / XTMW_cor

          ENDDO

200   CONTINUE  ! NEWMJD

      RETURN
      END   ! end MWEBV_FLUXCOR

C ===========================================
+DECK,RDFILE_USRTAGS.
      SUBROUTINE RDFILE_USERTAGS()
c
c Created Aug 2011 by R.Kessler
c If namelist USERTAGS_FILE is set, then read integer tag
c for each SN specified. These tags are then included in 
c analysis ntuples and fitres files. Motivation is to 
c easily tag subsets such as SN confirmed from a particular
c telescope.  For SN not listed in the USERTAGS_FILE,
c the tag is automatically set to zero.
c
c If an unknown CCID is found in the USERTAGS_FILE, 
c it is ignored (i.e., no abort)
c
c The format of the user-tag file is
c
c  SN:  <CID1>  <TAG-VALUE1>
c  SN:  <CID2>  <TAG-VALUE2>
c  SN:  <CID3>  <TAG-VALUE3>
c  etc ...
c
c --------------------

      IMPLICIT NONE


+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,USRTAGCM.

      INTEGER LEN, ITAG, iwd, NWD, N
      CHARACTER 
     &   CWD*60
     &  ,CKEY*(MXCHAR_CCID)
     &  ,CCID*(MXCHAR_CCID)
     &  ,NAME_ForC*(MXCHAR_FILENAME)
     &  ,FNAM*30

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN ----------------

      N_USERTAGS    = 0

      IF ( USERTAGS_FILE .EQ. ' ' ) RETURN

      FNAM = 'RDFILE_USERTAGS'

      LEN = INDEX(USERTAGS_FILE,' ') - 1

c init all tags to zero
      DO itag = 1, MXUSERTAG
        USERTAG_VALUELIST(itag) = 0
        USERTAG_CCIDLIST(itag)  = ''
        USERTAG_USED(itag)      = 0
      ENDDO

      CALL PRBANNER("RDFILE_USERTAGS")
      print*,'  Read user tags to identify subsets. '

      NAME_ForC = USERTAGS_FILE(1:LEN)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE,NAME_forC,
     &          FNAM//char(0), LEN, 30 ) 

      DO 100 iwd = 1, NWD-1

         CALL get_PARSE_WORD_fortran(iwd+0,CWD,LEN)
         CKEY = CWD(1:MXCHAR_CCID)

         if ( CKEY .EQ. 'SN:' ) then

           N_USERTAGS = N_USERTAGS + 1
           N = N_USERTAGS

           if ( N .GT. MXUSERTAG ) then
             write(c1err,61) MXUSERTAG
61           format('Number of USER TAGS exceeds bound of ',I5)
             c2err = 'Check ' // USERTAGS_FILE(1:60)
             CALL MADABORT("RDFILE_USERTAGS", c1err, c2err )
           endif

           CALL get_PARSE_WORD_fortran(iwd+1,CWD,LEN)
           READ ( CWD, *) CCID

           CALL get_PARSE_WORD_fortran(iwd+2,CWD,LEN)
           READ ( CWD, *) ITAG

           USERTAG_CCIDLIST(N)  = CCID
           USERTAG_VALUELIST(N) = ITAG

         endif

100   CONTINUE

      RETURN
      END


C =========================================
+DECK,GTUSERTAG.
      SUBROUTINE GET_USERTAG(CCID)

c
c Load global USERTAG value for this SN
c
      CHARACTER CCID*(*)

c local var
+CDE,SNPAR.
+CDE,USRTAGCM.


      INTEGER i, LCCID, LTMP
      CHARACTER CCID_TMP*(MXCHAR_CCID)

c -------------- BEGIN --------------

      USERTAG = -999
      IF ( N_USERTAGS .LE. 0 ) RETURN

      LCCID = INDEX(CCID,' ') - 1
      DO 100 i = 1, N_USERTAGS

         if ( USERTAG_USED(i) .NE. 0 ) GOTO 100

         CCID_TMP = USERTAG_CCIDLIST(i)
         LTMP     = INDEX(CCID_TMP,' ') - 1

         IF ( LTMP          .NE. LCCID             ) GOTO 100
         IF ( CCID(1:LCCID) .NE. CCID_TMP(1:LCCID) ) GOTO 100
         
         USERTAG = USERTAG_VALUELIST(i)
         USERTAG_USED(i) = 1
         RETURN
100   CONTINUE


      RETURN
      END  

C ==================================
+DECK,MULTISEASON.
      SUBROUTINE MULTISEASON(IFLAG)

c Created Oct 2014
c Driver for quick analysis to check for multi-season variability.
c 
c May 1 2019: convert GET_MULTISEASON args to double.

      IMPLICIT NONE

      INTEGER IFLAG ! (I) 

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER NEWMJD, EPMIN, EPMAX, EP, NOBS, iSeason
      INTEGER ITMP_REJECT(MXEPOCH)
      REAL*8  TMP8_MJD(MXEPOCH)
      REAL*8  TMP8_FLUX(MXEPOCH), TMP8_FLUXERR(MXEPOCH)
      REAL*8  OUT_CHI2RED(MXSEASON), OUT_AVGFLUX(MXSEASON)
      REAL*8  OUT_MJDMIN(MXSEASON),  OUT_MJDMAX(MXSEASON)
      REAL   PARLIST(8), CHI2RED, CUTVAL
      CHARACTER CCID_forC*(MXCHAR_CCID)
      LOGICAL USE_TGAP, USE_MASK

c -------------------- BEGIN --------------

      IF ( IFLAG == IFLAG_INI ) THEN

         USE_TGAP = MULTISEASON_TGAP < 1.0E8
         USE_MASK = MULTISEASON_OPTMASK > 0
         if ( .NOT. USE_TGAP ) THEN
            MULTISEASON_OPTMASK = 0
            RETURN
         endif
         if ( .NOT. USE_MASK ) MULTISEASON_OPTMASK = 1

c copy user-analysis parameters to list 
         PARLIST(1) = MULTISEASON_OPTMASK
         PARLIST(2) = MULTISEASON_TGAP
         PARLIST(3) = MULTISEASON_NREJECT_OUTLIER

c call to C function in multiseason.c
         CALL INIT_MULTISEASON(PARLIST)  

         RETURN
      ENDIF

      if ( MULTISEASON_OPTMASK == 0 ) return 

c ------ if we get here then analyze this CID -------

c create local array of MJD, FLUX, FLUXERR that were selected by SNRECON
      NOBS = 0

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 201 EP = EPMIN, EPMAX
           if ( ISNLC_SNRECON_USE(ep) == 0 ) GOTO 201
           NOBS = NOBS + 1
           TMP8_MJD(NOBS)     = SNLC8_MJD(ep)
           TMP8_FLUX(NOBS)    = DBLE( SNLC_FLUXCAL(ep) ) 
           TMP8_FLUXERR(NOBS) = DBLE( SNLC_FLUXCAL_ERRTOT(ep) )
 201    CONTINUE
 200  CONTINUE


c --------------
      CCID_forC = SNLC_CCID(1:ISNLC_LENCCID) // char(0)
      NOBS      = ISNLC_NEWMJD_STORE

      CALL GET_MULTISEASON( 
     &      CCID_forC
     &     ,NOBS, TMP8_MJD, TMP8_FLUX, TMP8_FLUXERR ! (I)
     &     ,ITMP_REJECT         ! (O) mask of reject epochs
     &     ,NSEASON_TOT         ! (O) number of seasons found
     &     ,OUT_CHI2RED         ! (O) reduced chi2 per season
     &     ,OUT_MJDMIN          ! (O) min-MJD for each season
     &     ,OUT_MJDMAX          ! (O) max-MJD for each season
     &     ,OUT_AVGFLUX         ! (O) avg flux for each season
     &     )

c transfer to float globals
      DO iSeason = 1, NSEASON_TOT
         MULTISEASON_CHI2RED(iSeason) = SNGL(OUT_CHI2RED(iSeason))
         MULTISEASON_MJDMIN(iSeason)  = SNGL(OUT_MJDMIN(iSeason))
         MULTISEASON_MJDMAX(iSeason)  = SNGL(OUT_MJDMAX(iSeason))
         MULTISEASON_AVGFLUX(iSeason) = SNGL(OUT_AVGFLUX(iSeason))
      ENDDO

      CUTVAL = MULTISEASON_CHI2RED_ACTIVE
      DO iSeason = 1, NSEASON_TOT
        CHI2RED = MULTISEASON_CHI2RED(iSeason)
        IF ( CHI2RED > CUTVAL ) THEN
           NSEASON_ACTIVE = NSEASON_ACTIVE + 1
        ENDIF
      ENDDO

c ------------------------------------------
c transfer ITMP_REJECT flag to ISNLC_RECON_USE 
c so that plots show rejected epochs

      NOBS = 0

      DO 2000 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 2001 EP = EPMIN, EPMAX
           if ( ISNLC_SNRECON_USE(ep) == 0 ) GOTO 2001
           NOBS = NOBS + 1
           if ( ITMP_REJECT(NOBS) == 1 ) then
              ISNLC_SNRECON_USE(ep) = 0
           endif
 2001   CONTINUE
 2000 CONTINUE

      RETURN
      END  ! end of MULTISEASON


C ============================================
+DECK,SELECT_EARLYLC.
      LOGICAL FUNCTION SELECT_EARLYLC(EP)
c
c Created March 2015 by R.Kessler
c Return TRUE if EARLYLC-requirements are satsified.
c Logical AND is applied to each selection defined in
c subroutine PARSE_EARLYLC_STRING().
c
c Note that all epochs BEFORE EARLYLC requirements are accepted;
c epochs are rejected after all of the EARLYLC obs or nights
c are found.
c
c 9/15/2017: implement SNR_START and PHOTMASK_START (see manual)
c
c -------------------

      IMPLICIT NONE

      INTEGER EP    ! (I) epoch to analyze

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,EARLYCOM.
+CDE,FILTCOM.

      REAL SNR, PROB, MJD
      INTEGER IFILT_OBS, MASK, OVPMASK, OVPMASK_START, NMJD_DIF
      LOGICAL LCUTS, LSNR, LPHOTPROB, LPHOTMASK, LFILT
      LOGICAL LDMP, SAMENIGHT, LNOSEL
      CHARACTER CFILT*2

C --------------- BEGIN --------------
 
      SELECT_EARLYLC = .TRUE.
      IF ( EARLYLC_STRING .EQ. '' ) RETURN

cc      print*,' xxx HELOO from SELECT_EARLYLC: ep = ', ep

c strip off info for this epoch.
      IFILT_OBS = ISNLC_IFILT_OBS(ep)
      CFILT     = FILTDEF_STRING(ifilt_obs:ifilt_obs)
      PROB      = SNLC_PHOTPROB(ep)
      MASK      = ISNLC_PHOTFLAG(ep)
      MJD       = SNGL( SNLC8_MJD(ep) )

      if ( SNLC_FLUXCAL_ERRTOT(ep) > 0 ) then
         SNR  = SNLC_FLUXCAL(ep) / SNLC_FLUXCAL_ERRTOT(ep)
         if ( SNR > SNR_START_EARLYLC ) then
            NSNR_START_EARLYLC = NSNR_START_EARLYLC + 1
         endif
      else 
         SNR = 0.0
      endif       

      IF ( PHOTMASK_EARLYLC .NE. 0 ) THEN
        OVPMASK = IAND(PHOTMASK_EARLYLC,MASK)
      ELSE
        OVPMASK = 999  ! any number > 0
      ENDIF

c check PHOTMASK_START required to start counting epochs (9/15/2017)
c --> ignore epochs before PHOTMASK_START is satisfied.
      IF ( PHOTMASK_START_EARLYLC > 0 ) THEN
        OVPMASK_START = IAND(PHOTMASK_START_EARLYLC,MASK)
      ELSE
        OVPMASK_START = 999  ! any number > 0
      ENDIF 

      IF ( OVPMASK_START > 0 ) THEN
         NPHOTMASK_START_EARLYLC = NPHOTMASK_START_EARLYLC + 1 
      ENDIF

c set cut-logicals.
      LFILT      = (INDEX(FILTERS_EARLYLC,CFILT(1:1)) > 0)

      LSNR       = (SNR .GE. SNRMIN_EARLYLC) .AND.
     &             (NSNR_START_EARLYLC>0)

      LPHOTPROB  = PROB .GE. PHOTPROBMIN_EARLYLC

      LPHOTMASK  = ( OVPMASK > 0) .AND.
     &             ( NPHOTMASK_START_EARLYLC > 0)

      SAMENIGHT  = ( (MJD-MJDLAST_EARLYLC) < DT_SAMENIGHT )

      LCUTS = (LFILT .and. LSNR .and. LPHOTPROB .and. LPHOTMASK )

c apply all cuts to increment number of early obs.
      IF ( LCUTS ) THEN
         NOBS_EARLYLC = NOBS_EARLYLC + 1
         if ( .NOT. SAMENIGHT ) then
            NNIGHT_EARLYLC = NNIGHT_EARLYLC + 1
            MJDLAST_EARLYLC = MJD 
         endif
      ENDIF

c ---------------------------------------------------
c check if we reached max number of OBS or NIGHTS

      IF( NOBS_EARLYLC > MAXOBS_EARLYLC ) THEN
         SELECT_EARLYLC = .FALSE.
      ENDIF

      IF ( NNIGHT_EARLYLC > MAXNIGHT_EARLYLC ) THEN
         SELECT_EARLYLC = .FALSE.
      ENDIF

      IF ( SELECT_EARLYLC ) MJDLAST_SELECT = MJD


c check NDAYADD option to add number of days instead of
c number of obs or nights.

      LNOSEL = (.NOT. SELECT_EARLYLC) .and. (NDAYADD_EARLYLC>0)
      NMJD_DIF = -9
      if ( LNOSEL .and. MJDLAST_SELECT > 10000 ) then
         NMJD_DIF = int(MJD - MJDLAST_SELECT+0.5)
         SELECT_EARLYLC = (NMJD_DIF < NDAYADD_EARLYLC)
      endif
    
c xxxxxxxxxxxxxxx
c      print*,' xxx LNOSEL=',LNOSEL,
c     &   '  MJD,MJDLAST_SELECT=', MJD,MJDLAST_SELECT
c      print*,' xxx --> NMJD_DIF=', NMJD_DIF, 
c     &     '   SELECT=', SELECT_EARLYLC
c xxxxxxxxxxxxxxx

      LDMP = .FALSE.  ! (PROB < 1.0E9)
      if ( LDMP ) THEN
         print*,' xxx ------------------------------------- '
         write(6,666) EP, CFILT, LFILT,
     &           MJD, PROB, NOBS_EARLYLC, NNIGHT_EARLYLC
666      format(T2, 'xxx EP=',I3'-',A1, '(',L1,')', 2x, 
     &         'MJD=',F9.3, 2x, 'PROB=',F5.2, 2x,
     &         'N[OBS,NITE]=',2I3 )

         print*,' xxx SNR, SNRMIN_EARLYLC = ', SNR, SNRMIN_EARLYLC
         print*,' xxx MAXOBS_EARLYLC, MAXNIGHT_EARLYLC = ',
     &                MAXOBS_EARLYLC, MAXNIGHT_EARLYLC

         print*,' xxx NPHOTMASK_START_EARLYLC = ', 
     &                NPHOTMASK_START_EARLYLC

         write(6,667) LFILT, LSNR, LPHOTPROB, LPHOTMASK
667      format(T2, 'xxx LCUT(FILT,SNR,PHOTPROB,PHOTMASK) = ',4L3)
         print*,' xxx LCUTS, SELECT = ', LCUTS, SELECT_EARLYLC
         call flush(6)
      endif

      RETURN
      END     ! SELECT_EARLYLC

C ========================================
+DECK,PARSE_EARLYLC.
      SUBROUTINE PARSE_EARLYLC_STRING()

C Mar 2015 - 
c  parse &SNLCINP input EARLYLC_STRING and set global 
c  variables in common EARLYCOM. 
c  Also print summary to stdout.
c 
c Valid keys contained in the EARLYLC_STRING are
c (with example values):
c   MAXOBS:            4        ! default = 999
c   MAXNIGHT:          4        ! default = 999
c   FILTERS:         riz      ! default = all bands
c   SNRMIN:          5.0      ! default = -999
c   PHOTPROBMIN:     0.5      ! default = -999 
c   PHOTMASK        4096      ! default =  0
c   NDAYADD           10      ! default =  0
c   PHOTMASK_START  4096      ! default =  0    (disabled)
c   SNR_START          5      ! default =  999  (disabled)
c
c 9/15/2017: check for PHOTMASK_START
c

c -------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,EARLYCOM.

      INTEGER iwd, NWD, NOTUSED, L0, L1, MSKOPT
      CHARACTER 
     &   cwd0*(MXCHAR_FILEWORD),
     &   cwd1*(MXCHAR_FILEWORD), FNAM*22
      LOGICAL USEWD(200)

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C -------------- BEGIN -----------------

      FNAM = 'PARSE_EARLYLC_STRING'
      MSKOPT = MSKOPT_PARSE_WORDS_STRING

c set defaults
 
      NDAYADD_EARLYLC        =  0
      MAXOBS_EARLYLC         =  999
      MAXNIGHT_EARLYLC       =  999
      SNRMIN_EARLYLC         = -999.
      PHOTPROBMIN_EARLYLC    = -999.
      PHOTMASK_EARLYLC       =  0
      PHOTMASK_START_EARLYLC =  0 
      NPHOTMASK_START_EARLYLC=  0
      SNR_START_EARLYLC      =  -9999.
      NSNR_START_EARLYLC     =  0
      FILTERS_EARLYLC        = SURVEY_FILTERS
      
      IF ( EARLYLC_STRING .EQ. '' ) RETURN

      NWD = STORE_PARSE_WORDS(MSKOPT, EARLYLC_STRING//char(0), 
     &         FNAM//char(0), 100, 30)

      DO iwd = 1, NWD
         USEWD(iwd) = .FALSE.
      ENDDO

      DO 10 iwd = 1, NWD

          cwd0 = '' ; cwd1 = ''
      
          CALL get_PARSE_WORD_fortran(iwd+0, cwd0, L0)
          if ( iwd < NWD ) then
             CALL get_PARSE_WORD_fortran(iwd+1, cwd1, L1)
          endif

          if ( cwd0(1:6) .EQ. 'MAXOBS' ) then
             read(cwd1,* ) MAXOBS_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:7) .EQ. 'NDAYADD' ) then
             read(cwd1,* ) NDAYADD_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:8) .EQ. 'MAXNIGHT' ) then
             read(cwd1,* ) MAXNIGHT_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:7) .EQ. 'FILTERS' ) then
             FILTERS_EARLYLC = cwd1
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:6) .EQ. 'SNRMIN' ) then
             read(cwd1,* ) SNRMIN_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:11) .EQ. 'PHOTPROBMIN' ) then
             read(cwd1,* ) PHOTPROBMIN_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

c   be careful with two keys that have same 'PHOTMASK' in string
          if ( cwd0(1:14) .EQ. 'PHOTMASK_START' ) then
             read(cwd1,* ) PHOTMASK_START_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          else if ( cwd0(1:8) .EQ. 'PHOTMASK' ) then
             read(cwd1,* ) PHOTMASK_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:9) .EQ. 'SNR_START' ) then
             read(cwd1,* ) SNR_START_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

10    CONTINUE

      GLOBAL_BANNER = 'Init Selection of Early Part of Light Curve'
      CALL PRBANNER (GLOBAL_BANNER(1:60) )

      write(6,50) MAXOBS_EARLYLC, MAXNIGHT_EARLYLC
50    format(T5,'Select first ',I2,' obs or ',I2,' nights satisfying:')
      print*,'        FILTER  in   ', FILTERS_EARLYLC(1:40)
      print*,'   and  PHOTPROB > ', PHOTPROBMIN_EARLYLC
      print*,'   and  SNR      > ', SNRMIN_EARLYLC
      print*,'   and  NDAYADD  = ', NDAYADD_EARLYLC
   
      if ( PHOTMASK_EARLYLC > 0 ) then
         print*,'   and  PHOTFLAG contains ', PHOTMASK_EARLYLC
      endif

      if ( PHOTMASK_START_EARLYLC > 0 ) then
         print*,'   After epoch where PHOTFLAG contains ', 
     &         PHOTMASK_START_EARLYLC
      endif

      if ( SNR_START_EARLYLC > -900. ) then
         print*,'   After epoch where SNR > ', SNR_START_EARLYLC
      endif

      print*,' '
      call flush(6)

c ------------------------------------
c if any words are not used --> ABORT !!!

      NOTUSED =  0
      DO 66 iwd = 1, NWD
        if ( .NOT. USEWD(iwd) ) then
            NOTUSED = NOTUSED + 1
            CALL get_PARSE_WORD_fortran(iwd, cwd0, L0)
            write(6,666) cwd0 
666         format('ERROR: EARLYLC_STRING contains invalid ', A20)
        endif
66    CONTINUE

      IF ( NOTUSED > 0 ) THEN
        write(c1err,61) NOTUSED
        write(c2err,62) EARLYLC_STRING
61      format('Found ',I2,' undefined words in')
62      format('EARLYLC_STRING="', A48, '"' )
        CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF
      
      RETURN
      END  ! end of PARSE_EARLYLC_STRING

C ========================================================
+DECK,ISTAT_REQUIRE_EPOCHS.
      INTEGER FUNCTION ISTAT_REQUIRE_EPOCHS()

c Created Sep 2017
c Return 1 (TRUE) if epochs satify user input REQUIRE_EPOCHS_STRING.
c

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,REQEPCOM.

      INTEGER 
     &    NEWMJD, EPMIN, EPMAX, EP, i, NOBS(3)

      REAL*8 
     &   MJD_FIRST, MJD_LAST, MJD, MJD_DIF
     &  ,MJD_WIN_BEFORE(2), MJD_WIN_AFTER(2)
     &  ,SNR, FLUX, FLUXERR, z1

      CHARACTER FNAM*24
      LOGICAL  LPASS, LTRANGE(3), LDMP

C ------------------- BEGIN ----------------

      FNAM       = 'ISTAT_REQUIRE_EPOCHS'

      ISTAT_REQUIRE_EPOCHS     = 1
      NDAYS_ABOVE_SNRMIN_REQEP = 0.0
      IF ( NFILT_REQEP .EQ. 0 ) RETURN

      MJD_FIRST  = -9.0
      MJD_LAST   = -9.0 

      do i = 1, 3
        LTRANGE(i) = .FALSE.
        NOBS(i)    = 0
      ENDDO

      IF ( ISFRAME_OBS_REQEP ) then
         z1   = 1.0 
      else
         z1  = 1.0 + SNLC_REDSHIFT
         if ( SNLC_REDSHIFT < 0.0 ) then
            c1err = 'Negative redshift !'
            c2err = 'Cannot compute TREST'
            CALL MADABORT(FNAM, c1err, c2err )
         endif
      endif

C - - - - - - -  - -

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

      DO 201 EP = EPMIN, EPMAX

           MJD      = SNLC8_MJD(EP)
           FLUX     = DBLE( SNLC_FLUXCAL(EP) )
           FLUXERR  = DBLE( SNLC_FLUXCAL_ERRTOT(EP) )
           SNR      = 0.0
           IF ( FLUXERR > 0.00001 ) THEN
              SNR = FLUX / FLUXERR
           ENDIF

           IF ( SNR > SNRMIN_REQEP ) THEN
              if ( MJD_FIRST < 0.0 ) MJD_FIRST = MJD
              MJD_LAST = MJD
              NOBS(2) = NOBS(2) + 1
           ENDIF
201   CONTINUE
200   CONTINUE


c -----------------------------------
c check range of epochs above SNR
      MJD_DIF = MJD_LAST - MJD_FIRST
      NDAYS_ABOVE_SNRMIN_REQEP = SNGL( MJD_DIF/z1 )
      if ( NDAYS_ABOVE_SNRMIN_REQEP > TRANGE_REQEP(2) 
     &        .OR. NOBS(2)==0 ) THEN
         ISTAT_REQUIRE_EPOCHS = 0
         GOTO 888
      endif

c We have a short-enough transient.
c Check that there there is at least 1 obs before and after
c the live range, so that a longer-duration event could
c have been observed.

      MJD_WIN_BEFORE(1) = MJD_FIRST - TRANGE_REQEP(1)*z1
      MJD_WIN_BEFORE(2) = MJD_FIRST - 0.001

      MJD_WIN_AFTER(1) = MJD_LAST + 0.001
      MJD_WIN_AFTER(2) = MJD_LAST + TRANGE_REQEP(3)*z1

      DO 400 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
      DO 401 EP = EPMIN, EPMAX

           MJD      = SNLC8_MJD(EP)
           
           if ( MJD > MJD_WIN_BEFORE(1) .and. 
     &          MJD < MJD_WIN_BEFORE(2) ) then
             NOBS(1) = NOBS(1) + 1
           endif

           if ( MJD > MJD_WIN_AFTER(1) .and. 
     &          MJD < MJD_WIN_AFTER(2) ) then
             NOBS(3) = NOBS(3) + 1
           endif

401   CONTINUE
400   CONTINUE

c ------------------------------------------------------

      DO i = 1, 3
        if ( NOBS(i)>0 .OR. TRANGE_REQEP(i) < 1.0E-9 ) THEN
           LTRANGE(i) = .TRUE.
        endif 
      ENDDO

      LPASS = ( LTRANGE(1) .and. LTRANGE(2) .and. LTRANGE(3) )
      IF ( LPASS ) THEN
         ISTAT_REQUIRE_EPOCHS = 1
      ELSE
         ISTAT_REQUIRE_EPOCHS = 0
      ENDIF

c - - - - - - - - - - - 
888   CONTINUE
 
      LDMP = ( SNLC_CID < -5 )
      IF ( LDMP ) THEN
        print*,' ' 
        print*,' xxx ---------- DUMP ISTAT_REQUIRE_EPOCHS ------ '
        print*,' xxx CID = ', SNLC_CID
        print*,' xxx TRANGE  = ', TRANGE_REQEP
        print*,' xxx LTRANGE = ', LTRANGE
        print*,' xxx NOBS    = ', NOBS
        print*,' xxx MJD_FIRST/LAST = ', 
     &      sngl(MJD_FIRST), '/', sngl(MJD_LAST)
        print*,' xxx ISTAT_REQUIRE_EPOCHS=', ISTAT_REQUIRE_EPOCHS
        print*,' ' 
      ENDIF

      RETURN
      END   ! end ISTAT_REQUIRE_EPOCHS


C ========================================================
+DECK,PARSE_REQUIRE_EPOCHS.
      SUBROUTINE PARSE_REQUIRE_EPOCHS_STRING()

c Created Sep 2017
c Parse &SNLCINP input REQUIRE_EPOCHS_STRING.
c Main goal is to select fast transients and reject the 
c larger source of Supernova.
c
c Example: 
c   REQUIRE_EPOCHS_STRING = 'FILTERS riz  TOBS_RANGES  14 20 25 SNRMIN 5'
c   REQUIRE_EPOCHS_STRING = 'FILTERS riz  TREST_RANGES 14 20 25 SNRMIN 5'
c
c Legacy Example:  
c    REQUIRE_EPOCHS_STRING = 'gri 14 20 21'
c --> For the gri passbands:
c  + Require (MJD_max - MJD_min)_DETECT < 20 days = [TRANGE(2)]
c  + require NOBS>=1 within 14 days before MJD_min  [TRANGE(1)]
c  + require NOBS>=1 within 21 days after  MJD_max  [TRANGE(3)]
c
c  For TRANGE(2), a "detection" is defined by SNR > CUTWIN_SNRMAX(1).
c  The NOBS>=1 requirements ensure observations before and after
c  the detect-range to avoid edge effects such as a falling
c  light curve at the start of a season where we can't see the
c  entire LC. Such edge cases can be rejected.
c
c  Setting TRANGE(1)=0 or TRANGE(3)=0 will disable the 
c  corresponding requirement.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,REQEPCOM.

      INTEGER ifilt, IFILT_OBS, iwd, NWD, i, L0, L1, MSKOPT
      character FNAM*28, CFILT*2, cwd0*80, cwd1*80
      LOGICAL LEGACY, USEWD(40)

      INTEGER FILTINDX

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------------- BEGIN ----------------

      FNAM = 'PARSE_REQUIRE_EPOCHS_STRING'
      MSKOPT = MSKOPT_PARSE_WORDS_STRING

c set defaults
      ISFRAME_REST_REQEP = .FALSE. 
      ISFRAME_OBS_REQEP  = .FALSE.
      DO i = 1, 3
        TRANGE_REQEP(i)  = 0.0 
      ENDDO
      NFILT_REQEP     = 0
      FILTLIST_REQEP  = ''
      SNRMIN_REQEP    = 0.0   ! defines detection

      IF ( REQUIRE_EPOCHS_STRING .EQ. '' ) RETURN

      NWD = STORE_PARSE_WORDS(MSKOPT,REQUIRE_EPOCHS_STRING//char(0),
     &          FNAM//char(0), 100, 22 )

      LEGACY = ( NWD .EQ. 4 ) 

      IF ( LEGACY ) THEN
        ISFRAME_OBS_REQEP = .TRUE.
        call get_PARSE_WORD_fortran(1, cwd0, L0)
        read( CWD0,* ) FILTLIST_REQEP

        call get_PARSE_WORD_fortran(2, cwd0, L0)
        read( CWD0,* ) TRANGE_REQEP(1)

        call get_PARSE_WORD_fortran(3, cwd0, L0)
        read( CWD0,* ) TRANGE_REQEP(2)

        call get_PARSE_WORD_fortran(4, cwd0, L0)
        read( CWD0,* ) TRANGE_REQEP(3)

        SNRMIN_REQEP = CUTWIN_SNRMAX(1)
      ELSE
         DO iwd = 1, NWD
            USEWD(iwd) = .FALSE.
         ENDDO
 
         DO 44 iwd = 1, NWD-1

           call get_PARSE_WORD_fortran(iwd+0, cwd0, L0)
           call get_PARSE_WORD_fortran(iwd+1, cwd1, L1)
          
           if ( cwd0(1:7) .EQ. 'FILTERS' ) then
              read(cwd1,* ) FILTLIST_REQEP
              USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
           else if ( cwd0(1:6) .EQ. 'SNRMIN' ) then
              read(cwd1,* ) SNRMIN_REQEP
              USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
           else if ( cwd0(1:11) .EQ. 'TOBS_RANGES' ) then
              USEWD(iwd) = .TRUE.;  
              ISFRAME_OBS_REQEP = .TRUE.
              do i = 1, 3
                call get_PARSE_WORD_fortran(iwd+i, cwd1, L1)
                read(cwd1,* ) TRANGE_REQEP(i); USEWD(iwd+i)=.TRUE.
              enddo
           else if ( cwd0(1:12) .EQ. 'TREST_RANGES' ) then
              USEWD(iwd) = .TRUE.;  
              ISFRAME_REST_REQEP = .TRUE.
              do i = 1, 3
                call get_PARSE_WORD_fortran(iwd+i, cwd1, L1)
                read(cwd1,* ) TRANGE_REQEP(i); USEWD(iwd+i)=.TRUE.
              enddo
           endif

44       CONTINUE
      ENDIF

c ------------------------------------------
c store absolute filter indices in sparse list
      NFILT_REQEP = INDEX(FILTLIST_REQEP,' ') - 1
      DO 10 ifilt=1, NFILT_REQEP
        CFILT = FILTLIST_REQEP(ifilt:ifilt)
        IFILT_OBS = FILTINDX(cfilt // ' ')
        IFILTLIST_REQEP(IFILT) = IFILT_OBS
10    CONTINUE

      CALL PRBANNER(FNAM)      
      print*,'   Require Epochs for filters : ', 
     &       FILTLIST_REQEP(1:NFILT_REQEP)
      
      write(6,41) 'Detection Requires SNR  > ', SNRMIN_REQEP        
      write(6,42) '(Tlast - Tfirst)_Detect < ', TRANGE_REQEP(2)
      write(6,42) 'Pre-detect  veto range  = ', TRANGE_REQEP(1)
      write(6,42) 'Post-detect veto range  = ', TRANGE_REQEP(3)
      print*,' ISFRAME[OBS,REST] = ', 
     &     ISFRAME_OBS_REQEP, ISFRAME_REST_REQEP
41    format(T8,A, F6.1 )
42    format(T8,A, F6.1, ' days' )

      RETURN
      END         ! end PARSE_REQUIRE_EPOCHS_STRING



C ========================================================
+DECK,INIT_MAGCOR.
      SUBROUTINE INIT_MAGCOR(MAGCOR_INFILE)

c Created Dec 7 2016 by R.Kessler
c Read optional list of mag-correction vs. epoch from ASCII file.
c The file syntax is a FITRES-formatted file containing
c    VARNAMES:  ROW  MAGCOR EXTRA1 EXTRA2 ...
c    SN: [CID]-[MJD]-[BAND]  [MAGCOR] [EXTRA1] [EXTRA2]
c    etc ..
c and see snana manual section  "Epoch-Dependent Mag Corrections".
c Here we read only ROW and MAGCOR, and ignore all other variables.
c ROW must be first column, but MAGCOR can be in any column.
c 
c If there is a minus sign in front of the file name,
c     MAGCOR_INFILE = '-/BLA/BLA/MAGCOR.DAT'
c then subtract MAGCOR instead of adding.
c
c  NVAR: 2
c  VARNAMES:  ROW  MAGCOR
c  ROW:  [CID]-[MJD]-[BAND]  [MAGCOR]
c  ROW:  [CID]-[MJD]-[BAND]  [MAGCOR]
c   etc ...
c
c Additional columns are allowed, but will be ignored.
c
c Nov 13 2018: pass MAGCOR_INFILE as input argument.
c
c ----------------------

      IMPLICIT NONE
    
+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER MAGCOR_INFILE*(MXCHAR_FILENAME)  ! (I)

      INTEGER LEN1, LEN2, LEN3, OPTMASK_STORE, ISTAT
      CHARACTER 
     &     cFILE*(MXCHAR_FILENAME)
     &    ,cTABLE*20, cVARLIST*20, FNAM*12

c functions
      INTEGER  SNTABLE_AUTOSTORE_INIT, EXIST_VARNAME_AUTOSTORE
      EXTERNAL SNTABLE_AUTOSTORE_INIT, EXIST_VARNAME_AUTOSTORE
      INTEGER ISTAT_MAGCOR_ADD

C ------------ BEGIN -------------

      NSTORE_MAGCOR = 0
      NUSE_MAGCOR   = 0
      IF ( MAGCOR_INFILE .EQ. ' '    ) RETURN
      IF ( MAGCOR_INFILE .EQ. 'NULL' ) RETURN
      IF ( MAGCOR_INFILE .EQ. 'NONE' ) RETURN

      SIGN_MAGCOR = +1  ! default is to add
      IF ( MAGCOR_INFILE(1:1) .EQ. '-' ) THEN
         SIGN_MAGCOR = -1  ! subtract instead
         MAGCOR_INFILE = MAGCOR_INFILE(2:)
      ENDIF

      FNAM = 'INIT_MAGCOR'
      CALL PRBANNER('INIT_MAGCOR: read mag-correction vs. epoch')

      CALL ENVreplace(MAGCOR_INFILE) 
      LEN1   = INDEX(MAGCOR_INFILE,' ') - 1
      cFILE  = MAGCOR_INFILE(1:LEN1) // char(0)

c check header to see if if MAGCOR has been added in version
c ISTAT=1 if MAGCOR alread added ; ISTAT=0 if not already added.
      ISTAT = ISTAT_MAGCOR_ADD(MAGCOR_INFILE,VERSION_PHOTOMETRY(1))

c avoid double-counting MAGCOR
      IF ( ISTAT==0 .and. SIGN_MAGCOR < 0 ) THEN
         C1ERR = 'MAGCOR not in data fluxes --> '
         C2ERR = 'Will not subtract MAGCOR'
         CALL MADABORT(FNAM,C1ERR,C2ERR)          
      ENDIF
      IF ( ISTAT==1 .and. SIGN_MAGCOR > 0 ) THEN
         C1ERR = 'MAGCOR already in data fluxes --> '
         C2ERR = 'Will not double-count MAGCOR.'
         CALL MADABORT(FNAM,C1ERR,C2ERR)          
      ENDIF

      cTABLE = 'MAGCOR' // char(0)  ! any table name will work for ASCII
      LEN2   = INDEX(cTABLE,' ') - 1

      cVARLIST = 'MAGCOR' // char(0)
      LEN3     = INDEX(cVARLIST,' ') - 1

      OPTMASK_STORE = 5  ! 1->5 on May 11 2017
      NSTORE_MAGCOR = 
     &       SNTABLE_AUTOSTORE_INIT(cFILE, cTABLE, cVARLIST, 
     &               OPTMASK_STORE,  LEN1, LEN2, LEN3 )

      write(6,20) NSTORE_MAGCOR
 20   format(/, T4,'Stored ', I6, ' epochs of MAG corrections. ')
      print*,'    Sign of MAGCOR : ', SIGN_MAGCOR
      print*,' '  ;  CALL FLUSH(6)

      RETURN
      END  ! end INIT_MAGCOR


C ========================================      
+DECK,ISTAT_MAGCOR_ADD.
      INTEGER FUNCTION ISTAT_MAGCOR_ADD(MAGCOR_FILE,VERSION)

c Check header of MAGCOR_FILE to see if VERSION has MAGCOR
c already added.  CHeck MAGCOR_FILE for
c
c   VERSION_ADD:  <VERSION>
c
c If MAGCOR already added in data files, return 1.
c If MAGCOR not added, return 0
c
c This function is used to help avoid double-counting MAGCOR,
c but the MAGCOR-add process (outside SNANA) must add  the 
c VERSION_ADD key at the top of the file.
c
c May 22 2018: skip lines with comment field

      IMPLICIT NONE
+CDE,SNPAR.

c inputs
      CHARACTER MAGCOR_FILE*(*), VERSION*(*)

c local
      INTEGER FOUND_ROW, LUN, NWD, LEN, LENVER, NLINE, MSKOPT
      LOGICAL SAME_LEN, SAME_VER, KEYMATCH
      CHARACTER LINE*200, cwd*80, VERSION_ADD*80, FNAM*22
      CHARACTER C1ERR*72, C2ERR*72

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
C --------------- BEGIN ---------------

      ISTAT_MAGCOR_ADD = 0 ! init function value
      FNAM   = 'ISTAT_MAGCOR_ADD'
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      LENVER = INDEX(VERSION,' ' ) - 1
 
      NLINE=0; FOUND_ROW=0 ; LUN = 24
      OPEN(   UNIT   = LUN
     &      , FILE   = MAGCOR_FILE
     &      , STATUS = 'OLD'
     &           )    


c keep reading until first ROW key is found
     
      DO 200 WHILE ( FOUND_ROW == 0 ) 
         READ(LUN,100) LINE
 100     format(A160)

         IF ( LINE(1:1) .EQ. '#' ) GOTO 200

         NLINE = NLINE + 1

         if ( NLINE > 50 ) then
            C1ERR = 'Could not find ROW key after 50 lines.'
            C2ERR = 'Check ' // MAGCOR_FILE
            CALL MADABORT(FNAM,C1ERR,C2ERR)   
         endif

         NWD = STORE_PARSE_WORDS(MSKOPT, LINE//char(0), 
     &            FNAM//char(0), 200, 22)

         if ( NWD < 2 ) goto 200

         CALL get_PARSE_WORD_fortran(1,cwd,LEN)

         IF ( cwd(1:4) .EQ. 'ROW:' ) goto 500
         
         KEYMATCH = cwd(1:16) .EQ. 'VERSION_ADD:' 
         IF ( KEYMATCH ) THEN
            CALL get_PARSE_WORD_fortran(2,VERSION_ADD,LEN) 
            SAME_LEN = ( LEN .EQ. LENVER )
            SAME_VER = ( VERSION(1:LEN) .EQ. VERSION_ADD(1:LEN) ) 
            IF ( SAME_LEN .and. SAME_VER ) THEN               
              ISTAT_MAGCOR_ADD = 1 
              GOTO 500
            ENDIF
         ENDIF
200   CONTINUE
      
500   CONTINUE
      CLOSE(UNIT = LUN)

      RETURN
      END

C ========================================================
+DECK,EXEC_MAGCOR.
      SUBROUTINE EXEC_MAGCOR(ep)

c Dec 2016
c Apply MAGCOR read in INIT_MAGCOR. The corrections are
c applied to the FLUXCAL.
c Modify SNLC_FLUXCAL(ep) and SNLC_MAG(ep)
c
c May 1 2017: abort on crazy MAGCOR
c ---------------------------------

      IMPLICIT NONE
    
      INTEGER ep ! epoch index

c local variables
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
      
      INTEGER IFILT_OBS, ISTAT, L, L2
      REAL*8 MJD, DVAL
      REAL*4 MAGCOR, FCOR
      CHARACTER cVARNAME*20, BAND*2, cDUM*20
      CHARACTER STR_EPID1*60, STR_EPID2*60

      REAL MAGCOR_CRAZY
      PARAMETER ( MAGCOR_CRAZY = 0.2 ) 

c function
      EXTERNAL SNTABLE_AUTOSTORE_READ
c --------------- BEGIN -----------------

      IF ( NSTORE_MAGCOR <= 0 ) RETURN

      IFILT_OBS = ISNLC_IFILT_OBS(ep)
      BAND      = FILTDEF_STRING(ifilt_obs:ifilt_obs)       
      MJD       = SNLC8_MJD(ep)

c construct unique epoch-identifier by gluing SNID+MJD+BAND
c into a single string.

      L  = INDEX(SNLC_CCID,' ') - 1
      WRITE(STR_EPID1,40) SNLC_CCID(1:L), MJD, BAND, char(0)
40    FORMAT(A,'-',F9.3,'-', A1, A )

      cVARNAME = 'MAGCOR' // char(0)

      CALL SNTABLE_AUTOSTORE_READ(STR_EPID1, cVARNAME, ISTAT,
     &                 DVAL,cDUM, 60,10,10 )

c if no MAGCOR, then try again with IAUC name
      IF ( ISTAT .NE. 0 ) THEN
        L2  = INDEX(SNLC_NAME_IAUC,' ') - 1
        WRITE(STR_EPID2,40) SNLC_NAME_IAUC(1:L2), MJD, BAND, char(0)
        CALL SNTABLE_AUTOSTORE_READ(STR_EPID2, cVARNAME, ISTAT, 
     &                 DVAL,cDUM, 60,10,10 )
      ENDIF

      IF ( ISTAT .EQ. 0 ) then
        NUSE_MAGCOR  = NUSE_MAGCOR + 1
        MAGCOR = sngl(DVAL) * SIGN_MAGCOR

c trap crazy MAGCOR
        if ( abs(MAGCOR) > MAGCOR_CRAZY ) then
           write(C1ERR,61) MAGCOR
61         format('Crazy MAGCOR = ', G12.4 )
           C2ERR = 'Check ' // STR_EPID1(1:L+12)
           CALL MADABORT("EXEC_MAGCOR",C1ERR,C2ERR)
        endif

        FCOR   = 10**(-0.4*MAGCOR)

        SNLC_FLUXCAL(ep) = SNLC_FLUXCAL(ep) * FCOR
        SNLC_MAG(ep)     = SNLC_MAG(ep) + MAGCOR

c        write(6,66) DVAL, STR_EPID1, ISTAT
c66      format(' xxx MAGCOR=',F6.3,' for ', A20,'  ISTAT=',I3)
c        call flush(6)
      ENDIF

      CALL SETMASK_FLUXCOR_SNANA(MASK_FLUXCOR_SNANA)

      RETURN
      END  ! end EXEC_MAGCOR

C ========================================================
+DECK,END_MAGCOR.
      SUBROUTINE END_MAGCOR()
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.   
C --------------- BEGIN --------------

      IF ( NSTORE_MAGCOR == 0 ) RETURN

      print*,' '
      print*,' MAGCOR SUMMARY:'
      write(6,20) NUSE_MAGCOR, NSTORE_MAGCOR
20    format(T8,'Used ',I6,' MAGCOR epochs from ', 
     &          I6,' read from file.' )

      RETURN
      END


C ========================================================
+DECK,RD_VPEC_FILE.
      SUBROUTINE RD_VPEC_FILE()
c ----------------------------
      IMPLICIT NONE
c local var
+CDE,SNDATCOM.
+CDE,SNLCINP.
C ------------- BEGIN ------------
      IF ( VPEC_FILE .EQ. '' ) RETURN
      C1ERR = '&SNLCIP VPEC_FILE input is obsolete'
      C2ERR = 'Use HEADER_OVERRIDE_FILE'
      CALL MADABORT("RD_VPEC_FILE",C1ERR,C2ERR)   ! Jun 8 2020
      RETURN
      END  ! end of RD_VPEC_FILE


C ================================
+DECK,ZHD.
      SUBROUTINE REDSHIFT_HD()

c Created Oct 2013 by R.Kessler.
c Compute redshift 'ZHD' for  Hubble diagram, which is
c ZCMB + vPec correction.
c
c Nov 30 2016: 
c  + re-factor to use externally-computed SNLC_VPEC.
c    i.e., move the read-vpec-file stuff into RD_VPEC_FILE.
c
c
c Jan 26 2018: set SNLC_ZPEC[_ERR]
c
c ----------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      LOGICAL  DOCOR_VPEC
      REAL     ZERR1, ZERR2, ZPEC, ZPECERR

C ------------ BEGIN ---------

c init default with ZHD = CMB redshift
      SNLC_ZHD        = SNLC_ZCMB
      SNLC_ZHD_ERR    = SNLC_ZCMB_ERR

      DOCOR_VPEC = .FALSE.
      IF ( SNLC_VPEC     .NE. 0.0 ) DOCOR_VPEC = .TRUE.
      IF ( SNLC_VPEC_ERR .NE. 0.0 ) DOCOR_VPEC = .TRUE.

      SNLC_ZPEC     = SNLC_VPEC     / SNGL(CLIGHT)
      SNLC_ZPEC_ERR = SNLC_VPEC_ERR / SNGL(CLIGHT)

c ------------------------------------------
c re-compute ZHD and its error if SNLC_VPEC has non-null value
c Jan 3 2018: use VPEC (sigma_z) correction from Eq. 1 (A1) in
c             Davis 2012 [https://arxiv.org/pdf/1012.2912.pdf]

      IF ( DOCOR_VPEC ) THEN

         ZPEC     = ( SNLC_VPEC     / SNGL(CLIGHT) )
         ZPECERR  = ( SNLC_VPEC_ERR / SNGL(CLIGHT) )

         if ( RESTORE_WRONG_VPEC ) then
c    use incorrect VPEC convention ... to be deleted someday
            SNLC_ZHD = (1.0+SNLC_ZCMB) * (1.0+ZPEC) - 1.0  ! Jan 2018;
         else
c    use correct VPEC convention
            SNLC_ZHD = (1.0+SNLC_ZCMB) / (1.0+ZPEC) - 1.0  ! Oct 2020
         endif

         ZERR1 = SNLC_ZCMB_ERR  
         ZERR2 = ZPECERR * (1.0 + SNLC_ZCMB) ! Eq A1, Davis 2012
         SNLC_ZHD_ERR = sqrt(ZERR1*ZERR1 + ZERR2*ZERR2)
      ENDIF

      RETURN 
      END   ! REDSHIFT_HD

C ============================================
+DECK,SNRECON.
      SUBROUTINE SNRECON()
c
c Created Feb 10, 2006 by R.Kessler
c
c Miscellaneous reconstruction/computation of 
c useful variables for analysis.
c
c Includes:
c
c  * ISNLC_NFILT_TRESTMIN[MAX]
c  * ISNLC_NFILT_TREST2  
c  * SNLC_TREST(epoch)        = MJD - MJDatPEAK(search) 
c  * SNLC_TOBS(epoch)
c  *
c  * SNLC_FLUXCAL_ERRCALC(ifilt,epoch,isn)  ! calc flux error 
c  * SNHOST_ZPHOT[_ERR]
c  * SNLC_SNRMAX_FILT(ifilt)
c  * SNLC_SNRMAX_SORT(rank)
c  * SNLC_SNRMAX_IFILTDEF(ifilt)
c  * SNLC_FLUXCALMAX(ifilt)
c  * SNLC_FLUXCALMAX_ERR(ifilt)  ! Nov 2022
c
c  * correct SNLC_MAG and FLUXCAL for AB mag-offsets
c
c  * erase filter-epochs with bad photometry flag
c
c
c
c Feb 12 2018: for USE_SNHOST_ZPHOT=T, convert host zphot to host zcmb
c Feb 16 2018: compute SNHOST_SBMAG(ifilt)
c Mar 18 2017: fill SNLC_DTOBS[_SAMEFILT] = time since last obs
c Sep 16 2018: compute NOBS_DETECT and TLIVE_DETECT
c
c Nov 12 2018: check APPLY_FLUXCOR_BUG to apply bug of computing
c              SNRMAX variables before EXEC_FUDGE_FLUXCAL()
c
c Feb 08 2020: apply PSF, ZPERR, PHOTPROB cuts here so that USEFLAG is set.
c Feb 12 2020: check MWEBV_FORCE
c Nov 30 2020: compute SIM_EPCHI2FLUX for SNANA+EPOCHS table
c Feb 9  2022: fix bug setting SUBSURVEY_NAME_LIST
c -------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PRIVCOM.

c local var

      INTEGER 
     &   newmjd, ifilt, ifilt_obs, LENLIST, LENNAME, INDEX_OVP
     &  ,NBAND_SNRMAX, NBAND_SNRMAX2
     &  ,EPMIN, EPMAX, ep, isort, PHOTFLAG
     &  ,ORDER, INDEX_SORT(MXFILT_OBS)  ! SORT args

      REAL
     &   Fluxcal, Fluxcal_err, TRUEFLUX, ERRTEST
     &  ,Xnsig, MAG, SIM_MAG, magoff, ZP, PHOTPROB, TMP
     &  ,Tobs, z1, z, Trest, scale, arg, PSF, ZPERR
     &  ,Zhost, Zhosterr, LAMOBS, LAMZ1,  SNRMAX, SUM_AREAFRAC

      REAL*8  MJD8, EBV8, EBVERR8
      REAL*8  MJD8_LASTALL, MJD8_LASTFILT(MXFILT_ALL)
      REAL*8  MU_OLD, MU_NEW, z8
      LOGICAL 
     &   LSIG, LLAM, LZ, LTEST, LXMJD, LINCMJD
     &  ,LPSF, LZPERR, LPP, LERRTEST
     &  ,LSNRMAX(MXFILT_ALL)
     &  ,LSNRMAX2(MXFILT_ALL)
     &  ,LFLUX, LERR, LTMP, USE4SNRMAX

c function
      REAL*8   DLMAG8_REF
      EXTERNAL SORTFLOAT, modify_MWEBV_SFD
      INTEGER  ISTAT_REQUIRE_EPOCHS

C ------------------ BEGIN -----------------

c check to increment SUBSURVEY_LIST
c WARNING: If CFA follows CFA3, the code will think that CFA already exists as a survey  
      IF ( IDSURVEY .ne. IDSUBSURVEY ) THEN
        LENNAME = INDEX(SUBSURVEY_NAME,' ') - 1
        INDEX_OVP = INDEX(SUBSURVEY_NAME_LIST,SUBSURVEY_NAME(1:LENNAME)) 
        IF ( INDEX_OVP<=0 ) THEN
          LENLIST = INDEX(SUBSURVEY_NAME_LIST,' ') - 1
          if ( LENLIST == 0 ) then  
             SUBSURVEY_NAME_LIST = SUBSURVEY_NAME
          else
            SUBSURVEY_NAME_LIST = SUBSURVEY_NAME_LIST(1:LENLIST)
     &          // ',' // SUBSURVEY_NAME
          endif
        ENDIF
      ENDIF

c - - - - - - - - -
c prepare redshifts; e.g. use photo-z, apply systematic shifts, etc ...
      CALL SET_REDSHIFTS()

c - - - - -
      Z    = SNLC_REDSHIFT

      if ( Z > 0.0 ) then
         Z1 = 1.0  + z
      else
         Z1 = 1.0  ! in case Z = -9 is undefined; Trest -> Tobs
      endif

      ISNLC_NEPOCH_USE = 0


c ------ compute MJDMIN/MJDMAX here before calling SET_PKMJD ------

      SNLC8_MJDMIN  = 1.0E8
      SNLC8_MJDMAX  = 0.0
      DO NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        DO EP = EPMIN, EPMAX
          SNLC8_FLUXCAL(EP)        = DBLE(SNLC_FLUXCAL(ep))
          SNLC8_FLUXCAL_ERRTOT(EP) = DBLE(SNLC_FLUXCAL_ERRTOT(ep))
          MJD8  = SNLC8_MJD(EPMIN)
          IF( MJD8 .GT. SNLC8_MJDMAX ) SNLC8_MJDMAX = MJD8
          IF( MJD8 .LT. SNLC8_MJDMIN ) SNLC8_MJDMIN = MJD8
       ENDDO
      ENDDO

c Sep 21 2013: check option to modify MWEBV_SFD;
c Note that MWEBV and MWEBV_ERR are modified if OPT_MWEBV > 0
      EBV8 = DBLE(SNLC_MWEBV) ; EBVERR8 = DBLE(SNLC_MWEBV_ERR)

      CALL modify_MWEBV_SFD(OPT_MWEBV, SNLC8_RA, SNLC8_DEC,
     &                      EBV8, EBVERR8)  ! I -> O

      SNLC_MWEBV     = SNGL(EBV8)     * MWEBV_SCALE + MWEBV_SHIFT
      SNLC_MWEBV_ERR = SNGL(EBVERR8)  * MWEBV_SCALE      
      IF ( MWEBV_FORCE > -0.001 ) THEN
         SNLC_MWEBV = MWEBV_FORCE
         SNLC_MWEBV_ERR = 0.0
      ENDIF
 
c compute Galactic extinction in each band
c (Oct 11 2013: code moved from MAIN to here)
      CALL MWEBV_FLUXCOR()

c determine redshift for Hubble diagram (Oct 2013)
      CALL REDSHIFT_HD()

+SELF,IF=SNANA,SNFIT.
c get approx peakMJD
      if ( OPT_SETPKMJD > 0 ) THEN
         CALL SET_PEAKMJD()
      endif
+SELF.

      CALL SELECT_EPOCH_DRIVER(2) ! apply Trest cuts

c -----------------------------------------------
c pick host photoZ

      Zhost    = -9.0
      Zhosterr = -9.0

      if ( SNHOST_ZPHOT(1) .GT. 0.0 ) then
         zhost    = SNHOST_ZPHOT(1)
         zhosterr = SNHOST_ZPHOT_ERR(1)
      else
        SNHOST_ZPHOT(1)     = Zhost
        SNHOST_ZPHOT_ERR(1) = Zhosterr
      endif

       CALL SET_SNHOST_CONFUSION()

c compute lumi-distance using "standard" cosmology
c Useful as initial value for fits.

      IF ( Z .GT. 1.0E-5 ) THEN
         z8 = dble(z)
         SNLC_DLMAG  = SNGL(DLMAG8_REF(z8) )
      ELSE
         SNLC_DLMAG  = -9.0  ! undefined
      ENDIF


      do ifilt = 1, NFILTDEF_SURVEY   
         LSNRMAX(ifilt)       = .FALSE.
         LSNRMAX2(ifilt)      = .FALSE.
         MJD8_LASTFILT(ifilt) = -9.0
         CALL SET_SBMAG(ifilt)  ! Feb 17 2018: compute SBMAG from SBFLUX
      enddo
  
      NBAND_SNRMAX  = 0
      NBAND_SNRMAX2 = 0
      MJD8_LASTALL  = -9.0
      NEP_SIM_MAGOBS =  0
      SUM_AREAFRAC   = 0.0

c fill ISNLC_NFIELD with number of fields; 
      CALL COUNTFIELDS()

c init computation of PROB_TRUEFLUX
      CALL PROB_TRUEFLUX_CALC(0)

c = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
c = = = = = = = = START LOOP OVER EPOCHS = = = = = = = = 
c = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 
      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        MJD8  = SNLC8_MJD(EPMIN)
        Tobs  = SNGL(MJD8) - SNLC_SEARCH_PEAKMJD
        Trest = Tobs / z1

        SNLC_TOBS(EPMIN)  = Tobs
        SNLC_TREST(EPMIN) = Trest

        DO 201 EP = EPMIN, EPMAX

           ISNLC_SNRECON_USE(ep) = 0

           SNLC_TREST(EP) = Trest
           SNLC_TOBS(EP)  = Tobs
           IFILT_OBS = ISNLC_IFILT_OBS(ep)
           IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
           
           CALL CHECK_DUPLICATE_MJDBAND(ep) ! Jun 13 2017

c Feb 6 2020: fudge errors here before SNRMAX is computed

           CALL EXEC_FUDGE_FLUXCAL(ep)  ! flux and fluxerr fudges

           CALL SET_MAG(ep)  ! Jan 23 2018

           USE4SNRMAX = LFILTDEF_SNRMAX(ifilt_obs) ! Apr 2014

c test filter mean only if KCOR file is read.
           LLAM = .TRUE.

c Mar 22 2023 restore LLAM test that was mistakenly removed when
c             fortran-KCOR code was replaced with C code.
c 
          LZ = ( Z > 0 .and. Z < 998 )
          IF ( LZ .and. EXIST_CALIB_FILE ) THEN
            LAMOBS = FILTOBS_LAMAVG(ifilt_obs)
            LAMZ1  = LAMOBS / Z1
            LLAM   =
     &           LAMZ1  .GE. CUTWIN_LAMREST(1) .and.
     &           LAMZ1  .LE. CUTWIN_LAMREST(2) .and.
     &           LAMOBS .GE. CUTWIN_LAMOBS(1)  .and.	
     &           LAMOBS .LE. CUTWIN_LAMOBS(2)
          ENDIF
c
c strip off local variables.
          Fluxcal      = SNLC_FLUXCAL(ep)
          Fluxcal_err  = SNLC_FLUXCAL_ERRTOT(ep)
          mag          = SNLC_MAG(ep)

c Jan 3 2018: skip saturated mags
          if ( FLUXCAL_ERR .GE. 0.9E8 .AND. LSIM_SNANA ) GOTO 201

c convert sim-mag to SIM_FLUXCA
          IF ( ISJOB_SIM ) THEN
             ZP        = ZEROPOINT_FLUXCAL_DEFAULT
             SIM_MAG   = SIM_EPMAGOBS(ep)
             if ( SIM_MAG < 90.0 ) then
               NEP_SIM_MAGOBS = NEP_SIM_MAGOBS + 1 ! Nov 25 2019
               ARG            = 0.4*(ZP - SIM_MAG)
               TRUEFLUX       = 10.0**(ARG)
             else               
               TRUEFLUX = 0.0
             endif
             SIM_EPFLUXCAL(ep) = TRUEFLUX
             IF ( USESIM_TRUEFLUX ) SNLC_FLUXCAL(ep)=TRUEFLUX

             TMP  = (TRUEFLUX - FLUXCAL)/ FLUXCAL_ERR
             SIM_EPCHI2FLUX(ep) = TMP * TMP  ! Nov 30 2020
             SIM_EPPULL(ep)     = TMP        ! Mar 16 2021
             CALL PROB_TRUEFLUX_CALC(ep)
          ELSE
             SIM_EPFLUXCAL(ep)  = -9.0
             SIM_EPCHI2FLUX(ep) = -9.0
             SIM_EPPULL(ep)     = -9.0 
          ENDIF
 
+SELF,IF=SNANA,SNFIT.
          CALL FLUXERRCALC( ep, Fluxcal, Fluxcal_err )
+SELF.

c compute significance.
          Xnsig  = -999.0
          LERR   = (Fluxcal_err > 0.0 )
          LFLUX  = (abs(Fluxcal+9.0) > 1.0E-5 )  !  FLUXCAL != -9
          if ( LERR .and. LFLUX ) then
             Xnsig  = Fluxcal / Fluxcal_err
          endif

c ----------------
c Correct MAG and FLUXCAL  for  MAGOFF_AB.
c This correction is done AFTER Xsig = S/N is calculated

           magoff = MAGOBS_SHIFT_ZP_FILT(ifilt_OBS)
           SNLC_MAG(ep) = SNLC_MAG(ep) + magoff
           FLUXSCALE_ZP_FILT(IFILT_OBS) = 10.0**(-0.4 * magoff)

           if ( magoff .ne. 0.0 ) then
             scale = FLUXSCALE_ZP_FILT(IFILT_OBS) 
             SNLC_FLUXCAL(ep) =
     &       SNLC_FLUXCAL(ep) * Scale
             SNLC_FLUXCAL_ERRTOT(ep) =
     &       SNLC_FLUXCAL_ERRTOT(ep) * Scale
           endif


c Mar 2018: store time since last obs: all bands, and same band
          IF ( MJD8_LASTALL > 0.0 ) THEN
             SNLC_DTOBS(ep) = SNGL(MJD8 - MJD8_LASTALL)
          ENDIF
          IF ( MJD8_LASTFILT(ifilt) > 0.0 ) THEN
             SNLC_DTOBS_SAMEFILT(ep) = SNGL(MJD8 - MJD8_LASTFILT(ifilt))
          ENDIF
          MJD8_LASTALL         = MJD8
          MJD8_LASTFILT(ifilt) = MJD8

c ----------------
c signal is accepted if it passes S/noise cut,
c or it is within the Trest window.

          SNLC_SNR(ep) = Xnsig

c xxxxxxx mark delete Mar 2025 xxxxxxxx
c check how many obs are in the INCLUDE_MJD window (Aug 2015)
c          LINCMJD = MJD8 .GE. CUTWIN_MJD_INCLUDE(1) .and. 
c     &              MJD8 .LE. CUTWIN_MJD_INCLUDE(2)
c          IF ( LINCMJD ) ISNLC_NMJD_INCLUDE = ISNLC_NMJD_INCLUDE + 1
c xxxxxxxxxxxxxxxx

c check MJD-exclude window to reject epochs (but keep LC)
          LXMJD = MJD8 .GE. CUTWIN_MJD_EXCLUDE(1) .and. 
     &            MJD8 .LE. CUTWIN_MJD_EXCLUDE(2)
            
c Feb 2020: check PSF and ZPERR cuts here
          PSF  = SNLC_PSF_FWHM_ARCSEC(EP)
          LPSF = PSF .GE. CUTWIN_PSF(1) .and. PSF.LE.CUTWIN_PSF(2)

          ZPERR  = SNLC_ZEROPT_ERR(EP)
          LZPERR = ZPERR .GE. CUTWIN_ZPERR(1) .and. 
     &             ZPERR .LE. CUTWIN_ZPERR(2)
        
          PHOTPROB = SNLC_PHOTPROB(ep)
          LPP  = (PHOTPROB > CUTWIN_PHOTPROB(1) .OR. PHOTPROB<-0.001)

          ERRTEST = SNLC_FLUXCAL_ERRTEST(ep)
          LERRTEST = ERRTEST .GE. CUTWIN_ERRTEST(1) .and. ! Mar 2021
     &               ERRTEST .LE. CUTWIN_ERRTEST(2)

          LSIG = Xnsig .GE. cutwin_snrmin_filt(1,ifilt)
     &     .and. Tobs  .GE. cutwin_Tobs(1)  
     &     .and. Tobs  .LE. cutwin_Tobs(2)  
     &     .and. Trest .GE. cutwin_Trest(1)  
     &     .and. Trest .LE. cutwin_Trest(2)  
     &     .and. MJD8  .GE. cutwin_MJD(1)
     &     .and. MJD8  .LE. cutwin_MJD(2)
     &     .and. .not. LXMJD     ! Feb 2012
     &     .and. LLAM            ! rest-frame lambda OK (7/08/08)
     &     .and. LPSF .and. LZPERR .and. LPP    ! Feb 2020
     &     .and. LERRTEST                       ! Mar 2021
     &     .and. fluxcal_err >  0.0    ! flux err is > 0  

          IF ( .NOT. LSIG ) GOTO 201 ! Nov 30, 2011

c set use-flag for this epoch
          ISNLC_SNRECON_USE(ep) = 1

          if ( USE4SNRMAX ) then
             SNLC_SNRMAX_FILT(0)     = 
     &            MAX ( SNLC_SNRMAX_FILT(0), Xnsig )
             SNLC_SNRMAX_FILT(ifilt) = 
     &            MAX ( SNLC_SNRMAX_FILT(ifilt), Xnsig )
          endif

          if ( Fluxcal > SNLC_FLUXCALMAX(ifilt) ) then
             SNLC_FLUXCALMAX(ifilt)     = Fluxcal
             SNLC_FLUXCALMAX_ERR(ifilt) = Fluxcal_err
          endif

          EXIST_FILT(ifilt) = .TRUE.
          ISNLC_NEPOCH_USE  = ISNLC_NEPOCH_USE + 1

c track number of filters that pass SNRMAX cut
          LTEST = XNSIG .GE. CUTWIN_SNRMAX(1)
          LTMP  = USE4SNRMAX .and. (.not. LSNRMAX(ifilt))

          IF ( LTEST .and. LTMP ) THEN
             NBAND_SNRMAX = NBAND_SNRMAX + 1
             LSNRMAX(ifilt) = .TRUE.
          ENDIF

c repeat for 2nd SNRMAX2 cut 
          LTEST = XNSIG .GE. CUTWIN_SNRMAX2(1)
          LTMP  = USE4SNRMAX .and. (.not. LSNRMAX2(ifilt))
          IF ( LTEST .and. LTMP ) THEN
             NBAND_SNRMAX2 = NBAND_SNRMAX2 + 1
             LSNRMAX2(ifilt) = .TRUE.
          ENDIF

c check PHOTPROB (Mar 2018)
          PHOTPROB = SNLC_PHOTPROB(ep)
          if ( PHOTPROB > -0.0001 ) then
             SNLC_PHOTPROB_MIN = MIN(SNLC_PHOTPROB_MIN,PHOTPROB)
             ISNLC_NEPOCH_PHOTPROB = ISNLC_NEPOCH_PHOTPROB + 1
          endif

c if PHOTFLAG detection bit is set by user, compute MJD of first & last detection
          PHOTFLAG = ISNLC_PHOTFLAG(ep)
          if ( IAND(PHOTFLAG,PHOTFLAG_DETECT) > 0 ) then
             ISNLC_NOBS_DETECT = ISNLC_NOBS_DETECT + 1
             if ( ISNLC_NOBS_DETECT == 1 ) then
                SNLC8_MJD_DETECT_FIRST = MJD8
             endif
             SNLC8_MJD_DETECT_LAST = MJD8
          endif

c check for trigger bit set by survey (5.2019)          
          if ( IAND(PHOTFLAG,PHOTFLAG_TRIGGER) > 0 ) then
             SNLC8_MJD_TRIGGER = MJD8
          endif

+SELF,IF=SNANA,SNFIT.
          CALL CCD_AREAFRAC(ep)
          IF ( SNLC_AREAFRAC(ep) > -0.001 ) then
             SUM_AREAFRAC = SUM_AREAFRAC + SNLC_AREAFRAC(ep)
          ENDIF
+SELF.

c Mar 2025 : count NOBS_PREDETECT
          TMP = MJD8 - SNLC8_MJD_DETECT_FIRST  ! TMP < 0 for pre-detection
          if ( TMP .GE.  CUTWIN_TOBS_PREDETECT(1) .and.
     &         TMP .LE.  CUTWIN_TOBS_PREDETECT(2)  ) then
             ISNLC_NOBS_PREDETECT =  ISNLC_NOBS_PREDETECT + 1
          endif

201     CONTINUE     ! come here of LSIG fails

200   CONTINUE  ! NEWMJD

c - - - - - -  -

      SNLC_TLIVE_DETECT = 
     &   SNGL(SNLC8_MJD_DETECT_LAST - SNLC8_MJD_DETECT_FIRST)

      ISNLC_NFILT_SNRMAX    = NBAND_SNRMAX
      ISNLC_NFILT_SNRMAX2   = NBAND_SNRMAX2

      ORDER = -1
      CALL SORTFLOAT( NFILTDEF_SURVEY, SNLC_SNRMAX_FILT(1), 
     &                 ORDER, INDEX_SORT(1) )

      DO isort  = 1, NFILTDEF_SURVEY
         ifilt  = INDEX_SORT(isort)
         SNRMAX = SNLC_SNRMAX_FILT(ifilt)
         SNLC_SNRMAX_SORT(isort) = SNRMAX
      ENDDO

c -----------------------------------------
      CALL GET_USERTAG(SNLC_CCID )

c ----------------------------------------
c Oct 2014: check for multi-season activity
 
      CALL MULTISEASON(IFLAG_ANA)

c check epochs above/below threshold
      ISNLC_CUTFLAG_REQEP = ISTAT_REQUIRE_EPOCHS()

c evalute cuts on PRIVATE & SIMVAR variables
      CALL EVAL_PRIVATEVAR_CUTS()
      CALL EVAL_SIMVAR_CUTS()

c check option to estimate LC width
      CALL GET_SIM_LCWIDTH(1)

c check option to compute PROB_TRUEFLUX_CALC per band
      CALL PROB_TRUEFLUX_CALC(-1)

c May 2017: load ADDCOL arrays
      CALL TABLE_ADDCOL_LOAD()

      IF ( ISNLC_NEPOCH_USE > 0 ) then
        SNLC_AREAFRAC_AVG = SUM_AREAFRAC/float(ISNLC_NEPOCH_USE)
      ENDIF

      RETURN
      END   ! end of SNRECON

C =============================
+DECK,SET_REDSHIFTS.
      SUBROUTINE SET_REDSHIFTS()
c
c Created Jun 2021
c Called near beginning of SNRECON, this is a driver routine
c to finalize redshifts:
c  + option to use host photo-z
c  + fix for missing zHELIO (on very old surveys)
c  + systematic shifts
c  + etc ...

      IMPLICIT NONE

c +CDE,SNDATCOM.
c +CDE,SNLCINP.

C -------------- BEGIN ----------

c Check option to use host photo-z as redshift.
      CALL SET_SNHOST_ZPHOT()

c if ZHELIO < 0, convert zCMB -> zHELIO
      CALL SET_ZHELIO()

c check for systematic shifts
      CALL SET_zSHIFT()

      RETURN
      END  ! end SET_REDSHIFTS

C =============================
+DECK,SET_ZHELIO.
      SUBROUTINE SET_ZHELIO()

C Creatd Feb 25 2018
c If SNLC_ZHELIO < 0, transform from zCMB.
c Otherwise, check zHEL <-> zCMB transformation.
c If zCMB < 0 for TEXT format, compute zCMB from zHEL.
c
c  Jun 8 2020
c   + fix awful bug with sign of OPT sent to translator.
c      was translating zHELIO -> CMB instead of zCMB -> zHELIO
c   + if SNLC_HELIO[CMB] are both given in data file, make
c     crosscheck here using zTOL_HELIO2CMB test on dz/z
c 
c Mar 15 2021: if zCMB < 0 for text format, use computed value.
c Jun 07 2022: do not abort on bad tolerance if REFORMAT_SNANA=T
c Jan 28 2024: do NOT check zTOL if zERR > 1.0 due to sim artifact
c              from GENSIGMA_REDSHIFT option;
c                https://github.com/RickKessler/SNANA/issues/1265
c
c ---------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER OPT
      CHARACTER EQ*4, FNAM*12
      REAL*8  ZHEL8, ZCMB8, DZ8, zRATIO8
      LOGICAL BADz, SKIP_BADz

      REAL*8 zhelio_zcmb_translator ! function

C ------------- BEGIN ------------

      FNAM = 'SET_ZHELIO'

c now we have undefined zCMB

      EQ     = 'eq' // char(0)

c don't apply test on VERY low redshifts to avoid silly round-off
c or truncation errors. This is a hack to protect DES DIFFIMG that 
c has redshifts written as %.4f. Next dataFile update will have %.6f
c precisions and then can apply test all the way down to z ~ 1E-4

      IF ( SNLC_ZHELIO > 0.003 ) THEN  ! 0.003 is temp hack; should be 1E-4
         OPT    = +1  ! --> convert ZHEL to ZCMB
         ZHEL8 = DBLE(SNLC_ZHELIO)
         ZCMB8 = 
     &      zhelio_zcmb_translator(ZHEL8,SNLC8_RA,SNLC8_DEC,EQ,OPT, 4)

c For TEXT format only, set zCMB if not provided (Mar 15 2021);
c allows quick/sloppy makeDataFiles with real data.
         IF ( SNLC_zCMB < 0.0 .and. FORMAT_TEXT ) THEN
           SNLC_zCMB     = SNGL(ZCMB8)
           SNLC_zCMB_ERR = SNLC_ZHELIO_ERR
         ENDIF

         zRATIO8 = zCMB8/DBLE(SNLC_zCMB)
         DZ8     = abs(1.0 - zRATIO8)

         BADz      = ( SNLC_zCMB > 0.0 .and. DZ8 > zTOL_HELIO2CMB )
         SKIP_BADz = REFORMAT_SNANA .or. (SNLC_ZHELIO_ERR .GE. 0.9999)

         if ( BADz .and. .NOT.SKIP_BADz ) THEN
            CALL PRINT_PREABORT_BANNER(FNAM(1:10)//char(0),12)
            print*,' zHEL(dataFile) = ', SNLC_ZHELIO
            print*,' zCMB(dataFile) = ', SNLC_ZCMB
            print*,' zCMB(compute)  = ', ZCMB8
            print*,' zRATIO = zCMB(compute)/zCMB(dataFile) = ', 
     &                 sngl(zRATIO8)
            print*,' zTOL_HELIO2CMB = ', zTOL_HELIO2CMB
            C1ERR='Computed zCMB (from zHEL) outside tolerance w.r.t.'
            C2ERR='REDSHIFT_CMB in data file for CID=' // SNLC_CCID
            CALL MADABORT(FNAM,C1ERR,C2ERR)
         endif

      ELSE if ( SNLC_ZHELIO < 0.0 ) THEN
         OPT    = -1 ! --> convert CMB -> zHEL
cc         OPT    = +1 ! --> BUG
         ZCMB8  = DBLE ( SNLC_ZCMB )
         ZHEL8  = 
     &    zhelio_zcmb_translator(ZCMB8,SNLC8_RA,SNLC8_DEC,EQ,OPT, 4)

         SNLC_ZHELIO       = SNGL(ZHEL8)
         SNLC_ZHELIO_ERR   = SNLC_ZCMB_ERR
         SNLC_REDSHIFT     = SNLC_ZHELIO
         SNLC_REDSHIFT_ERR = SNLC_ZHELIO_ERR
      ENDIF

      RETURN
      END   ! end SET_ZHELIO

C =============================================
+DECK,SET_SNHOST_ZPHOT.
      SUBROUTINE SET_SNHOST_ZPHOT
  
c if USE_SNHOST_ZPHOT=T then set redshift variables to host zphot.
c This ignores accurate specz to enable using photo-z.

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER OPT
      CHARACTER EQ*4
      REAL*8  ZCMB8, ZHEL8

      REAL*8 zhelio_zcmb_translator ! function
C -------------- BEGIN ----------------

      IF ( .not. (USE_SNHOST_ZPHOT .or. USE_HOSTGAL_PHOTOZ) ) RETURN

      if ( .not. EXIST_SNHOST_ZPHOT ) then
          C1ERR = 'Cannot USE_HOSTGAL_PHOTOZ for CID='//SNLC_CCID
          C2ERR = 'Check data files, or set USE_HOSTGAL_PHOTOZ=F'
          CALL MADABORT("SNRECON", c1err, c2err )
      endif        

      OPT    = 1     ! --> convert ZHEL to ZCMB
      EQ     = 'eq' // char(0)
      ZHEL8  = DBLE( SNHOST_ZPHOT(1) )
      ZCMB8  =
     &    zhelio_zcmb_translator(ZHEL8,SNLC8_RA,SNLC8_DEC,EQ,OPT,4)

      SNLC_ZCMB         = SNGL(ZCMB8)
      SNLC_ZHELIO       = SNGL(ZHEL8)        
      SNLC_REDSHIFT     = SNGL(ZHEL8)

      SNLC_ZHELIO_ERR     = SNHOST_ZPHOT_ERR(1)
      SNLC_ZCMB_ERR       = SNHOST_ZPHOT_ERR(1)             
      SNLC_REDSHIFT_ERR   = SNHOST_ZPHOT_ERR(1)

      RETURN
      END     ! end SET_SNHOST_ZPHOT

C =============================================
+DECK,SET_zSHIFT.
      SUBROUTINE SET_zSHIFT
  
c Created Jun 5 2021
c Apply systematic z-shifts passed from &SNLCINP
c
c Dec 29 2024: allow ztol of 1E-5 to allow for slop in round-off in TEXT format
c Apr 22 2025: fix bug and shift ZPHOT_Q (quantiles)

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      LOGICAL LSHIFT_FINAL, LSHIFT_HOST_ZPHOT, LSHIFT_HOST_ZSPEC
      INTEGER OPT, q, igal
      REAL    zshift, ztol, zdif

      REAL*8 zhelio_zcmb_translator ! function
C -------------- BEGIN ----------------

c bail if none of the zSHIFT options are used
      if ( .not. DOzSHIFT ) RETURN

      LSHIFT_FINAL       = ( REDSHIFT_FINAL_SHIFT .NE. 0.0 )
      LSHIFT_HOST_ZSPEC  = ( HOSTGAL_ZSPEC_SHIFT  .NE. 0.0 )
      LSHIFT_HOST_ZPHOT  = ( HOSTGAL_ZPHOT_SHIFT  .NE. 0.0 )

      zshift = -9.0
      IF ( LSHIFT_FINAL ) THEN
         zshift  = REDSHIFT_FINAL_SHIFT 
      ENDIF

c Dec 29 2024: allow tolerance for round-off in text format
      ZTOL = 1.0E-5 
      
      IF ( LSHIFT_HOST_ZSPEC ) THEN
         zdif = SNHOST_ZSPEC(1) - SNLC_REDSHIFT 
         if ( abs(zdif) < ztol ) then
            zshift = HOSTGAL_ZSPEC_SHIFT + REDSHIFT_FINAL_SHIFT
            SNHOST_ZSPEC = SNHOST_ZSPEC + zshift
         endif
      ENDIF

      IF ( LSHIFT_HOST_ZPHOT ) THEN
         zdif = SNHOST_ZPHOT(1) - SNLC_REDSHIFT
         if ( abs(zdif) < ztol ) then
            zshift = HOSTGAL_ZPHOT_SHIFT + REDSHIFT_FINAL_SHIFT
            SNHOST_ZPHOT = SNHOST_zPHOT + zshift  
         endif

         if ( SNHOST_NZPHOT_Q > 0 ) then
            do q    = 1, SNHOST_NZPHOT_Q
            do igal = 1, MXSNHOST
	      SNHOST_ZPHOT_Q(igal,q) = SNHOST_ZPHOT_Q(igal,q) + zshift ! Apr 22 2025
            enddo  
            enddo
         endif
      ENDIF
      
      IF ( zshift .NE. -9.0 ) THEN
         if ( SNLC_REDSHIFT > 0.) SNLC_REDSHIFT = SNLC_REDSHIFT+ zshift
         if ( SNLC_ZHELIO   > 0.) SNLC_ZHELIO   = SNLC_ZHELIO  + zshift
         if ( SNLC_ZCMB     > 0.) SNLC_ZCMB     = SNLC_ZCMB    + zshift
      ENDIF

      RETURN
      END     ! end SET_zSHIFT

C ============================================
+DECK,IS_ZSPEC.
      LOGICAL FUNCTION IS_ZSPEC()

c Created March 20 2024 by R.Kessler and A.Mitra
c Return True if best redshift is a spec-z.
c Optimal logic is to use MASK_REDSHIFT_SOURCE that
c explcitly sets bit0 for host zspec and bit1 for SN zspec.
c However, if this MASK is not provided, one can assume
c specz if redshift error is less than &SNLCINP variable
c QUANTILE_ZERRMIN.

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

c define local zspec mask; 
c   grep MASK_REDSHIFT_SOURCE sndata.h
      INTEGER MASK_ZSPEC_SOURCE
      PARAMETER ( MASK_ZSPEC_SOURCE = 3) ! 1=zspec_host, 2=zspec(SN)

      IS_ZSPEC = (SNLC_REDSHIFT_ERR < QUANTILE_ZERRMIN) .or.
     &           (IAND(ISNLC_zSOURCE,MASK_ZSPEC_SOURCE) > 0)

      RETURN
      END

C ===============================
+DECK,SET_SNHOST_CONFUSION.
      SUBROUTINE SET_SNHOST_CONFUSION()
c 
c Created Sep 2 2022
c Compute HOST_CONFUSION based on Eq 3 in Gupta et al, 2016
c

      IMPLICIT NONE

+CDE,SNDATCOM.

      REAL*8   HC, DDLR_LIST(MXSNHOST)
      INTEGER  igal, NMATCH2
      LOGICAL LDMP / .FALSE. /
      character cCID*40

      REAL*8   HOST_CONFUSION
      EXTERNAL HOST_CONFUSION   ! see sntools.c
      
C ----------- BEGIN -------------

      SNHOST_CONFUSION = -9.0

      NMATCH2 = SNHOST_NMATCH2

c only the first MXSNHOST matches are stored
      if ( NMATCH2 > MXSNHOST ) NMATCH2 = MXSNHOST 

      if ( NMATCH2 .LE. 1 ) RETURN

c convert single precions to double precision
      DO igal = 1, NMATCH2
        DDLR_LIST(igal) = DBLE(SNHOST_DDLR(igal))
      ENDDO
      cCID = SNLC_CCID(1:ISNLC_LENCCID) // char(0)
      HC = HOST_CONFUSION(cCID,NMATCH2,DDLR_LIST,40)

      IF ( LDMP ) THEN
         print*,' xxx ----------------------------------------- '
         print*, ' xxx DUMP for SET_SNHOST_CONFUSION '
         write(6,60) SNLC_CCID(1:12), NMATCH2, 
     &         DDLR_LIST(1), DDLR_LIST(2)
60       format('  xxx CID=',A, 3x, 'NMATCH=',I2, 3x,'DDLR=', 2F9.3 )
         print*,' xxx HOST_CONFUSION = ', HC
         print*,' xxx '
 	 CALL FLUSH(6)
      ENDIF

      SNHOST_CONFUSION = SNGL(HC)

      RETURN
      END   ! end SET_SNHOST_CONFUSION

C ===============================
+DECK,SET_MAG.
      SUBROUTINE SET_MAG(ep)

C Created Jan 23 2018
C Compute observer mag SNLC_MAG(ep) to reduce
C data volume in files. Note that SNLC_MAGERR
c is not set because it is not used.
C 
C Aug 2022: check LDMP_SATURATE
c
      IMPLICIT NONE

      INTEGER ep  ! (I) epoch index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.

      REAL FLUXCAL, FLUXCAL_ERR, MAG, ZP
      INTEGER IFILT_OBS
      CHARACTER CFILT*2
C --------- BEGIN ------------

      Fluxcal      = SNLC_FLUXCAL(ep)
      Fluxcal_err  = SNLC_FLUXCAL_ERRTOT(ep)      

      IF ( FLUXCAL_ERR > 0.99E8 ) THEN
        MAG = MAG_SATURATE
        if ( LDMP_SATURATE ) then
             IFILT_OBS = ISNLC_IFILT_OBS(ep)
             cfilt     = FILTDEF_STRING(ifilt_obs:ifilt_obs)
             write(6,20) SNLC_CCID(1:8), SNLC_ZHELIO,
     &                   SNLC8_MJD(ep), CFILT(1:1), SIM_EPMAGOBS(ep)
20           format(T2,'SATURATION: ', 
     &          'CID=',A8, 2x, 'zHEL=',F6.4, 2x,
     &          'MJD=',F9.3,'-',A, 2x, 'TrueMag=',F8.3 )  
        endif
      ELSE IF ( FLUXCAL < 1.0E-9 ) THEN
        MAG = 128.0  ! negative flux
      ELSE 
        ZP  = SNGL(ZEROPOINT_FLUXCAL_DEFAULT)
        MAG = ZP - 2.5*LOG10(FLUXCAL)
      ENDIF

      SNLC_MAG(ep) = MAG

      RETURN
      END    ! end SET_MAG


C ===============================
+DECK,SET_SBMAG.
      SUBROUTINE SET_SBMAG(ifilt)

C Created Feb 17 2018
C Compute surface-brightness mag SNLC_SBMAG(ep) from SB flux.
C 
c Mar 23 2021: SBFLUXMIN -> 1.0 (was 0.1)
c Aug 11 2021: SBFLUX = -99 -> SBMAG=99
c
      IMPLICIT NONE
      INTEGER ifilt  ! (I) sparse filter index
+CDE,SNDATCOM.
      REAL SBFLUX, SBMAG, SBFLUXMIN, ZP
C --------- BEGIN ------------
      SBFLUX = SNHOST_SBFLUXCAL(ifilt)
      SBFLUXMIN = 1.0

      ZP = SNGL( ZEROPOINT_FLUXCAL_DEFAULT )
      IF ( SBFLUX > SBFLUXMIN ) THEN
         SBMAG = ZP - 2.5*LOG10(SBFLUX)
      ELSE
         SBMAG = ZP - 2.5*LOG10(SBFLUXMIN) 
      ENDIF

      IF ( SBFLUX .LE. -999.0 ) SBMAG = 99.0 ! Aug 2021 - undefined SB

      SNHOST_SBMAG(ifilt) = SBMAG
      RETURN
      END

C ========================
+DECK,PARSE_SIMVAR_CUTS.
      SUBROUTINE PARSE_SIMVAR_CUTS()
      IMPLICIT NONE

c Dec 2018
c Parse &SNLCINP input SIMVAR_CUTWIN_STRING

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER NTMP, i, NWD, LWD
      CHARACTER ctmp1*60, ctmp2*60, ctmp3*60, FNAM*20

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------- BEGIN ---------
      IF ( .NOT. ISJOB_SIM )  RETURN
      IF ( SIMVAR_CUTWIN_STRING .EQ. '' ) RETURN

      FNAM = 'PARSE_SIMVAR_CUTS'
      NTMP = 0 
      LWD = MXCHAR_CUTNAME-2
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_STRING,
     &     SIMVAR_CUTWIN_STRING(1:LWD)//char(0), FNAM//char(0), LWD, 20) 

      DO i = 1, NWD, 3
         NTMP = NTMP + 1
         CALL get_PARSE_WORD_fortran(i+0, ctmp1, LWD)
         CALL get_PARSE_WORD_fortran(i+1, ctmp2, LWD)
         CALL get_PARSE_WORD_fortran(i+2, ctmp3, LWD)
         SIMVAR_CUTWIN_LIST(NTMP) = CTMP1(1:40)
         READ(CTMP2,*)  SIMVAR_CUTWIN(1,NTMP)
         READ(CTMP3,*)  SIMVAR_CUTWIN(2,NTMP)
      ENDDO 
      NSIMVAR_CUTWIN = NTMP

      if ( NTMP > MXCUT_PRIVATE ) then
         write(c1err,61) NTMP, MXCUT_PRIVATE
 61      format('NSIMVAR_CUTWIN=',I2,' exceeds bound of ', I2)
         c2err = 'Check &SNLCINP input SIMCAR_CUTWIN_STRING'
         CALL MADABORT(FNAM, c1err, c2err )
      endif
      
      DO i = 1, NTMP
         LWD = INDEX(SIMVAR_CUTWIN_LIST(i),' ') - 1
         write(6,77) SIMVAR_CUTWIN_LIST(i)(1:LWD),
     &        SIMVAR_CUTWIN(1,i), SIMVAR_CUTWIN(2,i)
 77      format(T5,'SIMVAR_CUT on ', A20,' : ', F10.4,' to ', F10.4);
      ENDDO

      RETURN
      END   ! end PARSE_SIMVAR_CUTS


C ================================
+DECK,EVAL_SIMVAR_CUTS.
      SUBROUTINE EVAL_SIMVAR_CUTS()

c Created Dec 2018
c Evaluate PASS_SIMCUTS based on user-input SIMVAR_CUTWIN_STRING
c Check hard-coded SIM_xxx names, and also check SIMSED_xxx names.
c
c Nov 25 2019: check NEP_SIM_MAGOBS = number os SIM_MAGOBS < 99
c Jun 23 2020: abort of VARNAME not found
c Mar 07 2025: check SIM_PEAKMAG_[band]

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      LOGICAL FOUND
      INTEGER i, ipar, LENTMP, ifilt, ifilt_obs
      REAL*8  VMIN, VMAX
      CHARACTER VARNAME*40, CTMP*60, VARNAME_TMP*60, FNAM*20, cfilt*1

C --------------- BEGIN ------------

      IF ( NSIMVAR_CUTWIN == 0 ) RETURN
      FNAM = 'EVAL_SIMVAR_CUTS'

      DO 100 i = 1, NSIMVAR_CUTWIN
         FOUND   = .FALSE.
         VMIN    = DBLE( SIMVAR_CUTWIN(1,i) )
         VMAX    = DBLE( SIMVAR_CUTWIN(2,i) )
         VARNAME = SIMVAR_CUTWIN_LIST(i) 
         if ( VARNAME .EQ. 'SIM_ZCMB' ) then
            FOUND   = .TRUE.
            if ( SIM_REDSHIFT_CMB < VMIN ) PASS_SIMCUTS = .FALSE.
            if ( SIM_REDSHIFT_CMB > VMAX ) PASS_SIMCUTS = .FALSE.

         else if ( VARNAME .EQ. 'SIM_PEAKMJD' ) then
            FOUND   = .TRUE.
            if ( SIM_PEAKMJD < VMIN ) PASS_SIMCUTS = .FALSE.
            if ( SIM_PEAKMJD > VMAX ) PASS_SIMCUTS = .FALSE.

         else if ( VARNAME .EQ. 'SIM_SALT2c' ) then
            FOUND   = .TRUE.
            if ( SIM_COLORPAR < VMIN ) PASS_SIMCUTS = .FALSE.
            if ( SIM_COLORPAR > VMAX ) PASS_SIMCUTS = .FALSE.

         else if ( VARNAME .EQ. 'SIM_SALT2x1' ) then
            FOUND   = .TRUE.
            if ( SIM_SHAPEPAR < VMIN ) PASS_SIMCUTS = .FALSE.
            if ( SIM_SHAPEPAR > VMAX ) PASS_SIMCUTS = .FALSE.     

         else if ( VARNAME .EQ. 'NEP_SIM_MAGOBS' ) then
            FOUND   = .TRUE.
            if ( NEP_SIM_MAGOBS < int(VMIN) ) PASS_SIMCUTS = .FALSE.
            if ( NEP_SIM_MAGOBS > int(VMAX) ) PASS_SIMCUTS = .FALSE.     
         endif
     
c check SIMSED variables
         DO IPAR    = 1, NPAR_SIMSED
            CTMP    = SIMSED_PARNAME(ipar)
            LENTMP  = INDEX(CTMP,' ') - 1
            VARNAME_TMP = 'SIMSED_' // CTMP(1:LENTMP)
            if ( VARNAME .EQ. VARNAME_TMP ) then
            FOUND   = .TRUE.
               if ( SIMSED_PARVAL(ipar) < VMIN ) PASS_SIMCUTS = .FALSE.
               if ( SIMSED_PARVAL(ipar) > VMAX ) PASS_SIMCUTS = .FALSE.
            endif
         ENDDO

c  Mar 2025: check PEAKMAG
         do ifilt = 1, NFILTDEF_SURVEY
            ifilt_obs   = IFILTDEF_MAP_SURVEY(ifilt)
            cfilt       = FILTDEF_STRING(ifilt_obs:ifilt_obs)
            VARNAME_TMP = 'SIM_PEAKMAG_' // cfilt
            if ( VARNAME .EQ. VARNAME_TMP ) then
               FOUND   = .TRUE.
               if ( SIM_PEAKMAG(ifilt) < VMIN ) PASS_SIMCUTS = .FALSE.
               if ( SIM_PEAKMAG(ifilt) > VMAX ) PASS_SIMCUTS = .FALSE.
            endif
         enddo


         if ( .NOT. FOUND ) then
            c1err = 'Could not evaluate cut on ' // VARNAME(1:20)
            c2err = 'Check &SNLCINP  SIMVAR_CUTWIN_STRING'
            CALL MADABORT(FNAM, c1err, c2err )
         endif
 100  CONTINUE


      RETURN
      END  ! ene EVAL_SIMVAR_CUTS

C ======================================
+DECK,PRIVATECUTS.
      SUBROUTINE EVAL_PRIVATEVAR_CUTS()

c
c Created Nov 3 2014
c Evaluate optional cuts on private variables.
c PASS_PRIVCUTS has been initialized to TRUE; set this 
c flag to FALSE if any private variable cut-window fails.
c The private cuts are defined by &SNLCINP variable 

c PRIVATE_CUTWIN_STRING = 'VARNAME  CUTMIN  CUTMAX'
c   or
c PRIVATE_CUTWIN_STRING = 'VARNAME  != VETO_VALUE'
c
c Apr 27 2021: refactor to allow veto option
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      INTEGER ivar, APPLY_CUTFLAG
      REAL*8 VAL, CUTMIN, CUTMAX
C -------------- BEGIN ------------

      IF ( NCUT_PRIVATE .EQ. 0 ) RETURN

      DO 100 ivar = 1, NVAR_PRIVATE
         APPLY_CUTFLAG = USE_PRIVATE_CUTWIN(ivar)
         if ( APPLY_CUTFLAG == 0 ) goto 100

         ! strip off info stored from init stage
         VAL    = PRIVATE_VALUE(ivar)
         CUTMIN = PRIVATE_CUTWIN(1,IVAR)
         CUTMAX = PRIVATE_CUTWIN(2,IVAR) 

         IF ( APPLY_CUTFLAG < 0 ) then
            ! veto cut (Apr 2021)
            if ( VAL == CUTMIN ) PASS_PRIVCUTS = .FALSE.
         ELSE
            ! regular CUT-window
            if(VAL<CUTMIN .or. VAL>CUTMAX ) PASS_PRIVCUTS = .FALSE.
         ENDIF

         if ( .not. PASS_PRIVCUTS ) RETURN

 100  CONTINUE

      RETURN
      END    ! end of EVAL_PRIVATEVAR_CUTS()

C ===============================================
+DECK,INIFUDGEFLUX.
      SUBROUTINE INIT_FUDGE_FLUXCAL(IERR)

c
c Init fudges on FLUXCAL[ERR]
c Apr 2017: call INIT_NONLIN().
c Dec 2017: use IGNOREFILE function on FUDGE_HOSTNOISE_FILE
c              to allow NONE
c Feb 15 2018: call INIT_FLUXERRMODEL
c Apr 15 2018: mass OPTMASK argument to INIT_FLUXERRMODEL

      IMPLICIT NONE

      INTEGER IERR  ! (I) return 0 if all ok

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LL, OPTMASK, MSKTMP, RDMASK
      CHARACTER cFILE*(MXCHAR_FILENAME), cNONE*6, FNAM*20
      LOGICAL FORCE_FLUXERRCOR, FORCE_FLUXCOR, VALID_FILE
      LOGICAL ALLOW_FLUXERRCOR, ALLOW_FLUXCOR, ISDATA

c function in sntools.c
      INTEGER IGNOREFILE
C --------------- BEGIN ----------------

      IERR = 0 
      FNAM = 'INIT_FUDGE_FLUXCAL'

      DOFUDGE_HOSTNOISE    = .FALSE. 
      DOFUDGE_NONLIN       = .FALSE.
      DOFUDGE_FLUXERRMODEL = .FALSE.
      FORCEMASK_FLUXCOR    = 0 
      ISDATA = (.NOT. LSIM_SNANA)

c --------------------------------------------------------
c check FORCE option in case flux fudges already applied

      RDMASK = ISNLC_RDMASK_FLUXCOR_SNANA

      MSKTMP = MASK_FLUXERRCOR_SNANA
      CALL SETFORCE_FLUXCOR_SNANA(MSKTMP,FLUXERRMODEL_FILE)
      CALL SETFORCE_FLUXCOR_SNANA(MSKTMP,FUDGE_HOSTNOISE_FILE)
      FORCE_FLUXERRCOR = ( IAND(MSKTMP,FORCEMASK_FLUXCOR) > 0 ) 
      ALLOW_FLUXERRCOR = 
     &  FORCE_FLUXERRCOR .or. (IAND(RDMASK,MSKTMP)==0 )

      MSKTMP = MASK_FLUXCOR_SNANA
      CALL SETFORCE_FLUXCOR_SNANA(MSKTMP,MAGCOR_FILE)
      CALL SETFORCE_FLUXCOR_SNANA(MSKTMP,NONLINEARITY_FILE)
      FORCE_FLUXCOR  = ( IAND(MSKTMP,FORCEMASK_FLUXCOR) > 0 )
      ALLOW_FLUXCOR = 
     &  FORCE_FLUXCOR .or. (IAND(RDMASK,MSKTMP)==0 )

c ------------------------------------------------
      CALL ENVreplace(FUDGE_HOSTNOISE_FILE) 
      LL    = INDEX(FUDGE_HOSTNOISE_FILE,' ')-1
      cFILE = FUDGE_HOSTNOISE_FILE(1:LL) // char(0)
      IF ( IGNOREFILE(cFILE,LL) == 0 ) THEN
         DOFUDGE_HOSTNOISE = .TRUE.
         CALL INIT_NOISEMODEL_HOST_LEGACY( cFILE, LL );
      ENDIF       

c Apr 2017: check nonlinearity from user-supplied map      
      CALL ENVreplace(NONLINEARITY_FILE);
      LL    = INDEX(NONLINEARITY_FILE,' ')-1
      cFILE = NONLINEARITY_FILE(1:LL) // char(0)
      if ( IGNOREFILE(cFILE,LL) == 0 ) then
         DOFUDGE_NONLIN       = .TRUE.
         CALL INIT_NONLIN(cFile,LL)
      endif

c ------------------------------
c Feb 2018: check FLUXERRMAPs for DATA

      OPTMASK = FLUXERRMODEL_OPTMASK
      if ( REQUIRE_DOCANA .NE. 0 ) then
c   note that MASK_REQUIRE_DOCANA_FLUXERRMAP=1024 
c   in sntools_fluxErrModels.h      
         FLUXERRMODEL_OPTMASK = FLUXERRMODEL_OPTMASK + 1024 
      endif

      CALL ENVreplace(FLUXERRMODEL_FILE);
      LL    = INDEX(FLUXERRMODEL_FILE,' ')-1
      cFILE = FLUXERRMODEL_FILE(1:LL) // char(0)
      VALID_FILE = (IGNOREFILE(cFILE,LL) == 0)
      if ( VALID_FILE ) then
        CALL PRINTMSG_FLUXCOR(MASK_FLUXERRCOR_SNANA,"FLUXERRMODEL_FILE")
      endif
      IF ( VALID_FILE .and. ALLOW_FLUXERRCOR .and. ISDATA ) THEN
         cNONE = 'NONE' // char(0)
         DOFUDGE_FLUXERRMODEL = .TRUE.
         CALL INIT_FLUXERRMODEL(OPTMASK,cFile,cNONE,cNONE,LL,4,4)
      ENDIF
      
c March 2018: check FLUXERRMAPs for SIM
      CALL ENVreplace(SIM_FLUXERRMODEL_FILE);
      LL    = INDEX(SIM_FLUXERRMODEL_FILE,' ')-1
      cFILE = SIM_FLUXERRMODEL_FILE(1:LL) // char(0)
      IF ( IGNOREFILE(cFILE,LL) == 0  .and. LSIM_SNANA ) THEN
         cNONE = 'NONE' // char(0)
         DOFUDGE_FLUXERRMODEL = .TRUE.
         CALL INIT_FLUXERRMODEL(OPTMASK,cFile,cNONE,cNONE,LL,4,4)
      ENDIF

c ------------------------------------------------
c check MAGCOR (e.g. chromatic corrections) for data
c CALL INIT_MAGCOR()

      CALL ENVreplace(MAGCOR_FILE);
      LL    = INDEX(MAGCOR_FILE,' ')-1
      cFILE = MAGCOR_FILE(1:LL) // char(0)
      VALID_FILE = (IGNOREFILE(cFILE,LL) == 0) 
      if ( VALID_FILE ) then
        CALL PRINTMSG_FLUXCOR(MASK_FLUXCOR_SNANA,"MAGCOR_FILE")
      endif

      IF ( VALID_FILE .and. ALLOW_FLUXCOR .and. ISDATA ) THEN
         CALL INIT_MAGCOR(MAGCOR_FILE);
      ENDIF

c check SIM_MAGCOR_FILE
      CALL ENVreplace(SIM_MAGCOR_FILE);
      LL    = INDEX(SIM_MAGCOR_FILE,' ')-1
      cFILE = SIM_MAGCOR_FILE(1:LL) // char(0)
      IF ( IGNOREFILE(cFILE,LL) == 0  .and. LSIM_SNANA ) THEN
         CALL INIT_MAGCOR(SIM_MAGCOR_FILE);
      ENDIF

c - - - - - - - - - - - - - 
c error checking
      if ( DOFUDGE_HOSTNOISE .and. DOFUDGE_FLUXERRMODEL ) then
         c1err = 'Cannot specify FUDGE_HOSTNOISE_FILE ' // 
     &           'and FLUXERRMODEL_FILE'
         c2err = 'Use one file or the other.'
         CALL MADABORT(FNAM, c1err, c2err )
      endif

      RETURN
      END       ! end of INIT_FUDGE_FLUXCAL


C ==============================
+DECK,PRINTMSG_FLUXCOR.
      SUBROUTINE PRINTMSG_FLUXCOR(INMASK,CORFILE)

c Created Nov 14 2018
c Print appropriate message for FLUXCOR or FLUXERR correction.
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER  INMASK   ! (I) 1=fluxcor, 2=fluxerrcor

      INTEGER  RDMASK, LEN
      LOGICAL  ALLOW, FORCE, ISDATA
      CHARACTER*(*) CORFILE

C ------------------- BEGIN ------------------

      ISDATA = (.NOT. LSIM_SNANA)
      RDMASK = ISNLC_RDMASK_FLUXCOR_SNANA
      LEN    = INDEX(CORFILE,' ') - 1

      FORCE = ( IAND(INMASK,FORCEMASK_FLUXCOR)  > 0   ) 
      ALLOW = ( FORCE .or. ( IAND(INMASK,RDMASK)==0 ) )

c start with default behavior of ignoring already-applied correction
      IF ( (.NOT. ALLOW) .and. ISDATA ) THEN
         print*,' '
         print*,' !!! '//CORFILE// ' CORRECTION ALREADY APPLIED '
         print*,' !!!  ==> IGNORE '// CORFILE
         print*,' '
      ENDIF

c check option to FORCE correction, even if already applied
      IF ( ALLOW .and. FORCE .and. ISDATA ) THEN
         print*,' '
         print*,' !!! '//CORFILE// ' CORRECTION ALREADY APPLIED '
         print*,' !!! ==> FORCE '//CORFILE//' ANYWAY   '
         print*,' '
      ENDIF

c for sims, give reminder that corrections are not applied to sims.
      IF ( LSIM_SNANA ) THEN
        print*,' '
        print*,'  !!! IGNORE '//CORFILE//' for SIMULATION'
        print*,'  !!!   (or switch to SIM_'//CORFILE//' option)  '
        print*,' '
      ENDIF

      call flush(6)

      RETURN
      END  ! end PRINTMSG_FLUXCOR


C ===============================
+DECK,EXEC_FUDGE_FLUXCAL.
      SUBROUTINE EXEC_FUDGE_FLUXCAL(EP)

c Created Nov 15, 2011 by R.Kessler and J.Marriner
c Fudge FLUXCAL and ERROR based on user namelist option
c FUDGE_FLUXCAL_OFFSET/ERROR
c
c The following arrays are modified
c   - SNLC_FLUXCAL
c   - SNLC_FLUXCAL_ERRTOT
c
c Note that the SNLC_MAG array is not modified !!!
c
c
c Mar 9 2020: 
c   fix awful bug where previous FLUXCAL was used to apply
c   FUDGE_MAG_ERROR. Note RESTORE_DES3YR restores bug.
c
c Dec 2 2022: add string-length args to get_FLUXERRMODEL call.
c
c Jun 11 2024: implement SIM_FUDGE_MAG_ERROR_FILT (for DES-SN5YR)
c Jul 30 2024: move 'SNR = FLUXCAL/ERR1' aft3er ERR1 is computed to avoid divide-by-zero
c ------------

      IMPLICIT NONE

      INTEGER EP  ! (I) epoch index and SN index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.

c local var

      REAL*8
     &   ERR1, ERR2a, ERR2b, ERR3, ERR3_SIM, ERR_SIM, ERR_DATA
     &  ,ERR_ORIG, SCALE, FUDGE, SNR, SNR_PROTECT, LOGSNR
     &  ,SQERR, SQERR1, SQERR2a, SQERR2b, SQERR3, SQERRHOST, SQERRMAP
     &  ,RDNOISE_pe, FLUXCAL, FLUXCAL_BUG, FLUXADU
     &  ,AREA, NEA, PSFSIG1, PSFSIG2, PSFRATIO  
     &  ,GALMAG, SBMAG, SBFLUX, SNSEP, NOISEPAR(2)
     &  ,MJD, GAIN, SKYSIG, ZP, ZPDIF, PARLIST(20), Texpose
     &  ,SQTMP, Fscale, Fpe_source, Fpe_sky, Fpe_galaxy, GENMAG
     &  ,Fpe_list(3)

      INTEGER*8 GALID
      INTEGER IFILT_OBS, IFILT, OPT, NPAR, LL
      CHARACTER cfilt*2, FNAM*20, cFIELD*32, cBAND*2
      LOGICAL DOFUDGE

c function
      EXTERNAL NoiseEquivAperture, GET_NONLIN, get_FLUXERRMODEL
      REAL*8   NoiseEquivAperture, GET_NONLIN

c ------------ BEGIN ----------------

      FNAM = 'EXEC_FUDGE_FLUXCAL'
      IFILT_OBS = ISNLC_IFILT_OBS(ep)
      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
      cfilt     = FILTDEF_STRING(ifilt_obs:ifilt_obs)

      SNLC_FLUXCAL(ep) = SNLC_FLUXCAL(ep) 
     &     + SNLC_FLUXCAL_OFF(ifilt)               ! offset in data file
     &     + FUDGE_FLUXCAL_OFFSET_FILT(IFILT_OBS)  ! user-nml offset

c get C function arguments
      cBAND        = cfilt(1:1) // char(0)
      LL           = INDEX(SNLC_FIELD(ep), ' ') - 1
      cFIELD       = SNLC_FIELD(ep)(1:LL) // char(0)
      GALID        = SNHOST_OBJID(1) 
      SNSEP      = DBLE( SNHOST_ANGSEP(1) )
      GALMAG     = DBLE( SNHOST_MAGOBS(ifilt,1) )
      SBFLUX     = DBLE( SNHOST_SBFLUXCAL(ifilt) )
      SBMAG      = DBLE( SNHOST_SBMAG(ifilt) )
      FLUXCAL    = DBLE( SNLC_FLUXCAL(ep) )
      PSFSIG1    = DBLE( SNLC_PSF_SIG1(EP) )  ! Gauss sigma, pixel
      PSFSIG2    = DBLE( SNLC_PSF_SIG2(EP) )  ! idem, 2nd component
      PSFRATIO   = DBLE( SNLC_PSF_RATIO(EP) )
      NEA        = DBLE( SNLC_PSF_NEA(EP) )
      GAIN       = DBLE( SNLC_GAIN(ep) )
      SKYSIG     = DBLE( SNLC_SKYSIG(ep) )          ! sigma, ADU/pixel
      RDNOISE_pe = DBLE(SNLC_RDNOISE(ep) )  ! e-/pix
      ZP         = DBLE( SNLC_ZEROPT(ep) )
      ZPDIF      = ZP - ZEROPOINT_FLUXCAL_DEFAULT
      MJD        = SNLC8_MJD(EP)

c - - - - - - - - - - - - - - 
      SCALE    = DBLE(FUDGE_FLUXERR_SCALE_FILT(IFILT_OBS))
      ERR_ORIG = DBLE(SNLC_FLUXCAL_ERRTOT(ep))
      ERR1  = ERR_ORIG * SCALE
      SNR   = FLUXCAL/ERR1
      
      FUDGE = FUDGE_FLUXCAL_ERROR_FILT(IFILT_OBS)
      ERR2a = DBLE(FUDGE)  ! fudge error

      FUDGE = FUDGE_FLUXCAL_ERRPIX_FILT(IFILT_OBS)
      ERR2b = DBLE(FUDGE) ! fudge err/pix

      FUDGE = FUDGE_MAG_ERROR_FILT(IFILT_OBS)
      ERR3  = DBLE(FUDGE)* FLUXCAL ! fudge mag err

      SQERR1     = ERR1  * ERR1
      SQERR2a    = ERR2a * ERR2a
      IF ( ERR2a .LT. 0.0 ) SQERR2a = -SQERR2a
      SQERR2b    = ERR2b * ERR2b   ! * AREA  ! sum in quad over pixels
      SQERR3     = ERR3  * ERR3
      SQERRHOST  = 0.0 
      SQERRMAP   = 0.0 

      IF ( LSIM_SNANA ) THEN
        FUDGE     = SIM_FUDGE_MAG_ERROR_FILT(IFILT_OBS)
        ERR3_SIM  = DBLE(FUDGE)* FLUXCAL ! fudge mag err
	SQERR3    = SQERR3 + (ERR3_SIM*ERR3_SIM)
      ENDIF
	
c --------------------------------------------
c  Check for map corrections

      IF ( DOFUDGE_HOSTNOISE  ) THEN  ! compute ERRHOST
c call function to return
c  noisePar(1) =  FLUXCAL noise per pixel
c  noisePar(2) =  ERRSCALE to multiply skynoise  
         CALL GEN_NOISEMODEL_HOST_LEGACY(cBAND,cFIELD,GALID, 
     &           GALMAG, SBMAG, SNSEP, noisePar, 2,30);
         SQTMP     = NOISEPAR(2)**2 - 1.0 ! don't double-count error
         SQERRHOST = SQERR1 * SQTMP
      ENDIF


      IF ( DOFUDGE_FLUXERRMODEL  ) THEN ! compute ERRMAP
        OPT = 0 ; NPAR=0
        SNR_PROTECT = MAX(SNR,0.126)    ! --> LOGSNR >= -0.9 
        LOGSNR = log10(SNR_PROTECT)

c  grep IPAR_FLUXERRMAP sntools_fluxErrModels.h
        NPAR = NPAR+1;  PARLIST(NPAR) = MJD 
        NPAR = NPAR+1;  PARLIST(NPAR) = PSFSIG1
        NPAR = NPAR+1;  PARLIST(NPAR) = SKYSIG
        NPAR = NPAR+1;  PARLIST(NPAR) = ZP
        NPAR = NPAR+1;  PARLIST(NPAR) = LOGSNR
        NPAR = NPAR+1;  PARLIST(NPAR) = SBMAG
        NPAR = NPAR+1;  PARLIST(NPAR) = GALMAG
        NPAR = NPAR+1;  PARLIST(NPAR) = SNSEP
        CALL  get_FLUXERRMODEL(OPT,ERR1,cBAND,cFIELD,NPAR, PARLIST,
     &            ERR_SIM, ERR_DATA, 2,30 )  ! <== return ERR_SIM, ERR_DATA

        SQERRMAP = (ERR_DATA*ERR_DATA) - SQERR1 ! note: can be negative
      ENDIF


c avoid invalid fluxes.
      IF ( FLUXCAL .EQ. -9.0 ) RETURN

c bail if nothing to do
      DOFUDGE = 
     &     ( ERR1  > 0.0 ) .or.
     &     ( ERR2a > 0.0 ) .or.
     &     ( ERR2b > 0.0 ) .or.
     &     ( ERR3  > 0.0 ) .or.
     &     ( SQERRHOST  > 0.0 ) .or.
     &     ( SQERRMAP   > 0.0 ) 

      if ( .NOT. DOFUDGE ) GOTO 880  ! jump to nonlinearity flux-fudge

      AREA = 0.0 
      IF ( ERR2b > 0.0 ) THEN
         ! sum noise over pixels in effective background area
         if ( PSFSIG1 < 0.002 ) then
            c1err = 'Undefined PSF for FUDGE_FLUXCAL_ERRPIX'
            write(c2err,62) SNLC_CCID, MJD, cfilt
 62         format('CID=',A10,' for MJD=', F9.3,'-', A)
            CALL MADABORT(FNAM, c1err, c2err )
         endif
         AREA  = NEA
      ENDIF


      SQERR = SQERR1 + SQERR2a + (SQERR2b*AREA) + SQERR3 
     &      + SQERRHOST + SQERRMAP

      IF ( SQERR .LE. 0.0 ) THEN
         CALL PRINT_PREABORT_BANNER(FNAM(1:18)//char(0),40)
         print*,'   ERR1(from data file): ',          sngl(ERR1)
         print*,'   ERR2a(user-fluxcal fudge): ',     sngl(ERR2a)
         print*,'   ERR2b(user-fluxcal fudge/pix): ', sngl(ERR2b)
         print*,'   ERR3(user magerr fudge): ' ,      sngl(ERR3)
         print*,'   ERRHOST(FUDGE_HOSTNOISE_FILE): ', 
     &                  sngl( sqrt(SQERRHOST) )
         print*,'   ERRMAP(FLUXERRMODEL_FILE): ', 
     &                  sngl( sqrt(SQERRMAP) )
         write(c1err,61) 
     &        SNLC_CCID(1:ISNLC_LENCCID), cfilt, MJD
 61      format('Negative flux error for CID=',A, '-',A,
     &         3x, 'and MJD=',F9.3)
         c2err = 'Check error fudges in &SNLCINP'
         CALL MADABORT(FNAM, c1err, c2err )
      ENDIF

      SNLC_FLUXCAL_ERRTOT(ep) = SNGL ( SQRT(SQERR) )

      CALL SETMASK_FLUXCOR_SNANA(MASK_FLUXERRCOR_SNANA)

c ---------------------------
880   CONTINUE
c ---------------------------

c check GET_NONLIN option in sntools_nonlinearity.c
      IF ( DOFUDGE_NONLIN ) THEN

        if ( GAIN < 0.01 .or. SKYSIG < 0.0001 .or. ZP < 0.01 ) then
           CALL PRINT_PREABORT_BANNER(FNAM(1:18)//char(0),40)
           print*,'    BAND    = ', CFILT
           print*,'    GAIN    = ', sngl(GAIN), ' e-/pix'
           print*,'    ZP      = ', sngl(ZP),'  (ADU->MAG)'
           print*,'    SKYSIG  = ', sngl(SKYSIG),' ADU/pix '
           print*,'    RDNOISE = ', sngl(RDNOISE_pe),' e-/pix'
           c1err = 'Canot compute NON-LINEARITY'
           c2err = 'See above values'
           CALL MADABORT(FNAM, c1err, c2err )
        endif

      ! sum noise over pixels in effective background area
        FLUXADU = FLUXCAL * 10.0**(0.4*ZPDIF)

        Texpose    = SNLC_TEXPOSE(ep)
        Fpe_source = FLUXADU * GAIN
        IF ( Fpe_source < 0.0 ) Fpe_source = 0.01 ! must be positive
        Fpe_sky    = NEA * (SKYSIG*GAIN)**2
        Fpe_galaxy = 0.0  ! ?? NEA * SBMAG * GAIN ! ??
        GENMAG     = DBLE( SNLC_MAG(ep) )
        Fpe_list(1) = Fpe_source
        Fpe_list(2) = Fpe_sky
        Fpe_list(3) = Fpe_galaxy
	
        Fscale = GET_NONLIN(SNLC_CCID(1:ISNLC_LENCCID)//char(0),
     &                  cfilt(1:1)//char(0), Texpose, NEA, 
     &                  Fpe_list, GENMAG, ISNLC_LENCCID, 2 )
        SNLC_FLUXCAL(ep) = SNLC_FLUXCAL(ep) * SNGL(Fscale)
        CALL SETMASK_FLUXCOR_SNANA(MASK_FLUXCOR_SNANA)
      ENDIF

c ---------------------
c mag-corrections; e.g.. chromatic corrections from FGCM
      CALL EXEC_MAGCOR(ep) 

      RETURN
      END        ! end EXEC_FUDGE_FLUXCAL

C ===========================================
+DECK,SETFORCE_FLUXCOR_SNANA.
      SUBROUTINE SETFORCE_FLUXCOR_SNANA(MASK,INFILE)

c Created Nov 14 2018
c INFILE = '<fileName>'       --> do nothing
c INFILE = '<fileName FORCE>' --> set MASK bit of FORCEMASK_FLUXCOR
c                                 and set INFILE = fileName
c - - - - - -
      IMPLICIT NONE

      INTEGER MASK         ! (I) mask to set for FORCEMASK
      CHARACTER INFILE*(*) ! (I) name of input file

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER NAME_forC*(MXCHAR_FILENAME), cwd*(MXCHAR_FILENAME), FNAM*30
      INTEGER iwd, NWD, LENFILE,MSKOPT

      LOGICAL  IGNOREFILE_fortran
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ---------------- BEGIN --------------

      if ( IGNOREFILE_fortran(INFILE) ) RETURN  ! Apr 7 2022

      FNAM      = 'SETFORCE_FLUXCOR_SNANA'
      MSKOPT    = MSKOPT_PARSE_WORDS_STRING
      LENFILE   = INDEX(INFILE,' ') + 10 ! allow FORCE key after space
      NAME_forC = INFILE(1:LENFILE-1)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT, NAME_forC, 
     &         FNAM//char(0), LENFILE, 30)

      IF ( NWD <= 1 ) RETURN

c with more than 1 word, check for FORCE key

      DO 10 iwd = 1, NWD
         CALL get_PARSE_WORD_fortran(iwd,cwd,LENFILE)

         if ( iwd==1 ) then
            INFILE = cwd
         else if ( cwd(1:5) .EQ. 'FORCE' ) then
            FORCEMASK_FLUXCOR = IOR(FORCEMASK_FLUXCOR,MASK)
         endif
10    CONTINUE


      RETURN
      END ! end of SETFORCE_FLUXCOR_SNANA

C ===========================================
+DECK,SETMASK_FLUXCOR_SNANA.
      SUBROUTINE SETMASK_FLUXCOR_SNANA(MASK)

      IMPLICIT NONE

      INTEGER MASK  ! (I) mask to set
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER ALREADY_SET, FORCE
      CHARACTER FNAM*24

C --------------- BEGIN ------------------

      FNAM = 'SETMASK_FLUXCOR_SNANA'

c first check mask read from data file to see if fluxcor fudge
c was already applied

      ALREADY_SET = IAND(ISNLC_RDMASK_FLUXCOR_SNANA,MASK)
      FORCE       = IAND(FORCEMASK_FLUXCOR,MASK)

      if ( ALREADY_SET > 0 .and. FORCE == 0 ) RETURN

c xxxxxxxxxxxxxxxx
c      if ( ALREADY_SET > 0 .and. FORCE == 0 ) then
c         CMASK(MASK_FLUXCOR_SNANA)    = 'FLUXCOR/MAGCOR'
c         CMASK(MASK_FLUXERRCOR_SNANA) = 'FLUXERRCOR'
c         C1ERR = 'Will not apply ' // CMASK(MASK)
c         C2ERR = 'because data files already include '//CMASK(MASK)
c         CALL MADABORT(FNAM, c1err, c2err )
c      endif 
c xxxxxxxxxxxxxxxx

      ISNLC_WRMASK_FLUXCOR_SNANA = 
     &     IOR(ISNLC_WRMASK_FLUXCOR_SNANA,MASK)

      RETURN
      END   ! end of SETMASK_FLUXCOR_SNANA

C =================================
+DECK,COUNTFIELDS.
      SUBROUTINE COUNTFIELDS()
c
c Jun 8, 2009 R.Kessler
c
c Fill ISNLC_NFIELD with number of different fields used by this SN.
c NFIELD = 1 for isolated field, but can be > 1 for overlapping fields.
c
c
c --------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER 
     &   ep, NEP, i, ovp
     &  ,IDF, IDF_OVPLIST(MXFIELD_OVP)
     &  ,NFIELD, LENTMP, LENTOT, L2

      CHARACTER FIELDTMP*(MXCHAR_FIELDNAME), FNAM*12
      LOGICAL USE, FIRST

C ------------- BEGIN ----------

      NEP    = ISNLC_NEPOCH_STORE
      NFIELD = 0
      FNAM   = 'COUNTFIELDS'

      DO 101 ep = 1, NEP
          IDF   = ISNLC_IDFIELD(ep)

          USE = .FALSE.
          DO 102 i = 1, MIN(NFIELD,MXFIELD_OVP)
            if ( SNLC_FIELD(ep).EQ.SNLC_FIELD_OVPLIST(i) ) USE=.TRUE.
 102      CONTINUE          

          if ( .NOT. USE ) THEN
             NFIELD = NFIELD + 1
             IF ( NFIELD .LE. MXFIELD_OVP ) then
                SNLC_FIELD_OVPLIST(NFIELD) = SNLC_FIELD(ep)
                IDF_OVPLIST(NFIELD) = IDF
             ENDIF
          endif  ! end of USE
101   CONTINUE  ! ep loop


      IF ( NFIELD > MXFIELD_OVP ) THEN 
         CALL PRINT_PREABORT_BANNER(FNAM(1:11)//char(0),20)

         DO  i = 1, MIN(NFIELD,MXFIELD_OVP)
            write(6,60) i, SNLC_FIELD_OVPLIST(i)
60          format(T5,'FIELD_OVPLIST(',I2,') = ', A)
         ENDDO

         write(c1err,61) NFIELD
         write(c2err,62) MXFIELD_OVP
 61      format('NFIELD_OVP = ', I3,' exceeds bound of')
 62      format('MXFIELD_OVP = ', I3 )
         CALL MADABORT(FNAM, c1err, c2err )
      ENDIF

      ISNLC_NFIELD_OVP = NFIELD

c prepare catenated string SNLC_FIELD_forC that is sorted based 
c on survey fields.  e.g., if SURVEY_FIELDS = 'E1', 'E2' then 
c SNLC_FIELDS = E2,E1 gets constructed as SNLC_FIELD_forC = 'E1+E2'

      SNLC_FIELDLIST = ''
      LENTOT = 0
      FIRST  = .TRUE.

      DO 300 i = 1, NFIELD_SURVEY 
        FIELDTMP = SURVEY_FIELDNAME(i)  ! from SURVEY.DEF file
        LENTMP   = INDEX(FIELDTMP,' ')-1

        DO 301 ovp = 1, NFIELD  ! overlap fields in this SN
          L2 = INDEX(SNLC_FIELD_OVPLIST(ovp),' ')-1
          IF ( LENTMP .NE. L2 ) GOTO 301 

          IF ( SNLC_FIELD_OVPLIST(ovp) .EQ. FIELDTMP ) THEN

             if ( FIRST ) then
               SNLC_FIELDLIST = FIELDTMP
               LENTOT = LENTOT + LENTMP
               FIRST  = .FALSE.
             else
                SNLC_FIELDLIST =
     &          SNLC_FIELDLIST(1:LENTOT) // '+' // FIELDTMP(1:LENTMP)
                LENTOT = LENTOT + LENTMP + 1
             endif

          ENDIF
 301    CONTINUE
 300  CONTINUE

      IF ( LENTOT .EQ. 0  ) THEN
         SNLC_FIELDLIST = 'VOID'
      ENDIF

      RETURN
      END   ! end COUNTFIELDS


C ========================================
+DECK,U3BAND.
      SUBROUTINE U3BAND()
c
c Created Sep 13, 2008 by R.Kessler
c
c Special flag to require exactly three passbands
c that pass the global SNRCUT, and one of the passbands
c must be U-band. If only two passbands exist, the SN
c is rejected. If 4 or more passbands exist, then the
c reddest extra passbands are erased and the SN is used.
c For example, if griz -> UBVR, then all z-band fluxes
c and errors are set to -9.0, and SNRECON is called 
c again; this SN is then processed as if z-band had
c never existed.
c
c
c Jul 16, 2011: pass ISN as argument and remove IERR arg
c --------------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.

      INTEGER 
     &   NBAND, NTMP
     &  ,IFILT, IFILT_OBS, IFILT_OBS_LIST(MXFILT_ALL)
     &  ,ORDER
     &  ,INDEX_SORT(MXFILT_ALL)
     &  ,i, isort
     &  ,NERASE

      REAL 
     &   ZZ, RESTLAM
     &  ,RESTLAM_LIST(MXFILT_ALL)

      LOGICAL LSNRMAX, LU, LKEEP

      character cfilt*2, ccid*(MXCHAR_CCID), cdiscard*32

      REAL ULAMMAX
      PARAMETER ( ULAMMAX = 3900.0 ) ! max U-band lambda in rest-frame

      EXTERNAL SORTFLOAT

C ---------- BEGIN ---------

      NERASE = 0

      if ( .not. LTEST_U3BAND ) RETURN

      CCID = SNLC_CCID
      LKEEP = .TRUE.  ! keep SN by default

c require at least 3 passbands with SNRMAX cut.
c If not, set PEAKMJD = -9.0 and return so that
c this SN is rejected.

        NBAND = ISNLC_NFILT_SNRMAX
        IF ( NBAND .LT. 3 ) THEN
          LKEEP  = .FALSE.
          cdiscard = 'NBAND(SNRMAX) < 3'
          GOTO 150
        ENDIF

        ZZ          = 1.0  + SNLC_REDSHIFT


c filter loop: get list of observer passbands and check if
c U-band is there.

        NTMP = 0
        LU   = .FALSE.

        DO 101 ifilt = 1, NFILTDEF_SURVEY

           if ( .NOT. EXIST_FILT(ifilt) ) goto 101

           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)

           RESTLAM = FILTOBS_LAMAVG(ifilt_obs) / ZZ
           LSNRMAX = SNLC_SNRMAX_FILT(ifilt) .GT. CUTWIN_SNRMAX(1) 

           if ( .NOT. LSNRMAX ) GOTO 101

           IF ( RESTLAM .LT. ULAMMAX .and. 
     &          RESTLAM .GT. CUTWIN_RESTLAM(1) ) LU = .TRUE.

           NTMP = NTMP + 1
           IFILT_OBS_LIST(NTMP) = IFILT_OBS
           RESTLAM_LIST(NTMP)   = RESTLAM

101     CONTINUE  ! UFILT loop


        if ( .NOT. LU ) then
           LKEEP = .FALSE.
           cdiscard = 'No filter maps onto rest-U'
           goto 150
        endif

        if ( LU .and. NBAND .EQ. 3 ) GOTO 150

c here we have more than 3 bands with good SNRMAX.
c Erase reddest bands until we have the 3 bluest.

       ORDER = + 1 ! increasing order
       CALL SORTFLOAT( NBAND, RESTLAM_LIST, ORDER, INDEX_SORT)

c erase reddest filters as if they never existed
      DO i = 4, NTMP
        isort = INDEX_SORT(i)
        IFILT_OBS = IFILT_OBS_LIST(isort)
        cfilt = filtdef_string(ifilt_obs:ifilt_obs) 
        RESTLAM   = RESTLAM_LIST(isort)

        write(6,440) CCID, cfilt, RESTLAM
440     format(T8,'U3BAND CID=',A8, ' : erase filter=',A,
     &       ' with rest-Lambda=',F6.0,' A' )
        
        NERASE =  NERASE + 1
        CALL ERASE_FILTER(ifilt_obs)
      ENDDO

c --------
150     CONTINUE
        IF ( .NOT. LKEEP ) THEN
          SNLC_SEARCH_PEAKMJD = -9.0
          write(6,441) CCID, cdiscard
441       format(T8,'U3BAND CID=',A8, ' => DISCARD because ', A )
        ENDIF

c ------------------------
c call SNRECON again after erasing filter(s)
      IF ( NERASE .GT. 0 ) THEN
        CALL SNRECON()
      ENDIF


      RETURN
      END


C ========================================
+DECK,ERASEFLT.
      SUBROUTINE ERASE_FILTER(ifilt_obs)
c
c Created Sep 13, 2008 by R.Kessler
c
c Erase "ifilt_obs" for SN index ISN.
c Erasing is done by setting fluxes and errors to -9.
c
c --------

      IMPLICIT NONE
      INTEGER IFILT_OBS   !(O) SN index, and filter index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.


      INTEGER NEWMJD, EPMIN, EPMAX, ep, ifilt

      LOGICAL LTMP 

C -------- BEGIN -------

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        DO EP = EPMIN, EPMAX

          LTMP = IFILT_OBS .EQ. ISNLC_IFILT_OBS(ep)

          IF ( LTMP ) THEN
            SNLC_FLUXCAL(ep)        = -9.0
            SNLC_FLUXCAL_ERRTOT(ep) = -9.0
            SNLC_MAG(ep)        = -9.0
            SNLC_ZEROPT(ep)     = -9.0
            SNLC_ZEROPT_ERR(ep) = -9.0

            IFILT  = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
            EXIST_FILT(ifilt)         = .FALSE.
            ISNLC_NEPOCH_FILT(ifilt)   =  0
            SNLC_SNRMAX_FILT(0)       = -9.
            SNLC_SNRMAX_FILT(ifilt)   = -9.
            SNLC_SNRMAX_SORT(ifilt)   = -9.
            SNLC_FLUXCALMAX(ifilt)    = -9.
            SNLC_FLUXCALMAX_ERR(ifilt)  = -9.

          ENDIF

        ENDDO
      
200   CONTINUE

      RETURN
      END

C =============================================
+DECK,DLMAG8_REF.
      DOUBLE PRECISION FUNCTION DLMAG8_REF(Z8)
      IMPLICIT NONE
c Oct 23 2020: refactor DLMAG function to use sntools_cosmology.c
+CDE,SNDATCOM.
+CDE,SNLCINP.
      REAL*8 Z8             ! input redshift
      REAL*8 zCMB, zHEL, vPEC, H0, OM, OL, w0, wa

      REAL*8   DLMAG_fortC    ! C function in sntools_cosmology.c
      EXTERNAL DLMAG_fortC

C ------- BEGIN -------

      H0   = H0_REF(1)
      OM   = OMAT_REF(1)
      OL   = OLAM_REF(1)
      w0   = W0_REF(1)
      wa   = DWDA_REF(1)
      zCMB = z8
      zHEL = z8
      vPEC = 0.0 
      DLMAG8_REF = DLMAG_fortC(zCMB, zHEL, vPEC, H0, OM, OL, w0, wa)
      RETURN
      END           ! end DLMAG8_REF



C =============================
+DECK,CCDNUMSTAT.
      INTEGER FUNCTION CCDNUMSTAT(CCDNUM)
c
c Dec 2017
c Returns 0 if CCDNUM is valid; returns -1 otherwise.
c -------------------------

      IMPLICIT NONE

c function args

      INTEGER CCDNUM

c local args

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i
      LOGICAL LCCDNUM

C -------------- BEGIN --------------

      IF ( NCCDNUM_LIST .LE. 0 ) THEN  
         ! don't check  anything
         CCDNUMSTAT = 0
         RETURN
      ENDIF

      LCCDNUM = .FALSE.
      do i = 1, NCCDNUM_LIST
        if ( CCDNUM_LIST(i) .EQ. CCDNUM ) LCCDNUM = .TRUE.
      enddo


      IF ( LCCDNUM ) THEN
         CCDNUMSTAT   = 0
      ELSE 
         CCDNUMSTAT = -1
      endif

      RETURN
      END  ! end CCDNUMSTAT


C ================================================
+DECK,MAKE_SIMLIB_FILE.
      SUBROUTINE MAKE_SIMLIB_FILE(OPT_FLAG)

c Created Feb 2016
c Create LIBID entry in simlib file, based on info from data file.
c Beware that event distribution is not necessarily uniform since
c it has the data distribution.
c
c OPT_FLAG = 1 --> open simlib file and write header
c OPT_FLAG = 2 --> add next LIBID
c OPT_FLAG = 3 --> close file
c
c  OPT_SIMLIB_OUT & 1 -> write SIM_MAGOBS for all obs, 
c                        even for true flux = 0 and mag=99.
c  OPT_SIMLIB_OUT & 2 -> write SIM_MAGOBS only for true flux > 0
c
c
c Oct 15, 2019: fix format for SKYSIG : 6.2f -> 7.2f
c Nov 22, 2019: adapt to work on fakes and sims, and write MAG column.
c Oct 05, 2020: add ZP requirement to compute metadata; see FOUND_METADATA
c Jan 19, 2021: add pad space between MJD and IDEXPT
c Mar 26, 2021: 
c   + suppress GALID since it wrote 12345 (garbage) for DC2
c   + skip LIBID of PEAKMJD < 1000
c
c --------------------------

      IMPLICIT NONE

      INTEGER OPT_FLAG ! 1=> init file, 2=> add simlib entry

+CDE,SNDATCOM.
c +CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SIMLIBCOM.
+CDE,SPECCOM.

      REAL*8  MJD, GAIN, RDNOISE, SKYSIG, PSF1, PSF2, PSFRAT
      REAL*8  ZP, ZPERR, MAG, FLUX, FLUXERR, PIXSIZE, LAMOBS
      REAL*8  MJD_MIN, TOBS_MIN, PEAKMJD, DVAL
      INTEGER LIBID, IFILT, IFILT_OBS, LASTEP(MXFILT_OBS)
      INTEGER LEN0, LEN1, LEN2, EPMIN, EPMAX, NEWMJD, NOBS, iep, EP
      INTEGER LENcMAG, ISTAT, LENF, NFILTDEF_TMP
      LOGICAL IS_REAL_DATA, WRALL_SIM_MAGOBS, WRSET_SIM_MAGOBS
      LOGICAL WR_SIM_MAGOBS, FOUND_METADATA
      CHARACTER BAND*4, FNAM*20, SEDCMD*200, cDUM*20, CCID*32
      CHARACTER cMAG*12, cNCUTS*12, STR_OLD*40, STR_NEW*60

C ------------------ BEGIN ------------------

      IF( SIMLIB_OUTFILE .EQ. '' ) RETURN

      FNAM = 'MAKE_SIMLIB_FILE'
      IS_REAL_DATA = ( .NOT. ISJOB_SIM )

c check option to write ALL SIM_MAGOBS, even for SIM_MAGOBS=99 where
c no fake or sim event was generated and there is zero flux.
      WRALL_SIM_MAGOBS = 
     &    BTEST(OPT_SIMLIB_OUT,0) .and. (.not.IS_REAL_DATA)

c check option to write SIM_MAGOBS  only for true flux > 0
      WRSET_SIM_MAGOBS = 
     &    BTEST(OPT_SIMLIB_OUT,1) .and. (.not.IS_REAL_DATA)
      WR_SIM_MAGOBS = WRALL_SIM_MAGOBS .or.  WRSET_SIM_MAGOBS

      NFILTDEF_TMP = NFILTDEF_OBS

c -------------------------------------------

      IF ( OPT_FLAG == 1 ) THEN
       
+SELF,IF=SNANA.
        if ( NFILTDEF_TMP == 0 ) then
           C1ERR = 'NFILTDEF_OBS=0 --> no defined obs-frame filters'
           C2ERR = 'Check &SNLCINP input CALIB_FILE'
           CALL MADABORT(FNAM, c1err, c2err)
        endif
+SELF.


+SELF,IF=SNFIT,PSNID.
      C1ERR = 'Cannot use SIMLIB_OUT option with snlc_fit or psnid.'
      C2ERR = 'Use snana.exe instead. '
      CALL MADABORT(FNAM, c1err, c2err)
+SELF.

        GLOBAL_BANNER = 
     &      'Prepare to write SIMLIB file from data'
        CALL PRBANNER (GLOBAL_BANNER(1:60) )
        LEN1 = INDEX(SIMLIB_OUTFILE,' ') -1 
        print*,'   Open output SIMLIB file: ', SIMLIB_OUTFILE(1:LEN1)
        
        OPEN(   UNIT   = LUNOUT
     &        , FILE   = SIMLIB_OUTFILE
     &        , STATUS = 'UNKNOWN'         )

c - - - - - -
c write DOCANA 

        WRITE(LUNOUT,20)  'DOCUMENTATION:'

        WRITE(LUNOUT,24) 
     &       'PURPOSE: simulation cadence created from data'

        WRITE(LUNOUT,24) 
     &       'VERSION_PHOTOMETRY: ' // VERSION_PHOTOMETRY(1)(1:60)

        WRITE(LUNOUT,24) 'NOTES: '
        WRITE(LUNOUT,24) 
     &       '- Created from snana.exe using SIMLIB_OUTFILE option.'
        if ( WR_SIM_MAGOBS ) then
           WRITE(LUNOUT,24)
     &        '- SIM_MAGOBS are copied to MAG column.'   
        endif

        WRITE(LUNOUT,20) 'DOCUMENTATION_END:'
        WRITE(LUNOUT,20) ' ' 

c - - - - - - - -
        LEN1 = INDEX(SURVEY_NAME,' ') - 1
        LEN2 = INDEX(SURVEY_FILTERS,' ') - 1
        WRITE(LUNOUT,10) 'SURVEY:      ',  SURVEY_NAME(1:LEN1)        
        WRITE(LUNOUT,10) 'FILTERS:     ',  SURVEY_FILTERS(1:LEN2)
10      FORMAT(A, 1x, A)  ! KEY VAL

20      FORMAT(A)
24      FORMAT(T4,A)

        WRITE(LUNOUT,10) 'NLIBID:     ',  'NLIBID_REPLACE'

        if ( IS_REAL_DATA ) then   
          WRITE(LUNOUT,10) 'PSF_UNIT:    ',  'ARCSEC_FWHM'
          WRITE(LUNOUT,10) 'SKYSIG_UNIT: ',  'ADU_PER_SQARCSEC'  
          CALL SET_SIMLIB_SKYMAG()
          CALL SET_SIMLIB_ZPERR()
       endif

        WRITE(LUNOUT, '(/,A,/)' ) 'BEGIN LIBGEN' 
cc90      FORMAT(/, 'BEGIN LIBGEN',/  )

        CALL FLUSH(LUNOUT)
        CALL FLUSH(6)

        RETURN
      ENDIF

      IF ( OPT_FLAG == 3 ) THEN
         write(LUNOUT,400) 
400      format(/, 'END_OF_SIMLIB: ', / )
         close(UNIT = LUNOUT)

c replace N_SNLC_CUTS with comment giving number of SIMLIB entries
         write(cNCUTS,'(I6,2x)') N_SNLC_CUTS
         STR_OLD = 'NLIBID_REPLACE '
         STR_NEW = cNCUTS
         LEN0    = index(STR_OLD,' ') - 1
         LEN1    = 8    ! for cNCUT
         LEN2    = INDEX(SIMLIB_OUTFILE,' ') - 1
         write(SEDCMD,505) 
     &       STR_OLD(1:LEN0), STR_NEW(1:LEN1), SIMLIB_OUTFILE(1:LEN2)
c        print*,' xxx SEDCMD = ', SEDCMD
         CALL SYSTEM(SEDCMD)

505      FORMAT('sed -i ', "'s/", A, '/',A, "/g1'", 2x, A)

c if SUBSURVEY_LIST is not blank, use system 'sed' command
c to insert its comma-separate list at top of SIMLIB file.
c fixed key SUBSURVEY_LIST to be printed after SURVEY key (M. Vincenzi Feb 2022)
         IF ( SUBSURVEY_NAME_LIST .NE. '' ) THEN
            LEN1   = INDEX(SUBSURVEY_NAME_LIST,' ') - 1
            LEN2   = INDEX(SIMLIB_OUTFILE,' ') - 1
            SEDCMD = "sed -i '/SURVEY:/a  SUBSURVEY_LIST: " 
     &          // SUBSURVEY_NAME_LIST(1:LEN1) // "' " 
     &          // SIMLIB_OUTFILE(1:LEN2)
            CALL SYSTEM(SEDCMD)
         ENDIF

         return
      ENDIF

C ------------- OPT_FLAG=2 below -------------------------

      IF ( ISNLC_NEWMJD_STORE < 4 ) RETURN
      IF ( SNLC_SEARCH_PEAKMJD < 1000.0 ) RETURN ! Mar 26 2021

      DO IFILT_OBS = 1, MXFILT_OBS
         LASTEP(IFILT_OBS) = -9
      ENDDO


c ----------
c first loop through and count NOBS
      NOBS = 0
      DO 25 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 21 EP = EPMIN, EPMAX
           if ( WR_SIM_MAGOBS ) then
              MAG = SIM_EPMAGOBS(ep)
              if ( WRSET_SIM_MAGOBS .and. MAG > 98.0 ) goto 21
           endif
           NOBS = NOBS + 1
21     CONTINUE
25    CONTINUE

c -----------
      PIXSIZE = SNLC_PIXSIZE
      if ( PIXSIZE < 0.0 ) PIXSIZE = PIXSIZE_GUESS

      WRITE(LUNOUT,66)
66    FORMAT('#--------------------------------------------' )

c check option to force TMIN
      MJD_MIN  = SNLC8_MJD(1)
      PEAKMJD  = SNLC_SEARCH_PEAKMJD
      IF ( SIMLIB_OUT_TMINFIX < 999 ) THEN
        PEAKMJD = MJD_MIN - DBLE(SIMLIB_OUT_TMINFIX)
      ENDIF
      TOBS_MIN = MJD_MIN - PEAKMJD

      LIBID = SNLC_CID      ! UNIQUE_CIDINT(SNLC_CCID)
 
      WRITE(LUNOUT,101) LIBID, SNLC_CCID(1:ISNLC_LENCCID), TOBS_MIN
 101  FORMAT('LIBID: ', I8, 5x, '# cadence from SNID=', A, 2x,
     &    'min(MJD-PEAKMJD)=',F5.1  )

      WRITE(LUNOUT,103) SNLC8_RA, SNLC8_DEC, SNLC_MWEBV
 103  FORMAT('RA: ', F12.6, 8x, 'DEC:', F12.6, 5x, 'MWEBV: ',F7.4)

      WRITE(LUNOUT,105) NOBS, PIXSIZE, 
     &       SNLC_REDSHIFT,  PEAKMJD 
 105  FORMAT('NOBS: ', I4, 5x, 'PIXSIZE: ', F6.3, 5x,
     &       'REDSHIFT: 'F8.5, 5x, 'PEAKMJD: ', F9.3 )

      IF ( SUBSURVEY_NAME .NE. ' ' ) THEN
         WRITE(LUNOUT,10) 'SUBSURVEY:', SUBSURVEY_NAME
      ENDIF

c Nov 23 2019: add more info for simulated data
      IF ( WR_SIM_MAGOBS  ) THEN
cc          write(LUNOUT,"('GALID: ',I9)" ) SNHOST_OBJID(1)
         LENF = INDEX(SNLC_FIELDLIST,' ') - 1
         write(LUNOUT,"('FIELD: ',A )" ) SNLC_FIELDLIST(1:LENF) ! includes overlaps
      ENDIF

c - - - - - - - - - -

c - - - - -
      CALL SET_SIMLIB_TEMPLATE_INFO()  ! Feb 5 2020

      IF ( FOUND_TEMPLATE_INFO ) THEN
          write(LUNOUT,"('TEMPLATE_ZPT:',$)")
          DO ifilt = 1, NFILTDEF_SURVEY
             write(LUNOUT,"(F8.3,$)" ) SIMLIB_TEMPLATE_ZPT(ifilt)
          ENDDO
          write(LUNOUT,"(' ')")

          write(LUNOUT,"('TEMPLATE_SKYSIG:',$)")
          DO ifilt = 1, NFILTDEF_SURVEY
             write(LUNOUT,"(F9.2,$)" ) SIMLIB_TEMPLATE_SKYSIG(ifilt)
          ENDDO
          write(LUNOUT,"(' ')")

      ENDIF

c May 29 2020: write TAKE_SPECTRUM keys if there are spectra
      CALL WRITE_SIMLIB_TAKE_SPECTRUM(LUNOUT)

c write column header
      WRITE(LUNOUT,110) 
110   FORMAT(/,'#   MJD    IDEXPT  BAND  GAIN RDNOISE  SKYSIG  ', 
     &         'PSF1 PSF2 PSFRAT    ZP  ZPERR  MAG' )

      DO IFILT_OBS = 1, MXFILT_OBS
         LASTEP(IFILT_OBS) = -9
      ENDDO

c --------
      DO 300 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        DO 301 IEP = EPMIN, EPMAX

           EP        = IEP
           MJD       = SNLC8_MJD(EP)
           IFILT_OBS = ISNLC_IFILT_OBS(ep)
           IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
           BAND      = FILTDEF_STRING(ifilt_obs:ifilt_obs)

           if ( EP < 0 ) goto 301  ! nothing valid to print

           GAIN      = SNGL( SNLC_GAIN(ep) )
           RDNOISE   = SNGL( SNLC_RDNOISE(ep) )
           SKYSIG    = SNGL( SNLC_SKYSIG(ep) )
           PSF1      = SNGL( SNLC_PSF_SIG1(ep) )  
           PSF2      = SNGL( SNLC_PSF_SIG2(ep) )
           PSFRAT    = SNGL( SNLC_PSF_RATIO(ep) )
           ZP        = SNGL( SNLC_ZEROPT(ep) )
           ZPERR     = SNGL( SNLC_ZEROPT_ERR(ep) )

           cMAG      = '99' ; LENcMAG=2
           if ( WR_SIM_MAGOBS ) then
              MAG = SIM_EPMAGOBS(ep)
              if ( WRSET_SIM_MAGOBS .and. MAG > 98.0 ) goto 301
              write(cMAG,"(F8.4)") MAG
              LENcMAG = 8
           endif

           IF ( PSF1 < 1.0E-5 .and. SKYSIG > 1.0E-5 ) GOTO 301

c if simlib info is not available, estimate it from FLUX and FLUXERR.
c Mainly for low-z sample which has no meta data. 

           FOUND_METADATA = 
     &       ( PSF1 > 1.0E-5 .and. SKYSIG > 1.0E-5 .and. ZP > 1.0)

           IF ( .not. FOUND_METADATA ) THEN
              GAIN    = 1.0 ;  RDNOISE = 1.0 
              ZPERR   = DBLE( SIMLIB_ZPERR(ifilt_obs) )
              PSF2    = 0.0 ;  PSFRAT  = 0.0           
              FLUX    = SNLC_FLUXCAL(EP)
              FLUXERR = SNLC_FLUXCAL_ERRTOT(EP)
              LAMOBS  = FILTOBS_LAMAVG(IFILT_OBS)

              if ( LAMOBS < 0.0 ) then
                 c1err = 'Invalid/undefined band = ' // band
                 c2err = 'Make sure all bands are defined in kcor file'
                 CALL MADABORT(FNAM, C1ERR, C2ERR )
              endif

              CALL COMPUTE_SIMLIB_INFO(
     &               SNLC_CCID,FLUX, FLUXERR, LAMOBS,PIXSIZE,
     &               PSF1, SKYSIG, ZP)     ! returned
           ENDIF

           write(LUNOUT,120)  
     &        MJD, EP, BAND,    ! EP is a dummy ID
     &        GAIN, RDNOISE, 
     &        SKYSIG, PSF1, PSF2, PSFRAT,
     &        ZP, ZPERR, cMAG(1:LENcMAG)

120        format('S: ', 
     &            F9.3, 1x, I4, 2x, A2, 2x,  ! MJD, ID, BAND
     &            F5.2, 2x, F5.2, 2x,        ! GAIN, RDNOISE
     &            F7.2, 1x, 3(F6.2),2x,      ! SKYSIG, PSF info
     &            F6.3, 1x, F5.3, 1x, A      ! ZP, ZPERR, MAG
     &                )

301   CONTINUE
300   CONTINUE

      WRITE(LUNOUT,199) SNLC_CID
199   FORMAT('END_LIBID: ', I8, / )
      CALL FLUSH(6)

      RETURN
      END  ! end of MAKE_SIMLIB_FILE


C =========================================
+DECK,SET_SIMLIB_TEMPLATE_INFO.
      SUBROUTINE SET_SIMLIB_TEMPLATE_INFO()  

c Created Feb 2020
c If there is SKYSIG_T (template) info, set arrays
c    SIMLIB_TEMPLATE_ZPT[SKYSIG](ifilt)
c Search all epochs and extract typical epoch for each band.
c
c Mar 26 2021: require SKYSIG_T > 0

      IMPLICIT NONE

c local variables

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SIMLIBCOM.

      INTEGER ep, EPMIN, EPMAX, NEWMJD, IFILT, IFILT_OBS
      LOGICAL IS_SET(MXFILT_ALL), LZPT, LSKY
      REAL ZPT, SKYSIG

C ------------- BEGIN -------------

      DO IFILT = 1, NFILTDEF_SURVEY
        SIMLIB_TEMPLATE_ZPT(ifilt)    =  0.0
        SIMLIB_TEMPLATE_SKYSIG(ifilt) =  0.0 
        IS_SET(IFILT) = .FALSE.
      END DO


      FOUND_TEMPLATE_INFO = .FALSE.

c find first epoch for each band

      DO 300 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 301 EP = EPMIN, EPMAX           
           IFILT_OBS = ISNLC_IFILT_OBS(ep)
           IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
           ZPT       = SNLC_ZEROPT(ep)
           SKYSIG    = SNLC_SKYSIG_T(ep)
           LZPT      = (ZPT > 10.0)
           LSKY      = SKYSIG > 0.001
           if ( .not.IS_SET(ifilt) .and. LZPT .and. LSKY) then
             IS_SET(ifilt)                 = .TRUE.
             FOUND_TEMPLATE_INFO           = .TRUE.
             SIMLIB_TEMPLATE_ZPT(ifilt)    = ZPT
             SIMLIB_TEMPLATE_SKYSIG(ifilt) = SKYSIG             
           endif
 301    CONTINUE
 300  CONTINUE

      RETURN
      END

C ====================================
+DECK,SET_SIMLIB_SKYMAG.
      SUBROUTINE SET_SIMLIB_SKYMAG()

c Check SURVEY_NAME for space or ground missing;
c set SKYMAG_LIST and PSF_FWHM accordingly.
c Beware that list of space surveys is hard-wired.

      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM. 
+CDE,SIMLIBCOM.

      INTEGER i, LENS

C -------------- BEGIN --------------

      ISGROUND = .TRUE.  ! default
      IF ( INDEX(SURVEY_NAME,'HST'     ) > 0 ) ISGROUND = .FALSE.
      IF ( INDEX(SURVEY_NAME,'JWST'    ) > 0 ) ISGROUND = .FALSE.
      IF ( INDEX(SURVEY_NAME,'WFIRST'  ) > 0 ) ISGROUND = .FALSE.
      IF ( INDEX(SURVEY_NAME,'CANDELS' ) > 0 ) ISGROUND = .FALSE.

      LENS = INDEX(SURVEY_NAME,' ') - 1

      IF ( ISGROUND ) THEN
          write(6,20) SURVEY_NAME(1:LENS), 'GROUND'
          NLIST_SKY = NLIST_SKY_GROUND
          DO i = 1, NLIST_SKY_GROUND
            SKYLAM_LIST(i) = SKYLAM_GROUND_LIST(i)
            SKYMAG_LIST(i) = SKYMAG_GROUND_LIST(i)
          ENDDO
          PSF_FWHM_GUESS   = 1.0   ! arcSec
          PIXSIZE_GUESS    = 0.5   ! arcSec
          ADD_SKYSIG_PIX   = 0.05  ! skySigma per pixel to add in loop

      ELSE
          write(6,20) SURVEY_NAME(1:LENS), 'SPACE'
          NLIST_SKY = NLIST_SKY_SPACE
          DO i = 1, NLIST_SKY_SPACE
            SKYLAM_LIST(i) = SKYLAM_SPACE_LIST(i)
            SKYMAG_LIST(i) = SKYMAG_SPACE_LIST(i)
          ENDDO
          PSF_FWHM_GUESS   = 0.2  ! arcSec
          PIXSIZE_GUESS    = 0.1
          ADD_SKYSIG_PIX   = 0.01
      ENDIF

20    format(T5,'Survey ',A, ' --> ', A, ' instrument params.' )
      write(6,40) 'PSF_FWHM ' , PSF_FWHM_GUESS, 'arcSeconds'
      write(6,40) 'PIXSIZE  ' , PIXSIZE_GUESS, 'arcSeconds'
40    format(T10, 'Set ', A,' = ', F6.3, 2x, A )

      DO i = 1, NLIST_SKY
         write(6,50) SKYLAM_LIST(i), SKYMAG_LIST(i)
50       format(T10, 'Set SKYMAG(',F7.0,' A) = ', F5.2, ' / asec^2'  ) 
      ENDDO

c - - - - - - 
c Write info to SIMLIB file
      if ( ISGROUND ) then
         write(LUNOUT,11) 'GROUND'
      else
         write(LUNOUT,11) 'SPACE'
      endif
11      format(/, '# Assume instrument parameters for ', A)
        DO i = 1, NLIST_SKY
           write(LUNOUT,12) SKYLAM_LIST(i), SKYMAG_LIST(i)
12         format('# Assume SKYMAG(',F7.0,') = ', F5.2,' mag/asec^2')
        ENDDO

      RETURN
      END     ! end SET_SIMLIB_SKYMAG

C ====================================
+DECK,SET_SIMLIB_ZPERR.
      SUBROUTINE SET_SIMLIB_ZPERR()

c Set SIMLIB_ZPERR(ifilt_obs) using &SNLCINP input 
c   SIMLIB_ZPERR_LIST = 'abc .01 def .02 hij .014'
c
c If SIMLIB_ZPERR_LIST='', set all ZPERR = 0.01
c

      IMPLICIT NONE
c +CDE,SNPAR.
c +CDE,CTRLCOM. 
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SIMLIBCOM.
+CDE,FILTCOM.

      INTEGER ifilt, IFILTDEF, NF, iafilt(MXFILT_OBS)
      REAL xafilt(MXFILT_OBS), ZPERR

C -------------- BEGIN --------------

      DO IFILT = 1, MXFILT_ALL
        SIMLIB_ZPERR(IFILT) = 0.01  ! default
      ENDDO

      IF ( SIMLIB_ZPERR_LIST .EQ. '' ) RETURN

      CALL PARSE_FILTSTRING(0, SIMLIB_ZPERR_LIST, NF,iafilt,xafilt)
      DO ifilt    = 1, NF
         ifiltdef = IAFILT(ifilt)
         ZPERR    = xafilt(ifilt)
         SIMLIB_ZPERR(ifiltdef) = ZPERR        
      ENDDO

      RETURN
      END   ! ene SET_SIMLIB_ZPERR


C =======================================================
+DECK,COMPUTE_SIMLIB_INFO.
      SUBROUTINE COMPUTE_SIMLIB_INFO(CCID,FLUX,FLUXERR,LAMOBS,PIXSIZE,
     &                               PSF,SKYSIG,ZP)

c
c Created Jan 26 2017 by R.Kessler
c When &SNLCINP namelist SIMLIB_OUTFILE is specified (fileName),
c and the data files have no meta data, this function is called
c as a hack to compute SIMLIB row entries for PSF, SKYSIG and ZP.
c 
c Strategy here is numerical solution with assumptions on 
c the PSF and sky brightness. Maybe can be done analytically, 
c but I didn't try. 

c * Fix PSF.
c * assume a sky brightness vs. wavelength estimate from LSST 
c     deep-drill cadence. Interpolate SKYMAG_REF based on 
c     input LAMOBS = central wavelength of filter.
c * loop over grid of SKYSIG values, increments of 0.1
c * for each SKYSIG, SNR_meas = Fpe/sqrt(Fpe+SQSKYSG) is solved
c    (quadratic equation) for ZP(pe) between FLUXCAL and MAG.
c * Use ZP and SKYSIG to compute "SKYMAG_predict"
c * SKYSIG with smallest |SKYMAG_predict - SKYMAG_REF| 
c    is the result.
c
c Something similar was previously done for the low-z similb 
c using only CFA3_KEPLERCAM; the resulting CFA3_KEPLERCAM.SIMLIB
c was used to simulate low-z in
c    http://adsabs.harvard.edu/abs/2013ApJ...764...48K
c and also in the JLA(Betoule 2014) and PS1(Sconlic 2014)
c analyses.
c Unfortunately, I cannot find the script or used to create
c CFA3_KEPLERCAM.SIMLIB .
c
c May 2024: if LAMOBS is too large, abort with clear message.
c
c ----------------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SIMLIBCOM.
+CDE,CTRLCOM.
 
c subroutine args
      CHARACTER CCID*(MXCHAR_CCID)  ! (I) for error message only

      DOUBLE PRECISION 
     &   FLUX              ! (I) FLUXCAL
     &  ,FLUXERR           ! (I) error on above
     &  ,LAMOBS            ! (I) central wavelength of filter
     &  ,PIXSIZE           ! (I) pixel size, arcsec
     &  ,PSF, SKYSIG, ZP   ! (O)
 
    
c local args
      INTEGER NLOOP, MXLOOP
      REAL*8  
     &   PSF_SIG, SKYMAG, TMP_SKYMAG
     &  ,TMP_SKYSIG_PIX, TMP_SKYSIG_ASEC, TMP_SQSKYSIG_TOT
     &  ,TMP_ZP, TMP_Fsky_pix,  TMP_FSKY_ASEC, TMP_Fpe
     &  ,SNR, SQSNR, NEA, MAG, MAG_MAX,  ARG, AREA_PIXEL
     &  ,SKYMAGDIF, SKYMAGDIF_MIN, SKYMAGDIF_LAST, SNR_CHECK

      CHARACTER FNAM*20, C1ERR*80, C2ERR*80

      REAL*8   INTERP_1DFUN
      EXTERNAL INTERP_1DFUN

      LOGICAL LDMP

C --------------- BEGIN ---------------

c init output
      PSF = 0.0; SKYSIG=0.0 ; ZP=0.0

c      LDMP = .TRUE. 
      LDMP = .FALSE.

      FNAM = 'COMPUTE_SIMLIB_INFO' 

c set MAG_MAX based on Flux = FluxErr
      MAG_MAX = ZEROPOINT_FLUXCAL_DEFAULT - 2.5*LOG10(FLUXERR)
      if ( FLUX > FLUXERR ) then
         MAG = ZEROPOINT_FLUXCAL_DEFAULT - 2.5*LOG10(FLUX) 
      else
         MAG = MAG_MAX
      endif

c abort on insane FLUXERR
      IF ( FLUXERR < 1.0E-8 ) THEN
         write(c1err,161) 'FLUXERR', FLUXERR, FLUX
161      format('Insane ', A,' value = ', F12.4,
     &         3x, 'for FLUX=',F12.4)
         c2err = 'Check CID = ' // CCID
         CALL MADABORT(FNAM, c1err, c2err)
      ENDIF

c hard-wire PSF since we can't solve for all 3 items
      PSF      = PSF_FWHM_GUESS         ! set output
      PSF_SIG  = PSF_FWHM_GUESS/2.355   ! PSF in sigma, arcsec
      NEA      = 4.0*PI * (PSF_SIG*PSF_SIG)  ! Noise-equiv area, arcSec^2
      AREA_PIXEL = PIXSIZE**2     ! area of 1 pixel, arcsec^2

      SQSNR = (FLUX**2) / ( FLUXERR**2 + (0.0*FLUX)**2 )
      IF ( SQSNR < 2.0 ) SQSNR = 2.0  ! protect crazy SIMLIB values
      SNR   = sqrt(SQSNR)
      SKYMAGDIF_MIN = 9999.

      if ( LAMOBS > SKYLAM_LIST(NLIST_SKY) ) THEN
         write(C1ERR,601) LAMOBS, SKYLAM_LIST(NLIST_SKY)
601      format('LAMOBS=',F8.0,' exceeds max LAM=', F8.0 )
         C2ERR = 'Need to extend SKYLAM and SKYMAG ' //
     &           'arrays in SIMLIBCOM'
         CALL MADABORT(FNAM, c1err, c2err)
      endif 
	      
c linear interpolation to get estimate of Sky mag per asec^2
      SKYMAG = interp_1dfun(1, LAMOBS, NLIST_SKY, 
     &                  SKYLAM_LIST, SKYMAG_LIST,
     &                  FNAM//char(0), 20)

      IF ( LDMP ) THEN
        print*,' xxx --------------------------------- '
        print*,' xxx FLUX = ', sngl(FLUX), ' +- ', sngl(FLUXERR)
        print*,' xxx LAMOBS, SKYMAG = ', sngl(LAMOBS), sngl(SKYMAG)
        print*,' xxx NEA  = ', sngl(NEA)
        print*,' xxx PSF  = ', sngl(PSF_FWHM_GUESS), ' FWHM '
        print*,' xxx SNR  = ', sngl(SNR)
        print*,' xxx AREA_PIXEL = ', sngl(AREA_PIXEL)
      ENDIF

      SKYMAGDIF_LAST = 9999; SKYMAGDIF = 999. ; 
      TMP_SKYSIG_PIX = ADD_SKYSIG_PIX
      NLOOP = 0 ; MXLOOP = 100000

      DO WHILE ( SKYMAGDIF < SKYMAGDIF_LAST ) 
         NLOOP = NLOOP + 1
         SKYMAGDIF_LAST   = SKYMAGDIF

c  increment skysig (pe) per pix
         TMP_SKYSIG_PIX   = TMP_SKYSIG_PIX + ADD_SKYSIG_PIX  
         TMP_SKYSIG_ASEC  = TMP_SKYSIG_PIX / PIXSIZE  ! sqrt(AREA_PIXEL)

         TMP_SQSKYSIG_TOT = NEA * (TMP_SKYSIG_ASEC**2) ! total SQSKYSIG 
         TMP_FSKY_PIX     = TMP_SKYSIG_PIX**2         ! sky val/pix, pe
         TMP_FSKY_ASEC    = TMP_FSKY_PIX / AREA_PIXEL ! sky val/asec^2

         ARG           = 1.0 + 4.0 * TMP_SQSKYSIG_TOT / SQSNR
         TMP_Fpe       = (SQSNR/2.0) * ( 1.0 + sqrt(ARG) )
         TMP_ZP        = MAG + 2.5*LOG10(TMP_Fpe)

c check how close computed TMP_SKYMAG is to expected SKYMAG
         TMP_SKYMAG    = TMP_ZP - 2.5*log10(TMP_FSKY_ASEC)
         SKYMAGDIF     = abs(TMP_SKYMAG - SKYMAG)
         
         if ( SKYMAGDIF < SKYMAGDIF_MIN ) then
            SKYMAGDIF_MIN = SKYMAGDIF
            SKYSIG    = TMP_SKYSIG_PIX/PIXSIZE     ! per arcSec^2 
            ZP        = TMP_ZP                     ! pe per exposure
         endif

         IF ( NLOOP > MXLOOP ) THEN
            CALL PRINT_PREABORT_BANNER(FNAM(1:18)//char(0),40)
            print*,'   FLUX = ', sngl(FLUX), ' +- ', sngl(FLUXERR)
            print*,'   LAMOBS, SKYMAG = ', sngl(LAMOBS), sngl(SKYMAG)
            print*,'   NEA  = ', sngl(NEA)
            print*,'   PSF  = ', sngl(PSF_FWHM_GUESS), ' FWHM '
            print*,'   SNR  = ', sngl(SNR)
            print*,'   AREA_PIXEL = ', sngl(AREA_PIXEL)
            print*,'   NLOOP = ', NLOOP
            print*,'   last SKYSIG = ', sngl(TMP_SKYSIG_PIX/PIXSIZE)
            print*,'   last ZP     = ', sngl(TMP_ZP)
            C1ERR = 'Cannot determine SKYSIG '
            C2ERR = 'after NLOOP tries '
            CALL MADABORT(FNAM, c1err, c2err)
         ENDIF

         IF ( LDMP ) THEN
            SNR_CHECK = TMP_Fpe / sqrt(TMP_Fpe + TMP_SQSKYSIG_TOT )
           write(6,60) NLOOP, TMP_SKYSIG_PIX, SKYMAGDIF, SNR_CHECK/SNR
60         format(' xxx ', I3,' SkySig=',F5.2, 5x, 'SKYMAGDIF=',F8.5,
     &         5x,'SNR(test)=',F6.4 )
         ENDIF
      ENDDO

      IF ( LDMP ) THEN
        print*,' xxx FINAL PSF,SKYSIG,ZP = ',
     &       sngl(PSF), sngl(SKYSIG), sngl(ZP)
          print*,' xxx DEBUG STOP' ; CALL FLUSH(6)
          CALL EXIT(EXIT_ERRCODE)
      ENDIF

      RETURN
      END      ! end COMPUTE_SIMLIB_INFO

C ==================
+DECK,WRITE_SIMLIB_SPECTRUM.
      SUBROUTINE WRITE_SIMLIB_TAKE_SPECTRUM(LUN)

C Created May 29 2020
C If there are spectra, write TAKE_SPECTRUM keys to 
C SIMLIB header (LUNOUT)
C

      IMPLICIT NONE
      INTEGER LUN ! (I) write to this LUN

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SPECCOM.

c discard if FLUXERR/FLUXERR_MEDIAN exceeds this value
c --> avoid crazy large errors that result in bad FLUXUM/FLUXERRSUM.
      REAL TOL_FLUXERR_MEDIAN_RATIO
      PARAMETER ( TOL_FLUXERR_MEDIAN_RATIO = 50.0 ) 

      REAL*8  TOBS, LAMMIN, LAMMAX, SNR
      REAL*8  MJD, LAMMIN_BIN, LAMMAX_BIN
      REAL*8  FLUXSUM, SQERRSUM, FLAM, FLAMERR, DLAM
      REAL*8  FLAMERR_AVG, FLAMERR_RMS, FLAMERR_MEDIAN, RATIO
      INTEGER ispec, NLAMBIN, ilam, NBIN_REJECT
      INTEGER LEN_TOBS, LEN_SNR, LEN_LAMMIN, LEN_LAMMAX
      CHARACTER 
     &    STR_TOBS*20, STR_SNR*20, 
     &    STR_LAMMIN*20, STR_LAMMAX*20

      EXTERNAL ARRAYSTAT    
C ----------- BEGIN --------
      
      DO 222 ispec = 1, NSPECTRUM

         CALL RDSPEC_DRIVER(ispec)  ! apr 5 2021

         MJD       = MJD_SPECTRUM(ispec)
         TOBS      = TOBS_SPECTRUM(ispec)
         NLAMBIN   = NLAMBIN_SPECTRUM(ispec)
         LAMMIN    = LAMMIN_SPECTRUM(1)
         LAMMAX    = LAMMAX_SPECTRUM(NLAMBIN)

         FLUXSUM = 0.0 ; SQERRSUM = 0.0 
       
         CALL ARRAYSTAT(NLAMBIN, FLAMERR_SPECTRUM, 
     &                  FLAMERR_AVG, FLAMERR_RMS, FLAMERR_MEDIAN)

         NBIN_REJECT = 0 
         DO ilam = 1, NLAMBIN
             FLAM    = FLAM_SPECTRUM(ilam)
             FLAMERR = FLAMERR_SPECTRUM(ilam)
             LAMMIN_BIN = LAMMIN_SPECTRUM(ilam)
             LAMMAX_BIN = LAMMAX_SPECTRUM(ilam) 

             RATIO = FLAMERR/FLAMERR_MEDIAN
             if ( RATIO > TOL_FLUXERR_MEDIAN_RATIO ) then 
                NBIN_REJECT = NBIN_REJECT + 1
             else
               DLAM     = 2.0 ! LAMMAX_BIN - LAMMIN_BIN
               FLUXSUM  = FLUXSUM  + (FLAM*DLAM)
               SQERRSUM = SQERRSUM + (FLAMERR*DLAM)**2
             endif
         ENDDO
         SNR = FLUXSUM / sqrt(SQERRSUM)
         if ( NBIN_REJECT > 0 ) then
            write(6,212) SNLC_CCID(1:ISNLC_LENCCID), 
     &                 NBIN_REJECT, NLAMBIN, MJD
 212        format(t5, 'WARNING(',A,'): flag ', I4,' of ', I5, 2x,
     &        'bins as FLAMERR outlier (MJD=',F9.3,')' )
         endif
         
         CALL dble2string_nospace(TOBS, STR_TOBS, LEN_TOBS)
         CALL dble2string_nospace(SNR,  STR_SNR,  LEN_SNR)
         CALL dble2string_nospace(LAMMIN,  STR_LAMMIN, LEN_LAMMIN)
         CALL dble2string_nospace(LAMMAX,  STR_LAMMAX, LEN_LAMMAX)

         WRITE(LUN,225) 
     &      STR_TOBS(1:LEN_TOBS), STR_SNR(1:LEN_SNR),
     &      STR_LAMMIN(1:LEN_LAMMIN), STR_LAMMAX(1:LEN_LAMMAX)
 225     FORMAT('TAKE_SPECTRUM:  TOBS(', A, ')', 3x, 
     &           'SNR(',A,')', 3x, 'SNR_LAMOBS(',A,':',A, ')' )

 222  CONTINUE

      RETURN
      END  ! WRITE_SIMLIB_SPECTRUM

C ================================================
+DECK,DBLE2STRING_NOSPACE.
      SUBROUTINE dble2string_nospace(VAL, STRING, LEN)
      IMPLICIT NONE
      REAL*8 VAL            ! (I) double value to convert
      CHARACTER STRING*(*)  ! (O) string with float value 
      INTEGER  LEN          ! (O) length of string
      write(STRING,240) VAL
 240  format(F10.1)
      STRING = ADJUSTL(STRING)
      LEN = INDEX(STRING,' ') - 1
      RETURN
      END
+DECK,FLOAT2STRING_NOSPACE.
      SUBROUTINE float2string_nospace(VAL, STRING, LEN)
      IMPLICIT NONE
      REAL VAL              ! (I) float value to convert
      CHARACTER STRING*(*)  ! (O) string with float value 
      INTEGER  LEN          ! (O) length of string

      write(STRING,240) VAL
 240  format(F10.1)

      STRING = ADJUSTL(STRING)
      LEN = INDEX(STRING,' ') - 1

      RETURN
      END
C =======================================================
+DECK,FLUXERRCALC,IF=SNANA,SNFIT.
      SUBROUTINE FLUXERRCALC(iepoch, FLUXCAL, FLUXCAL_ERR )
c 
c Compute error from SKY,PSF and ZPT the same way as the
c simulation does. 
c
c Fill
c   SNLC_SKYFLUXCAL(iepoch)           ! fluxcal per pixel
c   SNLC_FLUXCAL_ERRCALC(iepoch)      ! calculated flux error
c   SNLC_FLUXCAL_HOSTERRCALC(iepoch)  ! idem for host noise contribution
c where
c   SKYFLUX_ERR_PHOTO^2 = TOTAL_ERR^2 - SIGNAL_ERR^2
c
c and SKYFLUX_ERR_CALC is determined from the
c effective aperture.
c
c Feb 12,2012 - complete re-write.
c   The ZEROPT is now for the search run instead of for the
c   template run, so no need for obsolete KSUM to translate ZPT.
c   The 'template' noise is ingored since we assume that
c   many template images exist. To include template noise,
c   the SKY_SIG entry in the data file can be increased.
c   Another caveat is that FLUXERR is computed here in ADU,
c   but the reference FLUX can be in ADU or uJy.  To avoid 
c   this confusion, the FLUXCAL error is computed from 
c     FLUXCAL_ERRCALC = FLUXADU_ERRCALC * ADUSCALE / 10**[0.4*ZPT]
c   Thus comparing the calculated FLUXCAL_ERRCALC to the real
c   FLUXCAL_ERRTOT is always unamgiguous
c
c   The calibrated FLUXCAL and its error are passed as arguments
c   to allow using fitted quantities that may work better for 
c   low SNR.
c
c
c Sep 21 2017: 
c  + implement CHECK_SNANA_DUMP
c  + check PIXSIZE !!!
c  + allow calc for any format (previously skipped TERSE)
c
c Mar 2 2018:
c  + REAL -> REAL*8
c
c Nov 15 2019: load SNLC_FLUXCAL_ERRTEST = ERRCALC/ERRTRUE
c
c --------------------------------------------
      IMPLICIT NONE
  
      INTEGER iepoch                ! (I) epoch & SN indices
      REAL    FLUXCAL, FLUXCAL_ERR  ! (I) FLUXCAL and its error

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.

c local var

      REAL
     &   GAIN
     &  ,RDNOISE_pe, RDNOISE_ADU
     &  ,SQERR_TOT
     &  ,SQERR_SIGNAL
     &  ,SQERR_SKY      ! integrated over effective aperture
     &  ,SQERR_ZP
     &  ,SQSUM, TMPRAT, TMPERR
     &  ,SKY_SIG_ADU, SKY_SIG2_ADU ! search and template (ADU/pixel)
     &  ,SKY_SIGTOT_ADU
     &  ,SKY_AVG_ADU
     &  ,SBFLUXCAL, SBFLUXCAL_ERR, SBFLUXADU
     &  ,FLUXADU, FLUXADU_ERR
     &  ,ZP,  ZPERR, ZPSCALE, ZPDIF
     &  ,SQ1, SQRD,  SQERR_HOST, HOST_SKY_RATIO, ERRCALC, ERRTRUE
     &  ,SKYFLUX_ERR_PHOTO
     &  ,SKYFLUX_ERR_CALC 
     &  ,PIXSIZE

      INTEGER IFILT_OBS, IFILT, DUMPFLAG, LENS
      CHARACTER cfilt*2, FNAM*12, STRING_INVALID*200

c function
      EXTERNAL NoiseEquivAperture, CHECK_SNANA_DUMP, ABORT_SNANA_DUMP
      REAL*8   NoiseEquivAperture
      INTEGER  CHECK_SNANA_DUMP_forC

      REAL*8  AREA, PSFSIG1, PSFSIG2, PSFRATIO, MJD8  ! args for above

C ------------- BEGIN --------------

      ERRCALC = -9.0 
      SNLC_FLUXCAL_ERRCALC(iepoch)     = -9.0
      FNAM = 'FLUXERRCALC'

c initialize output

      SKYFLUX_ERR_PHOTO                = -9.0
      SKYFLUX_ERR_CALC                 = -9.0

c strip off observing conditions into local variables.

      ifilt_obs  = ISNLC_IFILT_OBS(iepoch)
      IFILT      = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 

      SKY_SIG_ADU   = SNLC_SKYSIG(iepoch)   ! search sky-sigma, ADU/pix
      SKY_SIG2_ADU  = max(0.0,SNLC_SKYSIG_T(iepoch))   ! idem for template
      PSFSIG1       = DBLE(SNLC_PSF_SIG1(iepoch))    ! Gauss sigma, pixel
      PSFSIG2       = DBLE(SNLC_PSF_SIG2(iepoch))    ! idem, 2nd component
      PSFRATIO      = DBLE(SNLC_PSF_RATIO(iepoch)) 
      GAIN          = SNLC_GAIN(iepoch)             ! e-/ADU
      RDNOISE_pe    = SNLC_RDNOISE(iepoch)          ! e-/pix
      ZP            = SNLC_ZEROPT(iepoch)
      ZPERR         = SNLC_ZEROPT_ERR(iepoch)
      SBFLUXCAL     = SNHOST_SBFLUXCAL(ifilt)
      SBFLUXCAL_ERR = SNHOST_SBFLUXCAL_ERR(ifilt)
      PIXSIZE       = SNLC_PIXSIZE
      ERRTRUE       = SNLC_FLUXCAL_ERRTOT(iepoch)

      SKY_SIGTOT_ADU = SQRT(SKY_SIG_ADU**2 + SKY_SIG2_ADU**2)

c check a few things.
      IF ( FLUXERRCALC_ZPTERR  .GE. 0.0 ) THEN
          ZPERR = FLUXERRCALC_ZPTERR 
      ENDIF

      IF ( GAIN > 0.0 ) THEN
        RDNOISE_ADU  = RDNOISE_pe/GAIN     ! translate RDNOISE from e- to ADU
        SKY_AVG_ADU  = GAIN * (SKY_SIGTOT_ADU**2) ! needed to scale host noise
      ELSE
        SKY_AVG_ADU  = 0.0
        RDNOISE_ADU  = 0.0
      ENDIF

c ----------------------------------------------
c check for invalid/undefined values

      STRING_INVALID = ''
      if ( SKY_SIG_ADU   < 1.0E-4  ) then
         CALL APPEND_STRING(STRING_INVALID, 'SKY_SIG_ADU')
      endif
      if ( RDNOISE_ADU   < 0.0  ) then
         CALL APPEND_STRING(STRING_INVALID, 'RDNOISE')
      endif
      if ( PSFSIG1       < 0.001   ) then
         CALL APPEND_STRING(STRING_INVALID, 'PSFSIG1')
      endif
      if ( PSFSIG2       < 0.0     ) then
         CALL APPEND_STRING(STRING_INVALID, 'PSFSIG2')
      endif
      if ( PSFRATIO      < 0.0     ) then
         CALL APPEND_STRING(STRING_INVALID, 'PSFRATIO')
      endif
      if ( GAIN          < 0.01    ) then
         CALL APPEND_STRING(STRING_INVALID, 'GAIN')
      endif
      IF ( ZP < 0.01 .or. ZP > 60.0    ) then
         CALL APPEND_STRING(STRING_INVALID, 'ZP')
      endif
      IF ( ZPERR < 0.0 .or. ZPERR > 3.99     ) then
         CALL APPEND_STRING(STRING_INVALID, 'ZPERR')
      endif
      IF ( PIXSIZE       < 0.0001  ) then
         CALL APPEND_STRING(STRING_INVALID, 'PIXSIZE')
      endif

      IF ( STRING_INVALID .NE. '' ) GOTO 777  ! skip to dump

c set logical as soon as we get here.
      DO_FLUXERRCALC = .TRUE.

c use ZPT to convert calibated flux back into ADU
c (since FLUX in the data file can be either ADU or uJy)

      ZPDIF       = ZP - SNGL(ZEROPOINT_FLUXCAL_DEFAULT)
      ZPSCALE     = 10**(0.4*ZPDIF)   ! FLUXADU/FLUXCAL ratio
      FLUXADU     = ZPSCALE * FLUXCAL
      FLUXADU_ERR = ZPSCALE * FLUXCAL_ERR

c get signal error, but avoid problems with large negative fluxes
      tmprat = FLUXADU / FLUXADU_ERR
      if ( tmprat .GT. 0.5 ) then
         SQERR_SIGNAL = FLUXADU / GAIN   ! ADU^2
      else
         SQERR_SIGNAL = 0.0
      endif
      
c get effective area for sky-bkg = 1/[integral PSF^2], pixelsize^2
      AREA    = SNLC_PSF_NEA(iepoch) ! Mar 1 2021

c multiply skyerr^2 (per pixel) by effective area.
c Include optional read noise 

      SQ1  = SKY_SIGTOT_ADU  * SKY_SIGTOT_ADU
      SQRD = RDNOISE_ADU  * RDNOISE_ADU
      SQERR_SKY = SNGL( AREA * ( SQ1 + SQRD ) )

c Include host noise if surface brightness (SB) is defined.

      SQERR_HOST = 0.0
      IF ( SBFLUXCAL > 0.001 .and. SKY_AVG_ADU > 0.0 ) THEN
         SBFLUXCAL  = SBFLUXCAL*(PIXSIZE**2)  ! -> FLUXCAL per pixel
         SBFLUXADU  = SBFLUXCAL * ZPSCALE
         SQERR_HOST = SNGL(AREA*SQ1*(SBFLUXADU/SKY_AVG_ADU)) ! scale sky noise^2
         SQERR_SKY  = SQERR_SKY + SQERR_HOST
      ENDIF
      HOST_SKY_RATIO = sqrt ( SQERR_HOST / ( SQERR_SKY-SQERR_HOST) )

      SKYFLUX_ERR_CALC = SQRT(SQERR_SKY)    ! ADU

c compute calibrated skyflux per pixel^2
c  (not for error calc, but to compare with host surface brightess)
      
      SNLC_SKYFLUXCAL(iepoch) = 
     &   ((SKY_SIGTOT_ADU**2)*GAIN) / ZPSCALE

c compute error from zero-point smearing

      TMPERR    = 10**(0.4*ZPERR) - 1.0
      SQERR_ZP  = (FLUXADU * TMPERR)**2

c now combine calculated sky error and signal poisson noise
c for best estimate of flux error. This is what the simulation does.

      SQSUM = SQERR_SKY + SQERR_SIGNAL + SQERR_ZP
      ERRCALC                          = SQRT(SQSUM)/ZPSCALE
      SNLC_FLUXCAL_ERRCALC(iepoch)     = ERRCALC
      SNLC_FLUXCAL_HOSTERRCALC(iepoch) = SQRT(SQERR_HOST)/ZPSCALE

      IF ( ERRCALC > 0.0 .and. ERRTRUE > 0.0 ) THEN
        SNLC_FLUXCAL_ERRTEST(iepoch)  = ERRCALC/ERRTRUE
      ENDIF

c ------------------------------------
c Get photometry sky-error by subracting
c photo-stat signal error from total error

      SQERR_TOT    = FLUXADU_ERR * FLUXADU_ERR
      SQERR_SKY    = SQERR_TOT - SQERR_SIGNAL

      IF ( SQERR_SKY .GT. 0.0  ) THEN
         SKYFLUX_ERR_PHOTO = SQRT(SQERR_SKY)  ! ADU
      ELSE
         SKYFLUX_ERR_PHOTO = -9.0
      ENDIF

c --------------------------
c check for DUMP

777   CONTINUE
      IF ( DUMP_STRING .EQ. '' ) RETURN
      cfilt    = filtdef_string(ifilt_obs:ifilt_obs) 
      MJD8     = SNLC8_MJD(iepoch)
      DUMPFLAG = CHECK_SNANA_DUMP_forC(FNAM,SNLC_CCID,CFILT,MJD8)

      if ( DUMPFLAG > 0 ) then

        print*,' '
        print*,' XXX ---------------------------------------------- '       
        print*,' XXX FLUXERRCALC DUMP: '
        print*,' XXX CID=', SNLC_CCID(1:ISNLC_LENCCID),
     &         '  MJD=', sngl(MJD8), '  FILTER=',CFILT
        print*,' XXX FLUXADU = ', FLUXADU,' +- ', FLUXADU_ERR
        print*,' XXX FLUXCAL = ', FLUXCAL,' +- ', FLUXCAL_ERR
        print*,' XXX ZPT(AVG,ERR,SCALE) = ', 
     &               ZP, ZPERR, ZPSCALE
        print*,' XXX PSFSIG1, PSFSIG2   = ', 
     &               sngl(PSFSIG1), sngl(PSFSIG2),' Gauss pix'
        print*,' XXX GAIN               = ', GAIN
        print*,' XXX PIXSIZE, AREA      = ', PIXSIZE, sngl(AREA)
        print*,' XXX RDNOISE_ADU        = ', RDNOISE_ADU
        print*,' XXX SKY_SIG_ADU        = ', SKY_SIG_ADU, 
     &             ' ADU/pix (search)'
        print*,' XXX SKY_SIG2_ADU       = ', SKY_SIG2_ADU, 
     &             ' ADU/pix (template)'
        print*,' XXX SIG(HOST)/SIG(SKY) = ', HOST_SKY_RATIO
        print*,' XXX SKY_AVG_ADU        = ', SKY_AVG_ADU
        print*,' XXX SQERR_SIGNAL       = ', SQERR_SIGNAL,' ADU'
        print*,' XXX SQERR[SKY,TOT]     = ', 
     &        SQERR_SKY, SQERR_TOT,' ADU '
        print*,' XXX SIM_MAGOBS         = ', SIM_EPMAGOBS(iepoch)
        print*,' XXX SIM_LIBID          = ', SIM_LIBID

        write(6,60) SKYFLUX_ERR_PHOTO, SKYFLUX_ERR_CALC
60      format(T2,' XXX SKYERR_ADU(PHOTO,CALC) =',F10.3,F10.3 )


        write(6,61) ERRTRUE, ERRCALC
61      format(T3,'XXX FLUXCAL_ERR(PHOTO,CALC)=',F10.3,F10.3 )
        print*,'   '

        IF ( STRING_INVALID .NE. '' ) THEN
          LENS = INDEX(STRING_INVALID,' ' ) - 1
          print*,' XXX Invalid quantities: ', STRING_INVALID(1:LENS)
        ENDIF

        if ( DUMPFLAG == 2 ) CALL ABORT_SNANA_DUMP()

      endif

      RETURN
      END
+SELF.

C =====================================
+DECK,APPEND_STRING.
      SUBROUTINE APPEND_STRING(STRING,APPEND)
c return STRING = STRING // ':' // APPEND
c Note that there are no blank spaces. Each item is separated by colon.
      IMPLICIT NONE
      CHARACTER STRING*(*), APPEND*(*)
      INTEGER LENS
C ----------- BEGIN ------------
      LENS = INDEX(STRING,' ' ) - 1
      IF ( LENS == 0 ) then
        STRING = APPEND
      ELSE
        STRING = STRING(1:LENS) // ':' // APPEND
      ENDIF

      RETURN
      END

C =====================================
+DECK,CHECK_SNANA_DUMP_forC.
      INTEGER FUNCTION CHECK_SNANA_DUMP_forC(FUN,CCID,BAND,MJD)
   
C add char(0) terminators to strings and then call
C C function CHECK_SNANA_DUMP(...)

      IMPLICIT NONE

c inputs
      CHARACTER FUN*(*), CCID*(*), BAND*(*)
      REAL*8  MJD

c local args  
      INTEGER LEN_FUN, LEN_CCID, LEN_BAND, DUMPFLAG

c Declare C function
      EXTERNAL CHECK_SNANA_DUMP
      INTEGER CHECK_SNANA_DUMP
C ------------- BEGIN --------------

      LEN_FUN  = INDEX(FUN,  ' ' ) - 1
      LEN_CCID = INDEX(CCID, ' ' ) - 1
      LEN_BAND = INDEX(BAND, ' ' ) - 1

c      print*,' xxx FUN = ', FUN, LEN_FUN
c      print*,' xxx CCID = ', CCID, LEN_CCID
c      print*,' xxx BAND = ', BAND, LEN_BAND

      DUMPFLAG = CHECK_SNANA_DUMP(
     &        FUN(1:LEN_FUN) // char(0) ,
     &        CCID(1:LEN_CCID) // char(0) ,
     &        BAND(1:LEN_BAND) // char(0),
     &        MJD  )

      CHECK_SNANA_DUMP_forC = DUMPFLAG

      RETURN
      END

C ==========================================
+DECK,AREAFRAC,IF=SNANA,SNFIT.
      SUBROUTINE CCD_AREAFRAC(ep)

c Created aug 2014 by R.Kessler
c Use input globals NXPIX,NYPIX, XPIX(ep), YPIX(ep)
c to compute SNLC_AREAFRAC(ep) = A/AMAX where
c
c A    = area of largest rectangle containing XPIX, YPIX
c AMAX = area of CCD.
c
c For uniform CCD illumination, the distribution of AREAFRAC
c is uniform; AREAFRAC=0 at center of CCD, and AREAFRAC=1.00 
c at edge.
c
c Also note that this works only for data because there is
c no pixel-coord input to the simulation ... but maybe 
c someday XPIX and YPIX keys will be added to SIMLIB header.
c
c --------------
      IMPLICIT NONE

      INTEGER ep  ! (I) epoch index

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      REAL XCEN, YCEN, YSCALE, X, Y, xy, A, AMAX

C ------------- BEGIN -------

      SNLC_AREAFRAC(ep) = -9.0 ;
      if ( SNLC_NXPIX .LE. 0.0 .or. SNLC_NYPIX .LE. 0.0 ) RETURN

c      print*,' xxx NXPIX,NYPIX = ', SNLC_NXPIX, SNLC_NYPIX

      XCEN   = SNLC_NXPIX/2.0
      YCEN   = SNLC_NYPIX/2.0
      YSCALE = SNLC_NYPIX/SNLC_NXPIX

      X  = ABS(SNLC_XPIX(ep) - XCEN)
      Y  = ABS(SNLC_YPIX(ep) - YCEN) / YSCALE  ! --> scale to square

      if ( X > Y ) THEN
         xy = X  ! half-len of square
      else
         xy = Y
      endif

      AMAX = SNLC_NXPIX**2  ! max possible area
      A    = 4. * xy * xy   ! area containing XPIX, YPIX/Yscale

      SNLC_AREAFRAC(ep) = A/AMAX

      RETURN
      END   ! end of CCD_AREAFRAC
+SELF.

C ==========================================
+DECK,MON_SNANA.
      SUBROUTINE MON_SNANA(IFLAG)

c Re-Created Feb 2013
c Driver for monitor tables.
c May 2 2020: add call to TABLE_MARZ

      IMPLICIT NONE

      INTEGER IFLAG   ! (I) see IFLAG_XXX params

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.

      LOGICAL   LTMP
      CHARACTER FNAM*10

C ------------ BEGIN ---------
      FNAM = 'MON_SNANA'

      IF( .NOT. USE_TABLEFILE ) RETURN

c ------------------------------------------------------
      IF ( MADE_LCPLOT )  N_SNLC_PLOT = N_SNLC_PLOT + 1 
c ------------------------------------------------------

c fill OUTLIER table first so that SNANA table can include summary info
      IF ( OPT_TABLE(ITABLE_OUTLIER) > 0 ) THEN
         CALL TABLE_OUTLIER(IDTABLE_OUTLIER,IFLAG)   
      ENDIF

      IF ( OPT_TABLE(ITABLE_SNANA) > 0 ) THEN
         CALL TABLE_SNANA(IDTABLE_SNANA,IFLAG)   
      ENDIF


      IF ( MARZFILE_OUT .NE. '' ) THEN
         CALL TABLE_MARZ(IDTABLE_MARZ,IFLAG)
      ENDIF

      RETURN
      END     ! end of MON_SNANA

C ========================================
+DECK,MON_HUBBLEREF.
      SUBROUTINE MON_HUBBLEREF ( IERR )
c
c Plot theory MAG vs. Z for various Omega_{M,LAM,w}
c to have convenient theory references, and to 
c crosscheck DLZ8 function.
c
c May 29, 2007: add 407 with Omega_MAT=1
c Feb 02, 2013: switch to SNHIST_XXX functions in sntools_output.c.
c Jul 08, 2016: plot curves from z=0-2 (instead of 0-1)
c Apr 23, 2019: add 8th plot with Orad = 1.2E-5
c Oct 23, 2020: use DLMAG_fortC to get DLMAG

      IMPLICIT NONE
      INTEGER IERR ! (O) 0=> OK

+CDE,SNPAR.

c local var

      INTEGER iz, NBZ(2), iplot, hid, LENTIT
      REAL*8  Z0, vPEC, Z0arg(2), zbinsize, ZLIM(2), DLMAG
      character chis*80

c define parameters for theory plots

      INTEGER NPL, NDIM
      PARAMETER (NPL = 8, NDIM=1 )

      REAL*8
     &   OM(NPL)  / 0.3, 0.3,  0.3,  0.3,  0.0,  0.0,  1.0,  0.3 /
     &  ,OL(NPL)  / 0.7, 0.7,  0.7,  0.0,  0.0,  1.0,  0.0,  0.7 /
     &  ,OR(NPL)  / 0.0, 0.0,  0.0,  0.0,  0.0,  1.0,  0.0,  1.2E-5/
     &  ,w0(NPL)  /-1.0,-0.95,-0.95, 0.0,  0.0, -1.0, -1.0, -1.0 /
     &  ,wa(NPL)  / 0.0,-0.15, 0.15, 0.0,  0.0,  0.0,  0.0,  0.0 / 

c     &  ,W(NPL)   /-1.0,-0.9, -0.84, 0.0,  0.0, -1.0, -1.0, -1.0 /
c     &  ,DWDZ(NPL)/ 0.0, 0.0,  0.65, 0.0,  0.0,  0.0,  0.0,  0.0 / 

c functions

      REAL*8 DLMAG_FORTC

c ---------------- BEGIN ------------
      IERR = 0

      CALL PRBANNER ( "PLOT THEORY HUBBLE DIAGRAMS for REFERENCE")

c define Z bins for each plot

      ZLIM(1) = 0.0
      ZLIM(2) = 2.0
      NBZ(1)  = 200

      ZLIM(2) = 4.0
      NBZ(1)  = 200
ccccc

      Zbinsize = ( ZLIM(2)-ZLIM(1) ) / float(NBZ(1))

c book histos

      LENTIT = LEN(chis)

      DO iplot = 1, NPL
         write(chis,20) OM(iplot), OL(iplot), 
     &                  OR(iplot)/1.0E-5, w0(iplot), wa(iplot)
20       format('MU vs. z (OM,OL,Or*E5 =', 3(F5.3,',') , ')',
     &            2x, 'w0,wa = ',2F6.2, ')'  )
         hid = 400 + iplot
         chis = chis(1:70) // char(0)
         CALL SNHIST_INIT(NDIM, hid, chis, NBZ, zlim(1), zlim(2), 
     &                      LENTIT )
      END DO

c comput Mag vs. Z and fill histograms
      vPEC = 0.0 

      DO 100 iz    = 1, NBZ(1)
        Z0 = zbinsize * ( float(iz)-0.5 )
      DO 200 iplot = 1, NPL
 
c use H0_DEFAULT instead of namelist H0_REF so that plot is always the same.
        
        DLMAG = DLMAG_fortC(z0,z0, vPEC, H0_DEFAULT,
     &    OM(iplot), OL(iplot), w0(iplot), wa(iplot) )

        HID = 400 + iplot
        Z0arg(1) = z0  ! use array to aboif gcc 10 warning
        CALL SNHIST_FILL( NDIM, HID, Z0arg, DLMAG ) 

200   CONTINUE
100   CONTINUE   ! iz


      RETURN
      END   ! end of MON_HUBBLEREF


C ===============================================
+DECK,MJDSELECT.
      LOGICAL FUNCTION MJDSELECT ( imjd, cutbit )
c
c Returns TRUE if this IMJD passes cuts
c CUTBIT = 0 => apply all cuts.
c
c If cutbit < 0, then all cuts are applied EXCEPT
c for |cutbit|; i.e., the cut on |cutbit| is ignored.
c This is useful to plot variables with cuts on all other 
c variables except the one of interest. This allows you to
c see what gets cut.
c
c Note that if |cutbit| <= CUTBIT_MJD_MARKER,
c then this function really just selects from the 
c SN-dependent cuts (like RA, redshfit, etc ...) 
c and ignores the epoch index.
c
c Aug 22, 2007: modify to select NEWMJD instead of epoch.
c Nov 12, 2018: real MJD -> real*8 MJD
c -------------------------------------------
      IMPLICIT NONE

c declare subroutine args

      INTEGER 
     &   imjd     ! (I) epoch index
     &  ,cutbit   ! (I) cut to ignore (if negative)

+CDE,SNDATCOM.
+CDE,SNLCINP.

c local var

      INTEGER EPMIN, acutbit   ! abs(cutbit)
      REAL*8    MJD         
      INTEGER*8 CUTMASK8_ALL, CUTMASK8_TMP, OVP8
     
      LOGICAL LCUT_MJD, LCUT_SN

c -------------- BEGIN ------------------
 
      MJDSELECT =  .FALSE.

c -----------------------------------------------
c first make a few idiot checks

      EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd) 
      MJD   = SNGL(SNLC8_MJD(EPMIN))
      if ( MJD .LT. 40000. ) return

c ----------------------------------------

      IF ( CUTBIT .GE. 0 ) THEN
         MJDSELECT =  MJDMASK(imjd) .GT. 0
         RETURN
      ENDIF

c --------------------------------------------------
c Now we have a negative cutbit; 
c check all cuts except |cutbit|

      acutbit = abs(cutbit)

      if ( acutbit .GT. NCUTBIT ) then
          write(c1err,60) cutbit
60        format('bad value of CUTBIT = ', I4 )
          CALL MADABORT("MJDSELECT", c1err, "")
      endif

c get cut-mask with all bits set.
c Note "SN" and EPOCHS have different cutmask.

      if ( acutbit .LE. CUTBIT_MJD_MARKER ) then
           CUTMASK8_ALL =  CUTMASK8_SN_ALL
           LCUT_SN    = .TRUE.
           LCUT_MJD   = .FALSE.
      else 
           CUTMASK8_ALL =  CUTMASK8_MJD_ALL
           LCUT_SN      = .FALSE.
           LCUT_MJD     = .TRUE.
      endif

c define mask with all cuts except IBIT cut

      CUTMASK8_TMP = IBCLR ( CUTMASK8_ALL, acutbit-1 )

      IF ( LCUT_SN ) then
        OVP8  = IAND ( CUTMASK8_TMP, CUTMASK8_SN )
      ELSE
        OVP8  = IAND ( CUTMASK8_TMP, CUTMASK8_MJD(imjd))
      ENDIF

c  MJD passes if overlap mask equals mask with all
c  cuts EXCEPT |cutbit|

      MJDSELECT = ( OVP8 .EQ. CUTMASK8_TMP )

      RETURN
      END


   

C ==========================================
+DECK,GET_TRESTVAR.
      SUBROUTINE GET_TRESTVAR(
     &     NTLIST, TLIST, FLIST, SNRLIST      ! (I)
     &   , CUTWIN_TREST                       ! (I)
     &   , CUTWIN_TRESTMIN, CUTWIN_TRESTMAX   ! (I)
     &   , CUTWIN_TREST2                      ! (I)
     &   , NFILT, TMIN, TMAX                  ! (O)
     &   , NFTMIN, NFTMAX, NFT2               ! (O)
     &   , TGAPMAX, T0GAPMAX                  ! (O)
     &   , SNRSUM     )                       ! (O)

c Created May 25, 2009 by R.Kessler
c Return rest-frame variables related to TREST,
c where TREST = 0 at peak.
c NOTES:
c   - assumes that TLIST is ordered from min to max.
c
c
c Jul 01 2024 pass and process SNRLIST
c --------------------

      IMPLICIT NONE
+CDE,SNPAR.

      INTEGER 
     &   NTLIST        ! (I) size of TLIST array
     &  ,FLIST(NTLIST) ! (I) obs-filter list (to count NFTMIN[MAX])

      REAL  
     &   TLIST(NTLIST)         ! (I) rest-frame list
     &  ,SNRLIST(NTLIST)       ! (I) SNR list
     &  ,CUTWIN_TREST(2)       ! (I) global Trest-window
     &  ,CUTWIN_TRESTMIN(2)    ! (I) window to count NFTMIN 
     &  ,CUTWIN_TRESTMAX(2)    ! (I) idem for NFTMAX
     &  ,CUTWIN_TREST2(2)      ! (I) generic window
     
      REAL 
     &   TMIN, TMAX      ! (O) min, max Trest
     &  ,TGAPMAX         ! (O) max rest-frame gap (days)
     &  ,T0GAPMAX        ! (O) idem near peak

      INTEGER 
     &   NFILT           ! (O) NFILT in FLIST array
     &  ,NFTMIN          ! (O) Nfilt passing CUTWIN_TRESTMIN
     &  ,NFTMAX          ! (O) Nfilt passing CUTWIN_TRESTMAX
     &  ,NFT2            ! (O) Nfilt passing CUTWIN_TREST2

c local car

      INTEGER 
     &   i, ORDER, isort
     &  ,INDEX_SORT(MXEPOCH)
     &  ,IFILT_obs
    
      REAL 
     &  Trest, Tlast, TGAP, SNR, SNRSUM, SQSNRSUM
     & ,T0GAPWIN(2)

      LOGICAL 
     &   LT0GAP, LTMP
     &  ,LTMIN(MXFILT_ALL)
     &  ,LTMAX(MXFILT_ALL)
     &  ,LT2(MXFILT_ALL)
     &  ,LFILT(MXFILT_ALL)

c function

      EXTERNAL SORTFLOAT

C ------------------- BEGIN ---------------

c init output args
      Tmin      = +999.
      Tmax      = -999.       
      TGAPMAX   = -999.
      T0GAPMAX  = -999.
      NFTMIN    = 0
      NFTMAX    = 0
      NFILT     = 0
      NFT2      = 0
      SQSNRSUM  = 0.0
      SNRSUM    = 0.0
      
c local stuff
      Tlast     =  999.

c construct T0GAP-window from other cuts
      T0GAPWIN(1)  = CUTWIN_TRESTMIN(2)
      T0GAPWIN(2)  = CUTWIN_TRESTMAX(1)
 
      DO IFILT_OBS = 1, MXFILT_ALL
        LFILT(IFILT_OBS) = .FALSE.
        LTMIN(IFILT_OBS) = .FALSE.
        LTMAX(IFILT_OBS) = .FALSE.
        LT2(IFILT_OBS)   = .FALSE.
      ENDDO 


      ORDER = +1 
      CALL sortFloat(NTLIST, TLIST, ORDER, INDEX_SORT )
     
      DO 444 i   = 1, NTLIST

         isort      = INDEX_SORT(i)
         Trest      = TLIST(isort)
         ifilt_obs  = FLIST(isort)
         snr        = SNRLIST(isort)
	 
         if ( Trest .LT. CUTWIN_TREST(1)   ) GOTO 444          
         if ( Trest .GT. CUTWIN_TREST(2)   ) GOTO 444          

         IF ( .not. LFILT(ifilt_obs) ) then
            NFILT = NFILT + 1
            LFILT(ifilt_obs) = .TRUE.
         ENDIF

         LTMP = Trest .GE. CUTWIN_TRESTMIN(1) .and.
     &          Trest .LE. CUTWIN_TRESTMIN(2)
         IF ( LTMP .and.  .not. LTMIN(ifilt_obs) ) then
            NFTMIN = NFTMIN + 1
            LTMIN(ifilt_obs) = .TRUE.
         ENDIF

         LTMP = Trest .GE. CUTWIN_TRESTMAX(1) .and.
     &          Trest .LE. CUTWIN_TRESTMAX(2) 
         IF ( LTMP .and.  .not. LTMAX(ifilt_obs) ) then
            NFTMAX = NFTMAX + 1
            LTMAX(ifilt_obs) = .TRUE.
         ENDIF

         LTMP = Trest .GE. CUTWIN_TREST2(1) .and.
     &          Trest .LE. CUTWIN_TREST2(2) 
         IF ( LTMP .and.  .not. LT2(ifilt_obs) ) then
            NFT2 = NFT2 + 1
            LT2(ifilt_obs) = .TRUE.
         ENDIF

         IF ( LTMP ) THEN
           SQSNRSUM = SQSNRSUM + (SNR*SNR)
         ENDIF
	 
         Tmin = MIN ( Tmin, Trest )
         Tmax = MAX ( Tmax, Trest )

         if ( i .EQ. 1 ) then
           Tlast = Trest
           GOTO 444
         endif

         TGAP = Trest - Tlast
         if ( TGAP .GT. TGAPMAX ) then
             TGAPMAX = TGAP
         endif

         LT0GAP = .FALSE.
         if ( Trest > T0GAPWIN(1) .and. Trest < T0GAPWIN(2) ) 
     &       LT0GAP = .TRUE.
         if ( Tlast > T0GAPWIN(1) .and. Tlast < T0GAPWIN(2) ) 
     &       LT0GAP = .TRUE.
         if ( Trest > T0GAPWIN(2) .and. Tlast < T0GAPWIN(1) ) 
     &       LT0GAP = .TRUE.

         if ( LT0GAP .and. TGAP .GT. T0GAPMAX ) then
           T0GAPMAX = TGAP
         endif

         Tlast = Trest

444   CONTINUE

      if ( SQSNRSUM > 1.0E-8 ) SNRSUM = sqrt(SQSNRSUM)
      
      RETURN
      END    ! GET_TRESTVAR




C ====================================================
+DECK,DMP_CUTFAIL.
      SUBROUTINE DMP_CUTFAIL ( IMJD, idebug ) 
c
c Created Jan 31, 2006 by R.Kessler
c
c Dump CUTBITS that fail for this 'IMJD'
c 
c IDEBUG = 1 : general info for users
c IDEBUG = 2 : include detailed cut-masks for development
c
c Aug 2007: make special note when telescope is not found.
c Nov 2019: remove telescope logic and CUTBIT_IDTEL

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER IMJD   ! (I) sparse SN index and epoch
      INTEGER idebug     ! (I) debug level

c local var

      INTEGER  cid, ibit, ii, EPMIN
      character ccid*(MXCHAR_CCID)
      LOGICAL LCUT, LTEST

C ------------------- BEGIN --------------

      cid  = SNLC_CID
      ccid = SNLC_CCID

      EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,IMJD)

c write MJD-cutmask in hex format

      IF ( IDEBUG .GT. 1 ) then
        write(6,20) CUTMASK8_MJD(IMJD), ccid, IMJD
20      format(T5, 'CUTMASK8_MJD = x', z16.16, 2x, 
     &        'for  SN ', A12, 2x, 'NEWMJD ',I3 )
      ENDIF

c list failed bits for epoch-dependent cuts only

      DO ibit = CUTBIT_MJD_MARKER+1, NCUTBIT

        LTEST = BTEST ( CUTMASK8_MJD_ALL,        ibit-1 ) 
        LCUT  = BTEST ( CUTMASK8_MJD(IMJD),  ibit-1 )

        if ( LTEST .and.  .not. LCUT ) then
           ii = INDEX(cutvar_name(ibit),':') - 1

           write(6,30) 
     &        IMJD, snlc8_MJD(EPMIN),
     &        ibit, cutvar_name(ibit)(1:ii)

30         format(T5,'NEWMJD ',I2,1x,'(MJD=',F9.3,')',2x,
     &         'Failed CUTBIT ', I3, ' : ', A  )

        endif

      ENDDO

      RETURN
      END  ! end DMP_CUTFAIL
  
C =============================================
+DECK,DMP_SNFAIL.
      SUBROUTINE DMP_SNFAIL()
c
c Dump utility for SN that fails cuts
c Shows cuts that fail for SN, and cuts that fail for each epoch.
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER imjd, ibit, ii
      LOGICAL LCUT, LTEST

C ---------------- BEGIN ------------

      print*,' '
      print*,' ========== DMP_SNFAIL for CID ', SNLC_CID,
     &        ' ================= '

      DO 100 ibit = 1, CUTBIT_MJD_MARKER 

        LTEST = BTEST ( CUTMASK8_SN_ALL,  ibit-1 )
        LCUT  = BTEST ( CUTMASK8_SN,      ibit-1 )

        if ( LTEST .and.  .not. LCUT ) then
           ii = INDEX(cutvar_name(ibit),':') - 1
           
           write(6,30) ibit, cutvar_name(ibit)(1:ii)
     &          ,SNLC_CUTVAR(ibit)
     &          ,CUTWIN_VAR(1,ibit)
     &          ,CUTWIN_VAR(2,ibit)
30         format(T5, 'Failed SN cut ',I2,' : ', A,
     &        ' =', F8.2, ' (cutwin=',F8.1,' to ',G10.3,  ')'  )
        endif

100   CONTINUE

      do imjd = 1, ISNLC_NEWMJD_STORE
         CALL DMP_CUTFAIL ( IMJD, 1 )  ! MJD cut-failures
      enddo

      print*,' ===================================== '
      print*,' '
      RETURN
      END


C ==================================================
+DECK,SET_CUTMASK.
      SUBROUTINE SET_CUTMASK()

c
c Created Jan 31, 2006 by R.Kessler
c
c After SN data are read in, this routine
c sets CUTMASK8_SN and CUTMASK8_MJD(epoch), 
c and then determines which SN and epochs pass/fail cuts.
c
c To test SN 
c   if ( CUTMASK8_SN .EQ. CUTMASK8_SN_ALL ) then
c      use this SN
c   endif
c
c To test epochs,
c
c    if (  btest(EPOCHMASK(isn),epoch-1 )  ) then
c       use this epoch
c    endif
c
c       HISTORY
c    ~~~~~~~~~~~~~
c Feb 27 2018: set cut for ZP in Npe; see CUTWIN_ZP
c Feb 06 2020: add cut for Trest_trueflux
c Feb 20 2020: make sure PHOTPROB cut passes if PHOTPROB < 0
c Mar 16 2021: load SIM_EPPULL to enable cut on PULL
c Jul 01 2024: compute SNRLIST and pass to GET_TRESTVAR
c -----------------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.
+CDE,SPECCOM.

c local var

      INTEGER
     &   NEWMJD, imjd, NEWMJD_CUTS
     &  ,EPMIN, EPMAX, ep, ifilt, ifilt_obs
     &  ,ICUT, i, cid,  NTLIST
     &  ,FLIST(MXEPOCH)
     &  ,NFILT, NFTMIN, NFTMAX, NFT2

      INTEGER*8  CUTMASK8_TMP, OVP8_SN, OVP8_ALL

      LOGICAL LTEST, LCUT, LCUT1, LCUT2
 
      REAL  TMP, Tmin, Tmax, ZZ, TGAPMAX, T0GAPMAX
      REAL  TLIST(MXEPOCH), SNRLIST(MXEPOCH)
      REAL  TREST, TRUEMAG, PHOTPROB, SNRSUM

c functions
      LOGICAL MJDSELECT, LCIDSELECT

c ---------------- BEGIN ---------------

      NEWMJD       = ISNLC_NEWMJD_STORE
      NEWMJD_CUTS  = 0

c init common block var output

      CUTMASK8_SN   = 0
      

      Do imjd = 1, NEWMJD
         CUTMASK8_MJD(imjd) = 0
         MJDMASK(imjd)      = 0  ! init
      End Do

      CID = SNLC_CID

      IF ( SNLC_REDSHIFT > 0. ) THEN
         zz  = 1.0 + SNLC_REDSHIFT
      ELSE
         zz = 1.0  ! avoid crazy Tobsmin/max
      ENDIF

c check privat-var cuts and user cuts from private code
      IF ( .not. PASS_PRIVCUTS ) ISNLC_CUTFLAG_PRIVATE = 0 
      IF ( .not. PASS_SIMCUTS  ) ISNLC_CUTFLAG_SIMVAR  = 0 

c --------------------------------------------------------
c first evaluate SNLC_CUTVAR array for MJD-dependent
c SNLC_XXX arrays.

      DO 100 imjd = 1, NEWMJD

        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,imjd)

c Dec 18 2017: replace cloudAVG with PSF cut. Note that cut is in ARCSEC
         SNEP_CUTVAR(CUTBIT_PSF,imjd)  = 
     &       SNLC_PSF_SIG1(EPMIN) * (SNLC_PIXSIZE * 2.355)

         SNEP_CUTVAR(CUTBIT_ZP,imjd) = 
     &       SNLC_ZEROPT_forCUT(EPMIN) 

         SNEP_CUTVAR(CUTBIT_ZPERR,imjd) = 
     &       SNLC_ZEROPT_ERR(EPMIN)      ! Feb 2020

         PHOTPROB = SNLC_PHOTPROB(EPMIN)
         IF ( PHOTPROB < 0.0 ) PHOTPROB = 1.0  ! undefined PHOTPROB passes cut
         SNEP_CUTVAR(CUTBIT_PHOTPROB,imjd)  = PHOTPROB 

         SNEP_CUTVAR(CUTBIT_ERRTEST,imjd)  = 
     &       SNLC_FLUXCAL_ERRTEST(EPMIN)

         SNEP_CUTVAR(CUTBIT_SIMPULL,imjd)  = 
     &       SIM_EPPULL(EPMIN)

         SNEP_CUTVAR(CUTBIT_TREST,imjd)  = 
     &       SNLC_TREST(EPMIN)

         SNEP_CUTVAR(CUTBIT_TOBS,imjd)  = 
     &       SNLC_TOBS(EPMIN)

         SNEP_CUTVAR(CUTBIT_MJD,imjd)  = 
     &       SNGL( SNLC8_MJD(EPMIN) )

c Requiring valid true flux is a little tricky.
c Motivation is for fake light curves on images where a few epochs 
c didn't get overlaid for unknown reasons.
         SNEP_CUTVAR(CUTBIT_TREST_TRUEFLUX2,imjd) = 1.0
         IF ( ISJOB_SIM ) THEN
            Trest   = SNLC_TREST(EPMIN)
            TRUEMAG = SIM_EPMAGOBS(EPMIN)
            LCUT1   = (TREST > CUTWIN_TREST_TRUEFLUX(1) .and.
     &                 TREST < CUTWIN_TREST_TRUEFLUX(2) )
            LCUT2   = (TRUEMAG < 40)
            if ( LCUT1 .and. (.not. LCUT2) ) then
              SNEP_CUTVAR(CUTBIT_TREST_TRUEFLUX2,imjd) = 0.0
            endif
         ENDIF

100   CONTINUE

c ----------------------------------------------------
c Evaluate cutmask for each epoch

      DO 200 imjd = 1, NEWMJD

        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,imjd)

        CUTMASK8_TMP = 0
        CUTMASK8_MJD(imjd) = CUTMASK8_TMP

      DO 201 icut  = CUTBIT_MJD_MARKER+1, NCUTBIT

          LTEST = BTEST ( CUTMASK8_MJD_ALL, icut-1 )
          if ( .NOT. LTEST ) goto 201

          tmp = snep_cutvar(icut,imjd)
          LCUT = tmp .GE. cutwin_var(1,icut) .and.
     &           tmp .LE. cutwin_var(2,icut)

c set cut-bit if cut is satisfied
          if ( LCUT ) then
             CUTMASK8_TMP = IBSET ( CUTMASK8_TMP, icut-1 )
          endif 


201   CONTINUE   ! end ICUT loop

c if all cuts are satisfied for this epoch, then set MJDMASK

        CUTMASK8_MJD(imjd) = CUTMASK8_TMP


        if ( CUTMASK8_TMP .EQ. CUTMASK8_MJD_ALL ) then
           MJDMASK(imjd) = 1
           NEWMJD_CUTS   = NEWMJD_CUTS + 1
        endif

200   CONTINUE  ! end of IMJD loop

c -----------------------------------------------
c store number of epochs passing cuts,

      ISNLC_NEWMJD_CUTS = NEWMJD_CUTS

c -------------------------------------------
c fill SNLC_CUTVAR array for SN-dependent variables
c Note that this is done AFTER epoch-dependent cutmask
c so that NEWMJD_CUTS can be evaluated correctly.

         imjd  = 1

         SNLC_CUTVAR(CUTBIT_CID)       = 
     &        float ( SNLC_CID )

         SNLC_CUTVAR(CUTBIT_SNTYPE)     = 
     &        float ( ISNLC_TYPE )

         SNLC_CUTVAR(CUTBIT_REDSHIFT)  = 
     &       SNLC_REDSHIFT

         SNLC_CUTVAR(CUTBIT_REDSHIFT_ERR)  = 
     &       SNLC_REDSHIFT_ERR

         SNLC_CUTVAR(CUTBIT_RA)  = 
     &       SNGL( SNLC8_RA )
         SNLC_CUTVAR(CUTBIT_DEC)  = 
     &       SNGL( SNLC8_DEC )

         SNLC_CUTVAR(CUTBIT_HOSTSEP)  = SNHOST_ANGSEP(1)

         SNLC_CUTVAR(CUTBIT_PEAKMJD)  = 
     &       SNLC_SEARCH_PEAKMJD

         SNLC_CUTVAR(CUTBIT_NOBS_PREDETECT)  = 
     &       float ( ISNLC_NOBS_PREDETECT )  

         SNLC_CUTVAR(CUTBIT_SNRMAX)  = 
     &       SNLC_SNRMAX_FILT(0)
         SNLC_CUTVAR(CUTBIT_SNRMAX2)  = 
     &       SNLC_SNRMAX_FILT(0)  ! temp val; changed below
	       
         SNLC_CUTVAR(CUTBIT_NEPOCH)  = 
     &       float ( ISNLC_NEPOCH_STORE )

         SNLC_CUTVAR(CUTBIT_SEARCH)  = 
     &       SIM_SEARCHEFF_MASK

         SNLC_CUTVAR(CUTBIT_NFIELD)  = 
     &       float ( ISNLC_NFIELD_OVP )

         SNLC_CUTVAR(CUTBIT_MWEBV)  = 
     &        SNLC_MWEBV               ! added May 2012

         SNLC_CUTVAR(CUTBIT_NSEASON_ACTIVE)  = 
     &        float(NSEASON_ACTIVE)

         SNLC_CUTVAR(CUTBIT_REQEP)  = 
     &        float( ISNLC_CUTFLAG_REQEP )   ! added Sep 17 2017

         SNLC_CUTVAR(CUTBIT_PRIVATE)  = 
     &        float( ISNLC_CUTFLAG_PRIVATE )   ! added Nov 3 2014

         SNLC_CUTVAR(CUTBIT_SIMVAR)  = 
     &        float( ISNLC_CUTFLAG_SIMVAR )    ! added Dec 2018

c ---------------------------------------
c set TREST-related variables.
c Warning: this code must go here after evaluating
c cutmask from all other cuts.

c first build TLIST array for epochs that pass MJDSELECT()
       NTLIST = 0
       DO 444 imjd = 1, NEWMJD        
         if ( .NOT. MJDSELECT(imjd,0)  ) GOTO 444
         EPMIN     = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd)
         EPMAX     = ISNLC_EPOCH_RANGE_NEWMJD(2,imjd)
         DO EP     = EPMIN, EPMAX
           NTLIST  = NTLIST + 1
           TLIST(NTLIST)   = SNLC_Trest(EP)  
           FLIST(NTLIST)   = ISNLC_IFILT_OBS(EP)
           SNRLIST(NTLIST) = SNLC_SNR(EP)
	   
         ENDDO
444    CONTINUE

       CALL GET_TRESTVAR(NTLIST, TLIST, FLIST, SNRLIST  ! (I)
     &       ,CUTWIN_TREST                        ! (I)
     &       ,CUTWIN_TRESTMIN, CUTWIN_TRESTMAX    ! (I)
     &       ,CUTWIN_TREST2                       ! (I)
     &       ,NFILT, TMIN, TMAX                   ! (O)
     &       ,NFTMIN, NFTMAX, NFT2                ! (O)
     &       ,TGAPMAX, T0GAPMAX, SNRSUM )         ! (O) 

       SNLC_TGAPMAX  = TGAPMAX
       SNLC_T0GAPMAX = T0GAPMAX
       SNLC_SNRSUM   = SNRSUM
       
       SNLC_Trestmin = Tmin
       SNLC_Trestmax = Tmax
       SNLC_TrestRange = Tmax - Tmin    ! Dec 2017

       SNLC_Tobsmin = Tmin * ZZ
       SNLC_Tobsmax = Tmax * ZZ
	       
       ISNLC_NFILT_TRESTMIN  = NFTMIN
       ISNLC_NFILT_TRESTMAX  = NFTMAX
       ISNLC_NFILT_TREST2    = NFT2

c ----------------------------------------------------

       imjd  = 1
       EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd)

       SNLC_CUTVAR(CUTBIT_TRESTMIN)  = 
     &       SNLC_TRESTMIN
       SNLC_CUTVAR(CUTBIT_TRESTMAX)  = 
     &       SNLC_TRESTMAX
       SNLC_CUTVAR(CUTBIT_TRESTRANGE)  = 
     &       SNLC_TRESTRANGE

       SNLC_CUTVAR(CUTBIT_TobsMIN)  = 
     &       SNLC_TobsMIN
       SNLC_CUTVAR(CUTBIT_TobsMax)  = 
     &       SNLC_TobsMax

       SNLC_CUTVAR(CUTBIT_TGAPMAX)  = 
     &       SNLC_TGAPMAX
       SNLC_CUTVAR(CUTBIT_T0GAPMAX)  = 
     &       SNLC_T0GAPMAX

       SNLC_CUTVAR(CUTBIT_NFILT_SNRMAX)  = 
     &       float ( ISNLC_NFILT_SNRMAX )

       SNLC_CUTVAR(CUTBIT_NFILT_SNRMAX2)  = 
     &       float ( ISNLC_NFILT_SNRMAX2 )

       SNLC_CUTVAR(CUTBIT_NFILT_TRESTMIN)  = 
     &       float ( ISNLC_NFILT_TRESTMIN )

       SNLC_CUTVAR(CUTBIT_NFILT_TRESTMAX)  = 
     &       float ( ISNLC_NFILT_TRESTMAX )

       SNLC_CUTVAR(CUTBIT_NFILT_TREST2)  = 
     &       float ( ISNLC_NFILT_TREST2 )

c always make sure TREST2 cut passes since the only cut of
c interest in in NFILT_TREST2.
       SNLC_CUTVAR(CUTBIT_TREST2)  = CUTWIN_TREST2(1) + 0.1

       SNLC_CUTVAR(CUTBIT_SNRSUM)  = SNLC_SNRSUM
	       
c be careful with the SNRMAX indices.
       DO i         = 1, NFILT_SNRMAX  ! sparse index for SNRMAX cut
          ifilt_obs = IFILT_SNRMAX(i)  ! absolute filtetr index
          ifilt     = IFILTDEF_INVMAP_SURVEY(ifilt_obs)   ! sparse filt index
          icut      = CUTBIT_OFFSET_SNRMAX + i
          SNLC_CUTVAR(icut) = SNLC_SNRMAX_FILT(ifilt)
       ENDDO

c be careful with the HOST_SBFLUX indices.
       DO i         = 1, NFILT_HOST_SBFLUX  ! sparse index for SNRMAX cut
          ifilt_obs = IFILT_HOST_SBFLUX(i)  ! absolute filtetr index
          ifilt     = IFILTDEF_INVMAP_SURVEY(ifilt_obs)   ! sparse filt index
          icut      = CUTBIT_OFFSET_SBFLUX + i
          SNLC_CUTVAR(icut) = 
     &         SNHOST_SBFLUXCAL(ifilt)
       ENDDO

c -----------------------------------------------------
c After epochs, evaluate SN cut-mask 
c  (epoch-independent => use 1st epoch of SNLC_CUTVAR)
c This part comes AFTER epochmask so that we can cut
c on NEWMJD_CUTS

         CUTMASK8_TMP = 0

      DO 300 icut  = 1, CUTBIT_MJD_MARKER

          LTEST = BTEST (CUTMASK8_SN_ALL , icut-1 )
          if ( .NOT. LTEST ) GOTO 300

          tmp = snlc_cutvar(icut)
          LCUT = tmp .GE. cutwin_var(1,icut) .and.
     &           tmp .LE. cutwin_var(2,icut)

c special check for CID cut. This cut is probably redundant
c with the cut in PARSE_CID.

          if ( icut .EQ. CUTBIT_CID ) then
            LCUT = LCIDSELECT(SNLC_CID,SNLC_CCID,SNLC_NAME_IAUC)
          endif

c set cut-bit if cut is satisfied

          if ( LCUT ) then
             CUTMASK8_TMP = IBSET ( CUTMASK8_TMP, icut-1 )
             NACCEPT_CUT(icut) = NACCEPT_CUT(icut) + 1
          endif

300   CONTINUE   ! end ICUT loop

      CUTMASK8_SN = CUTMASK8_TMP

c set SN cut-logical

      IF ( CUTMASK8_SN .EQ. CUTMASK8_SN_ALL  ) THEN
         LSNCUTS       = .TRUE.
         CUTFLAG_SNANA = IBSET(CUTFLAG_SNANA,0)
         N_SNLC_CUTS   = N_SNLC_CUTS + 1
         if (NSPECTRUM > 0) N_SNLC_SPEC = N_SNLC_SPEC + 1
	 
         if(SNHOST_ZSPEC(1) > 0.) N_SNHOST_ZSPEC = N_SNHOST_ZSPEC+1
         if(SNHOST_ZPHOT(1) > 0.) N_SNHOST_ZPHOT = N_SNHOST_ZPHOT+1

	 N_MASK_zSOURCE_LC_CUTS(ISNLC_zSOURCE) =
     &   N_MASK_zSOURCE_LC_CUTS(ISNLC_zSOURCE) + 1

      ENDIF

c Jan 3, 2013
c increment Number of SN passing each incremental cut,
c and versus type. This info is dumped at the end of the
c job to trace where SN are lost.

      IF ( ISNLC_TYPE < 0 ) RETURN

      IF ( ISNLC_TYPE > MXTYPE ) THEN
        write(C1err,661) ISNLC_TYPE, MXTYPE
661     format('TYPE=',I5,' exceeds bound: MXTYPE=',I4 )
        C2err = 'Check CID = ' // SNLC_CCID
        CALL MADABORT("SET_CUTMASK", c1err, c2err ) 
      ENDIF

      CUTMASK8_TMP = 0
      DO icut = 1, NCUTBIT_SNLC
         CUTMASK8_TMP = IBSET(CUTMASK8_TMP,icut-1)
         OVP8_ALL     = IAND(CUTMASK8_TMP,CUTMASK8_SN_ALL)
         OVP8_SN      = IAND(CUTMASK8_SN,OVP8_ALL)
         IF ( OVP8_SN .EQ. OVP8_ALL ) THEN
            NPASSCUT_INCREMENT(ISNLC_TYPE,ICUT) =
     &      NPASSCUT_INCREMENT(ISNLC_TYPE,ICUT) + 1

c increment all types with ITYPE=-1 (Aug 2013)
            NPASSCUT_INCREMENT(-1,ICUT) =
     &      NPASSCUT_INCREMENT(-1,ICUT) + 1
         ENDIF
      ENDDO

      RETURN
      END  ! end of SET_CUTMASK


C ==============================================
+DECK,LCIDSELECT.
      LOGICAL FUNCTION LCIDSELECT(CID,CCID,NAME_IAUC)
c
c Created Dec 4, 2012 by R.Kessler
c Returns TRUE if current CID/CCID is accepted by
c any of 
c  CUTWIN_CID     (integer window of CID to accept)
c  SNCID_LIST     (integer list of CID to accept)
c  SNCCID_LIST    (char list of CCID to accept)
c
c and is NOT rejected by
c  SNCID_IGNORE       (integer list of CID to ignore)
c  SNCCID_IGNORE_ALL  (char list of CCID to ignore)
c
c This function replaces much of the obsolete CIDMASK(CID) array
c to avoid declaring such a large array.
c
c
c Oct 10 2020: fix bug checking SNCCID_IGNORE_ALL
c
c Jan 08 2025: set INDEX_CID_MATCH inside check for SNCID_LIST in case SNCID_LIST
c              has overlap with CID in SNCID_LIST_FILE.
c
C ---------------------------

      IMPLICIT NONE

c input function args
      INTEGER CID
      CHARACTER CCID*(*), NAME_IAUC*(*)

+CDE,SNPAR. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,INTERPCM.
+CDE,SNLCCOM.
   
      INTEGER i, LEN, LENCCID, LENIAUC, ISN_MATCH
      REAL XCID     
      CHARACTER CCID_forC*(MXCHAR_CCID), CCIDTMP*(MXCHAR_CCID)

c functions
      LOGICAL   STRINGMATCH
      INTEGER   MATCH_CIDLIST_EXEC
      EXTERNAL  MATCH_CIDLIST_EXEC
c ------------------ BEGIN ---------------

      LCIDSELECT = .FALSE.
      LENCCID    = INDEX(CCID//' ' , ' ') - 1
      CCID_forC  = CCID(1:LENCCID) // char(0)      
      INDEX_CID_MATCH = -9
c ----------------------------
c first check IGNORE Lists

      i = 1
      DO 30 WHILE ( SNCID_IGNORE(i) .GE. 1 ) 
        if ( CID .EQ. SNCID_IGNORE(i) ) GOTO 800
        i = i + 1
30    CONTINUE

      DO 40 i = 1, NCCID_IGNORE
        LEN   = INDEX(SNCCID_IGNORE_ALL(i),' ') - 1
        IF ( LEN .NE. LENCCID ) GOTO 40
        if ( CCID(1:LEN) .EQ. SNCCID_IGNORE_ALL(i)(1:LEN)) GOTO 800
40    CONTINUE

c -----------------------------
c Check integer window

      XCID = FLOAT(CID)
      IF ( XCID .GE. CUTWIN_CID(1) .and. 
     &     XCID .LE. CUTWIN_CID(2) ) then
        LCIDSELECT = .TRUE.
        GOTO 800
      ENDIF

c Since integer list is small, use brute-force looping.
      i = 1
      DO 130 WHILE ( SNCID_LIST(i) .GE. 1 ) 
        if ( CID .EQ. SNCID_LIST(i) ) then
          LCIDSELECT = .TRUE.
          INDEX_CID_MATCH = MATCH_CIDLIST_EXEC(CCID_forC,LENCCID) ! Jan 2024
          GOTO 800
        endif
        i = i + 1
130   CONTINUE

c use hash table to check list of CID strings since this list
c can be quite large.

      ISN_MATCH = MATCH_CIDLIST_EXEC(CCID_forC,LENCCID)
      if ( ISN_MATCH  < 0 ) then   ! try IAUC name
         LENIAUC    = INDEX(NAME_IAUC,' ') - 1
         CCID_forC  = NAME_IAUC(1:LENIAUC) // char(0)
         ISN_MATCH  = MATCH_CIDLIST_EXEC(CCID_forC,LENIAUC) ! use hash table
         if ( ISN_MATCH .GE. 0 ) CCID = NAME_IAUC ! write IAUC to output table 
      endif
      INDEX_CID_MATCH = ISN_MATCH     ! load global 
      LCIDSELECT = (ISN_MATCH .GE. 0)
      if ( LCIDSELECT ) GOTO 800

c - - - - - 
c finally, check list of CIDs on the MJD-interpolation list;
c see &SNLCINP namelist input SNMJD_LIST_FILE 

      DO 240 i = 1, N_INTERP_MJDLIST
        CCIDTMP = INTERP_CCIDLIST(i)
	
        IF ( STRINGMATCH(CCIDTMP,CCID) ) THEN
           LCIDSELECT = .TRUE.
           GOTO 800
        ENDIF

c Dec 2015: also check match with IAUC name
        IF ( STRINGMATCH(CCIDTMP,NAME_IAUC) ) THEN
           CCID       = NAME_IAUC  ! so that IAUC is written to output
           LCIDSELECT = .TRUE.
           GOTO 800
        ENDIF

240   CONTINUE

800   CONTINUE

      RETURN
      END   ! end LCIDSELECT


C ====================================
+DECK,STRINGMATCH.
      LOGICAL FUNCTION STRINGMATCH(STR1,STR2)

C Created Dec 2015
C Return True of STR1=STR2

      IMPLICIT NONE
      CHARACTER STR1*(*), STR2*(*)
      INTEGER   LEN1, LEN2

C ------------------ BEGIN -------------

      STRINGMATCH = .FALSE.
      LEN1 = INDEX(STR1,' ') -1
      LEN2 = INDEX(STR2,' ') -1
      IF ( LEN1 .NE. LEN2 ) RETURN

      IF ( STR1(1:LEN1) .EQ. STR2(1:LEN2) ) THEN
        STRINGMATCH = .TRUE.
      ENDIF
      
      RETURN
      END

C ======================
+DECK,STEPFUN8.
      DOUBLE PRECISION FUNCTION SMOOTH_STEPFUN8(SEP,SEPMAX)
c
c Created Sep 8, 2009 by R.Kessler
c 
c Define smooth function that goes from 0 to 1 between
c -SEPMAX and SEPMAX, and returns 0.5 at SEP=0.
c Return value of function at SEP.
c Function is atan.
c --------------------------
+CDE,SNPAR.
      REAL*8 SEP, SEPMAX  ! (I)
      REAL*8 TAU, F
c ----------- BEGIN ----------

      IF ( SEP .GT. SEPMAX ) THEN
         SMOOTH_STEPFUN8 = 1.0
         RETURN
      ENDIF
      IF ( SEP .LT. -SEPMAX ) THEN
         SMOOTH_STEPFUN8 = 0.0
         RETURN
      ENDIF

      TAU  = .1 * SEPMAX
      F    = 0.5 * (1. + ATAN(SEP/TAU)/ATAN(SEPMAX/TAU) )
      SMOOTH_STEPFUN8 = F

      RETURN
      END


C =======================================
+DECK,GET_HOSTXTINCT8.
      DOUBLE PRECISION FUNCTION GET_HOSTXTINCT8 ( AV, RV, Lambda )
      IMPLICIT NONE

c input args

      REAL*8
     &   AV      ! (I) extinction at  5495 A
     &  ,RV      ! (I) assumed A(V)/E(B-V) (e.g., = 3.1 in the LMC)
     &  ,Lambda  ! (I) wavelen, A

c local var

      REAL*8 x, y, a, b, fa, fb, dx, dx2, dx3
      REAL*8 y2, y3, y4, y5, y6, y7

C --------------- BEGIN --------------
      
      x = 10000./lambda    ! inverse wavelength in microns
      y = x - 1.82;

      if (x .GE. 0.3 .and. x .LT. 1.1) then   !  IR

         a =  0.574*(x**1.61)
         b = -0.527*(x**1.61)

      else if (x .GE. 1.1 .and. x .LT. 3.3) then    ! Optical/NIR

         y2 = y**2
         y3 = y**3
         y4 = y**4
         y5 = y**5
         y6 = y**6
         y7 = y**7

         a = 1. + 0.17699*y  - 0.50447*y2 - 0.02427*y3
     &          + 0.72085*y4 + 0.01979*y5 - 0.77530*y6
     &          + 0.32999*y7

         b = 1.41338*y + 2.28305*y2 + 1.07233*y3 - 5.38434*y4
     &                 - 0.62251*y5 + 5.30260*y6 - 2.09002*y7

      else if ( x .GE. 3.3 .and. x .LT. 8.0) then    ! UV

         if (x .GT. 5.9) then
          dx  = x - 5.9
          dx2 = dx  * dx
          dx3 = dx2 * dx
          fa = -0.04473*dx2 - 0.009779*dx3
          fb =  0.21300*dx2 + 0.120700*dx3
        else 
          fa = 0.0
          fb = 0.0
        endif

        a =  1.752 - 0.316*x - 0.104/((x-4.67)**2 + 0.341) + fa
        b = -3.090 + 1.825*x + 1.206/((x-4.62)**2 + 0.263) + fb

      else if (x .GE. 8.0 .and.  x .LE. 10.0 ) then  ! Far-UV

         dx  = x - 8.0
         dx2 = dx * dx
         dx3 = dx2 * dx

         a = -1.073 - 0.628*dx + 0.137*dx2 - 0.070*dx3
         b = 13.670 + 4.257*dx - 0.420*dx2 + 0.374*dx3

      else
          a = 0.0
          b = 0.0
      ENDIF

      GET_HOSTXTINCT8 = av*(a + b/RV)

      RETURN
      END

C ====================================================
+DECK,DFINT.
C
C Revision 1.1.1.1  1996/02/15 17:48:36  mclareni
C Kernlib
C
C
C#include "kernnum/pilot.h"

          DOUBLE PRECISION FUNCTION DFINT(NARG,ARG,NENT,ENT,TABLE)
C
          IMPLICIT NONE
C
C   INTERPOLATION ROUTINE. AUTHOR C. LETERTRE.
C   MODIFIED BY B. SCHORR, 1.07.1982.
C
C   Modified from CERNLIB funtion FINT to double precision
C by David Cinabro Feb 2006.  I did not make stylistic changes,
C even though those would seem to be called for.
C
c Oct 30, 2006 RSK : change arg dimensions from 9 to 90
c
c May 08, 2012: RSK replace hard-wired '90' with NARG in arg declarations
c Jul 10, 2012: RSK replace NARG with 500 (fix bug when NARG=1)
c
c Oct 26 2015: replace XXX(500) with  XXX(NARG) to avoid compile warnings.
c Jan 07 2016: ENT(NARG) -> ENT(500)
c Jan 11 2019: use NARG as argument instead of 500

          INTEGER   NARG         
          INTEGER   NENT(NARG+100)
ccc          REAL*8    ARG(NARG), ENT(500), TABLE(500)
          REAL*8    ARG(NARG+100), ENT(NARG+100), TABLE(NARG+100)

          INTEGER   INDEX(32)
          REAL*8    WEIGHT(32)
          LOGICAL   MFLAG
C
          INTEGER I,K,N
          INTEGER LOCA,LOCB,LOCC
          INTEGER LMAX,LMIN
          INTEGER ISTEP,KNOTS,NDIM,ISHIFT
          INTEGER LGFILE
          REAL*8 X,H,ETA, DX
C
C----------------------------------------------
          DFINT  =  0.
          IF(NARG .LT. 1  .OR.  NARG .GT. 5)  GOTO 300
          LMAX      =  0
          ISTEP     =  1
          KNOTS     =  1
          INDEX(1)  =  1
          WEIGHT(1) =  1.
          DO 100    N  =  1, NARG
             X     =  ARG(N)
             NDIM  =  NENT(N)
             LOCA  =  LMAX
             LMIN  =  LMAX + 1
             LMAX  =  LMAX + NDIM
             IF(NDIM .GT. 2)  GOTO 10
             IF(NDIM .EQ. 1)  GOTO 100
             H  =  X - ENT(LMIN)
             IF(H .EQ. 0.)  GOTO 90
             ISHIFT  =  ISTEP
             IF(X-ENT(LMIN+1) .EQ. 0.)  GOTO 21
             ISHIFT  =  0
             ETA     =  H / (ENT(LMIN+1) - ENT(LMIN))
             GOTO 30
  10         LOCB  =  LMAX + 1
  11         LOCC  =  (LOCA+LOCB) / 2
C
C Wow.  A computed goto.  Amazing.
C
             DX = X-ENT(LOCC)
             IF( DX .LT. 0.0  ) GOTO 12
             IF( DX .EQ. 0.0  ) GOTO 20
             IF( DX .GT. 0.0  ) GOTO 13
ccc             IF(X-ENT(LOCC))  12, 20, 13   ! obsolete


  12         LOCB  =  LOCC
             GOTO 14
  13         LOCA  =  LOCC
  14         IF(LOCB-LOCA .GT. 1)  GOTO 11
             LOCA    =  MIN0( MAX0(LOCA,LMIN), LMAX-1 )
             ISHIFT  =  (LOCA - LMIN) * ISTEP
             ETA     =  (X - ENT(LOCA)) / (ENT(LOCA+1) - ENT(LOCA))
             GOTO 30
  20         ISHIFT  =  (LOCC - LMIN) * ISTEP
  21         DO 22  K  =  1, KNOTS
                INDEX(K)  =  INDEX(K) + ISHIFT
  22            CONTINUE
             GOTO 90
  30         DO 31  K  =  1, KNOTS
                INDEX(K)         =  INDEX(K) + ISHIFT
                INDEX(K+KNOTS)   =  INDEX(K) + ISTEP
                WEIGHT(K+KNOTS)  =  WEIGHT(K) * ETA
                WEIGHT(K)        =  WEIGHT(K) - WEIGHT(K+KNOTS)
  31            CONTINUE
             KNOTS  =  2*KNOTS
  90         ISTEP  =  ISTEP * NDIM
 100         CONTINUE
          DO 200    K  =  1, KNOTS
             I  =  INDEX(K)
             DFINT  =  DFINT + WEIGHT(K) * TABLE(I)
 200         CONTINUE
          RETURN
 300      CONTINUE

c+SELF,IF=xxCERNLIB.
c          CALL KERMTR('E104.1',LGFILE,MFLAG,RFLAG)
c+SELF.
          IF(MFLAG) THEN
             IF(LGFILE .EQ. 0) THEN
                WRITE(*,1000) NARG
             ELSE
                WRITE(LGFILE,1000) NARG
             ENDIF
          ENDIF

c+SELF,IF=xxCERNLIB.
c          IF(.NOT. RFLAG) CALL ABEND
c+SELF.
          RETURN
1000      FORMAT( 7X,'FUNCTION DFINT ... NARG = ',I6,
     +              ' NOT WITHIN RANGE')
          END


C =========================
+DECK,POLINT8.
C
C snana.car,v 1.595 2012/05/04 01:13:13 
C
C
C Revision 1.1.1.1  1996/02/15 17:48:35  mclareni
C Kernlib
C
C Sep 2011: change to double precision
C
C #include "kernnum/pilot.h"
      SUBROUTINE POLINT8(F,ARG,MMMM,Z,SUM)
C         NEW VERSION OF E100 POLINT WRITTEN BY F.JAMES     DEC. 1976
C         LIMITED TO ORDER 19  (20 POINTS)  BY DIMENSION OF COF
C         BUT SUCH INTERPOLATION IS ALREADY UNSTABLE FOR ORDER 10

      IMPLICIT NONE

C subroutine args
      INTEGER MMMM
      DOUBLE PRECISION F(MMMM), ARG(MMMM), Z, SUM

c local var
      DOUBLE PRECISION COF(20)
      INTEGER M, MM, I, J, JNDEX, INDEX, LGFILE

      LOGICAL MFLAG
C ---------- BEGIN ----------
      IF(MMMM .LT. 2) GOTO 1900
      MM = MIN0(MMMM, 20)
      M = MM - 1
      DO 1780 I= 1, MM
         COF(I) = F(I)
 1780 CONTINUE
cc xxx obsolete  1780    COF(I) = F(I)

      DO 1800 I= 1, M
      DO 1790 J= I, M
         JNDEX = MM - J
         INDEX = JNDEX + I
         COF(INDEX) = (COF(INDEX)-COF(INDEX-1))/(ARG(INDEX)-ARG(JNDEX))
 1790 CONTINUE
 1800 CONTINUE
      SUM = COF(MM)
      DO 1810 I= 1, M
         INDEX = MM - I
         SUM = (Z-ARG(INDEX))*SUM + COF(INDEX)
 1810 CONTINUE
      RETURN
 1900 CONTINUE

c+SELF,IF=xxCERNLIB.
c      CALL KERMTR('E100.1', LGFILE, MFLAG, RFLAG)
c+SELF.
      IF(MFLAG) THEN
         IF(LGFILE .EQ. 0) THEN
            WRITE(*,2000) MMMM
         ELSE
            WRITE(LGFILE,2000) MMMM
         ENDIF
      ENDIF

c+SELF,IF=xxCERNLIB.
c      IF(.NOT. RFLAG) CALL ABEND
c+SELF.

      RETURN
 2000 FORMAT( 7X, 'SUBROUTINE POLINT8 ... K =', I6,
     +        ' IS LESS THAN 2')
      END



C ======================================
+DECK,FIRSTBIN_INTERP.
      INTEGER FUNCTION FIRSTBIN_INTERP (
     &   VALUE      ! (I) value to find bin for
     &  ,RANGE      ! (I) allowed range for VALUE
     &  ,BINSIZE    ! (I) binsize for RANGE
     &    )

c
c Return first bin to use for interpoliation.
c Asumes interp is done with 3 bins, where 2nd
c bin contains VALUE.
c
c ------------------------------

      IMPLICIT NONE
      REAL  VALUE, RANGE(2), BINSIZE  ! (I)

c local args    

      INTEGER ibin_cen, ibin_start, NBIN
      REAL dif

C ----------------- BEGIN ------------

      FIRSTBIN_INTERP  = -9

      dif      = value - range(1)
      ibin_cen = int ( (dif / binsize) + 0.5 ) + 1

      dif      = range(2) - range(1) + binsize/10000. 
      NBIN     = int( dif / binsize ) + 1 

c find starting bin for grid interpolation

      if ( ibin_cen .LE. 1 ) then
          ibin_start = 1
      else if ( ibin_cen .GE. NBIN ) then
          ibin_start = NBIN - 2
      else
          ibin_start = ibin_cen - 1   ! nominal case
      endif

      FIRSTBIN_INTERP  = ibin_start

      RETURN
      END     ! end FIRSTBIN_INTERP


C ==================================================
+DECK,LCUTVAR.
      LOGICAL FUNCTION LCUTVAR ( var, icut, VBOSE )
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,SNLCINP.

      REAL    VAR   ! (I) variable to  test cutwin
      INTEGER ICUT  ! (I) points to cutwin
      LOGICAL VBOSE ! (I) T=> print PASS or FAIL for each cut

c local var

      INTEGER ITMP
      CHARACTER CTMP*6

C -------------- BEGIN --------------

      LCUTVAR = var .GE. cutwin_var(1,icut) .and.
     &          var .LE. cutwin_var(2,icut)

      IF ( VBOSE ) THEN
          if ( LCUTVAR ) then
             CTMP = 'PASSES'
          else
             CTMP = 'FAILED'
          endif

          ITMP = INDEX(cutvar_name(icut),':') - 1
          ITMP = MIN(ITMP,14)
          write(6,20) cutvar_name(icut)(1:ITMP), var, CTMP
20        format(T10,A18,' = ', G10.3, 1x, A, ' CUT.' )
      ENDIF
 
      RETURN
      END

C ====================================
+DECK,DMPTRACE.
      SUBROUTINE DMPTRACE ( banner )
      IMPLICIT NONE
      character banner*(*)
      print*,'  XXXXX ', BANNER
      CALL FLUSH(6)
      RETURN
      END


C ========================================
+DECK,IPLOTSPLIT.
      INTEGER FUNCTION IPLOT_JOBSPLIT(NPLOT)
c
c Created Sep 28, 2012 by R.Kessler
c
c For single job, returns IPLOT = NPLOT is the 
c incremental (sparse) index. For non-trivial JOBSPLIT input,
c      IPLOT = (NPLOT-1) * NSPLIT_TOT + ISPLIT 
c so that the IPLOT are unique among each split job.
c Needed so that snana#fitres plot-macro works on merged
c histo files from split_and_fit.pl script.
c
c -----------------------------

      IMPLICIT NONE

      INTEGER NPLOT  ! (I) sequential plot number for this job

c local variables.

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER NJOBTOT, IJOB, IPLOT
      
C -------------- BEGIN ---------------     

c set default for non-split jobs.
      IPLOT = NPLOT

c check for internal split (mainly for FITS format)
      NJOBTOT = JOBSPLIT(2) ! total number of split jobs
      IJOB    = JOBSPLIT(1) ! do IJOB of NJOBTOT
      IF ( NJOBTOT .GT. 1 ) THEN
        IPLOT = (NPLOT-1) * NJOBTOT + IJOB        
      ENDIF

c check for text-format where SPLIT has been done externally
      NJOBTOT = JOBSPLIT_EXTERNAL(2) ! total number of split jobs
      IJOB    = JOBSPLIT_EXTERNAL(1) ! do IJOB of NJOBTOT
      IF ( NJOBTOT .GT. 1 ) THEN
        IPLOT = (NPLOT-1) * NJOBTOT + IJOB        
      ENDIF

c load output
      IPLOT_JOBSPLIT = IPLOT

      RETURN
      END

C =============================================
+DECK,GTSIMTYPE.
      SUBROUTINE GET_SIMNAME_TYPE(name)
      IMPLICIT NONE
      CHARACTER NAME*(*)
      INTEGER LL
+CDE,SNDATCOM.
+CDE,SNLCINP.
      NAME = ''
      IF ( .NOT. LSIM_SNANA ) RETURN
      LL = INDEX(SIMNAME_TYPE,' ') - 1
      NAME = SIMNAME_TYPE(1:LL) // char(0)  ! Ia, Ib, IIN, etc ...
      RETURN
      END


C =============================
+DECK,DOPLOT_SNLC.
      LOGICAL FUNCTION DOPLOT_SNLC()

C Created Aug 30 2013
C Returns T to make light curve plot for this SN.
C 
C ----------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNLCINP.

      INTEGER i, LENTMP
      LOGICAL DOPLOT

C ------------ BEGIN -------------

      DOPLOT = .FALSE.

      if ( OPT_TABLE(ITABLE_SNLCPAK) == 0 ) goto 888  ! Sep 8 2014

      if ( N_SNLC_PLOT < MXLC_PLOT ) THEN
         DOPLOT = .TRUE.
         GOTO 888
      endif

c check list of CCIDs to plot

      DO 100 i = 1, NCCID_PLOT
        LENTMP = INDEX( SNCCID_PLOT(i)//' ', ' ') - 1

        IF ( LENTMP .NE. ISNLC_LENCCID ) GOTO 100

        if ( SNCCID_PLOT(i) .EQ. SNLC_CCID ) then
          DOPLOT = .TRUE.
          GOTO 888
        endif

100   CONTINUE

888   CONTINUE
      DOPLOT_SNLC = DOPLOT

      RETURN
      END

C =============================
+DECK,DOPLOT_SPEC.
      LOGICAL FUNCTION DOPLOT_SPEC()

C Created May 30 2020
C Returns T to make spectra plot(s) for this SN
C 
C ----------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNLCINP.

      INTEGER i, LENTMP
      LOGICAL DOPLOT

C ------------ BEGIN -------------

      DOPLOT = .FALSE.
      if ( OPT_TABLE(ITABLE_SPECPAK) == 0 ) goto 888  

      if ( N_SNLC_PLOT < MXLC_PLOT ) THEN
         DOPLOT = .TRUE.
         GOTO 888
      endif

c check list of CCIDs to plot

      DO 100 i = 1, NCCID_PLOT
        LENTMP = INDEX( SNCCID_PLOT(i)//' ', ' ') - 1

        IF ( LENTMP .NE. ISNLC_LENCCID ) GOTO 100

        if ( SNCCID_PLOT(i) .EQ. SNLC_CCID ) then
          DOPLOT = .TRUE.
          GOTO 888
        endif

100   CONTINUE

888   CONTINUE
      DOPLOT_SPEC = DOPLOT

      RETURN
      END

C -----------------------------------------
+DECK,GETNLCPLOT,IF=SNANA.
      INTEGER FUNCTION SNANA_GET_NLCPLOT()

C Created May 17 2014 by R.Kessler
C Return NFIT_PER_SN = 0 or 1 based on SNLCINP options.
C For snana.exe job only.
c Sep 7 2014: use OPT_TABLE.

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
      INTEGER NLCPLOT, OPT
c --------------- BEGIN ------------

      NLCPLOT = 0  ! default -> no LC plotted
      OPT = OPT_TABLE(ITABLE_SNLCPAK)
      if ( OPT > 0 ) NLCPLOT = 1

c return function value
      SNANA_GET_NLCPLOT = NLCPLOT

      RETURN
      END
+SELF.

C ==============================
+DECK,SNLCPLOT,IF=SNANA.
      SUBROUTINE SNLCPLOT()

c Created Feb 2013 by R.Kessler
c Called only by snana.exe to 
c  * create sub dir
c  * pack light curves and PKMJD fit-curve
c  * cdtopdir
c
c Call wrappers in sntools_output.c to that there
c no native calls to CERNLIB or ROOT.
c
c
c Apr 11 2019:  MXEP_SNLCPAK -> 4*MXEPOCH (was 10*MXEPOCH)
c Jan 16 2020:  pass sim fluxes (see VSIMFLUX)
c -----------------------------------------------------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PKMJDCOM.

      CHARACTER  CCID*(MXCHAR_CCID), TEXT_forC*80

      LOGICAL  OVMODEL_ANYFUN, LTMP, DOPLOT_FILT(MXFILT_OBS)
      INTEGER 
     &   LENCCID, LENTEXT, NEWMJD, EPMIN, EPMAX, EP
     &  ,IFILT_OBS, IFILT, ipar, NBT, i, NFILT

      REAL*8  
     &    Z, Z1, Tobs, Trest, MJD, MJD_PLOT, TOBS_PLOT
     &   ,FLUX_DATA,  FLUXERR_DATA, FLUX_MODEL
     &   ,SQDIF, SQERR, CHI2, TMIN, TMAX, DT
     &   ,XVAL8(NPAR_ANYLC)
     
c SNLCPAK arrays

      INTEGER MXEP_SNLCPAK
      PARAMETER ( MXEP_SNLCPAK = 4*MXEPOCH )
      
      REAL*8
     &   VMJD(MXEP_SNLCPAK)
     &  ,VTOBS(MXEP_SNLCPAK)
     &  ,VFLUX(MXEP_SNLCPAK)
     &  ,VFLUX_ERR(MXEP_SNLCPAK)
     &  ,VSIMFLUX(MXEP_SNLCPAK) 
     &  ,VCHI2(MXEP_SNLCPAK)
     &  ,VREJECT(MXEP_SNLCPAK)
     &  ,VERRCALC(MXEP_SNLCPAK)
     &  ,VDUMERR(MXEP_SNLCPAK)  ! all zeros
c
     &  ,VBAND_NDOF(MXFILT_OBS)
     &  ,VBAND_CHI2(MXFILT_OBS)
     &  ,VBAND_PKFLUX(MXFILT_OBS)
     &  ,VBAND_PKFLUX_ERR(MXFILT_OBS)
     &  ,VBAND_PKMJD(MXFILT_OBS)
     &  ,VBAND_PKMJD_ERR(MXFILT_OBS)

      INTEGER
     &   NOBS
     &  ,VFILTOBS(MXEP_SNLCPAK)

c functions
      EXTERNAL  ANYLCFUN
      REAL*8    ANYLCFUN

      LOGICAL DOPLOT_SNLC

C ---------------- BEGIN --------------

c check if we should make the plot
      IF ( .NOT. DOPLOT_SNLC() ) RETURN

      CALL SNLCPAK_NFIT(1)      ! May 11 2014

      LENCCID = ISNLC_LENCCID
      CCID = SNLC_CCID(1:LENCCID) // char(0)

      OVMODEL_ANYFUN = (SNLC_SNANAFIT_PEAKMJD > 10.0) !show best peak-MJD fit
      NFILT   = NFILTDEF_SURVEY

      write(6,10) SNLC_CCID(1:LENCCID)
 10   format(T8,'SNLCPLOT: pack CID=',A,' for plotting.')
      call flush(6)

c create subdir
      CALL MAKEDIR_OUTPUT(CCID, SNLC_CID, LENCCID)

c prepare text string(s) to display on plot
      LENTEXT = LEN(TEXT_forC)

      write(TEXT_forC,20) ISNLC_TYPE, SNLC_REDSHIFT, char(0)
 20   format('TYPE = ', I3, 3x,'z=',F5.3, 3x, A )
      CALL SNLCPAK_DISPLAYTEXT(CCID, TEXT_forC, LENCCID, LENTEXT )
   
      IF ( OVMODEL_ANYFUN ) THEN
         TEXT_forC = 'Fit  ANYFUN  to estimate peak MJD' // char(0)
         CALL SNLCPAK_DISPLAYTEXT(CCID, TEXT_forC, LENCCID, LENTEXT )
      ENDIF

c flag which filter(s) to plot
      DO IFILT = 1, NFILT
        VBAND_NDOF(ifilt)   = 0.0           ! init this array
        VBAND_CHI2(ifilt)   = 0.0           ! init this array
        VBAND_PKFLUX(ifilt) = 0.0 
        VBAND_PKMJD(ifilt)  = 0.0

        DOPLOT_FILT(IFILT) = .TRUE.  ! default is all 
        IFILT_OBS = IFILTDEF_MAP_SURVEY(ifilt)
        LTMP = ( PKMJD_FIT(ifilt_obs) .GT. 100.0 )
        IF ( OVMODEL_ANYFUN .and. .NOT. LTMP ) then
          DOPLOT_FILT(IFILT) = .FALSE.
        ENDIF

c set default PKMJD
        VBAND_PKMJD(IFILT)     = SNLC_SEARCH_PEAKMJD
        VBAND_PKMJD_ERR(IFILT) = 0.0

      ENDDO

c -------------------------------
      Z    = SNLC_REDSHIFT
      Z1   = 1 + Z
c -----------------------------

      NOBS = 0
      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        MJD   = SNLC8_MJD(EPMIN)
        Tobs  = MJD - SNLC_SEARCH_PEAKMJD
        Trest = Tobs / Z1

        DO 201 EP = EPMIN, EPMAX

          FLUX_DATA     = SNLC_FLUXCAL(ep)
          FLUXERR_DATA  = SNLC_FLUXCAL_ERRTOT(ep)
          if ( FLUXERR_DATA .LE. 0.0 ) GOTO 201

          IFILT_OBS = ISNLC_IFILT_OBS(ep)
          IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 

          IF ( .NOT. DOPLOT_FILT(IFILT) ) GOTO 201

          VBAND_NDOF(ifilt) = VBAND_NDOF(ifilt) + 1.0 ! note this is real*8
          NOBS = NOBS + 1

          IF ( NOBS .GT. MXEP_SNLCPAK ) THEN
            write(C1ERR,661) NOBS, MXEP_SNLCPAK
 661        format('NOBS=',I5,' exceeds bound of MXEP_SNLCMAX=',I5)
            c2err = 'Increase bound for data array.'
            CALL MADABORT('SNLCPLOT(SNANA)', C1ERR, C2ERR)
          ENDIF

          VMJD(NOBS)      = MJD
          VTOBS(NOBS)     = TOBS
          VFLUX(NOBS)     = SNLC_FLUXCAL(ep)
          VFLUX_ERR(NOBS) = SNLC_FLUXCAL_ERRTOT(ep)
          VERRCALC(NOBS)  = SNLC_FLUXCAL_ERRCALC(ep)
          VSIMFLUX(NOBS) = SIM_EPFLUXCAL(ep)   ! Jan 2020

c Sep 7 2022: check options to fold LC within a single cylce.
          if ( MJDPERIOD_PLOT > .01 .and. NOBS > 1 ) then
             DT = MJD - VMJD(1) - MJDSHIFT_PLOT
             VMJD(NOBS)  = MOD(DT,MJDPERIOD_PLOT) + VMJD(1)

             DT = TOBS - VTOBS(1) - MJDSHIFT_PLOT
             VTOBS(NOBS) = MOD(DT,MJDPERIOD_PLOT) + VTOBS(1)
          endif

          VFILTOBS(NOBS)  = IFILT_OBS
          VREJECT(NOBS)   = DBLE( 1 - ISNLC_SNRECON_USE(ep) )
          VDUMERR(NOBS)   = 0.0  ! dummy arguments

c fetch model value and VCHI2 (if we fit the "ANYLC" function)

          if ( OVMODEL_ANYFUN ) then
            do ipar = 1, NPAR_ANYLC
              XVAL8(ipar) = 
     &        SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar)
            enddo

            FLUX_MODEL  = ANYLCFUN(MJD,XVAL8)
            SQDIF       = (FLUX_DATA - FLUX_MODEL)**2
            SQERR       = FLUXERR_DATA**2
            CHI2        = SQDIF/SQERR
            VCHI2(NOBS) = CHI2
            VBAND_CHI2(IFILT) = VBAND_CHI2(IFILT) + CHI2

c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
            if ( ifilt_obs == 4 .and. MJD < 56600. ) then
               write(6,621) MJD, TOBS, FLUX_DATA, 
     &             FLUX_MODEL, FLUXERR_DATA
 621           format(' xxx MJD=',F9.3, '  TOBS=',F6.1, 
     &             '  FLUX(D,M)=',2G10.3, '  FLUX_ERR=', G8.3 )
            endif
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


          endif  ! end of OVMODEL

201     CONTINUE  ! EP
200   CONTINUE   ! NEWMJD

c ------------------------------------------
c store data fluxes
      CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VFLUX, VFLUX_ERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_FLUXDATA, LENCCID)

c store REJECT flags
      CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VREJECT, VDUMERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_REJECT, LENCCID)

c store data-FITFUN chi2 
      IF ( OVMODEL_ANYFUN ) THEN
        CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VCHI2, VDUMERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_CHI2, LENCCID)
      ENDIF

c check for sim fluxes (Jan 2020)
      IF ( ISJOB_SIM ) THEN
        CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, 
     &     VSIMFLUX, VFLUX_ERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_FLUXSIM, LENCCID)
      ENDIF

c ------------------------------------------
      IF ( .NOT. OVMODEL_ANYFUN ) GOTO 500
c ------------------------------------------

c plot smooth best-fit ANYFUN function in 2-day bins.

      TMIN = -40.0
      TMAX = 140.0
      NBT  = int( (TMAX-TMIN) / DTOBS_MODEL_PLOT )
      DT   = (TMAX - TMIN) / float(NBT)
      NOBS = 0

      DO 300 ifilt = 1, NFILT
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
 
         VBAND_PKFLUX(ifilt)     = DBLE( PKFLUX_FIT(ifilt_obs) )
         VBAND_PKFLUX_ERR(ifilt) = DBLE( PKFLUX_ERR(ifilt_obs) )

         IF ( .not. EXIST_FILT(ifilt) ) GOTO 300 
         
         DO 320 i = 1, NBT
            Tobs  = TMIN + dT * ( float(i) - 0.5 )
            MJD   = Tobs + SNLC_SEARCH_PEAKMJD
            do ipar = 1, NPAR_ANYLC
               XVAL8(ipar) = SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar)
            enddo
            
            NOBS = NOBS + 1
            
            IF ( NOBS .GT. MXEP_SNLCPAK ) THEN
               write(C1ERR,661) NOBS, MXEP_SNLCPAK
               c2err = 'Increase bound for best-fit (ANYFUN) array.'
               CALL MADABORT('SNLCPLOT(SNANA)', C1ERR, C2ERR)
            ENDIF

            FLUX_MODEL       = ANYLCFUN(MJD,XVAL8)          
            
c avoid plotting artifacts with very small numbers (Oct 29 2014)
            IF( FLUX_MODEL < 1.0E-20 ) FLUX_MODEL = 0.0

            VMJD(NOBS)       = MJD
            VTOBS(NOBS)      = TOBS
            VFLUX(NOBS)      = FLUX_MODEL
            VFLUX_ERR(NOBS)  = 0.0
            VFILTOBS(NOBS)   = IFILT_OBS
            
320     CONTINUE  ! epoch-bin

300   CONTINUE  ! ifilt


c -------------------------------------------------

c store best-fit ANYLCFUN

      CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VFLUX, VFLUX_ERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_FITFUN, LENCCID)

c store filter-dependent quantities.
      VMJD(1)  = -9999.0 
      VTOBS(1) = -9999.0  ! dummy for unused TOBS arg

      CALL SNLCPAK_DATA(CCID, NFILT, VMJD, VTOBS, VBAND_NDOF, VDUMERR, 
     &     IFILTDEF_MAP_SURVEY, SNLCPAK_BANDFLAG_NDOF, LENCCID)

      CALL SNLCPAK_DATA(CCID, NFILT, VMJD,VTOBS, VBAND_CHI2, VDUMERR, 
     &     IFILTDEF_MAP_SURVEY, SNLCPAK_BANDFLAG_CHI2, LENCCID)

      CALL SNLCPAK_DATA(CCID, NFILT, VTOBS, VMJD,
     &   VBAND_PKFLUX, VBAND_PKFLUX_ERR, 
     &   IFILTDEF_MAP_SURVEY, SNLCPAK_BANDFLAG_PKFLUX, LENCCID)

c --------------------------------------------------
c fill output structure with above; here iy goes to a disk file.

 500  CONTINUE

      CALL SNLCPAK_DATA(CCID, NFILT, VMJD, VTOBS,
     &    VBAND_PKMJD,VBAND_PKMJD_ERR, 
     &    IFILTDEF_MAP_SURVEY, SNLCPAK_BANDFLAG_PKMJD, LENCCID)            

      CALL SNLCPAK_FILL(CCID, LENCCID)

c back to topdir
      CALL CDTOPDIR_OUTPUT(STDOUT_UPDATE)

c set global flag.
      MADE_LCPLOT = .TRUE.

      RETURN
      END            ! end of SNLCPLOT
+SELF.


C ==============================================
+DECK,SPECPLOT.
      SUBROUTINE SPECPLOT()

c Apr 2019
c Prepare spectra table for plotting (analog of SNLCPLOT)
c Works only for TEXT output; not for ROOT
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SPECCOM.

      INTEGER LENCCID, LENTEXT, ispec
      CHARACTER  CCID_forC*(MXCHAR_CCID)
      LOGICAL DOPLOT_SPEC

      EXTERNAL SPECPAK_DATA
C ----------------- BEGIN ---------------

c check if we should make the plot
      IF ( .NOT. DOPLOT_SPEC() ) RETURN

      IF ( MARZFILE_OUT .NE. '' ) RETURN

      LENCCID = ISNLC_LENCCID
      CCID_forC = SNLC_CCID(1:LENCCID) // char(0)

      write(6,10) SNLC_CCID(1:LENCCID)
 10   format(T8,'SPECPLOT: pack CID=',A,' for plotting.')
      call flush(6)

c load each spectrum into SPECPAK C-function util

      DO 100 ispec = 1, NSPECTRUM
         CALL RDSPEC_DRIVER(ispec)  ! Apr 5 2021

         CALL SPECPAK_DATA(
     &         CCID_forC
     &       , ID_SPECTRUM(ispec)
     &       , MJD_SPECTRUM(ispec)
     &       , TOBS_SPECTRUM(ispec)    ! May 7 2019
     &       , TEXPOSE_SPECTRUM(ispec)
     &       , NLAMBIN_SPECTRUM(ispec)
     &       , LAMMIN_SPECTRUM ! array of LAMMIN in each bin
     &       , LAMMAX_SPECTRUM ! array of LAMMAX in each bin
     &       , FLAM_SPECTRUM
     &       , FLAMERR_SPECTRUM
     &       , LENCCID )
 100     CONTINUE

c write out spectrum to TEXT table (ROOT not enabled)
      IF ( NSPECTRUM > 0 ) then
         CALL SPECPAK_FILL(CCID_forC, LENCCID)
      ENDIF

      RETURN
      END  ! SPECPLOT


C ==============================================
+DECK,CHECK_DUPLMJD.
      SUBROUTINE CHECK_DUPLICATE_MJDBAND(iep)

c Created Jun 13, 2017
c print & count error if current MJD & BAND is the same
c as previous epoch.

      IMPLICIT NONE

      INTEGER IEP ! (I) epoch index

c local var
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      REAL*8 MJD, MJD_LAST
      INTEGER IFILTOBS, IFILTOBS_LAST, i
      CHARACTER CFILT*2, cLIBID*40

c ---------------- BEGIN --------------

cc      IF ( .NOT. ABORT_ON_DUPLMJD  ) RETURN
      IF ( IEP <= 1 ) RETURN

      MJD      = SNLC8_MJD(IEP)
      MJD_LAST = SNLC8_MJD(IEP-1)
      IFILTOBS = ISNLC_IFILT_OBS(IEP)
      IFILTOBS_LAST = ISNLC_IFILT_OBS(IEP-1) 
 
      IF ( MJD      .NE. MJD_LAST      ) RETURN
      IF ( IFILTOBS .NE. IFILTOBS_LAST ) RETURN

      N_DUPLICATE_MJD = N_DUPLICATE_MJD + 1

c check if this MJD was already flagged as duplicate
      DO i = 1, min(200,NSTORE_DUPLICATE_MJD)
        IF ( MJD .EQ. DUPLICATE_MJDLIST(i) ) RETURN
      ENDDO

      NSTORE_DUPLICATE_MJD = NSTORE_DUPLICATE_MJD + 1

      if ( NSTORE_DUPLICATE_MJD < 200 ) then
         DUPLICATE_MJDLIST(NSTORE_DUPLICATE_MJD) = MJD
         CFILT = filtdef_string(ifiltobs:ifiltobs)
	 CLIBID = ''
	 IF ( LSIM_SNANA ) THEN
            write(CLIBID,600) SIM_LIBID
600	    format('LIBID=',I9)
         ENDIF
         write(6,666) SNLC_CCID(1:ISNLC_LENCCID), MJD, CFILT,
     &        SNLC_FIELDLIST, cLIBID
666      format(/,T3,'*** DUPLICATE MJD WARNING *** CID=',A, 3x,
     &        'MJD=', F10.4, 3x, 'BAND=', A, 2x,'FIELD=',A6,2x, A20 /)
         CALL FLUSH(6)
      endif  

      RETURN
      END     


C =======================
+PATCH,*SNTABLE.
C =======================

C call utilities to call table-interface C-functions

C ===========================================
+DECK,TABLE_OUTLIER.
      SUBROUTINE TABLE_OUTLIER(IDTABLE,IFLAG)
C
C Created Mar 17 2021
C Create and fill table for OUTLIER fluxes w.r.t, SIM truth or LC model fit.
C Goal is to replace outlier option in sntable_dump so that making 
C OUTLIER table is a 1-step process (snana.exe) instead of 2 steps
C (snana.exe + sntable_dump.py)
C
c Aug 11 2021: check SBMAG cut

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,OUTLIERCOM.

      INTEGER IDTABLE  ! (I) table ID
      INTEGER IFLAG    ! (I) see IFLAG_XXX params

c local var

      INTEGER   LENNAME, LENFMT, NEWMJD, EPMIN, EPMAX, EP, BIT
      INTEGER   IFILTOBS, IFILT
      LOGICAL   DOFILL_TABLE, LCUT_NSIG, LCUT_FTRUE, LCUT_SBMAG
      REAL      NSIG, FTRUE, SBMAG, FLUXCAL_FIT, FLUXCAL_ERR_FIT
      CHARACTER NAME_forC*40, TEXTFMT*20, TEXTFMT_forC*20, FNAM*14

      REAL  NSIG_OUTLIER_FIT  ! function 
      EXTERNAL  SNTABLE_CREATE, SNTABLE_FILL
C ---------------- BEGIN -----------------    
 
      FNAM = 'TABLE_OUTLIER'

c for snana job, must be sim from either SNANA or FAKE
      IF ( ISJOB_SNANA .and. (.NOT. ISJOB_SIM)  ) THEN
         c1err = 'Cannot make OUTLIER table for ' // 
     &           'real data using snana.exe.'
         c2err = 'Process SIM or FAKES; or run LC fit on real data'
         CALL MADABORT(FNAM, c1err, c2err)
      ENDIF

c FIT outliers work on real data or sim, so error check not needed.

       
      IF ( IFLAG .EQ. IFLAG_INI ) THEN

         OUTLIER_TABLE_NAME  = 'OUTLIER' 
         LENNAME   = INDEX(OUTLIER_TABLE_NAME, ' ') - 1
         NAME_forC = OUTLIER_TABLE_NAME(1:LENNAME) // char(0)

         TEXTFMT  = TEXTFORMAT_TABLE(ITABLE_OUTLIER)
         LENFMT   = INDEX(TEXTFMT, ' ') - 1
         TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)

         CALL SNTABLE_CREATE(IDTABLE, NAME_forC, TEXTFMT_forC, 
     &          LENNAME,LENFMT)  ! C fun

         CALL INIT_TABLE_OUTLIERVAR(IDTABLE, 'OUTLIER')

         CALL COUNT_OUTLIERS(0,0)

         RETURN
      ENDIF


c --------------------------
c fill table.

      if ( ISJOB_SNANA ) then
         DOFILL_TABLE = BTEST(CUTFLAG_SNANA,0)
      else
         DOFILL_TABLE = BTEST(CUTFLAG_SNANA,1)
      endif

      NEP_OUTLIER_PEREVT = 0 
      IF ( .NOT. DOFILL_TABLE ) RETURN

c   terminate strings for C table-functions (snana.car routine)
      CALL TABLE_STRING_TERMINATION(+1)

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 201 EP = EPMIN, EPMAX
           IFILTOBS   = ISNLC_IFILT_OBS(ep)
           IFILT      = IFILTDEF_INVMAP_SURVEY(IFILTOBS)
           if ( ISNLC_SNRECON_USE(ep) == 0 ) goto 201

           if ( ISJOB_SNANA ) then
              NSIG   = abs(SIM_EPPULL(ep))
              FTRUE  = SIM_EPFLUXCAL(ep)
              SBMAG  = SNHOST_SBMAG(ifilt) 
           else
+SELF,IF=SNFIT.
              NSIG   = NSIG_OUTLIER_FIT(ep)
              FTRUE  = 1000.0  ! something guaranteed to pass cut
              SBMAG  = 20.0    ! idem
+SELF.
           endif

           if ( NSIG  < -0.01            ) goto 201
           if ( FTRUE < FTRUECUT_OUTLIER ) goto 201   ! Mar 24 2021

           LCUT_NSIG  = ( NSIG  >= NSIGCUT_OUTLIER  ) 
           LCUT_FTRUE = ( FTRUE >= FTRUECUT_OUTLIER )
           LCUT_SBMAG = ( SBMAG <= SBMAGCUT_OUTLIER ) ! Aug 2021
 
           CALL COUNT_OUTLIERS(1,ep)

           if ( LCUT_NSIG .and. LCUT_FTRUE .and. LCUT_SBMAG ) then
              NEP_OUTLIER_TOT    = NEP_OUTLIER_TOT    + 1
              NEP_OUTLIER_PEREVT = NEP_OUTLIER_PEREVT + 1
              CALL LOAD_OUTLIER_VAR(ep)
              CALL SNTABLE_FILL(IDTABLE) ! generic C function
              CALL COUNT_OUTLIERS(2,ep)
           endif
 201    CONTINUE
 200  CONTINUE

      CALL TABLE_STRING_TERMINATION(-1) ! remove termination

      RETURN
      END    ! end TABLE_OUTLIER


C ======================================
+DECK,COUNT_OULIERS.
      SUBROUTINE COUNT_OUTLIERS(OPT,EP)

      IMPLICIT NONE
      INTEGER OPT  ! 0=init, 1=count all, 2=count outliers, 3=print summary
      INTEGER EP   ! epoch index

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.
+CDE,OUTLIERCOM.

      INTEGER IFILTOBS, BIT, PHOTFLAG
      REAL    XNALL(2), XNOUTLIER(2), XNBULK(2)
      REAL    EFF_OUTLIER, EFF_ERR, EFF_BULK, FOM, XX, XXX
      LOGICAL ISBITSET

c ------------ BEGIN -----------

      if ( NSIGCUT_OUTLIER < 1.0 ) RETURN

      IF ( EP > 0 )  THEN
         IFILTOBS   = ISNLC_IFILT_OBS(ep)
         PHOTFLAG   = ISNLC_PHOTFLAG(ep)
      ENDIF
      
      IF ( OPT == 0 ) THEN
         ! one-time init
         NEP_OUTLIER_TOT = 0
         DO ifiltobs = 1, MXFILT_ALL
            NEP_OUTLIER_CHECK(ifiltobs) = 0  ! total epochs checked per band
            NEP_OUTLIER_FOUND(ifiltobs) = 0  ! Noutlier per band
         ENDDO

         DO BIT = 1, MXBIT_PHOTFLAG
            NEP_OUTLIER_VS_PHOTBIT(1,BIT) = 0
            NEP_OUTLIER_VS_PHOTBIT(2,BIT) = 0
            NEP_ALL_VS_PHOTBIT(1,BIT) = 0
            NEP_ALL_VS_PHOTBIT(2,BIT) = 0
         ENDDO

      ELSE IF ( OPT == 1 ) THEN
         ! passes cuts, but before checking if it's an outlier
         NEP_OUTLIER_CHECK(ifiltobs) = NEP_OUTLIER_CHECK(ifiltobs) + 1

         do bit = 1, MXBIT_PHOTFLAG
            ISBITSET = BTEST(PHOTFLAG,bit-1)
            NEP_ALL_VS_PHOTBIT(1,BIT) = NEP_ALL_VS_PHOTBIT(1,BIT) + 1
            if ( ISBITSET ) then
               NEP_ALL_VS_PHOTBIT(2,BIT) = NEP_ALL_VS_PHOTBIT(2,BIT) + 1
            endif
         ENDDO

      ELSE IF ( OPT == 2 ) THEN
         ! it's an OUTLIER
         NEP_OUTLIER_FOUND(ifiltobs) = NEP_OUTLIER_FOUND(ifiltobs) + 1

         do bit = 1, MXBIT_PHOTFLAG
            ISBITSET = BTEST(PHOTFLAG,bit-1)
            NEP_OUTLIER_VS_PHOTBIT(1,BIT) = 
     &      NEP_OUTLIER_VS_PHOTBIT(1,BIT) + 1
            if ( ISBITSET ) then
               NEP_OUTLIER_VS_PHOTBIT(2,BIT) = 
     &         NEP_OUTLIER_VS_PHOTBIT(2,BIT) + 1
            endif
         enddo

      ELSE IF ( OPT == 3 ) THEN
         ! print summary
         print*,' '
         write(6,10) NSIGCUT_OUTLIER

 10      format('  PHOTFLAG BIT PERFORMANCE for REJECTING ',
     &             F5.1, ' sigma OUTLIERS:', / )

         print*,'  BIT   EFF(OUTLIER)   1-EFF(BULK)   FoM'
         print*,'  ----------------------------------------- '
         do bit = 1, MXBIT_PHOTFLAG
            XNALL(1)     = float(NEP_ALL_VS_PHOTBIT(1,BIT))
            XNALL(2)     = float(NEP_ALL_VS_PHOTBIT(2,BIT))
            XNOUTLIER(1) = float(NEP_OUTLIER_VS_PHOTBIT(1,BIT))
            XNOUTLIER(2) = float(NEP_OUTLIER_VS_PHOTBIT(2,BIT))
            XNBULK(1)    = XNALL(1) - XNOUTLIER(1) ! not outliers
            XNBULK(2)    = XNALL(2) - XNOUTLIER(2) ! not outliers
            if ( XNALL(2) > 0.0 .and. XNOUTLIER(1) > 0.0 ) then
               EFF_OUTLIER = XNOUTLIER(2) / XNOUTLIER(1)
               XX      = XNOUTLIER(2) * (XNOUTLIER(1) - XNOUTLIER(2))
               XXX     = XNOUTLIER(1) * XNOUTLIER(1) * XNOUTLIER(1)
               EFF_ERR     = sqrt(XX/XXX)
               EFF_BULK    = 1.0 - XNBULK(2) / XNBULK(1)
               FOM         = EFF_OUTLIER * EFF_BULK
               write(6,30) bit-1, EFF_OUTLIER, EFF_ERR, EFF_BULK, FoM
 30            format(T5,I2, 2x, F6.3,' +_', F6.3, 3x, F6.3, 3x, F6.3 ) 
            endif
         enddo
         call flush(6)
      ENDIF

      RETURN
      END  ! end COUNT_OUTLIERS

C =============================
+DECK,INITBOUTVAR.
      SUBROUTINE INIT_TABLE_OUTLIERVAR(ID, BLOCK)

      IMPLICIT NONE
      INTEGER   ID          ! (I) table ID
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT.
c +CDE,FILTCOM.
+CDE,OUTLIERCOM.

      INTEGER 
     &   IFILT, IFILT_OBS, ITEXT
     &  ,LENBLOCK, LENLIST, LENNAME, LENV, ipar, ivar

      LOGICAL LTMP, ADDCOL_SETPKMJD
      CHARACTER varlist*100, CTMP*60, CBLOCK*40
      CHARACTER FNAM*22, CFILT*2
      EXTERNAL  
     &    SNTABLE_ADDCOL
     &   ,SNTABLE_ADDCOL_int
     &   ,SNTABLE_ADDCOL_flt
     &   ,SNTABLE_ADDCOL_dbl
     &   ,SNTABLE_ADDCOL_str

c ------------ BEGIN ----------

      FNAM = 'INIT_TABLE_OUTLIERVAR'

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5 )
      call flush(6)

      LENBLOCK     = INDEX(BLOCK//' ',' ') - 1
      CBLOCK       = BLOCK(1:LENBLOCK) // char(0)
      LENLIST      = LEN(VARLIST)

c  for CCID, use special variable SNLC_CCID_forC that has char(0)
c  termination so that parsing CCID with C code is easier.

      VARLIST = 'CCID:C*20' // char(0)
      CALL SNTABLE_ADDCOL_str(ID, CBLOCK, SNLC_CCID, VARLIST,1,
     &                   LENBLOCK, 20 )

c ROWNUM is easy identifier for CID-MJD-BAND-CCDNUM;
c e.g., pass ROWNUM to script that fetches stamps.
      VARLIST = 'ROWNUM:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, NEP_OUTLIER_TOT, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'FIELD:C*12' // char(0)
      CALL SNTABLE_ADDCOL_str(ID, CBLOCK, OUTLIER_FIELD, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'MJD:D' // char(0)
      CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, OUTLIER_MJD, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'BAND:C*4' // char(0)
      CALL SNTABLE_ADDCOL_str(ID, CBLOCK, OUTLIER_BAND, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'IFILTOBS:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, OUTLIER_IFILTOBS, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'CCDNUM:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, OUTLIER_CCDNUM, VARLIST,1,
     &                   LENBLOCK, 20 )

c---
      VARLIST = 'IXPIX:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, OUTLIER_IXPIX, VARLIST,1,
     &                   LENBLOCK, 20 )
      VARLIST = 'IYPIX:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, OUTLIER_IYPIX, VARLIST,1,
     &                   LENBLOCK, 20 )
      VARLIST = 'AREAFRAC:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_AREAFRAC, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'PHOTFLAG:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, OUTLIER_PHOTFLAG, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'FLUXCAL_DATA:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_FLUXCAL_DATA, 
     &           VARLIST, 1, LENBLOCK, 20 )

      VARLIST = 'FLUXCAL_ERR_DATA:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_FLUXCAL_ERR_DATA, 
     &        VARLIST, 1, LENBLOCK, 20 )

      VARLIST = 'FLUXCAL_ERR_CALC:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK,OUTLIER_FLUXCAL_ERR_CALC,
     &            VARLIST, 1, LENBLOCK, 20 )

      if ( ISJOB_SNANA ) then
         ! outlier w.r.t. true sim/fake flux (SIM_MAGOBS column in data file)
         VARLIST = 'FLUXCAL_TRUE:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_FLUXCAL_TRUE, 
     &        VARLIST, 1, LENBLOCK, 20 )
      else
         ! outlier w.r.t. LC fit
         VARLIST = 'FLUXCAL_FIT:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_FLUXCAL_FIT, 
     &        VARLIST, 1, LENBLOCK, 20 )

         VARLIST = 'FLUXCAL_ERR_FIT:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_FLUXCAL_ERR_FIT, 
     &         VARLIST, 1, LENBLOCK, 20 )

         VARLIST = 'FLUXCAL_ERRTOT_FIT:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_FLUXCAL_ERRTOT_FIT, 
     &         VARLIST, 1, LENBLOCK, 20 )
      endif

      VARLIST = 'NSIG:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_NSIG, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'LOGSNR:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_LOGSNR, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'SBMAG:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_SBMAG, VARLIST,1,
     &                   LENBLOCK, 20 )

c - - - -
      VARLIST = 'ZP:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_ZP, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'PSF:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_PSF, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'SKYSIG:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_SKYSIG, VARLIST,1,
     &                   LENBLOCK, 20 )

+SELF,IF=SNFIT.
      VARLIST = 'z:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_z, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'TREST:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, OUTLIER_TREST, VARLIST,1,
     &                   LENBLOCK, 20 )

+SELF.
      RETURN
      END   ! end INIT_TABLE_OUTLIERVAR

+SELF,IF=DELETE.
c =======================================
+DECK,SNTABLE_ADDCOL_C.
      SUBROUTINE SNTABLE_ADDCOL_C(ID,CBLOCK,CPTR,VARLIST,USE4TEXT)
C Jun 6 2022: wrapper to call SNTABLE_ADDCOL for string arg;
c    to avoid gcc 10 compiler warnings.
      IMPLICIT NONE
c input args
      INTEGER ID, USE4TEXT
      CHARACTER CBLOCK*(*), CPTR*(*), VARLIST*(*)
c local args
      INTEGER LENBLOCK, LENVAR
      EXTERNAL SNTABLE_ADDCOL
c --------- BEGIN --------
      LENBLOCK = INDEX(CBLOCK//' ', ' '  )
      LENVAR   = INDEX(VARLIST//' ', ' ' )
      CALL SNTABLE_ADDCOL(ID, CBLOCK, CPTR, VARLIST, USE4TEXT,
     &                   LENBLOCK, LENVAR )
      RETURN
      END

c =======================================
+DECK,SNTABLE_ADDCOL_I.
      SUBROUTINE SNTABLE_ADDCOL_I(ID,CBLOCK,IPTR,VARLIST,USE4TEXT)
C Jun 6 2022: wrapper to call SNTABLE_ADDCOL for INTEGER arg;
c    to avoid gcc 10 compiler warnings.
      IMPLICIT NONE
c input args
      INTEGER ID, USE4TEXT, IPTR
      CHARACTER CBLOCK*(*), VARLIST*(*)
c local args
      INTEGER LENBLOCK, LENVAR
      EXTERNAL SNTABLE_ADDCOL
c --------- BEGIN --------
      LENBLOCK = INDEX(CBLOCK//' ', ' '  )
      LENVAR   = INDEX(VARLIST//' ', ' ' )
      CALL SNTABLE_ADDCOL(ID, CBLOCK, IPTR, VARLIST, USE4TEXT,
     &                   LENBLOCK, LENVAR )
      RETURN
      END

c =======================================
+DECK,SNTABLE_ADDCOL_F.
      SUBROUTINE SNTABLE_ADDCOL_F(ID,CBLOCK,FPTR,VARLIST,USE4TEXT)
C Jun 6 2022: wrapper to call SNTABLE_ADDCOL for REAL*4 arg;
c    to avoid gcc 10 compiler warnings.
      IMPLICIT NONE
c input args
      INTEGER ID, USE4TEXT
      REAL*4  FPTR
      CHARACTER CBLOCK*(*), VARLIST*(*)
c local args
      INTEGER LENBLOCK, LENVAR
      EXTERNAL SNTABLE_ADDCOL
c --------- BEGIN --------
      LENBLOCK = INDEX(CBLOCK//' ', ' '  )
      LENVAR   = INDEX(VARLIST//' ', ' ' )
      CALL SNTABLE_ADDCOL(ID, CBLOCK, FPTR, VARLIST, USE4TEXT,
     &                   LENBLOCK, LENVAR )
      RETURN
      END

c =======================================
+DECK,SNTABLE_ADDCOL_D.
      SUBROUTINE SNTABLE_ADDCOL_D(ID,CBLOCK,DPTR,VARLIST,USE4TEXT)
C Jun 6 2022: wrapper to call SNTABLE_ADDCOL for REAL*8 arg;
c    to avoid gcc 10 compiler warnings.
      IMPLICIT NONE
c input args
      INTEGER ID, USE4TEXT
      REAL*8  DPTR
      CHARACTER CBLOCK*(*), VARLIST*(*)
c local args
      INTEGER LENBLOCK, LENVAR
      EXTERNAL SNTABLE_ADDCOL
c --------- BEGIN --------
      LENBLOCK = INDEX(CBLOCK//' ', ' '  )
      LENVAR   = INDEX(VARLIST//' ', ' ' )
      CALL SNTABLE_ADDCOL(ID, CBLOCK, DPTR, VARLIST, USE4TEXT,
     &                   LENBLOCK, LENVAR )
      RETURN
      END
+SELF.

C =============================
+DECK,LOAD_OUTLIER_VAR.
      SUBROUTINE LOAD_OUTLIER_VAR(ep)

c Created Mar 17 2021
c Load OUTLIER_XXX variables for epoch 'ep'.
c
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.
+CDE,OUTLIERCOM.

      INTEGER  ep  ! (I) epoch index to load

      INTEGER IFILT_OBS, IFILT
      CHARACTER BAND*4
      REAL SNR

c ---------- BEGIN ---------

      IFILT_OBS   = ISNLC_IFILT_OBS(ep)
      IFILT       = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
      BAND        = filtdef_string(ifilt_obs:ifilt_obs)

      OUTLIER_MJD          = SNLC8_MJD(ep)
      OUTLIER_IFILTOBS     = IFILT_OBS
      OUTLIER_BAND         = BAND
      OUTLIER_FIELD        = SNLC_FIELD(ep)
      OUTLIER_CCDNUM       = ISNLC_CCDNUM(ep)
      OUTLIER_PHOTFLAG     = ISNLC_PHOTFLAG(ep)
      OUTLIER_FLUXCAL_DATA      = SNLC_FLUXCAL(ep)
      OUTLIER_FLUXCAL_ERR_DATA  = SNLC_FLUXCAL_ERRTOT(ep)
      OUTLIER_FLUXCAL_ERR_CALC  = SNLC_FLUXCAL_ERRCALC(ep)
      OUTLIER_NSIG         = abs(SIM_EPPULL(ep))
      OUTLIER_ZP           = SNLC_ZEROPT(ep)
      OUTLIER_PSF          = SNLC_PSF_SIG1(ep)
      OUTLIER_SKYSIG       = SNLC_SKYSIG(ep)

      SNR  = OUTLIER_FLUXCAL_DATA/OUTLIER_FLUXCAL_ERR_DATA
      OUTLIER_LOGSNR       = LOG10(max(0.1,SNR))

      OUTLIER_SBMAG        = SNHOST_SBMAG(ifilt)

      OUTLIER_IXPIX     = INT(SNLC_XPIX(ep))
      OUTLIER_IYPIX     = INT(SNLC_YPIX(ep))
      OUTLIER_AREAFRAC  = SNLC_AREAFRAC(ep)

      OUTLIER_z         = SNLC_REDSHIFT
      OUTLIER_TREST     = SNLC_TREST(ep)

      IF ( ISJOB_SNANA ) THEN
         ! true flux from SIM_MAGOBS 
         OUTLIER_FLUXCAL_TRUE      = SIM_EPFLUXCAL(ep)
      ELSE
         ! get model fit flux
         OUTLIER_FLUXCAL_FIT        = SNLC_FLUXCAL_FIT(ep)
         OUTLIER_FLUXCAL_ERR_FIT    = SNLC_FLUXCAL_ERR_FIT(ep)
         OUTLIER_FLUXCAL_ERRTOT_FIT = SNLC_FLUXCAL_ERRTOT_FIT(ep)
      ENDIF

      IF ( USE_TABLEFILE_ROOT ) THEN
         OUTLIER_BAND = OUTLIER_BAND(1:1) // char(0)
      ENDIF

      RETURN
      END   ! end LOAD_OUTLIER_VAR(ep)

      
C ===========================================
+DECK,NSIG_OUTLIER_FIT,IF=SNFIT.
      REAL FUNCTION NSIG_OUTLIER_FIT(ep)

c Created Mar 17 2021
c Function returns Nsig = | FLUXCAL_DATA / ERRTOT |
c where ERRTOT^2 = FLUXCAL_ERR_DATA^2 + FLUXCAL_ERR_FIT^2 
c Initial use is for OUTLIER table.
c
      IMPLICIT NONE
      INTEGER  ep  ! (I) epoch index

+CDE,SNDATCOM.
+CDE,SNANAFIT.
c +CDE,FILTCOM.
+CDE,OUTLIERCOM.

      REAL  FLUXCAL_FIT, FLUXCAL_ERR_FIT
      REAL  FLUXCAL_DATA, FLUXCAL_ERR_DATA, SQERR, ERRTOT, NSIG
      LOGICAL REJECT
C --------- BEGIN ---------

      NSIG = 0.0

      CALL GET_FITFLUX(ep, FLUXCAL_FIT, FLUXCAL_ERR_FIT,REJECT)

      FLUXCAL_DATA     = SNLC_FLUXCAL(ep)
      FLUXCAL_ERR_DATA = SNLC_FLUXCAL_ERRTOT(ep)

      IF ( FLUXCAL_ERR_FIT > 0.00001 ) THEN
         SQERR = (FLUXCAL_ERR_FIT  * FLUXCAL_ERR_FIT) + 
     &           (FLUXCAL_ERR_DATA * FLUXCAL_ERR_DATA)

         ERRTOT = SQRT(SQERR)
         NSIG   = abs(FLUXCAL_DATA-FLUXCAL_FIT) / ERRTOT
      ELSE
         ERRTOT = FLUXCAL_ERR_DATA
         NSIG   = -9.0  ! epoch not used
      ENDIF

c      print*,' xxx ep, DIF/ERR = ', 
c     &    ep, (FLUXCAL_DATA-FLUXCAL_FIT), '/', ERRTOT, NSIG

c load fit flux info to global so that it can be used elsewhere     
      SNLC_FLUXCAL_FIT(ep)        = FLUXCAL_FIT
      SNLC_FLUXCAL_ERR_FIT(ep)    = FLUXCAL_ERR_FIT
      SNLC_FLUXCAL_ERRTOT_FIT(ep) = ERRTOT

c set function value
      NSIG_OUTLIER_FIT = NSIG

      RETURN
      END     ! end NSIG_OUTLIER_FIT(ep)
     
C ==================================
+DECK,PR_OUTLIER_SUMMARY.
      SUBROUTINE PRINT_OUTLIER_SUMMARY()

c Created Mar 17 2021
c print OUTLIER fraction per band to stdout.
c If TEXTFILE_PREFIX is set, prepend top of file with summary
c using clumsy method of writing a separate header file and
c then using system cat command.

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

+CDE,FILTCOM.
+CDE,OUTLIERCOM.

c +CDE,SNPAR.
c +CDE,CTRLCOM.
c +CDE,SNLCINP.

      INTEGER IFILT, IFILTOBS, N0, N1, LEN_WHAT
      INTEGER LEN1, LEN2, LEN3, LEN_HEAD
      REAL FRAC
      CHARACTER cfilt*2, TEXT_WHAT*40, CMD_CAT*200, CMD_MOVE*200
      CHARACTER TEXTFILE*200, TMP_HEADER_FILE*200, LINE*60, LINE2*60
      LOGICAL   PREPEND_TEXTFILE

C ---------- BEGIN -----------

      call count_outliers(3,0)

      PREPEND_TEXTFILE = ( TEXTFILE_PREFIX .NE. ' ' )
      IF ( PREPEND_TEXTFILE ) THEN
c construct name of TEXT file to prepend outlier summary.
c Beware that TEXTFILE is fragile.
         LEN1 = INDEX(TEXTFILE_PREFIX,   ' ' ) - 1
         LEN2 = INDEX(OUTLIER_TABLE_NAME,' ' ) - 1
         TEXTFILE = TEXTFILE_PREFIX(1:LEN1) // '.' // 
     &       OUTLIER_TABLE_NAME(1:LEN2) // '.TEXT'
         LEN3 = INDEX(TEXTFILE,' ') - 1
         TMP_HEADER_FILE = 
     &       'TMP_HEAD_' // TEXTFILE_PREFIX(1:LEN1) // '.TEXT'
         LEN_HEAD = INDEX(TMP_HEADER_FILE,' ') - 1
         OPEN(UNIT=LUNTMP, FILE=TMP_HEADER_FILE, STATUS='UNKNOWN')
      ENDIF

c - - - - - - - 

      IF ( ISJOB_SNANA ) THEN
         TEXT_WHAT  = '|F_data-F_true(SIM)|/Sigma_F'
      ELSE
         TEXT_WHAT  = '|F_data-F_fit|/Sigma_F'
      ENDIF
      LEN_WHAT = INDEX(TEXT_WHAT,' ') - 1

      LINE = '    FLUX-OUTLIER SUMMARY per BAND for '
      write(LINE2,10) TEXT_WHAT(1:LEN_WHAT), NSIGCUT_OUTLIER
 10   format(T5, A, ' > ', F5.2, ' : ' )

      print*, ' '
      print*, LINE
      print*, LINE2
      call flush(6)

      if (PREPEND_TEXTFILE) then
         WRITE(LUNTMP,70) '=========================================='
         WRITE(LUNTMP,70) LINE
         WRITE(LUNTMP,70) LINE2
      endif

 70   format('# ', A)
c - - - - - - 

      DO ifilt  = 1, NFILTDEF_SURVEY
         ifiltobs  = IFILTDEF_MAP_SURVEY(ifilt)
         cfilt     = filtdef_string(ifiltobs:ifiltobs)

         N0 = NEP_OUTLIER_CHECK(ifiltobs)
         N1 = NEP_OUTLIER_FOUND(ifiltobs)
         if ( N0 > 0 ) then
            FRAC = FLOAT(N1) / FLOAT(N0)
         else
            FRAC = 0.0
         endif

         write(LINE,20) cfilt, FRAC, N1, N0
 20      format(T8,A1, '-Outlier frac = ', F8.5, 3x,
     &      '(', I6, '/', I6, ')'  )

         print*, LINE
         if (PREPEND_TEXTFILE) WRITE(LUNTMP,70) LINE

      ENDDO

      if(PREPEND_TEXTFILE) then
         WRITE(LUNTMP,70) ' '
         CLOSE(UNIT = LUNTMP)
c finally, use cat to glue header comments and table.
         CMD_CAT = 'cat ' // TEXTFILE(1:LEN3) //
     &         ' >> ' // TMP_HEADER_FILE 
         CMD_MOVE = 'mv ' // TMP_HEADER_FILE(1:LEN_HEAD) //  ' ' //
     &           TEXTFILE(1:LEN3)
         CALL SYSTEM(CMD_CAT // ' ; ' // CMD_MOVE)
      endif

      CALL FLUSH(6)

      RETURN
      END   ! end PRINT_OUTLIER_SUMMARY

C ===========================================
+DECK,TABLE_SNANA.
      SUBROUTINE TABLE_SNANA(IDTABLE,IFLAG)
c
c Apr 26 2017: check PRESCALE_TABLE
c
c ------------------------------
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,CTRLCOM.
+CDE,SNLCINP.

      INTEGER IDTABLE  ! (I) table ID
      INTEGER IFLAG    ! (I) see IFLAG_XXX params

c local var

      LOGICAL   DO_FILL, LPS
      REAL*8    PS
      INTEGER   LENNAME, LENFMT
      CHARACTER NAME*40, TEXTFMT*20, TEXTFMT_forC*20, FNAM*12
      EXTERNAL SNTABLE_CREATE, SNTABLE_FILL
     
      LOGICAL REJECT_PRESCALE  ! function

C -------------------- BEGIN -----------------
      FNAM = 'TABLE_SNANA'

      IF ( IFLAG .EQ. IFLAG_INI ) THEN

         NAME     = 'SNANA' // char(0)
         LENNAME  = INDEX(NAME,    ' ') - 1

         TEXTFMT  = TEXTFORMAT_TABLE(ITABLE_SNANA)
         LENFMT   = INDEX(TEXTFMT, ' ') - 1
         TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)

         CALL SNTABLE_CREATE(IDTABLE,NAME,TEXTFMT_forC, 
     &          LENNAME,LENFMT)  ! C fun

c make table of scalars
         CALL INIT_TABLE_SNANAVAR(IDTABLE, 'SNANA', 1)

c check option to store variables for each obs (Mar 2015)
         IF ( OPT_TABLE(ITABLE_SNANA) .EQ. 2 ) THEN
           CALL INIT_TABLE_SNOBSVAR(IDTABLE, 'SNOBS')
         ENDIF

         IF ( OPT_TABLE(ITABLE_SNANA) .EQ. 4 ) THEN ! Jan 2019
           CALL INIT_TABLE_SIM_MAGOBS(IDTABLE, 'MODELMAG')
         ENDIF

c for sims ...

         CALL INIT_TABLE_SIMVAR(IDTABLE, 'SIM')
         CALL FLUSH(6)
         RETURN
      ENDIF

c --------------------------
c fill table.

      DO_FILL = .FALSE.

      IF ( CUTMASK_SNANA_TABLE == 63 ) 
     &          DO_FILL = .TRUE.   ! default --> include everything

c check subset options
      IF (CUTFLAG_SNANA == 0 .and. CUTMASK_SNANA_TABLE == 0 )
     &          DO_FILL = .TRUE.
      IF( IAND(CUTFLAG_SNANA,CUTMASK_SNANA_TABLE) > 0 ) 
     &          DO_FILL = .TRUE.


      IF ( DO_FILL ) THEN

c       terminate strings for C table-functions (snana.car routine)
        CALL TABLE_STRING_TERMINATION(+1)

c check option to store MODEL-MAG on epoch grid (Feb 2019)
        IF ( OPT_TABLE(ITABLE_SNANA) .EQ. 4 ) THEN 
           CALL LOAD_TABLE_SIM_MAGOBS()
        ENDIF

        PS  = DBLE(PRESCALE_TABLE(ITABLE_SNANA))
        LPS = REJECT_PRESCALE(NCALL_SNANA_DRIVER,PS) 
        IF ( .not. LPS ) THEN
          CALL SNTABLE_FILL(IDTABLE)  ! generic C function
        ENDIF
   
        CALL TABLE_STRING_TERMINATION(-1)  ! remove termination
      ENDIF

      RETURN
      END    ! end of TABLE_SNANA

C =====================================
+DECK,TBSNVAR.
      SUBROUTINE INIT_TABLE_SNANAVAR(ID,BLOCK,IFLAG)
c
c Created Feb 1, 2013
c
c Initialize variables for snana-analysis table.
c Call generic function SNTABLE_ADDCOL() that loads a table 
c for each selected format: CERNLIB, ROOT, HDF5 ...
c
c IFLAG = 1 => regular SNANA variables
c IFLAG = 2 => use _FIT variables instead (if they exist) since
c              post-fit variables may be different than the
c              original SNANA variables (e.g., SNRMAX3 can change
c              if a filter is excluded from a fit.
c
c
c May 31 2016: add zCMB[ERR] to text file and remove legacy "z,zerr"
c              from text file [since z=zHELIO]
c
c Jan  8 2018: write zHEL[ERR] to text file
c Mar  9 2018: add PHOTPROB info, MIN and Nepochs
c Mar 10 2019: add HOST_OBJID with BLOCK_LL for long long int
c May 23 2019: bug fix: book HOST_RA[DEC] as double instead of float.
c Feb 20 2020: write MWEBV to TEXT table.
c May 14 2020: add zFLAG
c Mar 14 2021: always include PKMJDINI in TEXT output
c Mar 19 2021: add NEP_OUTLIER if OUTLIER table is defined
c Aug 13 2021: include HOST_SBMAG, and HOST_SB -> HOST_SBFLUXCAL
c Sep 09 2023: update to write 2nd HOST match.
c Jul 23 2024: add FITPROB_ITER1, FITCHI2RED_INI[2]
c Feb 05 2025: add LENSDMU[ERR]
c -------------------------------------------------------------

      IMPLICIT NONE
      INTEGER   ID          ! (I) table ID
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)
      INTEGER   IFLAG       ! (I) SNANA or _FIT variables

c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.
+CDE,SNLCINP.
+CDE,USRTAGCM.
+CDE,PRIVCOM.
+CDE,PKMJDCOM.
+CDE,REQEPCOM.
+CDE,OUTLIERCOM.
+CDE,TRUECHI2COM.

      INTEGER 
     &   IFILT, IFILT_OBS, ITEXT, ITEXT2, ITEXT_NO, ITEXT_YES, IGAL
     &  ,LENBLOCK, LENLIST, LENNAME, LENV, ipar, ivar

      LOGICAL LTMP, ADDCOL_SETPKMJD
      CHARACTER varlist*1000, CTMP*60, CBLOCK*40
      CHARACTER FNAM*20, VARNAME*40, CFILT*2
      EXTERNAL  
     &   SNTABLE_ADDCOL
     &  ,SNTABLE_ADDCOL_int
     &  ,SNTABLE_ADDCOL_flt
     &  ,SNTABLE_ADDCOL_dbl
     &  ,SNTABLE_ADDCOL_str

C ---------------- BEGIN ------------

      FNAM = 'INIT_TABLE_SNANAVAR'
      ITEXT_NO  = 0   ! --> for ROOT table only
      ITEXT_YES = 1   ! --> for TEXT and ROOT tables
      
      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5 )
      call flush(6)

      LENBLOCK     = INDEX(BLOCK//' ',' ') - 1
      CBLOCK       = BLOCK(1:LENBLOCK) // char(0)
      LENLIST      = LEN(VARLIST)

c check filter list for filter-dependent columns (Feb 2017)
      ADDCOL_FILTERS = SURVEY_FILTERS  ! default
      IF ( NFILT_REMAP_TABLE > 0 ) THEN
         ADDCOL_FILTERS = FILTLIST_REMAP_TABLE 
      ENDIF

      LTMP = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_SAVEPAR)
      ADDCOL_SETPKMJD = ( LTMP .and. OPT_SETPKMJD > 0 ) 

c - - - - - - ID variables - - - - - - 

      VARLIST = 'CID:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SNLC_CID, VARLIST,0, 
     &                   LENBLOCK, 20 )

c  for CCID, use special variable SNLC_CCID_forC that has char(0)
c  termination so that parsing CCID with C code is easier.

      VARLIST = 'CCID:C*20' // char(0)
      CALL SNTABLE_ADDCOL_str(ID, CBLOCK, SNLC_CCID, VARLIST,1,
     &                   LENBLOCK, 20 )

c Aug 2022: check optional user-column; e.g., to tag magshift value
      if ( SNTABLE_APPEND_VARNAME .NE. '' ) then
         LENV = INDEX(SNTABLE_APPEND_VARNAME,' ') - 1
         VARLIST = SNTABLE_APPEND_VARNAME(1:LENV) // ':F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK,SNTABLE_APPEND_VALUE,
     &              VARLIST,1,      LENBLOCK, 20 )      
      endif
c to do: when combined low-z is ready change IDSURVEY -> IDSUBSURVEY,
c but keep same name 'IDSURVEY'
      VARLIST = 'IDSURVEY:I' //  char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, IDSUBSURVEY, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'TYPE:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ISNLC_TYPE, VARLIST,1, 
     &                   LENBLOCK, 20 )

      VARLIST = 'NFIELD_OVP:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ISNLC_NFIELD_OVP, 
     &               VARLIST, 0,    LENBLOCK, 20 )

      VARLIST = 'FIELD:C*20' // char(0)
      CALL SNTABLE_ADDCOL_str(ID, CBLOCK, SNLC_FIELDLIST, VARLIST,1,
     &                   LENBLOCK, 20 )

c Feb 15 2018: remove condition on CCDNUM 
      ITEXT = ITEXT_NO
      IF(NCCDNUM_LIST>0) ITEXT = ITEXT_YES
      VARLIST = 'CCDNUM:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ISNLC_CCDNUM(1), 
     &            VARLIST,ITEXT,       LENBLOCK, 20 )

c -------------------------------------------
c CUTFLAG_SNANA is a mask as follows:
c 0    -> failed SNANA cuts
c bit0 -> passed SNANA cuts
c bit1 -> passed FIT cuts (i.e, valid fit + re-applied snana cuts)
      
      VARLIST = 'CUTFLAG_SNANA:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, CUTFLAG_SNANA, VARLIST,1,
     &                   LENBLOCK, 20)

c -------------------------------------------
c ERRFLAG_FIT = -9 -> no fit, just SNANA job
c ERRFLAG_FIT =  0 -> no fitting errors.
c ERRFLAG_FIT >  0 -> fit failed, see ERRFLAG codes in fitting program.

      ITEXT = ITEXT_NO
+SELF,IF=SNFIT.
      ITEXT=ITEXT_YES
+SELF.

      VARLIST = 'ERRFLAG_FIT:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ERRFLAG_FIT, 
     &              VARLIST, ITEXT,   LENBLOCK, 20 )

c --------------------------------------------
      IF ( N_USERTAGS .GT. 0) then
        VARLIST = 'USERTAG:I'  // char(0)
        CALL SNTABLE_ADDCOL_int(ID, CBLOCK, USERTAG, VARLIST,1,
     &                   LENBLOCK, 20)
      endif

      VARLIST = 'RA:D,DEC:D' // char(0)
      CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, SNLC8_RA, VARLIST,0,
     &                   LENBLOCK, 20 )

      VARLIST = 'AREAFRAC_AVG:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_AREAFRAC_AVG, 
     &              VARLIST,0,  LENBLOCK, 20 )

c -- NEPOCH ( Aug 2013)
 
      VARLIST = 'NEPOCH:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ISNLC_NEPOCH_STORE, 
     &               VARLIST,0,  LENBLOCK, 20 )

      VARLIST = 'NEPOCH_BADPHOT:I' // char(0)      ! added Jun 2016
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, NEPOCH_BADPHOT, VARLIST, 0,
     &                   LENBLOCK, 20 )


c Mar 2018: add info about PHOTPROB
      VARLIST = 'NEPOCH_PHOTPROB:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ISNLC_NEPOCH_PHOTPROB, 
     &            VARLIST,0,  LENBLOCK, 20 )

      VARLIST = 'PHOTPROB_MIN:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_PHOTPROB_MIN, 
     &                VARLIST,0,   LENBLOCK, 20 )

c Sep 2018: add optonal info about detections
c Nov 2020: write to TEXT file 
      IF ( PHOTFLAG_DETECT > 0 ) THEN
         VARLIST = 'NOBS_DETECT:I' // char(0)
         CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ISNLC_NOBS_DETECT,
     &                VARLIST,1, LENBLOCK, 20 )
         VARLIST = 'TLIVE_DETECT:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_TLIVE_DETECT, 
     &              VARLIST,1,   LENBLOCK, 20 )
      ENDIF


      IF ( OPT_TABLE(ITABLE_OUTLIER) > 0 ) THEN
         VARLIST = 'NEPOCH_OUTLIER:I' // char(0)
         CALL SNTABLE_ADDCOL_int(ID, CBLOCK, NEP_OUTLIER_PEREVT,
     &            VARLIST,1,   LENBLOCK, 20 )
      ENDIF
c - - - - -  redshift - - - - - 

      VARLIST = 'zHEL:F,zHELERR:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_ZHELIO, VARLIST, 1,
     &                   LENBLOCK, 20 )

      VARLIST = 'zCMB:F,zCMBERR:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_ZCMB, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'zHD:F,zHDERR:F' // char(0)  ! Hubble diagram redshift
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_ZHD, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'zFLAG:I' // char(0)  ! z-quality flag (May 2020)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ISNLC_zFLAG, VARLIST, 0,
     &                   LENBLOCK, 20 )

c z = zCMB for spec z, but for photo-z fit z & zERR are the original
c data redshifts to allow plotting zHD-z resids
      VARLIST = 'z:F,zERR:F'  // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_REDSHIFT, VARLIST, 0, 
     &                   LENBLOCK, 20)

c tack on VPEC
      VARLIST = 'VPEC:F,VPECERR:F'  // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_VPEC, VARLIST, 1,
     &                       LENBLOCK, 20 )

c tack on LENSDMU (Feb 2025)
      VARLIST = 'LENSDMU:F,LENSDMUERR:F'  // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_LENSDMU, VARLIST, 1,
     &                       LENBLOCK, 20 )

c - - - - -  Galactic extinction - - - -  -
c Feb 6 2020: write MWEBV to TEXT (but not the error)

      VARLIST = 'MWEBV:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_MWEBV, VARLIST, 1,
     &                   LENBLOCK, 20 )

      VARLIST = 'MWEBVERR:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_MWEBV, VARLIST, 0, 
     &                   LENBLOCK, 20 )

c - - - - - - HOST GALAXY - - - - 
      ITEXT = ITEXT_NO
      if ( WRTABLEFILE_HOST_TEXT .or. WRTABLEFILE_HOST2_TEXT ) ITEXT=1

      ITEXT2 = ITEXT_NO
      if ( WRTABLEFILE_HOST2_TEXT ) ITEXT2=ITEXT_YES  ! for 2nd host only

      VARLIST =  'HOST_NMATCH:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SNHOST_NMATCH, 
     &              VARLIST,ITEXT,   LENBLOCK, 20 )
      VARLIST =  'HOST_NMATCH2:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SNHOST_NMATCH2, 
     &              VARLIST,ITEXT,    LENBLOCK, 20 )

      IGAL = 1
      CALL INIT_TABLE_HOSTVAR(ID, IGAL, ITEXT, BLOCK)

      IGAL = 2
      CALL INIT_TABLE_HOSTVAR(ID, IGAL, ITEXT2, BLOCK)


c Apr 2022
c store host surface brightness if SB exists or host-mag exists.
c The host-mag check is a safety feature in case SB is undefined.
c E.g., DES event 1248110 has SBFLUX=-999 even though host mags are
c all in the 21-22 range. Likely a subtle problem measuring SBFLUX
c on the template image.

      IF ( EXIST_SNHOST_SB .OR. EXIST_SNHOST_MAGOBS) THEN 
c        HOST_SB -> HOST_SBFLUXCAL
        CALL TABLE_VARLIST_FILTERS('HOST_SBFLUXCAL','F', ADDCOL_FILTERS, 
     &    VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, ADDCOL_SNHOST_SBFLUXCAL(1),
     &    VARLIST(1:LENLIST)//char(0), itext, LENBLOCK, LENLIST)

        CALL TABLE_VARLIST_FILTERS('HOST_SBMAG','F', ADDCOL_FILTERS, 
     &    VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, ADDCOL_SNHOST_SBMAG(1),
     &    VARLIST(1:LENLIST)//char(0), itext, LENBLOCK, LENLIST)
      ENDIF


c - - - - -  pre-fit quantities to show for all events  - -  -

c PKMJDINI (e.g., from max-flux clump method)

      VARLIST = 'PKMJDINI:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_SEARCH_PEAKMJD, 
     &           VARLIST, ITEXT_YES, LENBLOCK, 20 ) ! needed by SNN classifier

      VARLIST = 'FITPROB_ITER1:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, FITPROB_ITER1, 
     &              VARLIST, ITEXT_NO,   LENBLOCK, 20 )

      VARLIST = 'FITCHI2RED_INI:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, FITCHI2RED_INI, 
     &              VARLIST, ITEXT_NO,   LENBLOCK, 20 )

      VARLIST = 'FITCHI2RED_INI2:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, FITCHI2RED_INI2, 
     &              VARLIST, ITEXT_NO,   LENBLOCK, 20 )

c - - - - time above threshold for REQUIRE_EPOCHS - - - - - - 

      IF( NFILT_REQEP > 0 ) THEN
        VARLIST = 'NDAYS_ABOVE_SNRMIN:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, NDAYS_ABOVE_SNRMIN_REQEP, 
     &                    VARLIST, ITEXT_YES,       LENBLOCK, 40 )
      ENDIF

c - - - - - max flux per band (May 2016) - - - - - - - - -

        CALL TABLE_VARLIST_FILTERS('FLUXCALMAX','F', ADDCOL_FILTERS, 
     &    VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, ADDCOL_FLUXCALMAX(1),
     &    VARLIST(1:LENLIST)//char(0), ITEXT_NO, LENBLOCK, LENLIST)

c ... and the uncertainty (Nov 2022)

        CALL TABLE_VARLIST_FILTERS('FLUXCALMAX_ERR','F',ADDCOL_FILTERS, 
     &   VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, ADDCOL_FLUXCALMAX_ERR(1),
     &    VARLIST(1:LENLIST)//char(0), ITEXT_NO, LENBLOCK, LENLIST)

c - - - - - - optional fit-params from PKMJD fit (Oct 20 2014) - - - 

      IF ( ADDCOL_SETPKMJD ) THEN
         DO ipar = IPAR_T0, IPAR_A2
            VARNAME = 'FIT_' // PKPARNAME(ipar)
            LENV    = INDEX(VARNAME,' ') - 1
            CALL TABLE_VARLIST_FILTERS(VARNAME(1:LENV),'F',
     &           SURVEY_FILTERS, VARLIST, LENLIST)
            
            CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, 
     &        SNLC_SNANAFIT_PEAKMJD_FITPAR(1,ipar),
     &        VARLIST(1:LENLIST)//char(0), ITEXT_YES, LENBLOCK, LENLIST)
         ENDDO

c ----------------------------
c  PKMJD per filter

         DO 222 ifilt  = 1, NFILTDEF_SURVEY
            ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
            cfilt     = filtdef_string(ifilt_obs:ifilt_obs)

            IF( IFILTOBS_REPLACE(IFILT_OBS) .NE. IFILT_OBS) GOTO 222

            VARNAME   = 'PKMJD_FIT_' // cfilt(1:1) // ':F'
            CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, PKMJD_FIT(ifilt_obs),
     &           VARNAME(1:20)//char(0), ITEXT_YES, LENBLOCK, 20 )
            
            VARNAME   = 'PKMJD_ERR_' // cfilt(1:1) //  ':F'
            CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, PKMJD_ERR(ifilt_obs),
     &           VARNAME(1:20)//char(0), ITEXT_YES, LENBLOCK, 20 )

 222     CONTINUE

c --------------------------
c      fit chi2 per filter
          CALL TABLE_VARLIST_FILTERS('FIT_CHI2','F', ADDCOL_FILTERS,
     &      VARLIST, LENLIST )
          CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, ADDCOL_CHI2_FITPKMJD(1),
     &      VARLIST(1:LENLIST)//char(0), ITEXT_YES, LENBLOCK, LENLIST)

c --------------------------
c      fit NDOF per filter
          CALL TABLE_VARLIST_FILTERS('FIT_NDOF','I', SURVEY_FILTERS,
     &      VARLIST, LENLIST)
          CALL SNTABLE_ADDCOL_int(ID, CBLOCK, NDOF_FITPKMJD(1),
     &      VARLIST(1:LENLIST)//char(0), ITEXT_YES, LENBLOCK, LENLIST)

      ENDIF  ! end of SETPKMJD if-block

c - - - - - -
      IF ( LPROB_TRUEFLUX .and. ISJOB_SIM ) THEN

c global PROB_TRUEFLUX for all bands combined
        VARNAME   = 'PROB_TRUEFLUX:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, PROB_TRUEFLUX(0),
     &        VARNAME(1:20), ITEXT_YES, LENBLOCK, 20)

c ... and for each individual band
        CALL TABLE_VARLIST_FILTERS('PROB_TRUEFLUX','F', ADDCOL_FILTERS,
     &     VARLIST, LENLIST )
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, ADDCOL_PROB_TRUEFLUX(1),
     &    VARLIST(1:LENLIST)//char(0), ITEXT_YES, LENBLOCK, LENLIST)

        CALL TABLE_VARLIST_FILTERS('NDOF_TRUEFLUX','I', ADDCOL_FILTERS,
     &         VARLIST, LENLIST )
        CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ADDCOL_NDOF_TRUEFLUX(1),
     &    VARLIST(1:LENLIST)//char(0), ITEXT_YES, LENBLOCK, LENLIST)

      ENDIF

c - - - - -  min and max MJD 
      VARLIST = 'MJDMIN:D,MJDMAX:D' // char(0)
      CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, SNLC8_MJDMIN, 
     &                VARLIST, ITEXT_NO,   LENBLOCK, 20 )

c - - - - - MJD_DETECT and MJD_TRIGGER (Sep 2023) - - - - -

      VARLIST = 'MJD_TRIGGER:D' // char(0)
      CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, SNLC8_MJD_TRIGGER, 
     &                VARLIST, ITEXT_NO,   LENBLOCK, 20 )

      VARLIST = 'MJD_DETECT_FIRST:D,MJD_DETECT_LAST:D' // char(0)
      CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, SNLC8_MJD_DETECT_FIRST, 
     &                VARLIST, ITEXT_NO,   LENBLOCK, 20 )


c - - - -  multi-season variability - - - -
      IF( MULTISEASON_OPTMASK > 0 ) THEN

c Aug 15 2018: include NTOT and NLC in output and TEXT output
        VARLIST = 'NSEASON_TOT:I' // char(0)
        CALL SNTABLE_ADDCOL_int(ID, CBLOCK, NSEASON_TOT, VARLIST,
     &                   ITEXT_YES, LENBLOCK, 40 )

        VARLIST = 'NSEASON_ACTIVE:I' // char(0)
        CALL SNTABLE_ADDCOL_int(ID, CBLOCK, NSEASON_ACTIVE, VARLIST,
     &                   ITEXT_YES, LENBLOCK, 40 )

        VARLIST = 'MULTISEASON_CHI2RED_1:F,' //
     &            'MULTISEASON_CHI2RED_2:F,' //
     &            'MULTISEASON_CHI2RED_3:F,' //
     &            'MULTISEASON_CHI2RED_4:F,' //
     &            'MULTISEASON_CHI2RED_5:F'  //
     &          char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, MULTISEASON_CHI2RED(1), 
     &               VARLIST, ITEXT_NO,     LENBLOCK, 160 )

        VARLIST = 'MULTISEASON_AVGFLUX_1:F,' //
     &            'MULTISEASON_AVGFLUX_2:F,' //
     &            'MULTISEASON_AVGFLUX_3:F,' //
     &            'MULTISEASON_AVGFLUX_4:F,' //
     &            'MULTISEASON_AVGFLUX_5:F' //
     &          char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, MULTISEASON_AVGFLUX(1), 
     &              VARLIST, ITEXT_NO,    LENBLOCK, 160 )
      ENDIF

c ------------------------------------


      IF ( IFLAG .EQ. 1 ) THEN

c snana variables with no fitting.

         VARLIST = 'TrestMIN:F,TrestMAX:F,TrestRange:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_TRESTMIN, 
     &               VARLIST, ITEXT_NO,     LENBLOCK, 40 )

         VARLIST = 'TobsMIN:F,TobsMAX:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_TOBSMIN, 
     &               VARLIST, ITEXT_NO,    LENBLOCK,  40 )

         VARLIST = 'TGAPMAX:F,T0GAPMAX:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_TGAPMAX, 
     &                VARLIST, ITEXT_NO,   LENBLOCK, 40 )

         VARLIST =  
     &      'NFILT_Tmin:I,NFILT_Tmax:I,NFILT_Trest2:I' // char(0) 
         CALL SNTABLE_ADDCOL_int(ID, CBLOCK,ISNLC_NFILT_TRESTMIN,
     &              VARLIST, ITEXT_NO,     LENBLOCK, 40 )

         VARLIST = 'NFILT_SNRMAX:I,NFILT_SNRMAX2:I'  // char(0)
         CALL SNTABLE_ADDCOL_int(ID, CBLOCK, ISNLC_NFILT_SNRMAX,
     &                VARLIST, ITEXT_NO,   LENBLOCK, 40 )

         VARLIST = 'SNRMAX:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_SNRMAX_SORT(1),
     &                VARLIST, ITEXT_NO,   LENBLOCK, 20 )

         VARLIST = 'SNRMAX1:F,SNRMAX2:F,SNRMAX3:F' // char(0) 
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_SNRMAX_SORT(1),
     &               VARLIST, ITEXT_YES,    LENBLOCK, 40 )

         VARLIST = 'SNRSUM:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNLC_SNRSUM,
     &                VARLIST, ITEXT_YES,   LENBLOCK, 20 )
c ----------
c Below are SNANA variables for which the FIT analog is not
c available here -> book FIT-analogs in snlc_fit.car

         CALL TABLE_VARLIST_FILTERS('SNRMAX', 'F', ADDCOL_FILTERS,
     &                    VARLIST, LENLIST )
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, ADDCOL_SNRMAX(1), 
     &    VARLIST(1:LENLIST)//char(0),ITEXT_NO, LENBLOCK, LENLIST)

         CALL TABLE_VARLIST_FILTERS('XTMW', 'F', ADDCOL_FILTERS, 
     &                    VARLIST, LENLIST )
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, ADDCOL_XTMW(1),
     &    VARLIST(1:LENLIST)//char(0), ITEXT_NO, LENBLOCK, LENLIST)

      ELSE

c variables re-evaluated after fit

         VARLIST = 'TrestMIN:F,TrestMAX:F,TrestRange:F'  // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, TRESTMIN_FIT, 
     &                 VARLIST, ITEXT_NO,  LENBLOCK, 40 )

         VARLIST = 'TobsMIN:F,TobsMAX:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, TOBSMIN_FIT, 
     &                  VARLIST, ITEXT_NO, LENBLOCK, 40 )

         VARLIST = 'TGAPMAX:F,T0GAPMAX:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, TGAPMAX_FIT, 
     &                 VARLIST, ITEXT_NO,  LENBLOCK, 40 )

         VARLIST = 'NFILT_Tmin:I,NFILT_Tmax:I' // char(0)
         CALL SNTABLE_ADDCOL_int(ID, CBLOCK, NFILT_TRESTMIN_FIT,
     &                VARLIST, ITEXT_NO,   LENBLOCK, 40 )


         VARLIST = 'NFILT_SNRMAX:I,NFILT_SNRMAX2:I' // char(0)
         CALL SNTABLE_ADDCOL_int(ID, CBLOCK, NFILT_SNRMAX_FIT, 
     &                 VARLIST, ITEXT_NO,  LENBLOCK, 40 )

         VARLIST = 'SNRMAX:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNRMAX_SORT_FIT(1), 
     &                VARLIST, ITEXT_NO,    LENBLOCK, 20 )

         VARLIST = 'SNRMAX1:F,SNRMAX2:F,SNRMAX3:F' // char(0) 
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNRMAX_SORT_FIT(1), 
     &                 VARLIST, ITEXT_YES,  LENBLOCK, 40 )

         VARLIST = 'SNRSUM:F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNRSUM_FIT,
     &                VARLIST, ITEXT_YES,   LENBLOCK, 20 ) 

      ENDIF

c - - - - - - private vars - - - - -

c for PRIVATE variables in data files, 
c glue together variables in comma-separate VARLIST

      IF ( NVAR_PRIVATE .GT. 0 ) THEN 
           CTMP    = PRIVATE_VARNAME(1)(1:MXCHAR_FILEWORD-1) // ' '
           LENNAME = INDEX(CTMP,' ') - 1
           VARLIST = CTMP(1:LENNAME) // ':D'
        do ivar = 2, NVAR_PRIVATE
           CTMP    = PRIVATE_VARNAME(ivar)
           LENNAME = INDEX(CTMP,' ') - 1
           LENLIST = INDEX(VARLIST,' ') - 1
           VARLIST = VARLIST(1:LENLIST) // ',' // 
     &        CTMP(1:LENNAME) // ':D'

        enddo

        LENLIST = INDEX(VARLIST,' ') - 1
        VARLIST = VARLIST(1:LENLIST) // char(0)

        CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, PRIVATE_VALUE(1), 
     &                VARLIST, ITEXT_NO,   LENBLOCK, LENLIST)
      ENDIF     ! end of NPAR_PRIVATE if-block

c --- Sep 23 2017: user variables --------
      IF ( NTABLEVAR_USER > 0 ) THEN
        DO ivar = 1, NTABLEVAR_USER
          VARLIST = TABLEVARNAME_USER(ivar)
          LENLIST = INDEX(VARLIST,' ') - 1
          VARLIST = VARLIST(1:LENLIST) // ':F' // char(0)
          CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, TABLEVALUE_USER(1), 
     &               VARLIST, ITEXT_YES, LENBLOCK, LENLIST+2)           
        ENDDO
      ENDIF

      RETURN
      END   !  end of INIT_TABLE_SNANAVAR


C ======================================
+DECK,INIT_TBHOSTVAR.
      SUBROUTINE INIT_TABLE_HOSTVAR(ID, IGAL, ITEXT, BLOCK)

c Created Sep 2023
c init table column for HOST_XXX (igal=1) or HOST2_XXX (igal=2)
c
c  Inputs
c   ID   : table ID
c   IGAL : 1 for best match, >1 for other matches
c   ITEXT: 1 -> write to text also
c
c
c Feb 23 2024: pass ITEXT for HOST MAGS so that they appear with
c              SNTABLE_LIST = 'SNANA(text:key,text:host)'
c
c Jul 13 2024: fix bug in which all gal property indices were 1 instead of IGAL.
c Sep 24 2024: fix so that MAGOBS works for IGAL > 1

      IMPLICIT NONE

c subroutine args
      INTEGER ID, IGAL, ITEXT   ! (I) 
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

c local var
      CHARACTER PREFIX*8, VARLIST*400, CBLOCK*40
      INTEGER   LP, LENLIST, LENBLOCK, ITEXT_LOCAL

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

c ------------- BEGIN ----------

      if ( IGAL == 1 ) then
        PREFIX = 'HOST_'
        LP     = 5
      else 
        write(PREFIX,20) IGAL
        LP = 6
20      format('HOST',I1,'_')
      endif

      LENBLOCK     = INDEX(BLOCK//' ',' ') - 1
      CBLOCK       = BLOCK(1:LENBLOCK) // char(0)
      LENLIST      = LEN(VARLIST)

c store HOST_OBJID as double precision because
c  * root tree supports Long64_t, but does not read back correctly
c  * sntable_dump extraction will write real*8 as integer.

      VARLIST =  PREFIX(1:LP) // 'OBJID:D' // char(0)
      CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, DSNHOST_OBJID(IGAL), 
     &             VARLIST,ITEXT,     LENBLOCK, 20 )

      VARLIST =  PREFIX(1:LP) // 'ZPHOT:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_ZPHOT(IGAL), 
     &             VARLIST,ITEXT,    LENBLOCK, 40 )
      VARLIST =  PREFIX(1:LP) // 'ZPHOTERR:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_ZPHOT_ERR(IGAL), 
     &               VARLIST,ITEXT,    LENBLOCK, 40 )

c     XYZ

      if(SNHOST_NZPHOT_Q > 0) then  
        VARLIST =  PREFIX(1:LP) // 'QZPHOT:F' // char(0)  
      	    CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_QZPHOT_MEAN(IGAL), 
     &      	        VARLIST,ITEXT,    LENBLOCK, 40 )
      	VARLIST =  PREFIX(1:LP) // 'QZPHOTSTD:F' // char(0)
      	    CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_QZPHOT_STD(IGAL), 
     &               	VARLIST,ITEXT,    LENBLOCK, 40 )
        end if
     
      VARLIST =  PREFIX(1:LP) // 'ZSPEC:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_ZSPEC(IGAL), 
     &             VARLIST,ITEXT,    LENBLOCK, 40 )
      VARLIST =  PREFIX(1:LP) // 'ZSPECERR:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_ZSPEC_ERR(IGAL), 
     &              VARLIST,ITEXT,  LENBLOCK, 40 )

      VARLIST = PREFIX(1:LP) // 'RA:D'  // char(0)
      CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, SNHOST8_RA(IGAL), 
     &          VARLIST,ITEXT,    LENBLOCK, 20 )
      VARLIST = PREFIX(1:LP) // 'DEC:D'  // char(0)
      CALL SNTABLE_ADDCOL_dbl(ID, CBLOCK, SNHOST8_DEC(IGAL), 
     &          VARLIST,ITEXT,   LENBLOCK, 20 )

      VARLIST = PREFIX(1:LP) // 'ANGSEP:F'  // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_ANGSEP(IGAL), 
     &         VARLIST,ITEXT,   LENBLOCK, 20 )

      VARLIST = PREFIX(1:LP) // 'DDLR:F'  // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_DDLR(IGAL), 
     &          VARLIST,ITEXT,    LENBLOCK, 20 )

      if ( igal == 1 ) then  
        VARLIST = 'HOST_CONFUSION:F'  // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_CONFUSION, 
     &          VARLIST,ITEXT,    LENBLOCK, 20 )
      endif

c physical properties
      ITEXT_LOCAL = 1  ! always write properties to text format
      if ( IGAL > 1 ) ITEXT_LOCAL = ITEXT  ! optional for other host matches

      IF ( EXIST_SNHOST_LOGMASS ) THEN
        VARLIST =  PREFIX(1:LP) // 'LOGMASS:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_LOGMASS(IGAL), 
     &          VARLIST, ITEXT_LOCAL,    LENBLOCK, 40 )
        VARLIST =  PREFIX(1:LP) // 'LOGMASS_ERR:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_LOGMASS_ERR(IGAL), 
     &          VARLIST, ITEXT_LOCAL,     LENBLOCK, 40 )
      ENDIF

      IF ( EXIST_SNHOST_LOGSFR ) THEN
        VARLIST =  PREFIX(1:LP) // 'LOGSFR:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_LOGSFR(IGAL), 
     &            VARLIST, ITEXT_LOCAL,    LENBLOCK, 40 )
        VARLIST =  PREFIX(1:LP) // 'LOGSFR_ERR:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_LOGSFR_ERR(IGAL), 
     &            VARLIST, ITEXT_LOCAL,    LENBLOCK, 40 )
      ENDIF

      IF ( EXIST_SNHOST_LOGsSFR ) THEN
        VARLIST =  PREFIX(1:LP) // 'LOGsSFR:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_LOGsSFR(IGAL), 
     &            VARLIST, ITEXT_LOCAL,   LENBLOCK, 40 )
        VARLIST =  PREFIX(1:LP) // 'LOGsSFR_ERR:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_LOGsSFR_ERR(IGAL), 
     &           VARLIST, ITEXT_LOCAL,    LENBLOCK, 40 )
      ENDIF

      IF ( EXIST_SNHOST_COLOR ) THEN
        VARLIST =  PREFIX(1:LP) // 'COLOR:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_COLOR(IGAL), 
     &             VARLIST, ITEXT_LOCAL,    LENBLOCK, 40 )
        VARLIST =  PREFIX(1:LP) // 'COLOR_ERR:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SNHOST_COLOR_ERR(IGAL), 
     &           VARLIST, ITEXT_LOCAL,     LENBLOCK, 40 )
      ENDIF

c Sep 24 2024: update to allow writing MAGOBS for both host matches.
      IF ( EXIST_SNHOST_MAGOBS ) THEN    ! host mags      
        CALL TABLE_VARLIST_FILTERS( PREFIX(1:LP)//'MAG', 'F',
     &       ADDCOL_FILTERS, VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL_flt(ID,CBLOCK,ADDCOL_SNHOST_MAGOBS(1,IGAL),
     &      VARLIST(1:LENLIST)//char(0),
     &      ITEXT_LOCAL, LENBLOCK, LENLIST)
      ENDIF

      RETURN
      END    ! INIT_TABLE_HOSTVAR

C =============================================
+DECK,TBOBSVAR.
      SUBROUTINE INIT_TABLE_SNOBSVAR(ID, BLOCK)

c Mar 2 2015: 
c Book epoch info in SNANA table.
c 
c Sep 23 2017: reduce MXOBS down to 1000 so that MJD*8 is handled by hbook.
c Oct 16 2017: include CCDNUM if it is there.
c Mar 03 2018: include SIM_FLUXCAL_HOSTERR(NOBS):F
c Mar 18 2018: include DTOBS(NOBS):F and DTOBS_SAMEFILT(NOBS):F
c
c Nov 30 2020: 
c    + change a few VARNAMEs to match names in FITRES+RESIDUALS
c    + add CHI2FLUX_SIM
c    + add several variables: GAIN, SKYSIG_T ...
c    + remove a few obscure variables 
c       (DTOBSLAST, DTOBSLAST_SAMEFILT, FLUXCAL_HOSTERRCALC)
c - - - - - - - - - 

      IMPLICIT NONE

      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

      INTEGER MXOBS_SNTABLE
      PARAMETER (MXOBS_SNTABLE = 900) ! cannot exceed 1000 for MJD*8

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
      INTEGER LENV, LENB, LENTMP
      CHARACTER CBLK*40, CNOBS*14, VARNAME*40
      LOGICAL  IGNORE

      EXTERNAL 
     &    SNTABLE_ADDCOL
     &   ,SNTABLE_ADDCOL_int
     &   ,SNTABLE_ADDCOL_flt
     &   ,SNTABLE_ADDCOL_dbl
     &   ,SNTABLE_ADDCOL_str
      LOGICAL  IGNOREFILE_fortran

C --------------- BEGIN -------------

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENV   = LEN(VARNAME)
      LENB   = INDEX(BLOCK//' ',' ') - 1
      CBLK   = BLOCK(1:LENB) // char(0)

      write(CNOBS,15) MXOBS_SNTABLE
15    format('NOBS[',I4.4,']' )  ! no spaces or commas in string
      VARNAME = CNOBS(1:12)  // char(0)  ! Nobs used in fit + NREJECT
      CALL SNTABLE_ADDCOL_int(ID, CBLK, ISNLC_NEWMJD_STORE,
     &     VARNAME, 0, LENB, LENV)

      VARNAME = 'USEFLAG(NOBS):I' // char(0)  
      CALL SNTABLE_ADDCOL_int(ID,CBLK, ISNLC_SNRECON_USE(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'PHOTFLAG(NOBS):I' // char(0)  
      CALL SNTABLE_ADDCOL_int(ID,CBLK, ISNLC_PHOTFLAG(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'PHOTPROB(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_PHOTPROB(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'IFILTOBS(NOBS):I' // char(0)  
      CALL SNTABLE_ADDCOL_int(ID,CBLK, ISNLC_IFILT_OBS(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'MJD(NOBS):D' // char(0)  
      CALL SNTABLE_ADDCOL_dbl(ID,CBLK, SNLC8_MJD(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXCAL_DATA(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_FLUXCAL(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXCAL_DATA_ERR(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_FLUXCAL_ERRTOT(1),
     &      VARNAME, 0, LENB,LENV)

c -- observing conditions

      VARNAME = 'ZP(NOBS):F' // char(0)    ! match FITRES+RESID table
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_ZEROPT(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'ZP_ERR(NOBS):F' // char(0)    ! match FITRES+RESIDS table
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_ZEROPT_ERR(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'PSF(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_PSF_SIG1(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'SKYSIG(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_SKYSIG(1),
     &      VARNAME, 0, LENB,LENV)
      VARNAME = 'SKYSIG_T(NOBS):F' // char(0)    ! Nov 30 2020
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_SKYSIG_T(1),
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'GAIN(NOBS):F' // char(0)    ! Nov 30 2020
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_GAIN(1),
     &      VARNAME, 0, LENB,LENV)

c --- error calculated from PSF+SKY+ZP, as the simulation would do

      VARNAME = 'FLUXCAL_ERRCALC(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SNLC_FLUXCAL_ERRCALC(1),
     &      VARNAME, 0, LENB,LENV)

c - - - - - - - - - - - - - - - - 

      IF ( ISJOB_SIM ) THEN
         VARNAME = 'FLUXCAL_SIM(NOBS):F' // char(0)   ! match FITRES+RESIDS
         CALL SNTABLE_ADDCOL_flt(ID,CBLK, SIM_EPFLUXCAL(1),
     &        VARNAME, 0, LENB,LENV)

         VARNAME = 'CHI2FLUX_SIM(NOBS):F' // char(0)  ! match FITRES+RESIDS
         CALL SNTABLE_ADDCOL_flt(ID,CBLK, SIM_EPCHI2FLUX(1),
     &        VARNAME, 0, LENB,LENV)

         VARNAME = 'MAGOBS_SIM(NOBS):F' // char(0) 
         CALL SNTABLE_ADDCOL_flt(ID,CBLK, SIM_EPMAGOBS(1),
     &        VARNAME, 0, LENB,LENV)
      ENDIF

      IF ( LSIM_SNANA ) THEN
         VARNAME = 'SIM_FLUXCAL_HOSTERR(NOBS):F' // char(0) 
         CALL SNTABLE_ADDCOL_flt(ID,CBLK, SIM_EPFLUXCAL_HOSTERR(1),
     &        VARNAME, 0, LENB,LENV)
      ENDIF

c include SNR_MAG[mag] if it exists.
      LENTMP  = INDEX(SIMNAME_SNRMON,' ')-1
      IGNORE  = ( IGNOREFILE_fortran(SIMNAME_SNRMON) ) 
      IF ( LSIM_SNANA .and. (.not.IGNORE)  ) THEN
         VARNAME = SIMNAME_SNRMON(1:LENTMP)// '(NOBS):F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID,CBLK, SIM_EPSNRMON(1),
     &        VARNAME, 0, LENB,LENV)
      ENDIF

      RETURN
      END   ! end INIT_TABLE_SNOBSVAR


C =============================================
+DECK,INIT_TABLE_SIM_MAGOBS.
      SUBROUTINE INIT_TABLE_SIM_MAGOBS(ID, BLOCK)

c Feb 2019
c Book only MODEL-MAG vs. EPOCH (much smaller output than SNANA+EPOCHS)
c MODEL-MAG is interpolated on a grid to enable plotting model colors. 
c
c  NEP_SIM_MODELGRID, SIM_MODELGRID_TOBS, SIM_MODELGRID_MAGOBS

      IMPLICIT NONE

      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER LENV, LENB, IFILT, IFILT_OBS
      LOGICAL IGNORE
      CHARACTER CBLK*40, CNOBS*20, VARNAME*40, cfilt*2

      EXTERNAL 
     &    SNTABLE_ADDCOL
     &   ,SNTABLE_ADDCOL_int
     &   ,SNTABLE_ADDCOL_flt
     &   ,SNTABLE_ADDCOL_dbl
     &   ,SNTABLE_ADDCOL_str

C --------------- BEGIN -------------

      IF ( .not. LSIM_SNANA ) RETURN ! sim only

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENV   = LEN(VARNAME)
      LENB   = INDEX(BLOCK//' ',' ') - 1
      CBLK   = BLOCK(1:LENB) // char(0)

      write(CNOBS,15) MXEP_MODELGRID
15    format('NEP_MODEL[',I4.4,']' )  ! no spaces or commas in string
      VARNAME = CNOBS(1:15)  // char(0) 
      CALL SNTABLE_ADDCOL_int(ID, CBLK, NEP_SIM_MODELGRID,
     &     VARNAME, 0, LENB, LENV)

      VARNAME = 'EPOCH_MODEL(NEP_MODEL):F' // char(0)  
      CALL SNTABLE_ADDCOL_flt(ID,CBLK, SIM_MODELGRID_TOBS(1),
     &      VARNAME, 0, LENB,LENV)

      DO ifilt = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)         
          cfilt     = filtdef_string(ifilt_obs:ifilt_obs)
          VARNAME   = 'MAGOBS_MODEL_' // cfilt(1:1) // 
     &                    '(NEP_MODEL):F' // char(0)
          CALL SNTABLE_ADDCOL_flt(ID,CBLK, 
     &          SIM_MODELGRID_MAGOBS(1,ifilt),
     &          VARNAME, 0, LENB,LENV )
      ENDDO

      RETURN
      END   ! end INIT_TABLE_SIM_MAGOBS

C =============================================
+DECK,FILL_TABLE_SIM_MAGOBS.
      SUBROUTINE LOAD_TABLE_SIM_MAGOBS()

c Feb 2019: 
c   load SIM_MODELGRID arrays for MODELMAG table.
c   This CWNT is designed to enable plotting model color vs. epoch
c
c NEP_SIM_MODELGRID, SIM_MODELGRID_TOBS, SIM_MODELGRID_MAGOBS
    
      IMPLICIT NONE

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IGRID, NEP, IFILT, IFILT_OBS
      REAL MAGOBS, TOBS

c function
      REAL SIM_MAGOBS_INTERP

C ---------- BEGIN ----------

      IF ( .not. LSIM_SNANA ) RETURN ! sim only
      
c define arbitrary epoch grid

      NEP = 0
      DO IGRID = -40, 100, 2
         NEP  = NEP + 1
         TOBS = FLOAT(IGRID)
         SIM_MODELGRID_TOBS(NEP) = TOBS
         
         DO ifilt = 1, NFILTDEF_SURVEY
            MAGOBS = SIM_MAGOBS_INTERP(ifilt,TOBS)
            SIM_MODELGRID_MAGOBS(NEP,IFILT) = MAGOBS
         ENDDO
      ENDDO
      NEP_SIM_MODELGRID = NEP
      RETURN
      END

+DECK,SIM_MAGOBS_INTERP.
      REAL FUNCTION SIM_MAGOBS_INTERP(IFILT,Tobs)

C Return interpolated SIM_MAGOBS for inputs:
c   * IFILT  = sparse filter index 
c   * Tobs   = MJD - SIM_PEAKMJD
     
      IMPLICIT NONE

      INTEGER IFILT
      REAL Tobs

+CDE,SNDATCOM.
+CDE,FILTCOM.

      INTEGER NEWMJD, EP, EPMIN, EPMAX, IFILT_OBS, EP0, EP1
      REAL MAGOBS, Tobs_tmp, T0, T1, MAG0, MAG1, frac
      REAL*8 MJD8
C ------------ BEGIN -----------

      MAGOBS = 99.0  ! init value

      T0=-9999. ; T1=-9999. ; EP0 = -9; EP1 = -9
      DO 100 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN  = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX  = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 101 EP = EPMIN, EPMAX
            IFILT_OBS = ISNLC_IFILT_OBS(ep)
            IF ( IFILT .NE. IFILTDEF_INVMAP_SURVEY(ifilt_obs)) GOTO 101
            MJD8      = SNLC8_MJD(EP)
            Tobs_tmp  = sngl(MJD8) - SIM_PEAKMJD
            MAGOBS    = SIM_EPMAGOBS(ep)
            if ( Tobs_tmp < Tobs ) then
               EP0 = EP; T0 = Tobs_tmp; MAG0 = MAGOBS
            endif
            if ( Tobs_tmp > Tobs .and. T1 < -999. ) THEN
               EP1 = ep; T1 = Tobs_tmp ; MAG1 = MAGOBS ; goto 444
            endif
 101     CONTINUE
 100  CONTINUE

 444  CONTINUE

      IF ( EP0 > 0 .and. EP1 > 0 ) THEN
         FRAC   = (Tobs-T0)/(T1-T0)
         MAGOBS = MAG0 + (MAG1-MAG0) * frac
      ENDIF

      SIM_MAGOBS_INTERP = MAGOBS

      RETURN
      END

C ========================================
+DECK,TBSIMVAR..
      SUBROUTINE INIT_TABLE_SIMVAR(ID,BLOCK)

c Created Feb 02, 2013
c Initialize table for simulated variables.
c
c Feb 27, 2020: add SIM_HOSTLIB_GALID
c Mar 19, 2020: add SIM_RV  to table
c Sep 11, 2020: add PySEDMODEL = BYOSED or SNEMO
c Dec 28, 2020: write SIM_gammaDM to TEXT file if non-zero
c Dec     2022: remove SIM_TYPE_INDEX
c Jan  8  2023: restore SIM_TYPE_INDEX (forgot why it was removed)
c Dec 23  2023: add SIM_WGT_POPULATION
c
      IMPLICIT  NONE
      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER 
     &    CTMP*(MXCHAR_FILEWORD)
     &  , VARLIST*400, CBLOCK*40
      INTEGER LENLIST, IPAR, LENBLOCK, LENTMP, LENM, ITEXT

      EXTERNAL 
     &    SNTABLE_ADDCOL
     &   ,SNTABLE_ADDCOL_int
     &   ,SNTABLE_ADDCOL_flt
     &   ,SNTABLE_ADDCOL_dbl
     &   ,SNTABLE_ADDCOL_str

C ---------------- BEGIN ---------------

      IF ( .NOT. LSIM_SNANA         ) RETURN 
      IF ( .NOT. WRTABLEFILE_SIMVAR ) RETURN


      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENBLOCK = INDEX(BLOCK//' ',' ') - 1
      LENLIST  = LEN(VARLIST)
      CBLOCK   = BLOCK(1:LENBLOCK) // char(0)


      IF ( SIM_SUBSAMPLE_INDEX >= 0 ) THEN
        VARLIST = 'SIM_SUBSAMPLE_INDEX:I' // char(0)  
        CALL SNTABLE_ADDCOL_int(ID,CBLOCK,SIM_SUBSAMPLE_INDEX,
     &                VARLIST, 0,     LENBLOCK, LENLIST)  
      ENDIF

      VARLIST = 'SIM_GENTYPE:I' //char(0) 
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_GENTYPE,  VARLIST, 1,  ! legacy name
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_TEMPLATE_INDEX:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SIM_TEMPLATE_INDEX,
     &               VARLIST,1,    LENBLOCK, LENLIST)

c Mar 22 2016: always output SIM_LIBID
cc      IF ( BTEST(SIMLIB_MSKOPT,1) ) THEN
        VARLIST = 'SIM_LIBID:I' // char(0)  
        CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SIM_LIBID,  VARLIST, 1,
     &                   LENBLOCK, LENLIST) 
        VARLIST = 'SIM_NGEN_LIBID:I' // char(0)  
        CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SIM_NGEN_LIBID,  VARLIST, 1,
     &                   LENBLOCK, LENLIST) 
cc      ENDIF

      VARLIST = 'SIM_NOBS_UNDEFINED:I' // char(0)  
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SIM_NOBS_UNDEFINED,
     &            VARLIST,0,       LENBLOCK, LENLIST)  

      VARLIST = 'SIM_SEARCHEFF_MASK:I' // char(0)
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SIM_SEARCHEFF_MASK, 
     &               VARLIST, 0,    LENBLOCK, LENLIST)

      VARLIST = 'SIM_MAGSMEAR_COH:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_MAGSMEAR_COH,  
     &             VARLIST, 0,      LENBLOCK, LENLIST)

      VARLIST = 'SIM_MWEBV:F' // char(0)  ! added Nov 26 2016
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_MWEBV,  
     &                VARLIST, 0,   LENBLOCK, LENLIST)

      VARLIST = 'SIM_ZCMB:F' // char(0) 
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_REDSHIFT_CMB,  
     &              VARLIST, 1,     LENBLOCK, LENLIST)

      VARLIST = 'SIM_ZHELIO:F' // char(0) 
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_REDSHIFT_HELIO, 
     &                VARLIST, 0,    LENBLOCK, LENLIST)

      VARLIST = 'SIM_ZHOST:F' // char(0) 
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_REDSHIFT_HOST,  
     &             VARLIST, 0,      LENBLOCK, LENLIST)

      VARLIST = 'SIM_ZFLAG:I' // char(0) 
      CALL SNTABLE_ADDCOL_int(ID, CBLOCK, SIM_REDSHIFT_FLAG,  
     &              VARLIST, 1,     LENBLOCK, LENLIST)

      VARLIST = 'SIM_VPEC:F' // char(0) 
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_VPEC,  
     &               VARLIST, 1,    LENBLOCK, LENLIST)

      VARLIST = 'SIM_DLMAG:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_DLMAG,  
     &               VARLIST, 1,    LENBLOCK, LENLIST)

c Feb 4 2025: add SIM_LENSDMU to text fitres file
      VARLIST = 'SIM_LENSDMU:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_LENSDMU,  
     &               VARLIST, 1,    LENBLOCK, LENLIST)

      IF ( SIM_MUSHIFT .NE. 0.0 ) THEN   ! hope that first events does not have SIM_MUSHIFT=0
        VARLIST = 'SIM_MUSHIFT:F' // char(0)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_MUSHIFT,  
     &               VARLIST, 1,    LENBLOCK, LENLIST)
      ENDIF

      VARLIST = 'SIM_PEAKMJD:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_PEAKMJD,  
     &               VARLIST, 1,     LENBLOCK, LENLIST)

c - - 
      VARLIST = 'SIM_WGT_POP' // ':F'   // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_WGT_POPULATION,
     &               VARLIST, 1,     LENBLOCK, LENLIST)  

      LENTMP = INDEX(SIMNAME_SHAPEPAR,' ') - 1  ! x1, delta, dm15
      VARLIST = SIMNAME_SHAPEPAR(1:LENTMP) // ':F'   // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_SHAPEPAR,
     &               VARLIST, 1,     LENBLOCK, LENLIST)  

      LENTMP = INDEX(SIMNAME_COLORPAR,' ') - 1  ! c, AV
      VARLIST = SIMNAME_COLORPAR(1:LENTMP) // ':F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_COLORPAR,  
     &              VARLIST, 1,     LENBLOCK, LENLIST)

      LENTMP = INDEX(SIMNAME_SHAPELAW,' ') - 1   ! SIM_alpha
      VARLIST = SIMNAME_SHAPELAW(1:LENTMP) // ':F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_SHAPELAW,  
     &              VARLIST, 1,     LENBLOCK, LENLIST)

      LENTMP = INDEX(SIMNAME_COLORLAW,' ') - 1   ! SIM_beta
      VARLIST = SIMNAME_COLORLAW(1:LENTMP) // ':F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_COLORLAW,  
     &                VARLIST, 1,   LENBLOCK, LENLIST)

c add SIM_gammaDM if not zero.
c Sep 7 2021: always write SIM_gammaDM in case first value is 0
c    followed by non0-zero values.
      VARLIST = 'SIM_gammaDM:F' // char(0) 
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_SALT2gammaDM,
     &                VARLIST, 1,   LENBLOCK, LENLIST )

      VARLIST = 'SIM_x0:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_SALT2x0,  
     &                VARLIST, 1,   LENBLOCK, LENLIST)

      VARLIST = 'SIM_mB:F' // char(0)
      CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_SALT2mb,  
     &                VARLIST, 1,   LENBLOCK, LENLIST)

c add SIM_AV only if not already defined. 
c This is for the SALT2 model with intinsic color (c) and 
c external scatter (SIM_AV) from dust.
c Aug 2 2022: perform test only for SALT2 model.

      if ( SIM_MODEL_INDEX .EQ. MODEL_SALT2 ) then
        if ( SIMNAME_COLORPAR(1:6) .NE. 'SIM_AV' ) then
          VARLIST = 'SIM_AV:F' // char(0)
          CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_AV,  
     &               VARLIST, 1,    LENBLOCK, LENLIST)
          VARLIST = 'SIM_RV:F' // char(0)
          CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_RV,  
     &                VARLIST, 1,     LENBLOCK, LENLIST)
        endif
      endif

c  SIMSED model params; glue SIMSED_ prefix (Feb 2014)
c  Apr 28 2015: set DOTEXT flag to 1

      DO IPAR    = 1, NPAR_SIMSED
         CTMP    = SIMSED_PARNAME(ipar)
         LENTMP  = INDEX(CTMP,' ') - 1
         VARLIST = 'SIMSED_' // CTMP(1:LENTMP) // ':F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID,CBLOCK, SIMSED_PARVAL(ipar),
     &        VARLIST, 1, LENBLOCK, LENLIST)
      ENDDO


c PySEDMODEL model params (BYOSED, SNEMO, ...)
      DO IPAR    = 1, NPAR_PySEDMODEL
         LENM    = INDEX(PySEDMODEL_NAME,' ') - 1
         CTMP    = PySEDMODEL_PARNAME(ipar)
         LENTMP  = INDEX(CTMP,' ') - 1
         VARLIST = PySEDMODEL_NAME(1:LENM) // '_' 
     &             // CTMP(1:LENTMP) // ':F' // char(0) 
         CALL SNTABLE_ADDCOL_flt(ID,CBLOCK, PySEDMODEL_PARVAL(ipar),
     &        VARLIST, 1, LENBLOCK, LENLIST)
      ENDDO

c Feb 2018: LCLIB model params 
      IF ( SIM_MODEL_INDEX == MODEL_LCLIB ) THEN        
        CALL TABLE_VARLIST_FILTERS('SIM_TEMPLATEMAG','F',ADDCOL_FILTERS, 
     &           VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL_flt(ID,CBLOCK, SIM_TEMPLATEMAG(1),
     &          VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)

        DO IPAR    = 1, NPAR_LCLIB
           CTMP    = LCLIB_PARNAME(ipar)
           LENTMP  = INDEX(CTMP,' ') - 1
           VARLIST = 'LCLIB_' // CTMP(1:LENTMP) // ':F' // char(0)
           CALL SNTABLE_ADDCOL_flt(ID,CBLOCK, LCLIB_PARVAL(ipar),
     &            VARLIST,1,   LENBLOCK, LENLIST)
        ENDDO
      ENDIF

c SIM_HOSTLIB params

      ITEXT = 0
      if ( WRTABLEFILE_HOST_TEXT ) ITEXT=1
      VARLIST = 'SIM_HOSTLIB_GALID' // ':D' // char(0) ! Feb 2020
         CALL SNTABLE_ADDCOL_dbl(ID,CBLOCK, DSIM_HOSTLIB_GALID,
     &        VARLIST, ITEXT,    LENBLOCK, LENLIST)

      DO IPAR    = 1, NPAR_SIM_HOSTLIB
         CTMP    = SIM_HOSTLIB_PARNAME(ipar)
         LENTMP  = INDEX(CTMP,' ') - 1
         VARLIST = 'SIM_HOSTLIB_' // CTMP(1:LENTMP) // ':F' // char(0)
         CALL SNTABLE_ADDCOL_flt(ID,CBLOCK, SIM_HOSTLIB_PARVAL(ipar),
     &        VARLIST, ITEXT,    LENBLOCK, LENLIST)
      ENDDO  

c - - - - - optional LCWIDTH for simulated MAGOBS -----
      if ( OPTSIM_LCWIDTH > 0 ) then
        CALL TABLE_VARLIST_FILTERS('SIM_LCWIDTH','F', ADDCOL_FILTERS, 
     &           VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL_flt(ID, CBLOCK, SIM_LCWIDTH(1),
     &      VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)
      endif

      RETURN
      END    ! end of INIT_TABLE_SIMVAR



C ===================================================
+DECK,TBVFILT.
      SUBROUTINE TABLE_VARLIST_FILTERS(PREFIX,CAST,FILTERS,
     &            VARLIST,LENLIST)

c Created Sep 28, 2012
c
c For input PREFIX  and defined FILTERS,  return 
c comma-separate list of variable names for column-wise ntuple.
c Example for FILTERS=gri,
c
c VARLIST = '[PREFIX]_g,[PREFIX]_r,[PREFIX]_i'
c
c If a filter is case-insensitive duplicate (i.e., u & U) 
c then append '2' at the end of the variable name. 
c The returned VARLIST is used in the HBNAME calls,
c and hence case-insensitive duplicates must be distiguished
c for ntuples.
c
c Feb  1, 2013: include ':F' after each variable.
c Feb  5, 2013: return LENLIST
c Feb 15, 2013: set max of MXFILT = 30 filters.
c Jun 24, 2013: ignore remapped filter(s)
c Oct 21, 2014: add CAST as input argument
c Jul 13, 2020: MXFILT -> 15
c ------------------------------------

      IMPLICIT NONE

      CHARACTER 
     &   PREFIX*(*)   ! (I) prefix for variable names
     &  ,CAST*(*)     ! (I) 'F', 'I', 'D'
     &  ,FILTERS*(*)  ! (I) list of filters; i.e, 'gri'
     &  ,VARLIST*(*)  ! (O) output list of varnames.

      INTEGER LENLIST    ! (O) length of VARLIST

c local var

+CDE,SNPAR.
+CDE,FILTCOM.

      INTEGER NFILT, ifilt, lenv, MXFILT, LENMAX, LENSUM
      INTEGER IFILTOBS
      LOGICAL LTMP
      character varname*32, cfilt*1, c1err*76, c2err*76

c function
      LOGICAL DUPLICATE_FILTER
      INTEGER FILTINDX

C ---------------- BEGIN ----------
  
      LENMAX = LEN(VARLIST)  ! abort if larger than this
      LENSUM = 0
cc cxxx      MXFILT = 30
      MXFILT = 15

      NFILT = INDEX(FILTERS,' ' ) - 1
      IF ( NFILT > MXFILT ) NFILT = MXFILT
      VARLIST = ''

c -----------
      DO 100 ifilt = 1, NFILT
         cfilt     = FILTERS(ifilt:ifilt)
         LTMP      = DUPLICATE_FILTER(ifilt,FILTERS)

         IFILTOBS = FILTINDX(cfilt // ' ')
         IF( IFILTOBS_REPLACE(IFILTOBS) .NE. IFILTOBS) GOTO 100

         varname   = PREFIX // '_' //  cfilt
         LENV = INDEX(VARNAME,' ') - 1
         if ( LTMP ) VARNAME = VARNAME(1:LENV) // '2'

         LENV = INDEX(VARNAME,' ') - 1
         LENSUM = LENSUM + LENV + 2  ! for error message only

         IF ( ifilt .eq. 1 ) then
            varlist = VARNAME(1:LENV) // ':' // CAST
         else if ( LENSUM < LENMAX ) then
            lenlist = INDEX(varlist,' ') - 1
            varlist = varlist(1:LENLIST) // ',' // 
     &            VARNAME(1:LENV) // ':' // CAST
         endif

100   CONTINUE

c ---------------------
c abort if required size (LENSUM) of VARLIST exceed size passed (LENMAX)

      IF ( LENSUM > LENMAX ) THEN
        write(c1err,661) LENSUM, LENMAX
661     format('LENSUM=',I4, ' but LEN(VARLIST)=',I4,
     &          ' is too short.')
        write(c2err,662) PREFIX, NFILT, FILTERS(1:NFILT)
662     format('PREFIX=',A,2x,'NFILT=',I3,'(',A,'+)'  )
        CALL MADABORT("TABLE_VARLIST_FILTERS", c1err, c2err)
      ENDIF

      LENLIST = INDEX(VARLIST,' ') - 1

      RETURN
      END     ! end of TABLE_VARLIST_FILTERS

C ======================================
+DECK,TABLE_ADDCOL_LOAD.
      SUBROUTINE TABLE_ADDCOL_LOAD()

c Created Feb 2017
c Load filter-dependent ADDCOL_XXX arrays.
c Use nominal filter indices, or REMAPED filters if
c &SNLCINP namelist input SNTABLE_FILTER_REMAP is set.

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PKMJDCOM.
c+CDE,SNHOSTCOM.
+CDE,TRUECHI2COM.

      INTEGER ifilt, NFILT, IFILTOBS, IFILTOBS_REMAP, IFILT_REMAP
      INTEGER LEN
      CHARACTER  CFILTOBS*2, CFILTOBS_REMAP*2, FNAM*18
      LOGICAL DO_NOMINAL, DO_REMAP, VALID_BAND
      LOGICAL USE, USEFILT_REMAP(MXFILT_ALL)
      REAL    SNRMAX, VAL_OLD, VAL_NEW
c function
      INTEGER FILTINDX

C ------------- BEGIN --------------

      FNAM = 'TABLE_ADDCOL_LOAD'

      DO_NOMINAL = ( NFILT_REMAP_TABLE == 0 ) 
      DO_REMAP   = ( .NOT. DO_NOMINAL)

      NFILT   = NFILTDEF_SURVEY

      IF ( DO_REMAP) THEN
        DO  ifilt=1, MXFILT_ALL
          USEFILT_REMAP(ifilt) = .FALSE.
        ENDDO
      ENDIF

      DO IFILT_REMAP = 1, NFILT_REMAP_TABLE
           ADDCOL_SNRMAX(IFILT_REMAP)     = -9.0
           ADDCOL_XTMW(IFILT_REMAP)       = -9.0
           ADDCOL_FLUXCALMAX(IFILT_REMAP)        = -9.0
           ADDCOL_FLUXCALMAX_ERR(IFILT_REMAP)     = -9.0
           ADDCOL_PROB_TRUEFLUX(IFILT_REMAP)      = -9.0
           ADDCOL_NDOF_TRUEFLUX(IFILT_REMAP)      =  0
           ADDCOL_SNHOST_MAGOBS(IFILT_REMAP,1)    = -9.0 
           ADDCOL_SNHOST_MAGOBS(IFILT_REMAP,2)    = -9.0 
           ADDCOL_SNHOST_SBFLUXCAL(IFILT_REMAP)   = -9.0
           ADDCOL_SNHOST_SBMAG(IFILT_REMAP)       = -9.0
      ENDDO

      DO 100 ifilt = 1, NFILT
         IFILTOBS = IFILTDEF_MAP_SURVEY(ifilt)
         CFILTOBS = filtdef_string(ifiltobs:ifiltobs)

         IF ( DO_NOMINAL ) then
           ADDCOL_SNRMAX(ifilt)           = SNLC_SNRMAX_FILT(ifilt)
           ADDCOL_XTMW(ifilt)             = SNLC_MWXT_FLUXFRAC(ifilt)
           ADDCOL_FLUXCALMAX(ifilt)       = SNLC_FLUXCALMAX(ifilt)
           ADDCOL_FLUXCALMAX_ERR(ifilt)   = SNLC_FLUXCALMAX_ERR(ifilt)
           ADDCOL_PROB_TRUEFLUX(ifilt)    = PROB_TRUEFLUX(ifilt)
           ADDCOL_NDOF_TRUEFLUX(ifilt)    = NDOF_TRUEFLUX(ifilt)
           ADDCOL_CHI2_FITPKMJD(ifilt)    = CHI2_FITPKMJD(ifilt)
           ADDCOL_SNHOST_MAGOBS(ifilt,1)  = SNHOST_MAGOBS(ifilt,1) 
           ADDCOL_SNHOST_MAGOBS(ifilt,2)  = SNHOST_MAGOBS(ifilt,2) 
           ADDCOL_SNHOST_SBFLUXCAL(ifilt) = SNHOST_SBFLUXCAL(ifilt) 
           ADDCOL_SNHOST_SBMAG(ifilt)     = SNHOST_SBMAG(ifilt) 
         ELSE 
             ! DO_REMAP
           CALL FILTER_REMAP_FETCH(IFILTOBS,  ! (I)
     &           IFILTOBS_REMAP,IFILT_REMAP)  ! (O)

           SNRMAX         = SNLC_SNRMAX_FILT(ifilt)
           VALID_BAND     = (SNRMAX > -8.999)
           if ( .NOT. VALID_BAND ) GOTO 100

           IFILT_REMAP    = IFILT_REMAP + 1  ! C -> fortran index
           CFILTOBS_REMAP = ADDCOL_FILTERS(ifilt_remap:ifilt_remap) 
           USE            = USEFILT_REMAP(IFILTOBS_REMAP)

c check that each band is mapped.
           if ( IFILTOBS_REMAP<0 .or. IFILT_REMAP<0 ) then
             C1ERR = 'Missing REMAP for Band= ' // CFILTOBS(1:1) //
     &          '  for CID=' // SNLC_CCID(1:ISNLC_LENCCID)
             C2ERR = 'Check SNTABLE_FILTER_REMAP in &SNLCINP'
             CALL MADABORT(FNAM, c1err, c2err)
           endif

           USEFILT_REMAP(IFILTOBS_REMAP) = .TRUE.

           VAL_OLD = ADDCOL_SNRMAX(IFILT_REMAP)
           VAL_NEW = SNLC_SNRMAX_FILT(ifilt)
           ADDCOL_SNRMAX(IFILT_REMAP) = MAX(VAL_OLD,VAL_NEW)

           ADDCOL_XTMW(IFILT_REMAP) = SNLC_MWXT_FLUXFRAC(ifilt)
           ADDCOL_PROB_TRUEFLUX(IFILT_REMAP) = PROB_TRUEFLUX(ifilt)
           ADDCOL_NDOF_TRUEFLUX(IFILT_REMAP) = NDOF_TRUEFLUX(ifilt)

           VAL_OLD = ADDCOL_FLUXCALMAX(IFILT_REMAP)
           VAL_NEW = SNLC_FLUXCALMAX(ifilt)
           ADDCOL_FLUXCALMAX(IFILT_REMAP) = MAX(VAL_OLD,VAL_NEW)

           VAL_OLD = ADDCOL_CHI2_FITPKMJD(IFILT_REMAP)
           VAL_NEW = CHI2_FITPKMJD(ifilt)
           ADDCOL_CHI2_FITPKMJD(IFILT_REMAP) = VAL_OLD + VAL_NEW
     
           ADDCOL_SNHOST_MAGOBS(IFILT_REMAP,1) = 
     &            SNHOST_MAGOBS(ifilt,1)      ! any band
           ADDCOL_SNHOST_MAGOBS(IFILT_REMAP,2) = 
     &            SNHOST_MAGOBS(ifilt,2)      ! any band
           ADDCOL_SNHOST_SBFLUXCAL(IFILT_REMAP) = 
     &            SNHOST_SBFLUXCAL(ifilt)   ! any band
           ADDCOL_SNHOST_SBMAG(IFILT_REMAP) = 
     &            SNHOST_SBMAG(ifilt)   ! any band

         ENDIF

100   CONTINUE

      RETURN  
      END   ! end TABLE_ADDCOL_LOAD

C ======================================
+DECK,TBSTRTERM.
      SUBROUTINE TABLE_STRING_TERMINATION(OPT)

c Created Jan 2014 by R.Kessler
c For ROOT, terminate strings with char(0) to be used by C++/root code.
c Note that the list of table string-variables is hard-wired;
c initial set is SNLC_CCID and SNLC_FIELDLIST.
c
c
c OPT > 0 --> add termination
c OPT < 0 --> remove termination
c
c Oct 20 2020: fix index for removing termination char

      IMPLICIT NONE

      INTEGER OPT  ! (I) integer option

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LENCID, LENFLD

C ------------ BEGIN --------------

      IF ( USE_TABLEFILE_ROOT ) THEN
         LENCID  = INDEX(SNLC_CCID,     ' ') - 1
         LENFLD  = INDEX(SNLC_FIELDLIST,' ') - 1

         IF ( OPT > 0 ) THEN 
           ! add termination
           SNLC_CCID      = SNLC_CCID(1:LENCID)      // char(0)
           SNLC_FIELDLIST = SNLC_FIELDLIST(1:LENFLD) // char(0)
         ELSE
           ! remove termination char 
           SNLC_CCID(LENCID:LENCID)      = ' '
           SNLC_FIELDLIST(LENFLD:LENFLD) = ' '
         ENDIF
      ENDIF

      RETURN
      END

C ===========================================
+DECK,TABLE_MARZ.
      SUBROUTINE TABLE_MARZ(IDTABLE,IFLAG)
c
c Created May 2020 by R.Kessler
c Driver for MARZ table with host-galaxy spectra.
c
c May 3 2021: include GALID as part of NAME
c Nov 16 2023: update text to handle 12 digit GALID instead of 9 digits
c ------------------------------
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,CTRLCOM.
+CDE,SNLCCOM.
+CDE,SNLCINP.
+CDE,SNFILECOM.
+CDE,SPECCOM.
+CDE,SNSIMCOM.

      INTEGER IDTABLE  ! (I) table ID
      INTEGER IFLAG    ! (I) see IFLAG_XXX params

c local var

      LOGICAL   DO_FILL
      INTEGER   LENNAME, LENFMT, ISPEC, LENCCID, LENz, LENGALID
      CHARACTER FNAM*12, NAME*40, TEXTFMT*20, TEXTFMT_forC*20
      CHARACTER CCID_forC*40, cGALID*24, cz*20
      REAL      z
      INTEGER*8 GALID
      EXTERNAL SNTABLE_CREATE, SNTABLE_FILL, SPECPAK_DATA

C -------------------- BEGIN -----------------
      FNAM = 'TABLE_MARZ'

+SELF,IF=SNFIT,PSNID.
      c1err = 'Cannot write MARZ spectra file with fit code'
      c2err = 'MARZFILE_OUT works only with snana.exe '
      CALL MADABORT(FNAM, c1err, c2err)
+SELF.

      IF ( IFLAG .EQ. IFLAG_INI ) THEN
         NAME     = 'MARZ' // char(0)
         LENNAME  = INDEX(NAME,    ' ') - 1
         TEXTFMT_forC = 'FITS' // char(0)
         LENFMT       =  4
         CALL SNTABLE_CREATE(IDTABLE, NAME, TEXTFMT_forC, 
     &          LENNAME,LENFMT)  ! C fun

         RETURN
      ENDIF

c --------------------------
c fill table.

      DO_FILL = LSNCUTS
      IF ( DO_FILL ) THEN
         ISPEC = 1
         LENCCID   = ISNLC_LENCCID
         CCID_forC = SNLC_CCID(1:LENCCID)
         if ( LSIM_SNANA ) then
            z      = SIM_REDSHIFT_HELIO
            GALID  = SIM_HOSTLIB_GALID
            cGALID ='GALID=None'

            write(cz,41) z
 41         format('z=',F5.3)
            if ( SIM_HOSTLIB_GALID > 0 ) then
               write(cGALID,44) SIM_HOSTLIB_GALID
 44            format('GALID=', I12.12 )
            endif

            LENz     = INDEX(cz,' ') - 1
            LENGALID = INDEX(cGALID,' ') - 1
 
            write(CCID_forC,40) SNLC_CCID(1:LENCCID), 
     &          cz(1:LENz), cGALID(1:LENGALID)
40          format(A, '[', A, ',', A, ']' )
            LENCCID = LENCCID + LENz + LENGALID + 3


         endif

         write(6,10) CCID_forC(1:LENCCID)
 10      format(T8,'SPECPLOT: pack CID=',A,' for MARZ table.')

         CCID_forC = CCID_forC(1:LENCCID) // char(0)

         CALL RDSPEC_DRIVER(ISPEC)  ! Apr 5 2021

         CALL SPECPAK_DATA(
     &         CCID_forC
     &       , ID_SPECTRUM(ispec)
     &       , MJD_SPECTRUM(ispec)
     &       , TOBS_SPECTRUM(ispec)    ! May 7 2019
     &       , TEXPOSE_SPECTRUM(ispec)
     &       , NLAMBIN_SPECTRUM(ispec)
     &       , LAMMIN_SPECTRUM
     &       , LAMMAX_SPECTRUM
     &       , FLAM_SPECTRUM
     &       , FLAMERR_SPECTRUM
     &       , LENCCID )

          CALL SPECPAK_FILL(CCID_forC, LENCCID)
      ENDIF

      RETURN
      END    ! end of TABLE_MARZ


C =============================================
+DECK,CWNDUP.
      LOGICAL FUNCTION DUPLICATE_FILTER(i1,FILTERS)

c Created Sep 29, 2012
c Return TRUE if any previous filter in FILTERS
c is defined after using LOCASE on both filters.
c
c Example 1: i1=3 and FILTERS='ugrizUGRIZ'
c            i1=3 corresponds to r, and previous filters are unique.
c                --> returns FALSE since there are no duplicates.
c
c Example 2: i1=8 and FILTERS='ugrizUGRIZ'
c            i1=8 corresponds to R, which is the same as 'r' after
c            converting to lower case --> returns TRUE.
c
c ------------------------------------------
      IMPLICIT NONE

      INTEGER i1             ! (I) check this filter in the list
      CHARACTER FILTERS*(*)  ! (I) list of filster; i.e, 'gri'

c local var

      INTEGER i2
      character cfilt1*2, cfilt2*2, cfilt1_lower*2, cfilt2_lower*2

c ----------------- BEGIN ------------

      DUPLICATE_FILTER = .FALSE.

      if ( i1 .eq. 1 ) return

      cfilt1      = FILTERS(i1:i1)
      CALL LOCASE(cfilt1, cfilt1_lower)

      DO i2 = 1, i1-1
         cfilt2      = FILTERS(i2:i2)
         CALL LOCASE(cfilt2, cfilt2_lower)
         if ( cfilt1_lower .EQ. cfilt2_lower ) then
            DUPLICATE_FILTER = .TRUE.
            return
         endif
      ENDDO

      RETURN
      END

C ================================================
+DECK,INITGALXT.
      SUBROUTINE INIT_GALextinct()

c Created Sep 19 2013 by R.Kessler
c
c - Hierarchy of OPT_MWCOLORLAW (and RV) for data, in order of priority
c    -> OPT_MWCOLORLAW         (if >=0 -> read from &SNLCINP namelist)
c    -> OPT_MWCOLORLAW_DEFAULT 
c
c - Hierarchy of OPT_MWCOLORLAW for sim
c    -> OPT_MWCOLORLAW         (if >=0 -> read from &SNLCINP namelist)
c    -> SIMOPT_MWCOLORLAW      (from sim files)
c
c
c - ABORT on invalid option
c
c - print info for colorLaw and MWEBV-updates
c
c ------------------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,SNSIMCOM.

      LOGICAL   LDATA, SETMWCL_USER, SETEBV_USER, SETRV_USER
      INTEGER   LENTEXT
      CHARACTER nameOpt*20, CTEXT*60
      EXTERNAL  text_MWoption

C ---------------- BEGIN -----------

      CALL PRBANNER("INIT_GALextinct") 
                             
      LDATA         = .NOT. LSIM_SNANA
      SETMWCL_USER  = ( OPT_MWCOLORLAW  > -1   ) 
      SETEBV_USER   = ( OPT_MWEBV       > -1   ) 
      SETRV_USER    = ( RV_MWCOLORLAW   > -0.01 ) 

c ---------------------------------

      IF ( LDATA ) THEN

c     ---------- check RV ---------
         if ( SETRV_USER ) then
            write(6,22) RV_MWCOLORLAW, 'User (&SNLCINP)'
         else
            RV_MWCOLORLAW = RV_MWCOLORLAW_DEFAULT
            write(6,22) RV_MWCOLORLAW, 'Default'
         endif

c     --------- check color law ------------
         if ( SETMWCL_USER ) then
            write(6,20) OPT_MWCOLORLAW, 'User (&SNLCINP)'
         else
            OPT_MWCOLORLAW = OPT_MWCOLORLAW_DEFAULT
            write(6,20) OPT_MWCOLORLAW, 'Default'
         endif

      ENDIF


      IF ( LSIM_SNANA ) THEN

         if ( SETRV_USER ) then
            write(6,22) RV_MWCOLORLAW, 'User (&SNLCINP)'
         else
            ! use simulated RV if not set by user
            RV_MWCOLORLAW = SIM_MWRV
            write(6,22) RV_MWCOLORLAW, 'Simulation'
         endif

         if ( SETMWCL_USER ) then
            write(6,20) OPT_MWCOLORLAW, 'User (&SNLCINP)'
         else
            ! use simulated color law if not set by user
            OPT_MWCOLORLAW = SIMOPT_MWCOLORLAW
            write(6,20) OPT_MWCOLORLAW, 'Simulation'
         endif

      ENDIF
        
 20   format(T5, 'OPT_MWCOLORLAW -> ',I3   , ' from ', A)
 22   format(T5, 'RV_MWCOLORLAW  -> ',F5.2 , ' from ', A)


      nameOpt = "COLORLAW" // char(0)
      call text_MWoption(nameOpt, OPT_MWCOLORLAW, CTEXT, 8,40)

      LENTEXT = INDEX(CTEXT,char(0)) - 1
      write(6,30) OPT_MWCOLORLAW, CTEXT(1:LENTEXT)
 30   format(T5,'OPT_MWCOLORLAW =  ', I4,' -> ', A )
      call flush(6)

c ---------------------------------------------
c check for option to modify MWEBV; 

      print*,' ' 


      IF ( LDATA ) THEN
         if ( SETEBV_USER ) then
            write(6,21) OPT_MWEBV, 'User (&SNLCINP)'
         else
         ! use default MWEBV map if not set by user
            OPT_MWEBV = OPT_MWEBV_DEFAULT
            write(6,21) OPT_MWEBV, 'Default'
         endif
      ENDIF

 21   format(T5, 'OPT_MWEBV -> ',I3,' from ', A)

      IF ( LSIM_SNANA ) THEN
         if ( SETEBV_USER ) then
            write(6,21) OPT_MWEBV, 'User (&SNLCINP)'
         else
         ! use simulated MWEBV value if option is not set by user
            OPT_MWEBV = 1       ! don't change  MWEBV in sim-data file
            write(6,21) SIMOPT_MWEBV, 'Simulation'
         endif
      ENDIF
        
      nameOpt = "EBV" // char(0)
      call text_MWoption(nameOpt, OPT_MWEBV, CTEXT, 3,40)
      LENTEXT = INDEX(CTEXT,char(0)) - 1
      write(6,40) OPT_MWEBV, CTEXT(1:LENTEXT)
 40   format(T5,'OPT_MWEBV =  ',I3,' -> ', A )
      call flush(6)

      RETURN
      END     ! end of INIT_GALextinct()

C =======================
+PATCH,*CALIB.
C =======================

C ===========================================
+DECK,NEAREST_IFILTDEF_WRAPPER.
      INTEGER FUNCTION NEAREST_IFILTDEF_WRAPPER( 
     &   OPT          ! (I) option; see below
     &  ,ifiltdef     ! (I) observer filter index
     &  ,rank_want    ! (I) 1=nearest, 2=2nd nearest, 3=3rd nearest
     &  ,Z            ! (I) redshift
     &  ,LAMDIF_MIN   ! (O) min lam-distance (A) 
     &    )

c
c Created Nov 2022
c Temporary wrapper to select either LEGACY/fortran function,
c or REFACTORED/C function. This function should be removed
c after the transistion to refactored code.

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER OPT, IFILTDEF, RANK_WANT
      REAL    z,  LAMDIF_MIN
      REAL*8  z8, LAMDIF_MIN8

      CHARACTER FNAM*32
      INTEGER NEAREST_IFILT_REST     ! lefacy fortran func
      INTEGER NEAREST_IFILTDEF_REST  ! refactored C code
C ------------- BEGIN -------------

         z8 = DBLE(z)  
         FNAM = 'NEAREST_IFILTDEF_WRAPPER' // char(0)
         NEAREST_IFILTDEF_WRAPPER = 
     &   NEAREST_IFILTDEF_REST(OPT, IFILTDEF,RANK_WANT,
     &                         z8, FNAM, LAMDIF_MIN8, 32)
         LAMDIF_MIN = SNGL(LAMDIF_MIN8)


      RETURN
      END     ! end NEAREST_IFILTDEF_WRAPPER


C =======================================
+DECK,FUPDDRIV.
      SUBROUTINE FILTER_UPDATE_DRIVER()
c
c Nov 8, 2010 R.Kessler
c
c --------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,FILTCOM.
+CDE,FILTUPDCM.

c local var

      INTEGER IFILT, IFILT_OBS, OPT
      LOGICAL LSAME, LUPD, ISBX
      CHARACTER C1ERR*80, C2err*80

c function
      LOGICAL ISBXFILT
C ------------- BEGIN ----------

      OPT = OPT_FILTER_UPDATE
      IF ( OPT .LE. 0 ) RETURN

      write(6,20) SNLC_CCID(1:ISNLC_LENCCID)
 20   format(T5,'***** UPDATE FILTER TRANSMISSION FOR CID = ', 
     &       A, ' ***** ')


      LUPD = ( OPT .EQ. OPT_FILTUPD_EACHSN ) .or.
     &       ( OPT .EQ. OPT_FILTUPD_MAP    )

c determine path with filter update; set global FILTER_UPDATE_DIR
c Make sure to do this outside the IFILT loop to avoid redundant
c loops through the maps.
      IF ( LUPD ) CALL GET_FILTER_UDPATE_DIR(SNLC_CCID)

c -----------------------------------------
c update filter transmissions based on option

      DO 10 IFILT = 1, NFILTDEF_SURVEY

        if ( ISNLC_NEPOCH_FILT(ifilt) .LE. 0 ) GOTO 10

        ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
        DOFLAG_FILTER_UPDATE(ifilt_obs) = OPT_FILTER_UPDATE

        ISBX      = ISBXFILT(ifilt_obs,'', 'OBS' )
   
        LSAME = (OPT .EQ. OPT_FILTUPD_SAMEFILT)  .or. ISBX

        if ( LSAME  ) then
            ! fancy way to use same filter response for each SN
           CALL FILTER_UPDATE_SAMEFILT(ifilt)
        else if ( LUPD ) then
           CALL FILTER_UPDATE_EACHSN(ifilt) 

        else
           write(c1err,60) OPT
60         format('Invalid  OPT_FILTER_UPDATE = ', I3 )
           c2err = 'Check OPT_FILTUPD_*  parameters in snana.car'
           CALL MADABORT("FILTER_UPDATE_DRIVER", C1ERR, C2ERR)
        endif

 10   CONTINUE
      

c ----------------------------------------------------
c  Finally, update ZP offsets for all filters.

      IF ( LUPD ) THEN
        CALL FILTER_UPDATE_ZPOFF()
      ENDIF

c later add stuff for K-corrections ... 

      RETURN
      END

C ====================================
+DECK,FUPDZP.
      SUBROUTINE FILTER_UPDATE_ZPOFF()

c Created July 2011
c Update MAGOBS_SHIFT_ZP_FILT(ifilt_obs) based on the
c zeropoint (AB) offsets in text-file $FDIR/ZPOFF.DAT .
c If this ZPOFF.DAT file does not exist, then just set 
c the offsets to the user offsets.
c
c -------------

      IMPLICIT NONE


c local args

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
c+CDE,PARSECOM.

      INTEGER IFILT, IFILT_OBS
      REAL ZPOFF_UPD(MXFILT_ALL)

C --------------- BEGIN -------------

       DO ifilt  = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          ZPOFF_UPD(ifilt_obs) = 0.0
       ENDDO

c update ZP-shift for each filter (i.e., add to user-shift)
      DO ifilt  = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         MAGOBS_SHIFT_ZP_FILT(ifilt_obs) = 
     &   MAGOBS_SHIFT_ZP_USER(ifilt_obs) + ZPOFF_UPD(ifilt_obs)
      ENDDO

      CALL DMP_ZPOFF

      RETURN
      END  ! end FILTER_UPDATE_ZPOFF

C ================================================
+DECK,GTFUPDDIR.
      SUBROUTINE GET_FILTER_UDPATE_DIR(CCID)

c Created May 18, 2012
c Find and load global  FILTER_UPDATE_DIR for this CCID.
c Used for filter-update option.

      IMPLICIT NONE

      CHARACTER CCID*(*)  ! (I) SN name

c local var

+CDE,SNPAR.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER LPDIR, LSDIR, LPATH, LCC, LMAP, IMAP1, IMAP2
      CHARACTER MAPDIR*100
c functions
      INTEGER IMAP2_FUPDMATCH

C -------------------- BEGIN --------------

      LCC   = INDEX(CCID,' ') - 1
      LPDIR = INDEX(PREFIX_UPD_FILTDIR,' ') -1 
      LSDIR = INDEX(SUFFIX_UPD_FILTDIR,' ') -1 
      LPATH = INDEX(FILTER_UPDATE_TOPDIR,' ') - 1


      if ( OPT_FILTER_UPDATE .EQ. OPT_FILTUPD_EACHSN ) then
         FILTER_UPDATE_DIR = FILTER_UPDATE_TOPDIR(1:LPATH) // '/' 
     &        // PREFIX_UPD_FILTDIR(1:LPDIR)
     &        // CCID(1:LCC)
     &        // SUFFIX_UPD_FILTDIR(1:LSDIR)

      else if ( OPT_FILTER_UPDATE .EQ. OPT_FILTUPD_MAP ) then

c search 2nd map for CCID match to get IMAP1
         
         IMAP2   = IMAP2_FUPDMATCH(CCID) 
         IMAP1   = MAP2_FILTER_UPDATE_PTRMAP1(IMAP2)
         MAPDIR  = MAP1_FILTER_UPDATE_SUBDIR(IMAP1)
         LMAP    = INDEX(MAPDIR,' ') - 1
         FILTER_UPDATE_DIR = FILTER_UPDATE_TOPDIR(1:LPATH) // '/' 
     &             // MAPDIR(1:LMAP)   

      endif

      RETURN
      END

C ================================================
+DECK,FUPD_EACHSN.
      SUBROUTINE FILTER_UPDATE_EACHSN(ifilt)

c Nov 8, 2010
c Read/update filter response for this sparse 'ifilt'
c Store in FILTOBS_TRANS_UPD array using same lambda 
c binning as in KCOR file. Updated lambda binning 
c can be different since it gets interpolated to the 
c original grid.
c
c Nov 2022: refactor to use new & old kcor/calib code.
c Dec 2023: remove fortran OPEN and rely on rd2column to read gzipped or unzipped files.
c

      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
c +CDE,PARSECOM.

c subroutine args
      INTEGER IFILT     ! (I) sparse indices

c local var

      INTEGER 
     &   IFILT_OBS, L0, LCC, LREF, LSN, LDIR, LTMPF, LCOM
     &  ,LPSN, LPREF, LSSN, LSREF, ilam, NLAM_UPD, NLAM_STORE
     &  ,istat, MXLAM, OPT_INTERP, OPT_FRAME, OPT_RD2COL

      CHARACTER 
     &   FILTFILE_SN*(MXCHAR_FILENAME)   ! SN tranmission vs. lambda
     &  ,FILTFILE_REF*(MXCHAR_FILENAME)  ! idem for primary ref
     &  ,TMPFILE*(MXCHAR_FILENAME)
     &  ,CCID*(MXCHAR_CCID)
     &  ,cfilt*1
     &  ,c1err*80
     &  ,c2err*80
     &  ,comment*40 

      REAL*8
     &   LAM
     &  ,FLAM_UPD(MXLAMBIN_FILT)    ! temp lambda array
     &  ,FTRANS_UPD(MXLAMBIN_FILT)  ! temp filterTrans array
     &  ,Trans_upd
     &  ,FLAM_STORE(MXLAMBIN_FILT) ! store trans on this lam array
     &  ,FTRANSSN_STORE(MXLAMBIN_FILT)
     &  ,FTRANSREF_STORE(MXLAMBIN_FILT)

      LOGICAL  LEXIST_SN, LEXIST_REF, UPD_DUMP

c define utilities from sntools.c
      INTEGER  RD2COLUMNFILE 
      EXTERNAL RD2COLUMNFILE 
  
      REAL*8   INTERP_1DFUN
      EXTERNAL INTERP_1DFUN
      EXTERNAL LOAD_FILTERTRANS_CALIB, GET_CALIB_FILTERLAM

C ---------------- BEGIN --------------

      UPD_DUMP = .FALSE.  ! internal dump logical

      ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
      cfilt     = filtdef_string(ifilt_obs:ifilt_obs)   
      LCC       = INDEX(SNLC_CCID, ' '     ) - 1 
      CCID      = SNLC_CCID(1:LCC)


       OPT_FRAME = OPT_FILTOBS - 1
       CALL  GET_CALIB_FILTERLAM(OPT_FRAME, IFILT_OBS, 
     &                      NLAM_STORE, FLAM_STORE)


c - - - - - 
      if (UPD_DUMP) then
        print*,' '
        print*, 'XXXXXX ----------------------------------------- '
        print*, 'XXXXXX FILTER_UPDATE_EACHSN  DUMP start for ', 
     &       CCID(1:LCC),'-', cfilt
        call flush(6)
      end if 

      OPT_INTERP = 1   ! 1=linear;  2=quadratic

      comment = CCID(1:LCC) // '-filter-update' // char(0)
      LCOM    = INDEX(comment,' ') - 1

c     get string lengths for file name

      LPSN  = INDEX(PREFIX_UPD_TRANSSN,' ') -1 
      LSSN  = INDEX(SUFFIX_UPD_TRANSSN,' ') -1 

      LPREF = INDEX(PREFIX_UPD_TRANSREF,' ') -1 
      LSREF = INDEX(SUFFIX_UPD_TRANSREF,' ') -1 

      L0    = INDEX(FILTER_UPDATE_PATH, ' ' ) - 1
      LDIR = INDEX(FILTER_UPDATE_DIR,' ') - 1

c construct full filename of SN and REF-transmission files.

      TMPFILE = PREFIX_UPD_TRANSSN(1:LPSN)   
     &           // cfilt // SUFFIX_UPD_TRANSSN(1:LSSN)
      LTMPF = INDEX(TMPFILE,' ') - 1
      FILTFILE_SN = FILTER_UPDATE_DIR(1:LDIR)  
     &                 // '/' // TMPFILE(1:LTMPF) 

      TMPFILE = PREFIX_UPD_TRANSREF(1:LPREF)   
     &          // cfilt // SUFFIX_UPD_TRANSREF(1:LSREF)
      LTMPF = INDEX(TMPFILE,' ') - 1
      FILTFILE_REF = FILTER_UPDATE_DIR(1:LDIR)  
     &          // '/' // TMPFILE(1:LTMPF) 


      if ( UPD_DUMP ) then
        print*, '++++ UPDATING FILTER ' 
     &          ,'IFILT = ', ifilt_obs,' '
     &         , cfilt(1:1), ' with NLAM '
     &         , NLAM_STORE , ' for SN ', CCID
        call flush(6)
       end if


c Use IOSTAT option to figure out which of the files
c FILTFILE_REF  and FILTFILE_SN exist

      OPT_RD2COL = 1  ! rd2columun does NOT abort on missing file

c     check if FILTFILE_REF exists?


      MXLAM   = MXLAMBIN_FILT
      LREF    = INDEX(FILTFILE_REF,' ') - 1
      TMPFILE = FILTFILE_REF(1:LREF) // char(0)
      istat   = rd2columnFile (TMPFILE, MXLAM, NLAM_UPD,
     &                 FLAM_UPD, FTRANS_UPD, OPT_RD2COL, LREF)  ! (out)
      LEXIST_REF = (istat > 0 ) 

      if (UPD_DUMP) then 
        print*, '  LEXIST_REF = ', LEXIST_REF,' for ', CCID
        call flush(6)
      end if

c - - - - - -
c    now interpolate to the original grid
c    for files which exist

      IF ( LEXIST_REF ) THEN
        DO 20 ilam = 1, NLAM_STORE
            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) = 0.0 
 
            LAM = FLAM_STORE(ilam)
            FTRANSREF_STORE(ilam) = 0.0 

            if ( LAM .LT. FLAM_UPD(1)        ) GOTO 20
            if ( LAM .GT. FLAM_UPD(NLAM_UPD) ) GOTO 20
 
            Trans_upd = interp_1dfun(OPT_INTERP, LAM, 
     &                  NLAM_UPD, FLAM_UPD, FTRANS_UPD, comment, LCOM)

            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) = sngl(Trans_upd) 
            FTRANSREF_STORE(ilam)  = Trans_upd

20      CONTINUE  ! ILAM loop over original lambda binning
        if (UPD_DUMP) then
          print*, "REF interp done"
          call flush(6)
        end if 

      ENDIF  ! end LEXIST_REF


c ------------------------------------
c     FILTFILE_SN exists?

      LSN     = INDEX(FILTFILE_SN,' ') - 1
      MXLAM   = MXLAMBIN_FILT
      TMPFILE = FILTFILE_SN(1:LSN) // char(0)
      istat   = rd2columnFile (TMPFILE, MXLAM, NLAM_UPD,
     &                 FLAM_UPD, FTRANS_UPD, OPT_RD2COL, LSN)  ! (out)
      LEXIST_SN = (istat > 0 )

c - - - - - - - 
c   INTERPOLATE to get FILTOBS_TRANSSN_UPD

      IF (LEXIST_SN) THEN
cc      print*, ' Interpolate SN file', NLAM_STORE
        DO 70 ilam = 1, NLAM_STORE
            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) = 0.0 

            LAM = FLAM_STORE(ilam)
            FTRANSSN_STORE(ilam) = 0.0 

            if ( LAM .LT. FLAM_UPD(1)        ) GOTO 70
            if ( LAM .GT. FLAM_UPD(NLAM_UPD) ) GOTO 70
 
            Trans_upd = interp_1DFUN(OPT_INTERP, LAM, 
     &             NLAM_UPD, FLAM_UPD, FTRANS_UPD, comment, LCOM )

            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) = sngl(Trans_upd) 
            FTRANSSN_STORE(ilam) = Trans_upd

70      CONTINUE  ! ILAM loop over original lambda binning
        if (UPD_DUMP) then
          print*, 'SN Interp done for', NLAM_STORE, CCID
          call flush(6)
        end if
      ENDIF


c    If neither file exists, abort program


      if (.NOT.( LEXIST_REF .OR. LEXIST_SN) ) then        
        c1err = 'Could not update filter-trans for CID = ' 
     &       // CCID(1:LCC) // '-' // cfilt
        c2err = 'FILTDIR=' // FILTER_UPDATE_DIR(1:LDIR)
        CALL MADABORT('FILTER_UPDATE_EACHSN', c1err, c2err )
      endif

c     IF either SN or REF file does not exist, copy the other 
c     file for the transmission functions


c     SN File does not exist. IF REF file exists, SN trans= Ref Trans
c                             IF REF file does not exist, SN trans undef
c                             but should have been aborted above

      if (.NOT. LEXIST_SN ) then 
        DO 170 ilam = 1, NLAM_STORE
            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) =  
     &      FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) 

            FTRANSSN_STORE(ilam) = FTRANSREF_STORE(ilam)
170     CONTINUE  ! ILAM loop over original lambda binning
      end if


c - - - - - - - - -
c     REF File does not exist. IF SN file exists, Ref trans= SN Trans
c                             IF SN file does not exist, Ref trans undef
c                             but should have been aborted above
      IF (.NOT. LEXIST_REF ) THEN
        DO 270 ilam = 1, NLAM_STORE
            LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS) 
            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) =
     &      FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) 

            FTRANSREF_STORE(ilam) = FTRANSSN_STORE(ilam)
270      CONTINUE  ! ILAM loop over original lambda binning
      ENDIF

      CALL LOAD_FILTERTRANS_CALIB(OPT_FRAME, IFILT_OBS, NLAM_STORE,
     &         FLAM_STORE, FTRANSSN_STORE )

c -----------------------------
      if ( UPD_DUMP ) then 
        print*, '%%%% ', NLAM_STORE
        if (mod(NLAM_STORE,2).EQ.0) then
           ilam = NLAM_STORE/2
        else
         ilam = (NLAM_STORE+1)/2
        end if
        LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS)
        print*, 'xxxxx', NLAM_STORE 
     &        , sngl(FTRANSSN_STORE(ilam))
     &        , sngl(FTRANSREF_STORE(ilam))

        print*, 'xxxx SN =' , CCID
        print*, 'xxxx LEXIST_REF =', LEXIST_REF
        print*, 'xxxx LEXIST_SN  =', LEXIST_SN
        print*, 'xxxx FILE_REF   =', FILTFILE_REF
        print*, 'xxxx FILE_SN    =', FILTFILE_SN

        print*, 'XXXXXX FILTER_UPDATE_EACHSN  DUMP end for ', CCID
        call flush(6)
      endif


      RETURN
      END   ! end FILTER_UPDATE_EACHSN


C ================================================
+DECK,FUPD_EACHSN_LEGACY.
      SUBROUTINE FILTER_UPDATE_EACHSN_LEGACY(ifilt)

c Nov 8, 2010
c Read/update filter response for this sparse 'ifilt'
c Store in FILTOBS_TRANS_UPD array using same lambda 
c binning as in KCOR file. Updated lambda binning 
c can be different since it gets interpolated to the 
c original grid.
c
c Nov 2022: refactor to use new & old kcor/calib code.
c

      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
c +CDE,PARSECOM.

c subroutine args
      INTEGER IFILT     ! (I) sparse indices

c local var

      INTEGER 
     &   IFILT_OBS, L0, LCC, LL, LDIR, LTMPF, LCOM
     &  ,LPSN, LPREF, LSSN, LSREF, ilam, NLAM_UPD, NLAM_STORE
     &  ,istat, MXLAM, OPT_INTERP, OPT_FRAME, OPT_RD2COL

      CHARACTER 
     &   FILTFILE_SN*(MXCHAR_FILENAME)   ! SN tranmission vs. lambda
     &  ,FILTFILE_REF*(MXCHAR_FILENAME)  ! idem for primary ref
     &  ,TMPFILE*(MXCHAR_FILENAME)
     &  ,CCID*(MXCHAR_CCID)
     &  ,cfilt*1
     &  ,c1err*80
     &  ,c2err*80
     &  ,comment*40 

      REAL*8
     &   LAM
     &  ,FLAM_UPD(MXLAMBIN_FILT)    ! temp lambda array
     &  ,FTRANS_UPD(MXLAMBIN_FILT)  ! temp filterTrans array
     &  ,Trans_upd
     &  ,FLAM_STORE(MXLAMBIN_FILT) ! store trans on this lam array
     &  ,FTRANSSN_STORE(MXLAMBIN_FILT)
     &  ,FTRANSREF_STORE(MXLAMBIN_FILT)
     
      LOGICAL  LEXIST_SN, LEXIST_REF, UPD_DUMP

c define utilities from sntools.c
      INTEGER  RD2COLUMNFILE 
      EXTERNAL RD2COLUMNFILE 
  
      REAL*8   INTERP_1DFUN
      EXTERNAL INTERP_1DFUN
      EXTERNAL LOAD_FILTERTRANS_CALIB, GET_CALIB_FILTERLAM

C ---------------- BEGIN --------------

      UPD_DUMP = .FALSE.  ! internal dump logical

      ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
      cfilt     = filtdef_string(ifilt_obs:ifilt_obs)   
      LCC       = INDEX(SNLC_CCID, ' '     ) - 1 
      CCID      = SNLC_CCID(1:LCC)

      OPT_FRAME = OPT_FILTOBS - 1
      CALL  GET_CALIB_FILTERLAM(OPT_FRAME, IFILT_OBS, 
     &                      NLAM_STORE, FLAM_STORE)

c - - - - - 
      if (UPD_DUMP) then
        print*,' '
        print*, 'XXXXXX ----------------------------------------- '
        print*, 'XXXXXX FILTER_UPDATE_EACHSN  DUMP start for ', 
     &       CCID(1:LCC),'-', cfilt
        call flush(6)
      end if 

      OPT_INTERP = 1   ! 1=linear;  2=quadratic

      comment = CCID(1:LCC) // '-filter-update' // char(0)
      LCOM    = INDEX(comment,' ') - 1

c     get string lengths for file name

      LPSN  = INDEX(PREFIX_UPD_TRANSSN,' ') -1 
      LSSN  = INDEX(SUFFIX_UPD_TRANSSN,' ') -1 

      LPREF = INDEX(PREFIX_UPD_TRANSREF,' ') -1 
      LSREF = INDEX(SUFFIX_UPD_TRANSREF,' ') -1 

      L0    = INDEX(FILTER_UPDATE_PATH, ' ' ) - 1
      LDIR = INDEX(FILTER_UPDATE_DIR,' ') - 1

c construct full filename of SN and REF-transmission files.

      TMPFILE = PREFIX_UPD_TRANSSN(1:LPSN)   
     &           // cfilt // SUFFIX_UPD_TRANSSN(1:LSSN)
      LTMPF = INDEX(TMPFILE,' ') - 1
      FILTFILE_SN = FILTER_UPDATE_DIR(1:LDIR)  
     &                 // '/' // TMPFILE(1:LTMPF) 

      TMPFILE = PREFIX_UPD_TRANSREF(1:LPREF)   
     &          // cfilt // SUFFIX_UPD_TRANSREF(1:LSREF)
      LTMPF = INDEX(TMPFILE,' ') - 1
      FILTFILE_REF = FILTER_UPDATE_DIR(1:LDIR)  
     &          // '/' // TMPFILE(1:LTMPF) 


      if ( UPD_DUMP ) then
        print*, '++++ UPDATING FILTER ' 
     &          ,'IFILT = ', ifilt_obs,' '
     &         , cfilt(1:1), ' with NLAM '
     &         , NLAM_STORE , ' for SN ', CCID
        call flush(6)
       end if


      OPT_RD2COL = 1

c Use IOSTAT option to figure out which of the files
c FILTFILE_REF  and FILTFILE_SN exist

c     check if FILTFILE_REF exists?

      istat=1
      LL = INDEX(FILTFILE_REF,' ') - 1
      TMPFILE =FILTFILE_REF(1:LL)
      OPEN(UNIT=LUNTMP, FILE=TMPFILE, STATUS='OLD',
     &      IOSTAT=istat)
      CLOSE( UNIT = LUNTMP) 

      if (istat .EQ. 0) then
         LEXIST_REF = .true.
         MXLAM   = MXLAMBIN_FILT
         TMPFILE = FILTFILE_REF(1:LL) // char(0)
         istat   = rd2columnFile (TMPFILE, MXLAM, NLAM_UPD 
     &            ,FLAM_UPD, FTRANS_UPD, OPT_RD2COL, LL)  ! (out)

      else 
          LEXIST_REF = .false.
      endif 

      if (UPD_DUMP) then 
        print*, '  LEXIST_REF = ', LEXIST_REF,' for ', CCID
        call flush(6)
      end if

c - - - - - -
c    now interpolate to the original grid
c    for files which exist

      IF ( LEXIST_REF ) THEN
        DO 20 ilam = 1, NLAM_STORE
            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) = 0.0 
 
            LAM = FLAM_STORE(ilam)
            FTRANSREF_STORE(ilam) = 0.0 

            if ( LAM .LT. FLAM_UPD(1)        ) GOTO 20
            if ( LAM .GT. FLAM_UPD(NLAM_UPD) ) GOTO 20
 
            Trans_upd = interp_1dfun(OPT_INTERP, LAM, 
     &                  NLAM_UPD, FLAM_UPD, FTRANS_UPD, comment, LCOM)

            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) = sngl(Trans_upd) 
            FTRANSREF_STORE(ilam)  = Trans_upd

20      CONTINUE  ! ILAM loop over original lambda binning
        if (UPD_DUMP) then
          print*, "REF interp done"
          call flush(6)
        end if 

      ENDIF  ! end LEXIST_REF


c ------------------------------------
c     FILTFILE_SN exists?


      istat=1
      LL = INDEX(FILTFILE_SN,' ') - 1
      TMPFILE =FILTFILE_SN(1:LL)
      OPEN(UNIT=LUNTMP, FILE=TMPFILE, STATUS='OLD',
     &  IOSTAT=istat)
     
      if (istat.EQ.0) then
         LEXIST_SN = .true.
c        readsnfile
         MXLAM   = MXLAMBIN_FILT
         TMPFILE = FILTFILE_SN(1:LL) // char(0)
         istat   = rd2columnFile (TMPFILE, MXLAM, NLAM_UPD 
     &            ,FLAM_UPD, FTRANS_UPD, OPT_RD2COL, LL)  ! (out)
      else 
         LEXIST_SN = .false.
      endif 

      CLOSE( UNIT = LUNTMP) 

c - - - - - - - 
c   INTERPOLATE to get FILTOBS_TRANSSN_UPD

      IF (LEXIST_SN) THEN
cc      print*, ' Interpolate SN file', NLAM_STORE
        DO 70 ilam = 1, NLAM_STORE
            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) = 0.0 

            LAM = FLAM_STORE(ilam)
            FTRANSSN_STORE(ilam) = 0.0 

            if ( LAM .LT. FLAM_UPD(1)        ) GOTO 70
            if ( LAM .GT. FLAM_UPD(NLAM_UPD) ) GOTO 70
 
            Trans_upd = interp_1DFUN(OPT_INTERP, LAM, 
     &             NLAM_UPD, FLAM_UPD, FTRANS_UPD, comment, LCOM )

            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) = sngl(Trans_upd) 
            FTRANSSN_STORE(ilam) = Trans_upd

70      CONTINUE  ! ILAM loop over original lambda binning
        if (UPD_DUMP) then
          print*, 'SN Interp done for', NLAM_STORE, CCID
          call flush(6)
        end if
      ENDIF


c    If neither file exists, abort program


      if (.NOT.( LEXIST_REF .OR. LEXIST_SN) ) then        
        c1err = 'Could not update filter-trans for CID = ' 
     &       // CCID(1:LCC) // '-' // cfilt
        c2err = 'FILTDIR=' // FILTER_UPDATE_DIR(1:LDIR)
        CALL MADABORT('FILTER_UPDATE_EACHSN', c1err, c2err )
      endif

c     IF either SN or REF file does not exist, copy the other 
c     file for the transmission functions


c     SN File does not exist. IF REF file exists, SN trans= Ref Trans
c                             IF REF file does not exist, SN trans undef
c                             but should have been aborted above

      if (.NOT. LEXIST_SN ) then 
        DO 170 ilam = 1, NLAM_STORE
            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) =  ! xxx mark
     &      FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS)   ! xxx mark

            FTRANSSN_STORE(ilam) = FTRANSREF_STORE(ilam)
170     CONTINUE  ! ILAM loop over original lambda binning
      end if


c - - - - - - - - -
c     REF File does not exist. IF SN file exists, Ref trans= SN Trans
c                             IF SN file does not exist, Ref trans undef
c                             but should have been aborted above
      IF (.NOT. LEXIST_REF ) THEN
        DO 270 ilam = 1, NLAM_STORE
            LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS) 
            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) =
     &      FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) 

            FTRANSREF_STORE(ilam) = FTRANSSN_STORE(ilam)
270      CONTINUE  ! ILAM loop over original lambda binning
      ENDIF

       CALL LOAD_FILTERTRANS_CALIB(OPT_FRAME, IFILT_OBS, NLAM_STORE,
     &         FLAM_STORE, FTRANSSN_STORE )

c -----------------------------
      if ( UPD_DUMP ) then 
        print*, '%%%% ', NLAM_STORE
        if (mod(NLAM_STORE,2).EQ.0) then
           ilam = NLAM_STORE/2
        else
         ilam = (NLAM_STORE+1)/2
        end if
        LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS)
        print*, 'xxxxx', NLAM_STORE 
     &        , sngl(FTRANSSN_STORE(ilam))
     &        , sngl(FTRANSREF_STORE(ilam))

        print*, 'xxxx SN =' , CCID
        print*, 'xxxx LEXIST_REF =', LEXIST_REF
        print*, 'xxxx LEXIST_SN  =', LEXIST_SN
        print*, 'xxxx FILE_REF   =', FILTFILE_REF
        print*, 'xxxx FILE_SN    =', FILTFILE_SN

        print*, 'XXXXXX FILTER_UPDATE_EACHSN  DUMP end for ', CCID
        call flush(6)
      endif


      RETURN
      END   ! end FILTER_UPDATE_EACHSN_LEGACY


C =======================================
+DECK,IMAP2FUPD.
      INTEGER FUNCTION IMAP2_FUPDMATCH(CCID)

c Created May 19, 2012
c Search array IMAP2_FILTER_UPDATE_CCID(imap2)
c to find CCID match; return IMAP2 = index of array.
c Used to match CCID to sparse index associated
c with the filter-subdir.

      IMPLICIT NONE
      CHARACTER CCID*(*)  ! (I) SN name to match

c local  var

+CDE,SNPAR.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER IMAP2, L0, L1
      CHARACTER CCID_TMP*(MXCHAR_CCID), C1ERR*72, C2ERR*72

C ---------------- BEGIN ------------------

      IMAP2_FUPDMATCH = -9
      L0 = INDEX(CCID,' ') - 1

      DO 100 IMAP2 = 1, NMAP2_FILTER_UPDATE

         CCID_TMP  = MAP2_FILTER_UPDATE_CCID(IMAP2)
         L1 = INDEX(CCID_TMP // ' ',' ') - 1

         IF ( L0 .NE. L1 ) GOTO 100
         IF ( CCID(1:L0) .NE. CCID_TMP(1:L1) ) GOTO 100

c if we get here then return
         IMAP2_FUPDMATCH = IMAP2
         RETURN

100   CONTINUE


c if we get here then abort.
      write(c1err,61) CCID(1:8)
61    format('Could not find MAP2_FILTER_UPDATE match for CID=',A)
      c2err = 'Check FILTER.INFO file.'
      CALL MADABORT('IMAP2_FUPDMATCH', c1err, c2err )


      RETURN
      END

C ================================================
+DECK,FUPD_SAME.
      SUBROUTINE FILTER_UPDATE_SAMEFILT(ifilt)
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
c +CDE,PARSECOM.

      INTEGER ifilt  ! (I) sparse SN & filter index

c local variables

      INTEGER ilam, NLAM, ifilt_obs

C ------------ BEGIN -------------

      ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
      NLAM      = NLAMBIN_FILTOBS(ifilt_obs)

      DO 100 ilam = 1, NLAM

          FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) = 
     &    FILTOBS_TRANS(ilam,IFILT_OBS) 

          FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) = 
     &    FILTOBS_TRANS(ilam,IFILT_OBS) 
100   CONTINUE

      RETURN
      END   ! end FILTER_UPDATE_SAMEFILT

C ==========================================
+DECK,SETZPOFF.
      SUBROUTINE SET_ZPOFF()
c
c Created July 17, 2011 by R.Kessler
c Called from RDKCOR to update MAGOBS_SHIFT_ZP_FILT(ifilt_obs) 
c for each filter. Update based on FILTOBS_ZPOFF_SNPHOT(ifilt_obs) 
c that is read either from the KCOR file or from the ZPOFF_FILE.
c
c Feb 22, 2012:
c  Use MAGOBS_SHIFT_ZP_USER(ifilt_obs)  so that final
c  SHIFT_ZP is OK even if RDKCOR is called multiple times.
c -------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,SNFILECOM.  SNDATA_ROOT is here
+CDE,FILTCOM.

      INTEGER IFILT, IFILT_OBS

C ------------- BEGIN -----------

c update ZP-shift for each filter (i.e., add to user-shift)
      DO ifilt  = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          MAGOBS_SHIFT_ZP_FILT(ifilt_obs) = 
     &    MAGOBS_SHIFT_ZP_USER(ifilt_obs) +
     &    FILTOBS_ZPOFF_SNPHOT(ifilt_obs)
      ENDDO

c check for lambda-dependent MAGOBS_SHIFT (Sep 30, 2015)
      CALL MAGOBS_SHIFT_UPDATE()

c dump ZPOFF values vs. filter
      CALL DMP_ZPOFF 

      RETURN
      END  ! end of SET_ZPOFF

C ==========================================
+DECK,DMP_ZPOFF.
      SUBROUTINE DMP_ZPOFF

c --------------------------
c Created Jul 17, 2011
c Dump zeropoint offsets to screen.
c
c Feb 2016: dump only obs-filters in kcor file; ingore un-defined filters.
c Nov 2022: separate filter loop over OBS and REST frame so that it works
c           for both legacy and refac kcor.
c
c July 2024: clarify stdout comment that ZP offsets are from ZPOFF.DAT file
c            and from user MAGOBS_SHIFT_ZP ... not from kcor-input file.
c -------------------------
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.

      REAL      ZPOFF_TOT
      INTEGER   ifilt_obs, ifilt_rest, ifilt
      character CFILT*2

C ------------------ BEGIN ------------

      print*,' '
      print*,'    Extra ZP offsets from ZPOFF.DAT + ' //
     &            '&SNLCINP MAGOBS_SHIFT_ZP:'
      
      DO 100 ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)     
         if ( ifilt_obs .EQ. IFILT_BESS_BX ) goto 100
         cfilt     = filtdef_string(ifilt_obs:ifilt_obs)
         ZPOFF_TOT = MAGOBS_SHIFT_ZP_FILT(ifilt_obs) 
         write(6,801) 'MAGOBS', cfilt(1:1), ZPOFF_TOT   
100   CONTINUE

      DO 200 ifilt = 1, NFILTDEF_REST
         ifilt_rest = IFILTDEF_MAP_REST(ifilt)     
         if ( ifilt_rest .EQ. IFILT_BESS_BX ) goto 200
         cfilt     = filtdef_string(ifilt_rest:ifilt_rest)
         ZPOFF_TOT = MAGREST_SHIFT_ZP_FILT(ifilt_rest) 
         write(6,801) 'MAGREST', cfilt(1:1), ZPOFF_TOT 
200   CONTINUE

801     format(T10,'Will apply extra ', 
     &     A,'_SHIFT_ZP(',A,') = ', F7.4 )

      CALL FLUSH(6)

      RETURN
      END  ! end of DMP_ZPOFF


C ======================================
+DECK,FILTBTEST.
      LOGICAL FUNCTION FILTBTEST(MSK8,ibit)
c Mar 29, 2011
C Return true if 1 <= IBIT < 90 is set in MSK8.
c Note that LSB=1 (not 0)
c

      INTEGER   IBIT    ! (I) bit to set 
      INTEGER*8 MSK8(2) ! (I/O) 8-byte mask to set

      INTEGER IBIT2
      INTEGER MXBIT
      PARAMETER ( MXBIT =  60 )

      LOGICAL LTMP
C ------------ BEGIN ------------

      if ( IBIT .LE. MXBIT ) then
        LTMP = BTEST(MSK8(1),IBIT-1)
      else if ( IBIT .LT. 2*MXBIT ) then
        IBIT2  = IBIT-MXBIT
        LTMP   = BTEST(MSK8(2),IBIT2-1)
      endif
      FILTBTEST = LTMP
      RETURN
      END

C ======================================
+DECK,FILTBSET.
      SUBROUTINE FILTBSET(MSK8,ibit)
c Mar 29, 2011
C set bit IBIT(1 to 2*MXBIT) for long int MSK8.
c Note that the input argument is also the output
c with IBIT set.

      INTEGER   IBIT    ! (I) bit to set 
      INTEGER*8 MSK8(2) ! (I/O) 8-byte mask to set

      INTEGER IBIT2
      INTEGER MXBIT
      PARAMETER ( MXBIT =  60 )

C ------------ BEGIN ------------

      if ( IBIT .LE. MXBIT ) then
        MSK8(1) = IBSET(MSK8(1),IBIT-1)
      else if ( IBIT .LT. 2*MXBIT ) then
        IBIT2   = IBIT-MXBIT
        MSK8(2) = IBSET(MSK8(2),IBIT2-1)
      endif

      RETURN
      END

C =======================================
+DECK,MAGOBS_SHIFT_UPDATE.
      SUBROUTINE MAGOBS_SHIFT_UPDATE()

c Created Sep 20 2015
c Loop over filters and apply optional shift-vs-lambda
c for ZP and PRIMARY mag. Allows coherent mag-shifts
c with just a few parameters instead of giving a mag
c shift for each band.
c See &SNLCINP parameters MAGOBS_SHIFT_[ZP,PRIMARY]_PARAMS(3)
c
      IMPLICIT NONE

c local 

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IFILT, IFILTDEF

      REAL MAGOBS_SHIFT_USRFUN  ! function
C --------------- BEGIN -----------

      DO ifilt = 1, NFILTDEF_SURVEY
         IFILTDEF = IFILTDEF_MAP_SURVEY(ifilt)

         magobs_shift_zp_filt(ifiltdef) = 
     &   magobs_shift_zp_filt(ifiltdef) +
     &          MAGOBS_SHIFT_USRFUN(ifiltdef, 'ZP') ! Sep 2015

         magobs_shift_primary_filt(ifiltdef) = 
     &   magobs_shift_primary_filt(ifiltdef) +
     &          MAGOBS_SHIFT_USRFUN(ifiltdef, 'PRIMARY') ! Sep 2015
      ENDDO

      RETURN
      END  ! end of MAGOBS_SHIFT_UPDATE

C =======================================
+DECK,MAGOBS_SHIFT_USRFUN.
      REAL FUNCTION MAGOBS_SHIFT_USRFUN(IFILTDEF, WHAT )

c Created Sep 30 2015
c Compute shift for what='ZP' or what='PRIMARY' for this IFILTDEF.
c Use SNLCINP parameters MAGOBS_SHIFT_[ZP,PRIMARY]_PARAMS to 
c determine polynomial function of wavelength. This allows computing
c correlated systematics among filters using a function of wavelength
c so that you don't have to enter a shift for each band separately.
c
c BEWARE: POLYNOMIAL FUNCTION OF LAMBDA IN MICRONS (NOT ANGSTROMS) 
c
c ----------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER    IFILTDEF   ! (I) absolute filter index
      CHARACTER  WHAT*(*)   ! (I) 'ZP' or 'PRIMARY'

c local var

      REAL LAM_um, SQLAM_um, COEF(0:2)
      CHARACTER FNAM*20

c ------------------- BEGIN ----------------

      FNAM = 'MAGOBS_SHIFT_USRFUN'
      MAGOBS_SHIFT_USRFUN = 0.0 

      IF ( WHAT(1:2) .EQ. 'ZP' ) THEN
         COEF(0) = MAGOBS_SHIFT_ZP_PARAMS(1)
         COEF(1) = MAGOBS_SHIFT_ZP_PARAMS(2)
         COEF(2) = MAGOBS_SHIFT_ZP_PARAMS(3)
      ELSE IF ( WHAT(1:7) .EQ. 'PRIMARY' ) THEN
         COEF(0) = MAGOBS_SHIFT_PRIMARY_PARAMS(1) 
         COEF(1) = MAGOBS_SHIFT_PRIMARY_PARAMS(2)
         COEF(2) = MAGOBS_SHIFT_PRIMARY_PARAMS(3)
      ELSE
         C1ERR = 'Invalid WHAT=' // WHAT
         C2ERR = 'for MAGOBS_SHIFT_XXX'
         CALL  MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF
      
      LAM_um   = FILTOBS_LAMAVG(ifiltdef)/1.0E4
      SQLAM_um = LAM_um * LAM_um

      MAGOBS_SHIFT_USRFUN =
     &      COEF(0)
     &    + COEF(1) * LAM_um
     &    + COEF(2) * SQLAM_um

c xxxxxxxxxxxxxxxxx
c      write(6,66) WHAT(1:2), MAGOBS_SHIFT_USRFUN, IFILTDEF, LAM_um
c66    format(' xxx ', A2, ' = ', F7.4,' for IFILTDEF=',I3, 
c     &      3x,'LAM=',F7.3,' um')
c      CALL FLUSH(6)
c xxxxxxxxxxxxxxxxx

      RETURN
      END  ! end of MAGOBS_SHIFT_USRFUN


C =======================================
+DECK,FUPDINI.
      SUBROUTINE FILTER_UPDATE_INIT(IERR)
c
c If FILTER_UPDATE_PATH is defined, read FILTER.INFO
c file for instructions on updating the filters for
c each SN.
c
c Jun 15 2016:  CALL ENVreplace(FILTER_UPDATE_PATH)
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,SNFILECOM.
c +CDE,PARSECOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER IERR

c local var

      INTEGER 
     &   LEN_UPDPATH, LEN_FULLPATH, L1, LEN_ROOT
     &  ,iwd, NWD, IERROPEN, ifilt, LWD0, LWD1

      character 
     &   FILTINFO_FILE*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)
     &  ,cwd*60, cwd_next*60, msg*100, FNAM*30

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------------- BEGIN -------------

      IERR = 0
      FNAM = 'FILTER_UPDATE_INIT'

      OPT_FILTER_UPDATE    = 0
      DO ifilt=1, MXFILT_ALL
        DOFLAG_FILTER_UPDATE(ifilt) = 0
      ENDDO

      PREFIX_UPD_TRANSSN  = ' '     
      PREFIX_UPD_TRANSREF = ' '
      PREFIX_UPD_FILTDIR  = ' '
      SUFFIX_UPD_TRANSSN  = ' '
      SUFFIX_UPD_TRANSREF = ' ' 
      SUFFIX_UPD_FILTDIR  = ' '
      FILTINFO_UPD_SN     = .FALSE.
      FILTINFO_UPD_REF    = .FALSE.

      IF ( FILTER_UPDATE_PATH .EQ. ' ' ) RETURN

      CALL ENVreplace(FILTER_UPDATE_PATH)

      msg = 
     &   "FILTER_UPDATE_INIT: Prepare SN-dependent Filter response"
      CALL PRBANNER(msg(1:60))

c -------------------------------------------------------
c first try $SNDATA_ROOT/filters/[FILTER_UPDATE_PATH]/
c if not there, then try absolute path.

      LEN_UPDPATH  = INDEX(FILTER_UPDATE_PATH,' ' ) -  1
      LEN_ROOT     = INDEX(SNDATA_ROOT,' ') - 1

      FILTER_UPDATE_TOPDIR = SNDATA_ROOT(1:LEN_ROOT) 
     &    // '/filters/' // FILTER_UPDATE_PATH(1:LEN_UPDPATH)
      LEN_FULLPATH  = INDEX(FILTER_UPDATE_TOPDIR,' ') - 1


c check if/where FILTER.INFO exists ...
      FILTINFO_FILE = FILTER_UPDATE_TOPDIR(1:LEN_FULLPATH) 
     &                 // '/FILTER.INFO'
      OPEN(UNIT=LUNTMP, FILE = FILTINFO_FILE,
     &     IOSTAT = IERROPEN, STATUS='OLD')
      IF ( IERROPEN .EQ. 0 ) THEN
        CLOSE(UNIT = LUNTMP)
      ELSE
c try absolute path
        LEN_FULLPATH = LEN_UPDPATH
        FILTER_UPDATE_TOPDIR  = FILTER_UPDATE_PATH
        FILTINFO_FILE = FILTER_UPDATE_PATH(1:LEN_UPDPATH)
     &           // '/FILTER.INFO'
      ENDIF

      L1 = INDEX(FILTINFO_FILE,' ') - 1
      print*,' Update Filter Response for each SN from : '
      print*,' ', FILTINFO_FILE(1:L1)

      NAME_forC = FILTINFO_FILE(1:L1)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE,NAME_forC,
     &         FNAM//char(0), L1, 30 )


c parse enough to know which type of FILTER.INFO file we have;
c set global  OPT_FILTER_UPDATE and call PARSE1_XXX or PARSE2_XXX
c to do the appropriate parsing.

      DO 10 iwd = 1, min(1000,NWD)

          CALL get_PARSE_WORD_fortran(iwd+0, cwd,      LWD0 )
          CALL get_PARSE_WORD_fortran(iwd+1, cwd_next, LWD1 )

          if ( cwd .EQ. ' ' ) goto 10

          if ( CWD .EQ. 'FILTER_SUBDIR:' ) THEN
             CALL PARSE1_FILTER_INFO(NWD)
             OPT_FILTER_UPDATE  = OPT_FILTUPD_EACHSN
             RETURN
          ENDIF

          if ( CWD .EQ. 'FILTER_PATH:' ) THEN
             CALL PARSE2_FILTER_INFO(NWD)
             OPT_FILTER_UPDATE  = OPT_FILTUPD_MAP
             RETURN
          ENDIF

10    CONTINUE


c if we get here then abort.

      c1err = 'Cannot parse FILTER.INFO file'
      c2err = FILTER_UPDATE_TOPDIR(1:LEN_FULLPATH)
      CALL MADABORT("FILTER_UPDATE_INIT", c1err, c2err)

      RETURN
      END  ! end FILTER_UPDATE_INIT

C ======================================
+DECK,PRS1FUPD.
      SUBROUTINE PARSE1_FILTER_INFO(NWD)

c parse FILTER.INFO file that has a different filter set
c for each SN.

      IMPLICIT NONE

      INTEGER NWD ! (I) number of words in file
+CDE,SNPAR.
c +CDE,PARSECOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER IWD, istar, LEN

      character 
     &   FILTER_SUBDIR*(MXCHAR_PATH)
     &  ,cwd*(MXCHAR_FILEWORD)
     &  ,cwd_next*(MXCHAR_FILEWORD)
     &  ,copt*(MXCHAR_FILEWORD)
     &  ,c1err*80, c2err*80

      LOGICAL LDUMP 

C ----------- BEGIN ----------

      DO 10 iwd = 1, NWD-1

          CALL get_PARSE_WORD_fortran(iwd+0, cwd,      LEN)
          CALL get_PARSE_WORD_fortran(iwd+1, cwd_next, LEN)

          if ( cwd .EQ. ' ' ) goto 10

          if ( cwd .EQ. 'FILTER_SUBDIR:' ) then
            FILTER_SUBDIR = cwd_next
            istar = Index(FILTER_SUBDIR,'{SNID}')
            PREFIX_UPD_FILTDIR = FILTER_SUBDIR(1:istar-1)
            SUFFIX_UPD_FILTDIR = FILTER_SUBDIR(istar+6:99)
          endif

          if ( cwd .EQ. 'FILETRANS_SN:' ) then
            CALL SET_FILTINFO_UPD("SN", cwd_next)
          endif
          if ( cwd .EQ. 'FILETRANS_REF:' ) then
            CALL SET_FILTINFO_UPD("REF", cwd_next)
          endif

          if ( cwd(1:7) .EQ. 'OPTION:' ) then
             copt = cwd_next
             if ( copt(1:7) .EQ. 'DEFAULT' ) then

             else if ( copt(1:8) .EQ. 'SAMEFILT' ) then
               OPT_FILTER_UPDATE  = OPT_FILTUPD_SAMEFILT
             else
               C1ERR = 'Invalid FilterFile.INFO OPTION: ' // copt(1:20)
               C2ERR = 'Valid options: DEFAULT SAMEFILT '
               CALL MADABORT("FILTER_UPDATE_INIT", C1ERR, C2ERR )
             endif
          endif

10    CONTINUE

      LDUMP = .false.
      if ( LDUMP ) then
          print*, ' xxxxxx FILTER_SUBDIR= ', FILTER_SUBDIR(1:20)
          print*, ' xxxxxx   PREFIX_UPD_FILTDIR =',
     &                       PREFIX_UPD_FILTDIR(1:20) 
          print*, ' xxxxxx   SUFFIX_UPD_FILTDIR =',
     &                       SUFFIX_UPD_FILTDIR(1:20) 
      endif

      RETURN
      END

C ======================================
+DECK,PRS2FUPD.
      SUBROUTINE PARSE2_FILTER_INFO(NWD)

c Created July 16, 2011 by R.Kessler
c parse FILTER.INFO file that has a defined set of filters
c such as one set per SDSS-CCD column.
c IMAP is a sparse index 1-NMAP
c INDX is the absolute filter-path index in the FILTER.INFO file.
c
c Load MAP1_FILTER_UPDATE (subdir vs. index) and 
c MAP2_FILTER_UPDATE (index vs. CCID)
c
c ------------------------

      IMPLICIT NONE

+CDE,SNPAR.
c+CDE,PARSECOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER NWD  ! (I) number of words to check

      INTEGER 
     &   IWD, INDX, LEN
     &  ,IMAP1, IMAP1_STORE, NMAP1, NMAP2

      character
     &   cwd0*(MXCHAR_FILEWORD)
     &  ,cwd1*(MXCHAR_FILEWORD)
     &  ,cwd2*(MXCHAR_FILEWORD)
     &  ,ccid*(MXCHAR_CCID)
     &  ,c1err*80, c2err*80

C ---------------- BEGIN -------------

      NMAP1_FILTER_UPDATE = 0
      NMAP2_FILTER_UPDATE = 0

      NMAP1 = 0
      NMAP2 = 0

      DO 10 iwd = 1, NWD-2

          call get_PARSE_WORD_fortran(iwd+0, cwd0, LEN)
          call get_PARSE_WORD_fortran(iwd+1, cwd1, LEN)
          call get_PARSE_WORD_fortran(iwd+2, cwd2, LEN)

          if ( cwd0 .EQ. ' ' ) goto 10


          if ( cwd0 .EQ. 'FILTER_PATH:' ) then
             read(cwd1,*) INDX

             NMAP1 = NMAP1 + 1
             NMAP1_FILTER_UPDATE = NMAP1

             if ( NMAP1 .GT. MXMAP1_FILTER_UPDATE ) then
               write(c1err,1660) NMAP1, MXMAP1_FILTER_UPDATE
1660           format('NMAP=',I3,
     &           ' exceeds bound of MXMAP1_FILTER_UPDATE=',I3)
               c2err = 'Increase bound or reduce NMAP'
               CALL MADABORT('PARSE2_FILTER_INFO', C1ERR, C2ERR)
             endif
             MAP1_FILTER_UPDATE_INDX(NMAP1)    = INDX
             MAP1_FILTER_UPDATE_SUBDIR(NMAP1)  = CWD2
          endif

          if ( cwd0 .EQ. 'FILETRANS_SN:' ) then
            CALL SET_FILTINFO_UPD('SN', cwd1)
          endif
          if ( cwd0 .EQ. 'FILETRANS_REF:' ) then
            CALL SET_FILTINFO_UPD('REF', cwd1)
          endif



          if ( cwd0 .EQ. 'SN:' ) then
             CCID = cwd1(1:MXCHAR_CCID)
             read(cwd2,*) INDX

c translate INDX to sparse IMAP1
             IMAP1_STORE = -9
             DO imap1 = 1, NMAP1_FILTER_UPDATE
                if ( MAP1_FILTER_UPDATE_INDX(imap1) .EQ. INDX) then
                   imap1_store = imap1
                endif
             END DO

             if ( IMAP1_STORE .LE. 0 ) then
               write(c1err,670) INDX, CCID
               c2err = 'Check FILTER.INFO file.'
670            format('Undefined INDX=',I8,'   for  CID = ',A8)
               CALL MADABORT('PARSE2_FILTER_INFO', C1ERR, C2ERR)
             endif

c update 2nd map
             NMAP2 = NMAP2 + 1
             NMAP2_FILTER_UPDATE = NMAP2

             if ( NMAP2 .GT. MXSNLC_FILTUPD ) then
                write(c1err,661) MXSNLC_FILTUPD
661             format('MAP2 size exceeds bound of MXSNLC_FILTUPD=',I6)
                c2err = 'Check FILTER.INFO file.'
                CALL MADABORT("PARSE2_FILTER_INFO", C1ERR, C2ERR)
             endif
             
             MAP2_FILTER_UPDATE_CCID(NMAP2)    = CCID
             MAP2_FILTER_UPDATE_PTRMAP1(NMAP2) = IMAP1_STORE

          endif  !   'SN:' key


10    CONTINUE

c ---------------------------------------------------------

      write(6,60) NMAP1_FILTER_UPDATE
60    format(T4,'Found ',I2,' filter sets to use for updates.')

      write(6,61) NMAP2_FILTER_UPDATE
61    format(T4,'Filter update map stored for ',I6,' SNe.' )

      print*,' -------------------------------------------------- '

      RETURN
      END

C =================================
+DECK,SETFUPD.
      SUBROUTINE SET_FILTINFO_UPD(KEY,STRING)
c
c Created Jul 16, 2011
c
c Parse STRING for asterisk, and store PREFIX and SUFFIX
c before/after the asterisk. Used later to determine the
c name of the filter transmission  file where the  asterisk
c is replaced with the filter-character.
c
c Jul 5 2013: string-length fixes to avoid segfault in debug mode.
c             See use of LKEY and LSTR.
c
c ---------

      IMPLICIT  NONE

c input arguments
      CHARACTER KEY*(*)     ! (I) 'SN' or 'REF'
      CHARACTER STRING*(*)  ! (I) string to define filter filename
 
c local variables

+CDE,SNPAR.
c +CDE,PARSECOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
  
      INTEGER istar, LSTR, LKEY
      LOGICAL LDUMP 
C ------------ BEGIN -------------
 
      LSTR = INDEX(STRING,' ' ) - 1
      LKEY = INDEX(KEY//' ',   ' ' ) - 1

      istar = Index(STRING,'*')

      IF ( KEY(1:LKEY) .EQ. 'REF' ) THEN
          PREFIX_UPD_TRANSREF = STRING(1:istar-1)
          SUFFIX_UPD_TRANSREF = STRING(istar+1:LSTR)
          FILTINFO_UPD_REF = .TRUE. 

      ELSE IF ( KEY(1:LKEY) .EQ. 'SN' ) THEN
          PREFIX_UPD_TRANSSN = STRING(1:istar-1)
          SUFFIX_UPD_TRANSSN = STRING(istar+1:LSTR)
          FILTINFO_UPD_SN = .TRUE. 

      ELSE

      ENDIF

c print comment about filename syntax

      LDUMP = .TRUE.
      IF ( LDUMP ) THEN
         write(6,20) KEY, STRING(1:LSTR)
20       format(T4,'Filter-Trans filenames(', A, ') : ''',A, 
     &          '''  with * => filter' )
      ENDIF

      RETURN
      END  ! end  SET_FILTINFO_UPD



C =======================
+PATCH,*SPLINE.
C =======================


cc +PATCH,*2DEX.

+KEEP,DA2DEX.

C Data for surface smoother
C 5/02/2011 : INMAX=6 -> 8

      INTEGER IND,NMAX,NCMAX,INMAX
      PARAMETER (NMAX=4000, NCMAX=NMAX*100,INMAX=8)  ! save memory

cc      PARAMETER (NMAX=10000,NCMAX=NMAX*100,INMAX=20)  ! original

      INTEGER NX(INMAX),NY(INMAX),KX(INMAX),KY(INMAX)
      INTEGER NND,JND(INMAX)
      REAL*8 TX(NMAX,INMAX),TY(NMAX,INMAX), C(NCMAX,INMAX)
      REAL*8 WRK1(NCMAX,INMAX)
      COMMON /DA2DEX/ TX,NX,TY,NY,C,WRK1,KX,KY,NND,JND

+DECK,IN2DEX.
      SUBROUTINE IN2DEX(IND,M,XX,YY,ZZ,XXM,YYM,SS,IER)
C-------------------------------
C Interface to 2d surface extrapolator.  This initializes the 2D 
C extrapolator by interfacing to the surface fitter and storing 
C the results. D. Cinabro May, 2006
C
C Usage:
C  IND (I) = Index of surface, INMAX allowed
C  M   (I) = number of data points (nx*ny)
C  XX  (I) = First Dimension inputs, double precision
C  YY  (I) = Second Dimension inputs, double precision
C  ZZ  (I) = Output of F(XX,YY) to be smoothed, double precision
C  XXM (I) = Range of X extrapolation min and max, double precision
C  YYM (I) = Range of Y extrapolation min and max, double precision
C  S   (I) = Smoothing parameter, double precision optimal value should be
C            bounded by (m-sqrt(2*m),m+sqrt(2m)).  See surfit documentation
C            for more advice.  Smaller means less smoothing.
C  IER (o) = Error flag.  <=0 is good, >0 is bad.  See surfit for meaning.
C
C Based on the DIERCKX package of Fortran subroutines for calculating 
C smoothing splines for various kinds of data and geometries, 
C with automatic knot selection.  This library is also called 
C FITPACK, but is independent of the FITPACK library by Alan Cline.
C
C Reference:
C Paul Dierckx, Curve and Surface Fitting with Splines, 
C Oxford University Press, 1993
C
C Developer
C Paul Dierckx, Department of Computer Science, K.U. Leuven, 
C Celestijnenlaan 200 A,
C B-3001, Heverlee, Belgium Paul.Dierckx@cs.kuleuven.ac.be
C---------------------------------------------------------------
C
      IMPLICIT NONE
C
C User inputs
C
      INTEGER IOPT,M,IER
      REAL*8 XX(M),YY(M),ZZ(M),XXM(2),YYM(2),SS
C
C Surfit inputs
C
      INTEGER I, NXEST,NYEST
      REAL*8 X(M),Y(M),Z(M),W(M),XB,XE,YB,YE,S,EPS
C
C Surfit outputs in common block needed for function
C
+CDE,DA2DEX.
+CDE,SNPAR.
+CDE,CTRLCOM.
C
      LOGICAL FIRST, USEY
      DATA FIRST/.TRUE./
      INTEGER IN
C
C Working arrays
C
      INTEGER IWRK(NMAX),LWRK1,LWRK2,KWRK
      REAL*8 FP,WRK2(NCMAX)
C
C--------------------------
C
      IF (FIRST) THEN
        FIRST = .FALSE.
        NND = 0
      ENDIF
C
      IN = 0
      IF (NND.GT.0) THEN
        DO 50 I = 1,NND
          IF (IND.EQ.JND(I)) THEN
            IN = I
          ENDIF
  50    CONTINUE
      ENDIF     
      IF (IN.EQ.0) THEN
        NND = NND + 1
        JND(NND) = IND
        IN = NND
      ENDIF

      IF (IN.GT.INMAX) THEN
        print*,' '
        print*,' IN2DEX Warning: IND =',IND
        print*,' Too many functions defined.  Increase INMAX '
        print*,' ***** ABORT ***** '
        CALL EXIT(EXIT_ERRCODE)
      ENDIF

C Tell the fitter to not use a user supplied set of knots
      IOPT = 1
      USEY = .FALSE.
      DO 100 I = 1,M
        X(I) = XX(I)
        Y(I) = YY(I)
        Z(I) = ZZ(I)
C All points wieghted equally
        W(I) = 1.0
        if ( Y(I) .NE. Y(1) ) USEY = .TRUE.
 100  CONTINUE
      XB = XXM(1)
      XE = XXM(2)
      YB = YYM(1)
      YE = YYM(2)
C Use cublic splines.  Cannot be larger than 5.
      KX(IN) = 3
 
      IF ( USEY ) then
         KY(IN) = 3
      ELSE
         KY(IN) = 1
      ENDIF

      S = SS
C Maximum Number of knots.  Value here is advice from surfit plus 10
      NXEST = KX(IN) + 1 + NINT(SQRT(REAL(M)/2.0))  + 10
      NYEST = KY(IN) + 1 + NINT(SQRT(REAL(M)/2.0))  + 10
C Nearness of fit parameter, 1/10000 should be more than adequate
      EPS = 0.0001
      LWRK1 = NCMAX
      LWRK2 = NCMAX
      KWRK = NMAX
C Zero out the working array to avoid hysterisis
      DO 101 I = 1,NCMAX
        WRK1(I,IN) = 0.0
 101  CONTINUE
C
C Call the fitter
C
      CALL SURFIT(IOPT,M,X,Y,Z,W,XB,XE,YB,YE,KX(IN),KY(IN),
     &  S,NXEST,NYEST,NMAX,EPS,NX(IN),TX(1,IN),NY(IN),TY(1,IN),
     &  C(1,IN),FP,WRK1(1,IN),LWRK1,WRK2,LWRK2,IWRK,KWRK,IER)
C
      RETURN
      END

+DECK,GE2DEDX.
      DOUBLE PRECISION FUNCTION GE2DEX(IND,XX1,YY1,IER)
C----------------------------------------------------
C GE2DEX gets the result of the smoothing initialized by IN2DEX
C
C GE2DEX(XX1,YY1,IER)
C  IND  (I) = Index of function, INMAX allowed
C  XX1  (I) = First Dimension input, double precision
C  YY1  (I) = Second Dimension inputs, double precision
C  IER  (o) = Error flag.  =0 is good, =10 is bad.  See bispev for meaning.
C---------------------------------------------------------
      IMPLICIT NONE
      REAL*8 XX1(1),YY1(1)
      INTEGER IER
      REAL*8 X1(1),Y1(1),Z1(1)
C
C Stuff from the fit
C
+CDE,DA2DEX.
+CDE,SNPAR.
+CDE,CTRLCOM.
C
C Working arrays
C
      INTEGER IWRK(NMAX),LWRK1,KWRK,IX,IY,IN,I
C---------------------------------------------------------
C Get the right index
      IN = 0
      DO 50 I = 1,NND
        IF (IND.EQ.JND(I)) THEN
          IN = I
        ENDIF
  50  CONTINUE
      IF (IN.EQ.0) THEN
        print*,' '
        print*,' GE2DEX Warning: IND =',IND
        print*,' Unrecognized function index? '
        print*,' ***** ABORT ***** '
        CALL EXIT(EXIT_ERRCODE)
      ENDIF

C Evaluate the spline at XX1, YY1

      X1(1) = XX1(1)
      Y1(1) = YY1(1)
      LWRK1 = NCMAX
      KWRK = NMAX
      IX = 1
      IY = 1
      CALL BISPEV(TX(1,IN),NX(IN),TY(1,IN),NY(IN),C(1,IN),
     &  KX(IN),KY(IN),X1,IX,Y1,IY,Z1,WRK1(1,IN),LWRK1,IWRK,KWRK,IER)
      GE2DEX = Z1(1)
C
      RETURN
      END
C =============================
+DECK,UTILEX.
      subroutine surfit(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,
     *  nmax,eps,nx,tx,ny,ty,c,fp,wrk1,lwrk1,wrk2,lwrk2,iwrk,kwrk,ier)
c given the set of data points (x(i),y(i),z(i)) and the set of positive
c numbers w(i),i=1,...,m, subroutine surfit determines a smooth bivar-
c iate spline approximation s(x,y) of degrees kx and ky on the rect-
c angle xb <= x <= xe, yb <= y <= ye.
c if iopt = -1 surfit calculates the weighted least-squares spline
c according to a given set of knots.
c if iopt >= 0 the total numbers nx and ny of these knots and their
c position tx(j),j=1,...,nx and ty(j),j=1,...,ny are chosen automatic-
c ally by the routine. the smoothness of s(x,y) is then achieved by
c minimalizing the discontinuity jumps in the derivatives of s(x,y)
c across the boundaries of the subpanels (tx(i),tx(i+1))*(ty(j),ty(j+1).
c the amounth of smoothness is determined by the condition that f(p) =
c sum ((w(i)*(z(i)-s(x(i),y(i))))**2) be <= s, with s a given non-neg-
c ative constant, called the smoothing factor.
c the fit is given in the b-spline representation (b-spline coefficients
c c((ny-ky-1)*(i-1)+j),i=1,...,nx-kx-1;j=1,...,ny-ky-1) and can be eval-
c uated by means of subroutine bispev.
c
c calling sequence:
c     call surfit(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,
c    *  nmax,eps,nx,tx,ny,ty,c,fp,wrk1,lwrk1,wrk2,lwrk2,iwrk,kwrk,ier)
c
c parameters:
c  iopt  : integer flag. on entry iopt must specify whether a weighted
c          least-squares spline (iopt=-1) or a smoothing spline (iopt=0
c          or 1) must be determined.
c          if iopt=0 the routine will start with an initial set of knots
c          tx(i)=xb,tx(i+kx+1)=xe,i=1,...,kx+1;ty(i)=yb,ty(i+ky+1)=ye,i=
c          1,...,ky+1. if iopt=1 the routine will continue with the set
c          of knots found at the last call of the routine.
c          attention: a call with iopt=1 must always be immediately pre-
c                     ceded by another call with iopt=1 or iopt=0.
c          unchanged on exit.
c  m     : integer. on entry m must specify the number of data points.
c          m >= (kx+1)*(ky+1). unchanged on exit.
c  x     : real array of dimension at least (m).
c  y     : real array of dimension at least (m).
c  z     : real array of dimension at least (m).
c          before entry, x(i),y(i),z(i) must be set to the co-ordinates
c          of the i-th data point, for i=1,...,m. the order of the data
c          points is immaterial. unchanged on exit.
c  w     : real array of dimension at least (m). before entry, w(i) must
c          be set to the i-th value in the set of weights. the w(i) must
c          be strictly positive. unchanged on exit.
c  xb,xe : real values. on entry xb,xe,yb and ye must specify the bound-
c  yb,ye   aries of the rectangular approximation domain.
c          xb<=x(i)<=xe,yb<=y(i)<=ye,i=1,...,m. unchanged on exit.
c  kx,ky : integer values. on entry kx and ky must specify the degrees
c          of the spline. 1<=kx,ky<=5. it is recommended to use bicubic
c          (kx=ky=3) splines. unchanged on exit.
c  s     : real. on entry (in case iopt>=0) s must specify the smoothing
c          factor. s >=0. unchanged on exit.
c          for advice on the choice of s see further comments
c  nxest : integer. unchanged on exit.
c  nyest : integer. unchanged on exit.
c          on entry, nxest and nyest must specify an upper bound for the
c          number of knots required in the x- and y-directions respect.
c          these numbers will also determine the storage space needed by
c          the routine. nxest >= 2*(kx+1), nyest >= 2*(ky+1).
c          in most practical situation nxest = kx+1+sqrt(m/2), nyest =
c          ky+1+sqrt(m/2) will be sufficient. see also further comments.
c  nmax  : integer. on entry nmax must specify the actual dimension of
c          the arrays tx and ty. nmax >= nxest, nmax >=nyest.
c          unchanged on exit.
c  eps   : real.
c          on entry, eps must specify a threshold for determining the
c          effective rank of an over-determined linear system of equat-
c          ions. 0 < eps < 1.  if the number of decimal digits in the
c          computer representation of a real number is q, then 10**(-q)
c          is a suitable value for eps in most practical applications.
c          unchanged on exit.
c  nx    : integer.
c          unless ier=10 (in case iopt >=0), nx will contain the total
c          number of knots with respect to the x-variable, of the spline
c          approximation returned. if the computation mode iopt=1 is
c          used, the value of nx should be left unchanged between sub-
c          sequent calls.
c          in case iopt=-1, the value of nx should be specified on entry
c  tx    : real array of dimension nmax.
c          on succesful exit, this array will contain the knots of the
c          spline with respect to the x-variable, i.e. the position of
c          the interior knots tx(kx+2),...,tx(nx-kx-1) as well as the
c          position of the additional knots tx(1)=...=tx(kx+1)=xb and
c          tx(nx-kx)=...=tx(nx)=xe needed for the b-spline representat.
c          if the computation mode iopt=1 is used, the values of tx(1),
c          ...,tx(nx) should be left unchanged between subsequent calls.
c          if the computation mode iopt=-1 is used, the values tx(kx+2),
c          ...tx(nx-kx-1) must be supplied by the user, before entry.
c          see also the restrictions (ier=10).
c  ny    : integer.
c          unless ier=10 (in case iopt >=0), ny will contain the total
c          number of knots with respect to the y-variable, of the spline
c          approximation returned. if the computation mode iopt=1 is
c          used, the value of ny should be left unchanged between sub-
c          sequent calls.
c          in case iopt=-1, the value of ny should be specified on entry
c  ty    : real array of dimension nmax.
c          on succesful exit, this array will contain the knots of the
c          spline with respect to the y-variable, i.e. the position of
c          the interior knots ty(ky+2),...,ty(ny-ky-1) as well as the
c          position of the additional knots ty(1)=...=ty(ky+1)=yb and
c          ty(ny-ky)=...=ty(ny)=ye needed for the b-spline representat.
c          if the computation mode iopt=1 is used, the values of ty(1),
c          ...,ty(ny) should be left unchanged between subsequent calls.
c          if the computation mode iopt=-1 is used, the values ty(ky+2),
c          ...ty(ny-ky-1) must be supplied by the user, before entry.
c          see also the restrictions (ier=10).
c  c     : real array of dimension at least (nxest-kx-1)*(nyest-ky-1).
c          on succesful exit, c contains the coefficients of the spline
c          approximation s(x,y)
c  fp    : real. unless ier=10, fp contains the weighted sum of
c          squared residuals of the spline approximation returned.
c  wrk1  : real array of dimension (lwrk1). used as workspace.
c          if the computation mode iopt=1 is used the value of wrk1(1)
c          should be left unchanged between subsequent calls.
c          on exit wrk1(2),wrk1(3),...,wrk1(1+(nx-kx-1)*(ny-ky-1)) will
c          contain the values d(i)/max(d(i)),i=1,...,(nx-kx-1)*(ny-ky-1)
c          with d(i) the i-th diagonal element of the reduced triangular
c          matrix for calculating the b-spline coefficients. it includes
c          those elements whose square is less than eps,which are treat-
c          ed as 0 in the case of presumed rank deficiency (ier<-2).
c  lwrk1 : integer. on entry lwrk1 must specify the actual dimension of
c          the array wrk1 as declared in the calling (sub)program.
c          lwrk1 must not be too small. let
c            u = nxest-kx-1, v = nyest-ky-1, km = max(kx,ky)+1,
c            ne = max(nxest,nyest), bx = kx*v+ky+1, by = ky*u+kx+1,
c            if(bx.le.by) b1 = bx, b2 = b1+v-ky
c            if(bx.gt.by) b1 = by, b2 = b1+u-kx  then
c          lwrk1 >= u*v*(2+b1+b2)+2*(u+v+km*(m+ne)+ne-kx-ky)+b2+1
c  wrk2  : real array of dimension (lwrk2). used as workspace, but
c          only in the case a rank deficient system is encountered.
c  lwrk2 : integer. on entry lwrk2 must specify the actual dimension of
c          the array wrk2 as declared in the calling (sub)program.
c          lwrk2 > 0 . a save upper boundfor lwrk2 = u*v*(b2+1)+b2
c          where u,v and b2 are as above. if there are enough data
c          points, scattered uniformly over the approximation domain
c          and if the smoothing factor s is not too small, there is a
c          good chance that this extra workspace is not needed. a lot
c          of memory might therefore be saved by setting lwrk2=1.
c          (see also ier > 10)
c  iwrk  : integer array of dimension (kwrk). used as workspace.
c  kwrk  : integer. on entry kwrk must specify the actual dimension of
c          the array iwrk as declared in the calling (sub)program.
c          kwrk >= m+(nxest-2*kx-1)*(nyest-2*ky-1).
c  ier   : integer. unless the routine detects an error, ier contains a
c          non-positive value on exit, i.e.
c   ier=0  : normal return. the spline returned has a residual sum of
c            squares fp such that abs(fp-s)/s <= tol with tol a relat-
c            ive tolerance set to 0.001 by the program.
c   ier=-1 : normal return. the spline returned is an interpolating
c            spline (fp=0).
c   ier=-2 : normal return. the spline returned is the weighted least-
c            squares polynomial of degrees kx and ky. in this extreme
c            case fp gives the upper bound for the smoothing factor s.
c   ier<-2 : warning. the coefficients of the spline returned have been
c            computed as the minimal norm least-squares solution of a
c            (numerically) rank deficient system. (-ier) gives the rank.
c            especially if the rank deficiency which can be computed as
c            (nx-kx-1)*(ny-ky-1)+ier, is large the results may be inac-
c            curate. they could also seriously depend on the value of
c            eps.
c   ier=1  : error. the required storage space exceeds the available
c            storage space, as specified by the parameters nxest and
c            nyest.
c            probably causes : nxest or nyest too small. if these param-
c            eters are already large, it may also indicate that s is
c            too small
c            the approximation returned is the weighted least-squares
c            spline according to the current set of knots.
c            the parameter fp gives the corresponding weighted sum of
c            squared residuals (fp>s).
c   ier=2  : error. a theoretically impossible result was found during
c            the iteration proces for finding a smoothing spline with
c            fp = s. probably causes : s too small or badly chosen eps.
c            there is an approximation returned but the corresponding
c            weighted sum of squared residuals does not satisfy the
c            condition abs(fp-s)/s < tol.
c   ier=3  : error. the maximal number of iterations maxit (set to 20
c            by the program) allowed for finding a smoothing spline
c            with fp=s has been reached. probably causes : s too small
c            there is an approximation returned but the corresponding
c            weighted sum of squared residuals does not satisfy the
c            condition abs(fp-s)/s < tol.
c   ier=4  : error. no more knots can be added because the number of
c            b-spline coefficients (nx-kx-1)*(ny-ky-1) already exceeds
c            the number of data points m.
c            probably causes : either s or m too small.
c            the approximation returned is the weighted least-squares
c            spline according to the current set of knots.
c            the parameter fp gives the corresponding weighted sum of
c            squared residuals (fp>s).
c   ier=5  : error. no more knots can be added because the additional
c            knot would (quasi) coincide with an old one.
c            probably causes : s too small or too large a weight to an
c            inaccurate data point.
c            the approximation returned is the weighted least-squares
c            spline according to the current set of knots.
c            the parameter fp gives the corresponding weighted sum of
c            squared residuals (fp>s).
c   ier=10 : error. on entry, the input data are controlled on validity
c            the following restrictions must be satisfied.
c            -1<=iopt<=1, 1<=kx,ky<=5, m>=(kx+1)*(ky+1), nxest>=2*kx+2,
c            nyest>=2*ky+2, 0<eps<1, nmax>=nxest, nmax>=nyest,
c            xb<=x(i)<=xe, yb<=y(i)<=ye, w(i)>0, i=1,...,m
c            lwrk1 >= u*v*(2+b1+b2)+2*(u+v+km*(m+ne)+ne-kx-ky)+b2+1
c            kwrk >= m+(nxest-2*kx-1)*(nyest-2*ky-1)
c            if iopt=-1: 2*kx+2<=nx<=nxest
c                        xb<tx(kx+2)<tx(kx+3)<...<tx(nx-kx-1)<xe
c                        2*ky+2<=ny<=nyest
c                        yb<ty(ky+2)<ty(ky+3)<...<ty(ny-ky-1)<ye
c            if iopt>=0: s>=0
c            if one of these conditions is found to be violated,control
c            is immediately repassed to the calling program. in that
c            case there is no approximation returned.
c   ier>10 : error. lwrk2 is too small, i.e. there is not enough work-
c            space for computing the minimal least-squares solution of
c            a rank deficient system of linear equations. ier gives the
c            requested value for lwrk2. there is no approximation re-
c            turned but, having saved the information contained in nx,
c            ny,tx,ty,wrk1, and having adjusted the value of lwrk2 and
c            the dimension of the array wrk2 accordingly, the user can
c            continue at the point the program was left, by calling
c            surfit with iopt=1.
c
c further comments:
c  by means of the parameter s, the user can control the tradeoff
c   between closeness of fit and smoothness of fit of the approximation.
c   if s is too large, the spline will be too smooth and signal will be
c   lost ; if s is too small the spline will pick up too much noise. in
c   the extreme cases the program will return an interpolating spline if
c   s=0 and the weighted least-squares polynomial (degrees kx,ky)if s is
c   very large. between these extremes, a properly chosen s will result
c   in a good compromise between closeness of fit and smoothness of fit.
c   to decide whether an approximation, corresponding to a certain s is
c   satisfactory the user is highly recommended to inspect the fits
c   graphically.
c   recommended values for s depend on the weights w(i). if these are
c   taken as 1/d(i) with d(i) an estimate of the standard deviation of
c   z(i), a good s-value should be found in the range (m-sqrt(2*m),m+
c   sqrt(2*m)). if nothing is known about the statistical error in z(i)
c   each w(i) can be set equal to one and s determined by trial and
c   error, taking account of the comments above. the best is then to
c   start with a very large value of s ( to determine the least-squares
c   polynomial and the corresponding upper bound fp0 for s) and then to
c   progressively decrease the value of s ( say by a factor 10 in the
c   beginning, i.e. s=fp0/10, fp0/100,...and more carefully as the
c   approximation shows more detail) to obtain closer fits.
c   to choose s very small is strongly discouraged. this considerably
c   increases computation time and memory requirements. it may also
c   cause rank-deficiency (ier<-2) and endager numerical stability.
c   to economize the search for a good s-value the program provides with
c   different modes of computation. at the first call of the routine, or
c   whenever he wants to restart with the initial set of knots the user
c   must set iopt=0.
c   if iopt=1 the program will continue with the set of knots found at
c   the last call of the routine. this will save a lot of computation
c   time if surfit is called repeatedly for different values of s.
c   the number of knots of the spline returned and their location will
c   depend on the value of s and on the complexity of the shape of the
c   function underlying the data. if the computation mode iopt=1
c   is used, the knots returned may also depend on the s-values at
c   previous calls (if these were smaller). therefore, if after a number
c   of trials with different s-values and iopt=1, the user can finally
c   accept a fit as satisfactory, it may be worthwhile for him to call
c   surfit once more with the selected value for s but now with iopt=0.
c   indeed, surfit may then return an approximation of the same quality
c   of fit but with fewer knots and therefore better if data reduction
c   is also an important objective for the user.
c   the number of knots may also depend on the upper bounds nxest and
c   nyest. indeed, if at a certain stage in surfit the number of knots
c   in one direction (say nx) has reached the value of its upper bound
c   (nxest), then from that moment on all subsequent knots are added
c   in the other (y) direction. this may indicate that the value of
c   nxest is too small. on the other hand, it gives the user the option
c   of limiting the number of knots the routine locates in any direction
c   for example, by setting nxest=2*kx+2 (the lowest allowable value for
c   nxest), the user can indicate that he wants an approximation which
c   is a simple polynomial of degree kx in the variable x.
c
c  other subroutines required:
c    fpback,fpbspl,fpsurf,fpdisc,fpgivs,fprank,fprati,fprota,fporde
c
c  references:
c   dierckx p. : an algorithm for surface fitting with spline functions
c                ima j. numer. anal. 1 (1981) 267-283.
c   dierckx p. : an algorithm for surface fitting with spline functions
c                report tw50, dept. computer science,k.u.leuven, 1980.
c   dierckx p. : curve and surface fitting with splines, monographs on
c                numerical analysis, oxford university press, 1993.
c
c  author:
c    p.dierckx
c    dept. computer science, k.u. leuven
c    celestijnenlaan 200a, b-3001 heverlee, belgium.
c    e-mail : Paul.Dierckx@cs.kuleuven.ac.be
c
c  creation date : may 1979
c  latest update : march 1987
c
c  ..

      IMPLICIT NONE

c  ..scalar arguments..
      real*8 xb,xe,yb,ye,s,eps,fp
      integer iopt,m,kx,ky,nxest,nyest,nmax,nx,ny,lwrk1,lwrk2,kwrk,ier
c  ..array arguments..
      real*8 x(m),y(m),z(m),w(m),tx(nmax),ty(nmax),
     * c((nxest-kx-1)*(nyest-ky-1)),wrk1(lwrk1),wrk2(lwrk2)
      integer iwrk(kwrk)
c  ..local scalars..
      real*8 tol
      integer i,ib1,ib3,jb1,ki,kmax,km1,km2,kn,kwest,kx1,ky1,la,lbx,
     * lby,lco,lf,lff,lfp,lh,lq,lsx,lsy,lwest,maxit,ncest,nest,nek,
     * nminx,nminy,nmx,nmy,nreg,nrint,nxk,nyk
c  ..function references..
      integer max0
c  ..subroutine references..
c    fpsurf
c  ..

c  we set up the parameters tol and maxit.
      maxit = 20
      tol = 0.1e-02
c  before starting computations a data check is made. if the input data
c  are invalid,control is immediately repassed to the calling program.
      ier = 10
      if(eps.le.0. .or. eps.ge.1.) go to 70
      if(kx.le.0 .or. kx.gt.5) go to 70
      kx1 = kx+1
      if(ky.le.0 .or. ky.gt.5) go to 70
      ky1 = ky+1
      kmax = max0(kx,ky)
      km1 = kmax+1
      km2 = km1+1
      if(iopt.lt.(-1) .or. iopt.gt.1) go to 70
      if(m.lt.(kx1*ky1)) go to 70
      nminx = 2*kx1
      if(nxest.lt.nminx .or. nxest.gt.nmax) go to 70
      nminy = 2*ky1
      if(nyest.lt.nminy .or. nyest.gt.nmax) go to 70
      nest = max0(nxest,nyest)
      nxk = nxest-kx1
      nyk = nyest-ky1
      ncest = nxk*nyk
      nmx = nxest-nminx+1
      nmy = nyest-nminy+1
      nrint = nmx+nmy
      nreg = nmx*nmy
      ib1 = kx*nyk+ky1
      jb1 = ky*nxk+kx1
      ib3 = kx1*nyk+1
      if(ib1.le.jb1) go to 10
      ib1 = jb1
      ib3 = ky1*nxk+1
  10  lwest = ncest*(2+ib1+ib3)+2*(nrint+nest*km2+m*km1)+ib3
      kwest = m+nreg
      if(lwrk1.lt.lwest .or. kwrk.lt.kwest) go to 70
      if(xb.ge.xe .or. yb.ge.ye) go to 70
      do 20 i=1,m
        if(w(i).le.0.) go to 70
        if(x(i).lt.xb .or. x(i).gt.xe) go to 70
        if(y(i).lt.yb .or. y(i).gt.ye) go to 70
  20  continue
      if(iopt.ge.0) go to 50
      if(nx.lt.nminx .or. nx.gt.nxest) go to 70
      nxk = nx-kx1
      tx(kx1) = xb
      tx(nxk+1) = xe
      do 30 i=kx1,nxk
        if(tx(i+1).le.tx(i)) go to 70
  30  continue
      if(ny.lt.nminy .or. ny.gt.nyest) go to 70
      nyk = ny-ky1
      ty(ky1) = yb
      ty(nyk+1) = ye
      do 40 i=ky1,nyk
        if(ty(i+1).le.ty(i)) go to 70
  40  continue
      go to 60
  50  if(s.lt.0.) go to 70
  60  ier = 0
c  we partition the working space and determine the spline approximation
      kn = 1
      ki = kn+m
      lq = 2
      la = lq+ncest*ib3
      lf = la+ncest*ib1
      lff = lf+ncest
      lfp = lff+ncest
      lco = lfp+nrint
      lh = lco+nrint
      lbx = lh+ib3
      nek = nest*km2
      lby = lbx+nek
      lsx = lby+nek
      lsy = lsx+m*km1
      call fpsurf(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,
     * eps,tol,maxit,nest,km1,km2,ib1,ib3,ncest,nrint,nreg,nx,tx,
     * ny,ty,c,fp,wrk1(1),wrk1(lfp),wrk1(lco),wrk1(lf),wrk1(lff),
     * wrk1(la),wrk1(lq),wrk1(lbx),wrk1(lby),wrk1(lsx),wrk1(lsy),
     * wrk1(lh),iwrk(ki),iwrk(kn),wrk2,lwrk2,ier)
  70  return
      end

      subroutine fpback(a,z,n,k,c,nest)
      IMPLICIT NONE

c  subroutine fpback calculates the solution of the system of
c  equations a*c = z with a a n x n upper triangular matrix
c  of bandwidth k.
c  ..
c  ..scalar arguments..
      integer n,k,nest
c  ..array arguments..
      real*8 a(nest,k),z(n),c(n)
c  ..local scalars..
      real*8 store
      integer i,i1,j,k1,l,m
c  ..
      k1 = k-1
      c(n) = z(n)/a(n,1)
      i = n-1
      if(i.eq.0) go to 30
      do 20 j=2,n
        store = z(i)
        i1 = k1
        if(j.le.k1) i1 = j-1
        m = i
        do 10 l=1,i1
          m = m+1
          store = store-c(m)*a(i,l+1)
  10    continue
        c(i) = store/a(i,1)
        i = i-1
  20  continue
  30  return
      end

      subroutine fpbspl(t,n,k,x,l,h)
      IMPLICIT NONE
c  subroutine fpbspl evaluates the (k+1) non-zero b-splines of
c  degree k at t(l) <= x < t(l+1) using the stable recurrence
c  relation of de boor and cox.
c  ..
c  ..scalar arguments..
      real*8 x
      integer n,k,l
c  ..array arguments..
      real*8 t(n),h(6)
c  ..local scalars..
      real*8 f,one
      integer i,j,li,lj
c  ..local arrays..
      real*8 hh(5)
c  ..
      one = 0.1e+01
      h(1) = one
      do 20 j=1,k
        do 10 i=1,j
          hh(i) = h(i)
  10    continue
        h(1) = 0.
        do 21 i=1,j
          li = l+i
          lj = li-j
          f = hh(i)/(t(li)-t(lj))
          h(i) = h(i)+f*(t(li)-x)
          h(i+1) = f*(x-t(lj))
  21  continue
  20  continue
      return
      end

      subroutine fpsurf(iopt,m,x,y,z,w,xb,xe,yb,ye,kxx,kyy,s,nxest,
     * nyest,eta,tol,maxit,nmax,km1,km2,ib1,ib3,nc,intest,nrest,
     * nx0,tx,ny0,ty,c,fp,fp0,fpint,coord,f,ff,a,q,bx,by,spx,spy,h,
     * index,nummer,wrk,lwrk,ier)
      IMPLICIT NONE

c  ..
c  ..scalar arguments..
      real*8 xb,xe,yb,ye,s,eta,tol,fp,fp0
      integer iopt,m,kxx,kyy,nxest,nyest,maxit,nmax,km1,km2,ib1,ib3,
     * nc,intest,nrest,nx0,ny0,lwrk,ier
c  ..array arguments..
      real*8 x(m),y(m),z(m),w(m),tx(nmax),ty(nmax),c(nc),fpint(intest),
     * coord(intest),f(nc),ff(nc),a(nc,ib1),q(nc,ib3),bx(nmax,km2),
     * by(nmax,km2),spx(m,km1),spy(m,km1),h(ib3),wrk(lwrk)
      integer index(nrest),nummer(m)
c  ..local scalars..
      real*8 acc,arg,cos,dmax,fac1,fac2,fpmax,fpms,f1,f2,f3,hxi,p,pinv,
     * piv,p1,p2,p3,sigma,sin,sq,store,wi,x0,x1,y0,y1,zi,eps,
     * rn,one,con1,con9,con4,half,ten
      integer i,iband,iband1,iband3,iband4,ibb,ichang,ich1,ich3,ii,
     * in,irot,iter,i1,i2,i3,j,jrot,jxy,j1,kx,kx1,kx2,ky,ky1,ky2,l,
     * la,lf,lh,lwest,lx,ly,l1,l2,n,ncof,nk1x,nk1y,nminx,nminy,nreg,
     * nrint,num,num1,nx,nxe,nxx,ny,nye,nyy,n1,rank
c  ..local arrays..
      real*8 hx(6),hy(6)
cc      real*8 dif  ! for computed goto
c  ..function references..
      real*8 abs,fprati,sqrt
      integer min0
c  ..subroutine references..
c    fpback,fpbspl,fpgivs,fpdisc,fporde,fprank,fprota
c  ..
c  set constants
      one = 0.1e+01
      con1 = 0.1e0
      con9 = 0.9e0
      con4 = 0.4e-01
      half = 0.5e0
      ten = 0.1e+02
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c part 1: determination of the number of knots and their position.     c
c ****************************************************************     c
c given a set of knots we compute the least-squares spline sinf(x,y),  c
c and the corresponding weighted sum of squared residuals fp=f(p=inf). c
c if iopt=-1  sinf(x,y) is the requested approximation.                c
c if iopt=0 or iopt=1 we check whether we can accept the knots:        c
c   if fp <=s we will continue with the current set of knots.          c
c   if fp > s we will increase the number of knots and compute the     c
c      corresponding least-squares spline until finally  fp<=s.        c
c the initial choice of knots depends on the value of s and iopt.      c
c   if iopt=0 we first compute the least-squares polynomial of degree  c
c     kx in x and ky in y; nx=nminx=2*kx+2 and ny=nminy=2*ky+2.        c
c     fp0=f(0) denotes the corresponding weighted sum of squared       c
c     residuals                                                        c
c   if iopt=1 we start with the knots found at the last call of the    c
c     routine, except for the case that s>=fp0; then we can compute    c
c     the least-squares polynomial directly.                           c
c eventually the independent variables x and y (and the corresponding  c
c parameters) will be switched if this can reduce the bandwidth of the c
c system to be solved.                                                 c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  ichang denotes whether(1) or not(-1) the directions have been inter-
c  changed.
      ichang = -1
      x0 = xb
      x1 = xe
      y0 = yb
      y1 = ye
      kx = kxx
      ky = kyy
      kx1 = kx+1
      ky1 = ky+1
      nxe = nxest
      nye = nyest
      eps = sqrt(eta)
      if(iopt.lt.0) go to 20
c  calculation of acc, the absolute tolerance for the root of f(p)=s.
      acc = tol*s
      if(iopt.eq.0) go to 10
      if(fp0.gt.s) go to 20
c  initialization for the least-squares polynomial.
  10  nminx = 2*kx1
      nminy = 2*ky1
      nx = nminx
      ny = nminy
      ier = -2
      go to 30
  20  nx = nx0
      ny = ny0
c  main loop for the different sets of knots. m is a save upper bound
c  for the number of trials.
  30  do 420 iter=1,m
c  find the position of the additional knots which are needed for the
c  b-spline representation of s(x,y).
        l = nx
        do 40 i=1,kx1
          tx(i) = x0
          tx(l) = x1
          l = l-1
  40    continue
        l = ny
        do 50 i=1,ky1
          ty(i) = y0
          ty(l) = y1
          l = l-1
  50    continue
c  find nrint, the total number of knot intervals and nreg, the number
c  of panels in which the approximation domain is subdivided by the
c  intersection of knots.
        nxx = nx-2*kx1+1
        nyy = ny-2*ky1+1
        nrint = nxx+nyy
        nreg = nxx*nyy
c  find the bandwidth of the observation matrix a.
c  if necessary, interchange the variables x and y, in order to obtain
c  a minimal bandwidth.
        iband1 = kx*(ny-ky1)+ky
        l = ky*(nx-kx1)+kx
        if(iband1.le.l) go to 130
        iband1 = l
        ichang = -ichang
        do 60 i=1,m
          store = x(i)
          x(i) = y(i)
          y(i) = store
  60    continue
        store = x0
        x0 = y0
        y0 = store
        store = x1
        x1 = y1
        y1 = store
        n = min0(nx,ny)
        do 70 i=1,n
          store = tx(i)
          tx(i) = ty(i)
          ty(i) = store
  70    continue
        n1 = n+1

        if( (nx-ny) .LT. 0 ) goto  80
        if( (nx-ny) .EQ. 0 ) goto 120
        if( (nx-ny) .GT. 0 ) goto 100

  80    do 90 i=n1,ny
          tx(i) = ty(i)
  90    continue
        go to 120
 100    do 110 i=n1,nx
          ty(i) = tx(i)
 110    continue
 120    l = nx
        nx = ny
        ny = l
        l = nxe
        nxe = nye
        nye = l
        l = nxx
        nxx = nyy
        nyy = l
        l = kx
        kx = ky
        ky = l
        kx1 = kx+1
        ky1 = ky+1
 130    iband = iband1+1
c  arrange the data points according to the panel they belong to.
        call fporde(x,y,m,kx,ky,tx,nx,ty,ny,nummer,index,nreg)
c  find ncof, the number of b-spline coefficients.
        nk1x = nx-kx1
        nk1y = ny-ky1
        ncof = nk1x*nk1y
c  initialize the observation matrix a.
        do 140 i=1,ncof
          f(i) = 0.
          do 141 j=1,iband
            a(i,j) = 0.
 141    continue   ! RK
 140    continue
c  initialize the sum of squared residuals.
        fp = 0.
c  fetch the data points in the new order. main loop for the
c  different panels.
        do 250 num=1,nreg
c  fix certain constants for the current panel; jrot records the column
c  number of the first non-zero element in a row of the observation
c  matrix according to a data point of the panel.
          num1 = num-1
          lx = num1/nyy
          l1 = lx+kx1
          ly = num1-lx*nyy
          l2 = ly+ky1
          jrot = lx*nk1y+ly
c  test whether there are still data points in the panel.
          in = index(num)
 150      if(in.eq.0) go to 250
c  fetch a new data point.
          wi = w(in)
          zi = z(in)*wi
c  evaluate for the x-direction, the (kx+1) non-zero b-splines at x(in).
          call fpbspl(tx,nx,kx,x(in),l1,hx)
c  evaluate for the y-direction, the (ky+1) non-zero b-splines at y(in).
          call fpbspl(ty,ny,ky,y(in),l2,hy)
c  store the value of these b-splines in spx and spy respectively.
          do 160 i=1,kx1
            spx(in,i) = hx(i)
 160      continue
          do 170 i=1,ky1
            spy(in,i) = hy(i)
 170      continue
c  initialize the new row of observation matrix.
          do 180 i=1,iband
            h(i) = 0.
 180      continue
c  calculate the non-zero elements of the new row by making the cross
c  products of the non-zero b-splines in x- and y-direction.
          i1 = 0
          do 200 i=1,kx1
            hxi = hx(i)
            j1 = i1
            do 190 j=1,ky1
              j1 = j1+1
              h(j1) = hxi*hy(j)*wi
 190        continue
            i1 = i1+nk1y
 200      continue
c  rotate the row into triangle by givens transformations .
          irot = jrot
          do 220 i=1,iband
            irot = irot+1
            piv = h(i)
            if(piv.eq.0.) go to 220
c  calculate the parameters of the givens transformation.
            call fpgivs(piv,a(irot,1),cos,sin)
c  apply that transformation to the right hand side.
            call fprota(cos,sin,zi,f(irot))
            if(i.eq.iband) go to 230
c  apply that transformation to the left hand side.
            i2 = 1
            i3 = i+1
            do 210 j=i3,iband
              i2 = i2+1
              call fprota(cos,sin,h(j),a(irot,i2))
 210        continue
 220      continue
c  add the contribution of the row to the sum of squares of residual
c  right hand sides.
 230      fp = fp+zi**2
c  find the number of the next data point in the panel.
c xxx 240      in = nummer(in)
          in = nummer(in)
          go to 150
 250    continue
c  find dmax, the maximum value for the diagonal elements in the reduced
c  triangle.
        dmax = 0.
        do 260 i=1,ncof
          if(a(i,1).le.dmax) go to 260
          dmax = a(i,1)
 260    continue
c  check whether the observation matrix is rank deficient.
        sigma = eps*dmax
        do 270 i=1,ncof
          if(a(i,1).le.sigma) go to 280
 270    continue
c  backward substitution in case of full rank.
        call fpback(a,f,ncof,iband,c,nc)
        rank = ncof
        do 275 i=1,ncof
          q(i,1) = a(i,1)/dmax
 275    continue
        go to 300
c  in case of rank deficiency, find the minimum norm solution.
c  check whether there is sufficient working space
 280    lwest = ncof*iband+ncof+iband
        if(lwrk.lt.lwest) go to 780
        do 290 i=1,ncof
          ff(i) = f(i)
          do 291 j=1,iband
            q(i,j) = a(i,j)
 291    continue   ! RK
 290    continue
        lf =1
        lh = lf+ncof
        la = lh+iband
        call fprank(q,ff,ncof,iband,nc,sigma,c,sq,rank,wrk(la),
     *    wrk(lf),wrk(lh))
        do 295 i=1,ncof
          q(i,1) = q(i,1)/dmax
 295    continue
c  add to the sum of squared residuals, the contribution of reducing
c  the rank.
        fp = fp+sq
 300    if(ier.eq.(-2)) fp0 = fp
c  test whether the least-squares spline is an acceptable solution.
        if(iopt.lt.0) go to 820
        fpms = fp-s
        if(abs(fpms).le.acc) then

           if ( fp .LT. 0 ) GOTO 815
           if ( fp .EQ. 0 ) GOTO 815
           if ( fp .GT. 0 ) GOTO 820
        endif
c  test whether we can accept the choice of knots.
        if(fpms.lt.0.) go to 430
c  test whether we cannot further increase the number of knots.
        if(ncof.gt.m) go to 790
        ier = 0
c  search where to add a new knot.
c  find for each interval the sum of squared residuals fpint for the
c  data points having the coordinate belonging to that knot interval.
c  calculate also coord which is the same sum, weighted by the position
c  of the data points considered.
c xxxx 310    do 320 i=1,nrint
        do 320 i=1,nrint
          fpint(i) = 0.
          coord(i) = 0.
 320    continue
        do 360 num=1,nreg
          num1 = num-1
          lx = num1/nyy
          l1 = lx+1
          ly = num1-lx*nyy
          l2 = ly+1+nxx
          jrot = lx*nk1y+ly
          in = index(num)
 330      if(in.eq.0) go to 360
          store = 0.
          i1 = jrot
          do 350 i=1,kx1
            hxi = spx(in,i)
            j1 = i1
            do 340 j=1,ky1
              j1 = j1+1
              store = store+hxi*spy(in,j)*c(j1)
 340        continue
            i1 = i1+nk1y
 350      continue
          store = (w(in)*(z(in)-store))**2
          fpint(l1) = fpint(l1)+store
          coord(l1) = coord(l1)+store*x(in)
          fpint(l2) = fpint(l2)+store
          coord(l2) = coord(l2)+store*y(in)
          in = nummer(in)
          go to 330
 360    continue
c  find the interval for which fpint is maximal on the condition that
c  there still can be added a knot.
 370    l = 0
        fpmax = 0.
        l1 = 1
        l2 = nrint
        if(nx.eq.nxe) l1 = nxx+1
        if(ny.eq.nye) l2 = nxx
        if(l1.gt.l2) go to 810
        do 380 i=l1,l2
          if(fpmax.ge.fpint(i)) go to 380
          l = i
          fpmax = fpint(i)
 380    continue
c  test whether we cannot further increase the number of knots.
        if(l.eq.0) go to 785
c  calculate the position of the new knot.
        arg = coord(l)/fpint(l)
c  test in what direction the new knot is going to be added.
        if(l.gt.nxx) go to 400
c  addition in the x-direction.
        jxy = l+kx1
        fpint(l) = 0.
        fac1 = tx(jxy)-arg
        fac2 = arg-tx(jxy-1)
        if(fac1.gt.(ten*fac2) .or. fac2.gt.(ten*fac1)) go to 370
        j = nx
        do 390 i=jxy,nx
          tx(j+1) = tx(j)
          j = j-1
 390    continue
        tx(jxy) = arg
        nx = nx+1
        go to 420
c  addition in the y-direction.
 400    jxy = l+ky1-nxx
        fpint(l) = 0.
        fac1 = ty(jxy)-arg
        fac2 = arg-ty(jxy-1)
        if(fac1.gt.(ten*fac2) .or. fac2.gt.(ten*fac1)) go to 370
        j = ny
        do 410 i=jxy,ny
          ty(j+1) = ty(j)
          j = j-1
 410    continue
        ty(jxy) = arg
        ny = ny+1
c  restart the computations with the new set of knots.
 420  continue
c  test whether the least-squares polynomial is a solution of our
c  approximation problem.
 430  if(ier.eq.(-2)) go to 830
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c part 2: determination of the smoothing spline sp(x,y)                c
c *****************************************************                c
c we have determined the number of knots and their position. we now    c
c compute the b-spline coefficients of the smoothing spline sp(x,y).   c
c the observation matrix a is extended by the rows of a matrix,        c
c expressing that sp(x,y) must be a polynomial of degree kx in x and   c
c ky in y. the corresponding weights of these additional rows are set  c
c to 1./p.  iteratively we than have to determine the value of p       c
c such that f(p)=sum((w(i)*(z(i)-sp(x(i),y(i))))**2) be = s.           c
c we already know that the least-squares polynomial corresponds to     c
c p=0  and that the least-squares spline corresponds to p=infinity.    c
c the iteration process which is proposed here makes use of rational   c
c interpolation. since f(p) is a convex and strictly decreasing        c
c function of p, it can be approximated by a rational function r(p)=   c
c (u*p+v)/(p+w). three values of p(p1,p2,p3) with corresponding values c
c of f(p) (f1=f(p1)-s,f2=f(p2)-s,f3=f(p3)-s) are used to calculate the c
c new value of p such that r(p)=s. convergence is guaranteed by taking c
c f1 > 0 and f3 < 0.                                                   c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      kx2 = kx1+1
c  test whether there are interior knots in the x-direction.
      if(nk1x.eq.kx1) go to 440
c  evaluate the discotinuity jumps of the kx-th order derivative of
c  the b-splines at the knots tx(l),l=kx+2,...,nx-kx-1.
      call fpdisc(tx,nx,kx2,bx,nmax)
 440  ky2 = ky1 + 1
c  test whether there are interior knots in the y-direction.
      if(nk1y.eq.ky1) go to 450
c  evaluate the discontinuity jumps of the ky-th order derivative of
c  the b-splines at the knots ty(l),l=ky+2,...,ny-ky-1.
      call fpdisc(ty,ny,ky2,by,nmax)
c  initial value for p.
 450  p1 = 0.
      f1 = fp0-s
      p3 = -one
      f3 = fpms
      p = 0.
      do 460 i=1,ncof
        p = p+a(i,1)
 460  continue
      rn = ncof
      p = rn/p
c  find the bandwidth of the extended observation matrix.
      iband3 = kx1*nk1y
      iband4 = iband3 +1
      ich1 = 0
      ich3 = 0
c  iteration process to find the root of f(p)=s.
      do 770 iter=1,maxit
        pinv = one/p
c  store the triangularized observation matrix into q.
        do 480 i=1,ncof
          ff(i) = f(i)
          do 470 j=1,iband
            q(i,j) = a(i,j)
 470      continue
          ibb = iband+1
          do 481 j=ibb,iband4
            q(i,j) = 0.
 481    continue
 480    continue
        if(nk1y.eq.ky1) go to 560
c  extend the observation matrix with the rows of a matrix, expressing
c  that for x=cst. sp(x,y) must be a polynomial in y of degree ky.
        do 550 i=ky2,nk1y
          ii = i-ky1
          do 551 j=1,nk1x  ! RK
c  initialize the new row.
            do 490 l=1,iband
              h(l) = 0.
 490        continue
c  fill in the non-zero elements of the row. jrot records the column
c  number of the first non-zero element in the row.
            do 500 l=1,ky2
              h(l) = by(ii,l)*pinv
 500        continue
            zi = 0.
            jrot = (j-1)*nk1y+ii
c  rotate the new row into triangle by givens transformations without
c  square roots.
            do 540 irot=jrot,ncof
              piv = h(1)
              i2 = min0(iband1,ncof-irot)
              if(piv.eq.0.) then

                 if ( i2 .LT. 0 ) goto 551  ! RK 550 -> 551
                 if ( i2 .EQ. 0 ) goto 550  ! RK 550 -> 551
                 if ( i2 .GT. 0 ) goto 520
              endif
c  calculate the parameters of the givens transformation.
              call fpgivs(piv,q(irot,1),cos,sin)
c  apply that givens transformation to the right hand side.
              call fprota(cos,sin,zi,ff(irot))
              if(i2.eq.0) go to 551  ! RK 550 -> 551
c  apply that givens transformation to the left hand side.
              do 510 l=1,i2
                l1 = l+1
                call fprota(cos,sin,h(l1),q(irot,l1))
 510          continue
 520          do 530 l=1,i2
                h(l) = h(l+1)
 530          continue
              h(i2+1) = 0.
 540        continue
 
 551    continue
 550    continue
 560    if(nk1x.eq.kx1) go to 640
c  extend the observation matrix with the rows of a matrix expressing
c  that for y=cst. sp(x,y) must be a polynomial in x of degree kx.
        do 630 i=kx2,nk1x
          ii = i-kx1
          do 631 j=1,nk1y
c  initialize the new row
            do 570 l=1,iband4
              h(l) = 0.
 570        continue
c  fill in the non-zero elements of the row. jrot records the column
c  number of the first non-zero element in the row.
            j1 = 1
            do 580 l=1,kx2
              h(j1) = bx(ii,l)*pinv
              j1 = j1+nk1y
 580        continue
            zi = 0.
            jrot = (i-kx2)*nk1y+j
c  rotate the new row into triangle by givens transformations .
            do 620 irot=jrot,ncof
              piv = h(1)
              i2 = min0(iband3,ncof-irot)
              if(piv.eq.0.) then

                if ( i2 .LT. 0 ) goto 631 ! RK 630 -> 631
                if ( i2 .EQ. 0 ) goto 631
                if ( i2 .GT. 0 ) goto 600
              endif
c  calculate the parameters of the givens transformation.
              call fpgivs(piv,q(irot,1),cos,sin)
c  apply that givens transformation to the right hand side.
              call fprota(cos,sin,zi,ff(irot))
              if(i2.eq.0) go to 631  ! RK
c  apply that givens transformation to the left hand side.
              do 590 l=1,i2
                l1 = l+1
                call fprota(cos,sin,h(l1),q(irot,l1))
 590          continue
 600          do 610 l=1,i2
                h(l) = h(l+1)
 610          continue
              h(i2+1) = 0.
 620        continue
 631    continue  ! RK
 630    continue
c  find dmax, the maximum value for the diagonal elements in the
c  reduced triangle.
 640    dmax = 0.
        do 650 i=1,ncof
          if(q(i,1).le.dmax) go to 650
          dmax = q(i,1)
 650    continue
c  check whether the matrix is rank deficient.
        sigma = eps*dmax
        do 660 i=1,ncof
          if(q(i,1).le.sigma) go to 670
 660    continue
c  backward substitution in case of full rank.
        call fpback(q,ff,ncof,iband4,c,nc)
        rank = ncof
        go to 675
c  in case of rank deficiency, find the minimum norm solution.
 670    lwest = ncof*iband4+ncof+iband4
        if(lwrk.lt.lwest) go to 780
        lf = 1
        lh = lf+ncof
        la = lh+iband4
        call fprank(q,ff,ncof,iband4,nc,sigma,c,sq,rank,wrk(la),
     *   wrk(lf),wrk(lh))
 675    do 680 i=1,ncof
          q(i,1) = q(i,1)/dmax
 680    continue
c  compute f(p).
        fp = 0.
        do 720 num = 1,nreg
          num1 = num-1
          lx = num1/nyy
          ly = num1-lx*nyy
          jrot = lx*nk1y+ly
          in = index(num)
 690      if(in.eq.0) go to 720
          store = 0.
          i1 = jrot
          do 710 i=1,kx1
            hxi = spx(in,i)
            j1 = i1
            do 700 j=1,ky1
              j1 = j1+1
              store = store+hxi*spy(in,j)*c(j1)
 700        continue
            i1 = i1+nk1y
 710      continue
          fp = fp+(w(in)*(z(in)-store))**2
          in = nummer(in)
          go to 690
 720    continue
c  test whether the approximation sp(x,y) is an acceptable solution.
        fpms = fp-s
        if(abs(fpms).le.acc) go to 820
c  test whether the maximum allowable number of iterations has been
c  reached.
        if(iter.eq.maxit) go to 795
c  carry out one more step of the iteration process.
        p2 = p
        f2 = fpms
        if(ich3.ne.0) go to 740
        if((f2-f3).gt.acc) go to 730
c  our initial choice of p is too large.
        p3 = p2
        f3 = f2
        p = p*con4
        if(p.le.p1) p = p1*con9 + p2*con1
        go to 770
 730    if(f2.lt.0.) ich3 = 1
 740    if(ich1.ne.0) go to 760
        if((f1-f2).gt.acc) go to 750
c  our initial choice of p is too small
        p1 = p2
        f1 = f2
        p = p/con4
        if(p3.lt.0.) go to 770
        if(p.ge.p3) p = p2*con1 + p3*con9
        go to 770
 750    if(f2.gt.0.) ich1 = 1
c  test whether the iteration process proceeds as theoretically
c  expected.
 760    if(f2.ge.f1 .or. f2.le.f3) go to 800
c  find the new value of p.
        p = fprati(p1,f1,p2,f2,p3,f3)
 770  continue
c  error codes and messages.
 780  ier = lwest
      go to 830
 785  ier = 5
      go to 830
 790  ier = 4
      go to 830
 795  ier = 3
      go to 830
 800  ier = 2
      go to 830
 810  ier = 1
      go to 830
 815  ier = -1
      fp = 0.
 820  if(ncof.ne.rank) ier = -rank
c  test whether x and y are in the original order.
 830  if(ichang.lt.0) go to 930
c  if not, interchange x and y once more.
      l1 = 1
      do 840 i=1,nk1x
        l2 = i
        do 841 j=1,nk1y
          f(l2) = c(l1)
          l1 = l1+1
          l2 = l2+nk1x
 841  continue    ! RK
 840  continue
      do 850 i=1,ncof
        c(i) = f(i)
 850  continue
      do 860 i=1,m
        store = x(i)
        x(i) = y(i)
        y(i) = store
 860  continue
      n = min0(nx,ny)
      do 870 i=1,n
        store = tx(i)
        tx(i) = ty(i)
        ty(i) = store
 870  continue
      n1 = n+1

      if( (nx-ny) .LT. 0 ) GOTO 880
      if( (nx-ny) .EQ. 0 ) GOTO 920
      if( (nx-ny) .GT. 0 ) GOTO 900

 880  do 890 i=n1,ny
        tx(i) = ty(i)
 890  continue
      go to 920
 900  do 910 i=n1,nx
        ty(i) = tx(i)
 910  continue
 920  l = nx
      nx = ny
      ny = l
 930  if(iopt.lt.0) go to 940
      nx0 = nx
      ny0 = ny
 940  return
      end

      subroutine fpdisc(t,n,k2,b,nest)
      IMPLICIT NONE
c  subroutine fpdisc calculates the discontinuity jumps of the kth
c  derivative of the b-splines of degree k at the knots t(k+2)..t(n-k-1)
c  ..scalar arguments..
      integer n,k2,nest
c  ..array arguments..
      real*8 t(n),b(nest,k2)
c  ..local scalars..
      real*8 an,fac,prod
      integer i,ik,j,jk,k,k1,l,lj,lk,lmk,lp,nk1,nrint
c  ..local array..
      real*8 h(12)
c  ..
      k1 = k2-1
      k = k1-1
      nk1 = n-k1
      nrint = nk1-k
      an = nrint
      fac = an/(t(nk1+1)-t(k1))
      do 40 l=k2,nk1
        lmk = l-k1
        do 10 j=1,k1
          ik = j+k1
          lj = l+j
          lk = lj-k2
          h(j) = t(l)-t(lk)
          h(ik) = t(l)-t(lj)
  10    continue
        lp = lmk
        do 30 j=1,k2
          jk = j
          prod = h(j)
          do 20 i=1,k
            jk = jk+1
            prod = prod*h(jk)*fac
  20      continue
          lk = lp+k1
          b(lmk,j) = (t(lk)-t(lp))/prod
          lp = lp+1
  30    continue
  40  continue
      return
      end

      subroutine fpgivs(piv,ww,cos,sin)
      IMPLICIT NONE
c  subroutine fpgivs calculates the parameters of a givens
c  transformation .
c  ..
c  ..scalar arguments..
      real*8 piv,ww,cos,sin
c  ..local scalars..
      real*8 dd,one,store
c  ..function references..
      real*8 abs,sqrt
c  ..
      one = 0.1e+01
      store = abs(piv)
      if(store.ge.ww) dd = store*sqrt(one+(ww/piv)**2)
      if(store.lt.ww) dd = ww*sqrt(one+(piv/ww)**2)
      cos = ww/dd
      sin = piv/dd
      ww = dd
      return
      end

      subroutine fprank(a,f,n,m,na,tol,c,sq,rank,aa,ff,h)
      IMPLICIT NONE
c  subroutine fprank finds the minimum norm solution of a least-
c  squares problem in case of rank deficiency.
c
c  input parameters:
c    a : array, which contains the non-zero elements of the observation
c        matrix after triangularization by givens transformations.
c    f : array, which contains the transformed right hand side.
c    n : integer,wich contains the dimension of a.
c    m : integer, which denotes the bandwidth of a.
c  tol : real value, giving a threshold to determine the rank of a.
c
c  output parameters:
c    c : array, which contains the minimum norm solution.
c   sq : real value, giving the contribution of reducing the rank
c        to the sum of squared residuals.
c rank : integer, which contains the rank of matrix a.
c
c  ..scalar arguments..
      integer n,m,na,rank
      real*8 tol,sq
c  ..array arguments..
      real*8 a(na,m),f(n),c(n),aa(n,m),ff(n),h(m)
c  ..local scalars..
      integer i,ii,ij,i1,i2,j,jj,j1,j2,j3,k,kk,m1,nl
      real*8 cos,fac,piv,sin,yi
      double precision store,stor1,stor2,stor3
c  ..function references..
      integer min0
c  ..subroutine references..
c    fpgivs,fprota
c  ..
      m1 = m-1
c  the rank deficiency nl is considered to be the number of sufficient
c  small diagonal elements of a.
      nl = 0
      sq = 0.
      do 90 i=1,n
        if(a(i,1).gt.tol) go to 90
c  if a sufficient small diagonal element is found, we put it to
c  zero. the remainder of the row corresponding to that zero diagonal
c  element is then rotated into triangle by givens rotations .
c  the rank deficiency is increased by one.
        nl = nl+1
        if(i.eq.n) go to 90
        yi = f(i)
        do 10 j=1,m1
          h(j) = a(i,j+1)
  10    continue
        h(m) = 0.
        i1 = i+1
        do 60 ii=i1,n
          i2 = min0(n-ii,m1)
          piv = h(1)
          if(piv.eq.0.) go to 30
          call fpgivs(piv,a(ii,1),cos,sin)
          call fprota(cos,sin,yi,f(ii))
          if(i2.eq.0) go to 70
          do 20 j=1,i2
            j1 = j+1
            call fprota(cos,sin,h(j1),a(ii,j1))
            h(j) = h(j1)
  20      continue
          go to 50
  30      if(i2.eq.0) go to 70
          do 40 j=1,i2
            h(j) = h(j+1)
  40      continue
  50      h(i2+1) = 0.
  60    continue
c  add to the sum of squared residuals the contribution of deleting
c  the row with small diagonal element.
  70    sq = sq+yi**2
  90  continue
c  rank denotes the rank of a.
      rank = n-nl
c  let b denote the (rank*n) upper trapezoidal matrix which can be
c  obtained from the (n*n) upper triangular matrix a by deleting
c  the rows and interchanging the columns corresponding to a zero
c  diagonal element. if this matrix is factorized using givens
c  transformations as  b = (r) (u)  where
c    r is a (rank*rank) upper triangular matrix,
c    u is a (rank*n) orthonormal matrix
c  then the minimal least-squares solution c is given by c = b' v,
c  where v is the solution of the system  (r) (r)' v = g  and
c  g denotes the vector obtained from the old right hand side f, by
c  removing the elements corresponding to a zero diagonal element of a.
c  initialization.
      do 100 i=1,rank
        do 101 j=1,m
          aa(i,j) = 0.
 101  continue  ! RK
 100  continue
c  form in aa the upper triangular matrix obtained from a by
c  removing rows and columns with zero diagonal elements. form in ff
c  the new right hand side by removing the elements of the old right
c  hand side corresponding to a deleted row.
      ii = 0
      do 120 i=1,n
        if(a(i,1).le.tol) go to 120
        ii = ii+1
        ff(ii) = f(i)
        aa(ii,1) = a(i,1)
        jj = ii
        kk = 1
        j = i
        j1 = min0(j-1,m1)
        if(j1.eq.0) go to 120
        do 110 k=1,j1
          j = j-1
          if(a(j,1).le.tol) go to 110
          kk = kk+1
          jj = jj-1
          aa(jj,kk) = a(j,k+1)
 110    continue
 120  continue
c  form successively in h the columns of a with a zero diagonal element.
      ii = 0
      do 200 i=1,n
        ii = ii+1
        if(a(i,1).gt.tol) go to 200
        ii = ii-1
        if(ii.eq.0) go to 200
        jj = 1
        j = i
        j1 = min0(j-1,m1)
        do 130 k=1,j1
          j = j-1
          if(a(j,1).le.tol) go to 130
          h(jj) = a(j,k+1)
          jj = jj+1
 130    continue
        do 140 kk=jj,m
          h(kk) = 0.
 140    continue
c  rotate this column into aa by givens transformations.
        jj = ii
        do 190 i1=1,ii
          j1 = min0(jj-1,m1)
          piv = h(1)
          if(piv.ne.0.) go to 160
          if(j1.eq.0) go to 200
          do 150 j2=1,j1
            j3 = j2+1
            h(j2) = h(j3)
 150      continue
          go to 180
 160      call fpgivs(piv,aa(jj,1),cos,sin)
          if(j1.eq.0) go to 200
          kk = jj
          do 170 j2=1,j1
            j3 = j2+1
            kk = kk-1
            call fprota(cos,sin,h(j3),aa(kk,j3))
            h(j2) = h(j3)
 170      continue
 180      jj = jj-1
          h(j3) = 0.
 190    continue
 200  continue
c  solve the system (aa) (f1) = ff
      ff(rank) = ff(rank)/aa(rank,1)
      i = rank-1
      if(i.eq.0) go to 230
      do 220 j=2,rank
        store = ff(i)
        i1 = min0(j-1,m1)
        k = i
        do 210 ii=1,i1
          k = k+1
          stor1 = ff(k)
          stor2 = aa(i,ii+1)
          store = store-stor1*stor2
 210    continue
        stor1 = aa(i,1)
        ff(i) = store/stor1
        i = i-1
 220  continue
c  solve the system  (aa)' (f2) = f1
 230  ff(1) = ff(1)/aa(1,1)
      if(rank.eq.1) go to 260
      do 250 j=2,rank
        store = ff(j)
        i1 = min0(j-1,m1)
        k = j
        do 240 ii=1,i1
          k = k-1
          stor1 = ff(k)
          stor2 = aa(k,ii+1)
          store = store-stor1*stor2
 240    continue
        stor1 = aa(j,1)
        ff(j) = store/stor1
 250  continue
c  premultiply f2 by the transpoze of a.
 260  k = 0
      do 280 i=1,n
        store = 0.
        if(a(i,1).gt.tol) k = k+1
        j1 = min0(i,m)
        kk = k
        ij = i+1
        do 270 j=1,j1
          ij = ij-1
          if(a(ij,1).le.tol) go to 270
          stor1 = a(ij,j)
          stor2 = ff(kk)
          store = store+stor1*stor2
          kk = kk-1
 270    continue
        c(i) = store
 280  continue
c  add to the sum of squared residuals the contribution of putting
c  to zero the small diagonal elements of matrix (a).
      stor3 = 0.
      do 310 i=1,n
        if(a(i,1).gt.tol) go to 310
        store = f(i)
        i1 = min0(n-i,m1)
        if(i1.eq.0) go to 300
        do 290 j=1,i1
          ij = i+j
          stor1 = c(ij)
          stor2 = a(i,j+1)
          store = store-stor1*stor2
 290    continue
 300    fac = a(i,1)*c(i)
        stor1 = a(i,1)
        stor2 = c(i)
        stor1 = stor1*stor2
        stor3 = stor3+stor1*(stor1-store-store)
 310  continue
      fac = stor3
      sq = sq+fac
      return
      end

      real*8 function fprati(p1,f1,p2,f2,p3,f3)
c  given three points (p1,f1),(p2,f2) and (p3,f3), function fprati
c  gives the value of p such that the rational interpolating function
c  of the form r(p) = (u*p+v)/(p+w) equals zero at p.
c  ..
c  ..scalar arguments..
      real*8 p1,f1,p2,f2,p3,f3
c  ..local scalars..
      real*8 h1,h2,h3,p
c  ..
      if(p3.gt.0.) go to 10
c  value of p in case p3 = infinity.
      p = (p1*(f1-f3)*f2-p2*(f2-f3)*f1)/((f1-f2)*f3)
      go to 20
c  value of p in case p3 ^= infinity.
  10  h1 = f1*(f2-f3)
      h2 = f2*(f3-f1)
      h3 = f3*(f1-f2)
      p = -(p1*p2*h3+p2*p3*h1+p3*p1*h2)/(p1*h1+p2*h2+p3*h3)
c  adjust the value of p1,f1,p3 and f3 such that f1 > 0 and f3 < 0.
  20  if(f2.lt.0.) go to 30
      p1 = p2
      f1 = f2
      go to 40
  30  p3 = p2
      f3 = f2
  40  fprati = p
      return
      end

      subroutine fprota(cos,sin,a,b)
      IMPLICIT NONE
c  subroutine fprota applies a givens rotation to a and b.
c  ..
c  ..scalar arguments..
      real*8 cos,sin,a,b
c ..local scalars..
      real*8 stor1,stor2
c  ..
      stor1 = a
      stor2 = b
      b = cos*stor2+sin*stor1
      a = cos*stor1-sin*stor2
      return
      end

      subroutine fporde(x,y,m,kx,ky,tx,nx,ty,ny,nummer,index,nreg)
      IMPLICIT NONE
c  subroutine fporde sorts the data points (x(i),y(i)),i=1,2,...,m
c  according to the panel tx(l)<=x<tx(l+1),ty(k)<=y<ty(k+1), they belong
c  to. for each panel a stack is constructed  containing the numbers
c  of data points lying inside; index(j),j=1,2,...,nreg points to the
c  first data point in the jth panel while nummer(i),i=1,2,...,m gives
c  the number of the next data point in the panel.
c  ..
c  ..scalar arguments..
      integer m,kx,ky,nx,ny,nreg
c  ..array arguments..
      real*8 x(m),y(m),tx(nx),ty(ny)
      integer nummer(m),index(nreg)
c  ..local scalars..
      real*8 xi,yi
      integer i,im,k,kx1,ky1,k1,l,l1,nk1x,nk1y,num,nyy
c  ..
      kx1 = kx+1
      ky1 = ky+1
      nk1x = nx-kx1
      nk1y = ny-ky1
      nyy = nk1y-ky
      do 10 i=1,nreg
        index(i) = 0
  10  continue
      do 60 im=1,m
        xi = x(im)
        yi = y(im)
        l = kx1
        l1 = l+1
  20    if(xi.lt.tx(l1) .or. l.eq.nk1x) go to 30
        l = l1
        l1 = l+1
        go to 20
  30    k = ky1
        k1 = k+1
  40    if(yi.lt.ty(k1) .or. k.eq.nk1y) go to 50
        k = k1
        k1 = k+1
        go to 40
  50    num = (l-kx1)*nyy+k-ky
        nummer(im) = index(num)
        index(num) = im
  60  continue
      return
      end

      subroutine bispev(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wrk,lwrk,
     * iwrk,kwrk,ier)
      IMPLICIT NONE
c  subroutine bispev evaluates on a grid (x(i),y(j)),i=1,...,mx; j=1,...
c  ,my a bivariate spline s(x,y) of degrees kx and ky, given in the
c  b-spline representation.
c
c  calling sequence:
c     call bispev(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wrk,lwrk,
c    * iwrk,kwrk,ier)
c
c  input parameters:
c   tx    : real array, length nx, which contains the position of the
c           knots in the x-direction.
c   nx    : integer, giving the total number of knots in the x-direction
c   ty    : real array, length ny, which contains the position of the
c           knots in the y-direction.
c   ny    : integer, giving the total number of knots in the y-direction
c   c     : real array, length (nx-kx-1)*(ny-ky-1), which contains the
c           b-spline coefficients.
c   kx,ky : integer values, giving the degrees of the spline.
c   x     : real array of dimension (mx).
c           before entry x(i) must be set to the x co-ordinate of the
c           i-th grid point along the x-axis.
c           tx(kx+1)<=x(i-1)<=x(i)<=tx(nx-kx), i=2,...,mx.
c   mx    : on entry mx must specify the number of grid points along
c           the x-axis. mx >=1.
c   y     : real array of dimension (my).
c           before entry y(j) must be set to the y co-ordinate of the
c           j-th grid point along the y-axis.
c           ty(ky+1)<=y(j-1)<=y(j)<=ty(ny-ky), j=2,...,my.
c   my    : on entry my must specify the number of grid points along
c           the y-axis. my >=1.
c   wrk   : real array of dimension lwrk. used as workspace.
c   lwrk  : integer, specifying the dimension of wrk.
c           lwrk >= mx*(kx+1)+my*(ky+1)
c   iwrk  : integer array of dimension kwrk. used as workspace.
c   kwrk  : integer, specifying the dimension of iwrk. kwrk >= mx+my.
c
c  output parameters:
c   z     : real array of dimension (mx*my).
c           on succesful exit z(my*(i-1)+j) contains the value of s(x,y)
c           at the point (x(i),y(j)),i=1,...,mx;j=1,...,my.
c   ier   : integer error flag
c    ier=0 : normal return
c    ier=10: invalid input data (see restrictions)
c
c  restrictions:
c   mx >=1, my >=1, lwrk>=mx*(kx+1)+my*(ky+1), kwrk>=mx+my
c   tx(kx+1) <= x(i-1) <= x(i) <= tx(nx-kx), i=2,...,mx
c   ty(ky+1) <= y(j-1) <= y(j) <= ty(ny-ky), j=2,...,my
c
c  other subroutines required:
c    fpbisp,fpbspl
c
c  references :
c    de boor c : on calculating with b-splines, j. approximation theory
c                6 (1972) 50-62.
c    cox m.g.  : the numerical evaluation of b-splines, j. inst. maths
c                applics 10 (1972) 134-149.
c    dierckx p. : curve and surface fitting with splines, monographs on
c                 numerical analysis, oxford university press, 1993.
c
c  author :
c    p.dierckx
c    dept. computer science, k.u.leuven
c    celestijnenlaan 200a, b-3001 heverlee, belgium.
c    e-mail : Paul.Dierckx@cs.kuleuven.ac.be
c
c  latest update : march 1987
c
c  ..scalar arguments..
      integer nx,ny,kx,ky,mx,my,lwrk,kwrk,ier
c  ..array arguments..
      integer iwrk(kwrk)
      real*8 tx(nx),ty(ny),c((nx-kx-1)*(ny-ky-1)),x(mx),y(my),z(mx*my),
     * wrk(lwrk)
c  ..local scalars..
      integer i,iw,lwest
c  ..
c  before starting computations a data check is made. if the input data
c  are invalid control is immediately repassed to the calling program.
      ier = 10
      lwest = (kx+1)*mx+(ky+1)*my
      if(lwrk.lt.lwest) go to 100
      if(kwrk.lt.(mx+my)) go to 100
      if ( (mx-1) .LT. 0 ) GOTO  100
      if ( (mx-1) .EQ. 0 ) GOTO  30
      if ( (mx-1) .GT. 0 ) GOTO  10

  10  do 20 i=2,mx
        if(x(i).lt.x(i-1)) go to 100
  20  continue

  30  continue  

      if ( (my-1) .LT. 0 ) goto 100
      if ( (my-1) .EQ. 0 ) goto 60
      if ( (my-1) .GT. 0 ) goto 40


  40  do 50 i=2,my
        if(y(i).lt.y(i-1)) go to 100
  50  continue
  60  ier = 0
      iw = mx*(kx+1)+1
      call fpbisp(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wrk(1),wrk(iw),
     * iwrk(1),iwrk(mx+1))
 100  return
      end

      subroutine fpbisp(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wx,wy,lx,ly)
      IMPLICIT NONE
c  ..scalar arguments..
      integer nx,ny,kx,ky,mx,my
c  ..array arguments..
      integer lx(mx),ly(my)
      real*8 tx(nx),ty(ny),c((nx-kx-1)*(ny-ky-1)),x(mx),y(my),z(mx*my),
     * wx(mx,kx+1),wy(my,ky+1)
c  ..local scalars..
      integer kx1,ky1,l,l1,l2,m,nkx1,nky1,i,j,i1,j1
      real*8 arg,sp,tb,te
c  ..local arrays..
      real*8 h(6)
c  ..subroutine references..
c    fpbspl
c  ..
      kx1 = kx+1
      nkx1 = nx-kx1
      tb = tx(kx1)
      te = tx(nkx1+1)
      l = kx1
      l1 = l+1
      do 40 i=1,mx
        arg = x(i)
        if(arg.lt.tb) arg = tb
        if(arg.gt.te) arg = te
  10    if(arg.lt.tx(l1) .or. l.eq.nkx1) go to 20
        l = l1
        l1 = l+1
        go to 10
  20    call fpbspl(tx,nx,kx,arg,l,h)
        lx(i) = l-kx1
        do 30 j=1,kx1
          wx(i,j) = h(j)
  30    continue
  40  continue
      ky1 = ky+1
      nky1 = ny-ky1
      tb = ty(ky1)
      te = ty(nky1+1)
      l = ky1
      l1 = l+1
      do 80 i=1,my
        arg = y(i)
        if(arg.lt.tb) arg = tb
        if(arg.gt.te) arg = te
  50    if(arg.lt.ty(l1) .or. l.eq.nky1) go to 60
        l = l1
        l1 = l+1
        go to 50
  60    call fpbspl(ty,ny,ky,arg,l,h)
        ly(i) = l-ky1
        do 70 j=1,ky1
          wy(i,j) = h(j)
  70    continue
  80  continue
      m = 0
      do 130 i=1,mx
        l = lx(i)*nky1
        do 90 i1=1,kx1
          h(i1) = wx(i,i1)
  90    continue
        do 120 j=1,my
          l1 = l+ly(j)
          sp = 0.
          do 110 i1=1,kx1
            l2 = l1
            do 100 j1=1,ky1
              l2 = l2+1
              sp = sp+c(l2)*h(i1)*wy(j,j1)
 100        continue
            l1 = l1+nky1
 110      continue
          m = m+1
          z(m) = sp
 120    continue
 130  continue
      return
      end


C ==============================
+PATCH,*FITPKMJD.

C utility to fit for the peak-MJD.
C ==============================



C ====================================
+DECK,SET_PEAKMJD.
      SUBROUTINE SET_PEAKMJD()

c Created Oct 24, 2009 by R.Kessler
c
c Analyze and/or fit light curve to estimate peak-MJD. 
c Fill SNLC_SEARCH_PEAKMJD to be used as the initial 
c Tpeak-estimate in the light curve fit.
c
c This routine will not work properly for low SNR light curves.
c The minimum SNR on a light curve must be at least 4.
c
c Namelist variable OPT_SETPKMJD determines options;
c see OPTBIT_SETPKMJD_XXX options in global declaration.
c
c           HISTORY
c
c May 10 2016: remove PSF>2 epochs to get fluxMax (avoid crazy fluxes)
c              See new parameter PSFMAX_forFLUXMAX
c
c May 17, 2019: implement new options OPTBIT_SETPKMJD_[TRIGGER,MAXFLUX2]
c May 20, 2019: return if less then 2 epochs.
c Jan 27, 2020: use STDOUT_UPDATE flag to print screen update.
c May 01, 2020: implement SHIFT_SETPKMJD
c May 05, 2020: implement OPT_SETPKMJD_SIM option
c -------------------------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PKMJDCOM.

      INTEGER 
     &   EPMAX, EP
     &  ,EP_atFLUXMAX(0:MXFILT_ALL), EPTEST_atFLUXMAX(0:MXFILT_ALL)
     &  ,IFILT_OBS, ifilt, ifilt_snrmin 
     &  ,IFILT_OBS2, IFILT_OUTLIER, IFILT_REJECT
     &  ,NPKMJD, LUN, VBOSE

      REAL 
     &   PKMJDSUM, PKMJDAVG, PKMJDDIF, PKMJDDIF_MAX
     &  ,PKMJD, DIF, WGTSUM, WGT
     &  ,FLUX, FLUXERR, SNR, SNRMIN
     &  ,FLUXMAX(0:MXFILT_ALL)
     &  ,MJDatFLUXMAX(0:MXFILT_ALL)
     &  ,SNRatFLUXMAX(0:MXFILT_ALL)
         
      REAL*8  
     &   MJD8, F8, PKMJD8, PKMJD8ERR, PKFLUX8, PKFLUX8ERR
     &  ,PARLIST(3), FITWIN_MJD8(2)

      LOGICAL 
     &    LSET, LDMP, LDMP_USER, NOABORT, LABORT
     &   ,USEFILT(MXFILT_ALL)
     &   ,USE_MJDatFLUXMAX, USE_MJDatFMAXCLUMP
     &   ,USE_MJDatTRIGGER
     &   ,USE_SIMPKMJD
     &   ,FIRST_INIT, DOFIT, NOFIT

      CHARACTER cfilt*8, FNAM*12, METHOD*24, CCID*(MXCHAR_CCID)

c define hard-wired cut-parameters
      REAL   
     &   MJDMIN_LC
     &  ,PKMJD_OUTLIER
     &  ,MAX_SNRMIN_REJECT

      PARAMETER ( 
     &   MJDMIN_LC           = 40000. ! min MJD to consider for light curve
     &  ,PKMJD_OUTLIER       = 30.0   ! reject PKMJD off by this much 
     &  ,MAX_SNRMIN_REJECT   = 2.0    ! max SNRMIN to reject filter
     &     )
      
c function
      EXTERNAL init_obs_atFLUXMAX, get_obs_atFLUXMAX

C ---------------- BEGIN ----------------

      if ( OPT_SETPKMJD <= 0 ) RETURN

      FNAM = 'SET_PEAKMJD'
      CCID = SNLC_CCID

      if ( ISNLC_NEWMJD_STORE < 2 ) RETURN

c July 12 2013: check option to use MJD at max flux (no fitting)
      USE_MJDatFLUXMAX  = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_FLUXMAX)
      USE_MJDatFMAXCLUMP = 
     &           BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_FLUXMAX2)
     &     .or.  BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_FLUXMAX3)
      USE_MJDatTRIGGER  = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_TRIGGER)
      USE_SIMPKMJD      = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_SIM)
      DOFIT = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_ANYFUN) .or. ! Bazin09
     &        BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_POLYCOR)
      NOFIT = (.NOT. DOFIT)

      if ( USE_MJDatTRIGGER .and. PHOTFLAG_TRIGGER == 0 ) then
        c1err = 'Must set PHOTFLAG_TRIGGER in &SNLCINP'
        c2err = 'to set PEAKMJD = MJD_TRIGGER'
        CALL MADABORT(FNAM, c1err, c2err)
      endif

c May 5 2020: check option to use true SIM_PEAKMJD 
      IF ( USE_SIMPKMJD ) THEN
        if ( LSIM_SNANA ) then
            PKMJD = SIM_PEAKMJD
            GOTO 800
        else
           c1err = 'Cannot use OPT_SETPKMJD += 2048 for real data'
           c2err = 'This option (use SIM_PEAKMJD) is for sim only'
           CALL MADABORT(FNAM, c1err, c2err)
        endif
      ENDIF

c bail if the user CUTWIN_PEAKMJD does not contain  any observations:
      IF ( SNLC8_MJDMIN .GT. CUTWIN_PEAKMJD(2) ) RETURN
      IF ( SNLC8_MJDMAX .LT. CUTWIN_PEAKMJD(1) ) RETURN

c first-time init: 
c  + print comments to stdout
c  + open separate log file to dump MNFIT stuff for each SN
      FIRST_INIT = (NFIT_PKMJD==0) 

      IF  ( FIRST_INIT ) THEN  ! init
         LSET = .FALSE.
         print*,' ' 
         if ( USE_MJDatFLUXMAX ) then
            write(6,80) 'MJD at max flux' ; LSET=.TRUE.
            METHOD = '(FLuxMax)'
         else if ( USE_MJDatFMAXCLUMP ) then
            write(6,80) 
     &         'MJD at max flux in dense clump of SNR-detections.'
            LSET=.TRUE.
            METHOD = '(FmaxClump)'
         else if ( USE_MJDatTRIGGER ) then
            write(6,80) 'MJD_TRIGGER' ; LSET=.TRUE.
            METHOD = '(MJD_trigger)'
         endif

         if( DOFIT ) then
            write(6,80) 'Bazin fit' ; LSET=.TRUE.
            METHOD = '(FluxMax+BazinFit)'
            if ( USE_MJDatFMAXCLUMP ) METHOD = '(FmaxClump+BazinFit)'
         endif
 80      format(' SET_PEAKMJD method: ', A)
         print*,' ' 
         call flush(6)

         if ( .not. LSET ) then
            write(6,80) 'UNKNOWN'
            write(c1err,86) OPT_SETPKMJD
 86         format('Unknown OPT_SETPKMJD=',I5,' in &SNLCINP.')
            c2err = 'See manual for OPT_SETPKMJD'
            CALL MADABORT(FNAM, c1err,c2err ) 
         endif

         VBOSE = 1
         PARLIST(1) = MJDWIN_SETPKMJD    ! user MJDWIN from &SNLCINP
         PARLIST(2) = SNRCUT_SETPKMJD    ! user SNRCUT from &SNLCINP
         PARLIST(3) = SNRMIN_forFLUXMAX  ! backup SNRCUT if above always fails
         call init_obs_atFLUXMAX(OPT_SETPKMJD, PARLIST, VBOSE)

c open outfile to dump MINUIT stdout
         if ( DOFIT ) then
            LUN = LUNPKMJD
            OPEN(UNIT=LUN,FILE=MNFIT_PKMJD_LOGFILE,status='UNKNOWN')
         endif

c open INTERP-OUT file if set
+SELF,IF=SNANA.
         IF ( SNMJD_OUT_FILE .NE. ' ' ) THEN
            LUN = LUNINTERP
            OPEN(UNIT=LUN,FILE=SNMJD_OUT_FILE,status='UNKNOWN')
            write(LUNINTERP,46) 
 46         format('VARNAMES:',2x,'CID', 4x,'FILT', 5x,'MJD',
     &           10x,'FLUX      FLUXERR')
         ENDIF
+SELF.

      ENDIF  ! end of FIRST_INIT
    
      NFIT_PKMJD = NFIT_PKMJD  + 1

      global_banner = 
     &   'SET_PEAKMJD: Find Estimate of PEAK-MJD for CID='  // 
     &   CCID
cc      CALL PRBANNER ( global_banner )

      IF ( NFILTDEF_SURVEY .GT. MXFILT_OBS ) THEN
        write(c1err,1661) NFILTDEF_SURVEY
        write(c2err,1662) MXFILT_OBS
1661    format('There are ', I3,' obs-filters,')
1662    format('but SET_PEAKMJD works for up to ',I2,' filters.')
        CALL MADABORT(FNAM, c1err, c2err)        
      ENDIF

c initialize

      DO 480 IFILT_OBS = 0, MXFILT_ALL
         EP_atFLUXMAX(IFILT_OBS)  = -9
         FLUXMAX(IFILT_OBS)       =  0.0
         MJDatFLUXMAX(IFILT_OBS)  = -9.0 
         SNRatFLUXMAX(IFILT_OBS)  = -9.0 
         
         IF ( IFILT_OBS .EQ. 0 ) goto 480

         PKMJD_FIT(IFILT_OBS)     =  0.0
         PKMJD_ERR(IFILT_OBS)     = -9.0
         PKFLUX_FIT(IFILT_OBS)    = -9.0
         PKFLUX_ERR(IFILT_OBS)    = -9.0
         
         USEFILT(ifilt_obs) = .FALSE.
 480  CONTINUE


      PKMJD_ERRMIN = 1.0E9
      PKMJD_ERRWGT = 0.0

      PKFLUX_ERRMIN = 1.0E9
      PKFLUX_ERRWGT = 0.0

c find epoch with max flux for each filter using C-function
       
       CALL get_obs_atFLUXMAX(
     &      CCID(1:ISNLC_LENCCID)//char(0),
     &      ISNLC_NEWMJD_STORE,
     &      SNLC_FLUXCAL, SNLC_FLUXCAL_ERRTOT,   
     &      SNLC8_MJD, ISNLC_IFILT_OBS,
     &      EP_atFLUXMAX(0),            ! <== returned array vs. IFILTOBS
     &      MXCHAR_CCID )

c use EP at max flux to set FLUXMAX, MJD at max, SNR at max.
      DO 40 ifilt = 0, NFILTDEF_SURVEY
         if ( ifilt == 0 ) then
            ifilt_obs = 0
         else
            ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         endif
         EP = EP_atFLUXMAX(ifilt_obs)+1 ! from C code

         if ( EP < 0 ) then
           SNRatFLUXMAX(ifilt_obs) = 0.01
           MJDatFLUXMAX(ifilt_obs) = 0.01
           goto 40
         endif

         FLUX      = SNLC_FLUXCAL(EP)
         FLUXERR   = SNLC_FLUXCAL_ERRTOT(EP)

         FLUXMAX(ifilt_obs)      = FLUX
         MJDatFLUXMAX(ifilt_obs) = SNGL(SNLC8_MJD(ep))
         if ( FLUXERR > 0.0 ) then
            SNRatFLUXMAX(ifilt_obs) = FLUX/FLUXERR
         else
            SNRatFLUXMAX(ifilt_obs) = 0.0
         endif
40     CONTINUE

c -------------------------------------
c check option to use MJD at max-flux or at TRIGGER
      IF ( NOFIT ) THEN
         IF ( USE_MJDatFLUXMAX .or. USE_MJDatFMAXCLUMP ) THEN
            PKMJD  = MJDatFLUXMAX(0) 
         ELSE IF ( USE_MJDatTRIGGER ) THEN
            PKMJD  = SNGL(SNLC8_MJD_TRIGGER)
         ELSE
            C1err = 'Invalid NOFIT option.'
            c2err = 'Expecting MJD-at-maxFlux or MJD-at-Trigger'
            CALL MADABORT(FNAM, c1err, c2err)  
         ENDIF

         SNLC_SEARCH_PEAKMJD    = PKMJD
         IF ( STDOUT_UPDATE ) then
            write(6,50) CCID(1:ISNLC_LENCCID), PKMJD, METHOD
         ENDIF

         RETURN
      ENDIF


c --------- Below do some kind of Bazin fit -----------

c --------------
c Find valid filter with smallest SNR at epoch with max-FLux,
c and that has SNR below MAX_SNRMIN_REJECT.
c If all filters have SNR > MAX_SNRMIN_REJECT then use all filters;
c otherwise toss the one with smallest SNR at FLUXMAX.

      SNRMIN = 999999999.
      IFILT_SNRMIN = -9
      DO ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         SNR = SNRatFLUXMAX(ifilt_obs)

         if (    SNR .LT. SNRMIN 
     &     .and. SNR .LT. MAX_SNRMIN_REJECT
     &     .and. SNR .GT. 0.0  ) then

            SNRMIN = SNR
            ifilt_snrmin = ifilt_obs  ! filter to reject
         endif
      ENDDO

c -----------------------------------------
c Now fit each filter to general function using MINUIT.
c Take weighted PKMJD-average so that badly measured
c PKMJD don't have much effect

      NPKMJD   = 0
      PKMJDSUM = 0.0
      WGTSUM   = 0.0
      PKMJDDIF_MAX = 0.0
      FITWIN_MJD8(1) = MJDatFLUXMAX(0) + CUTWIN_TOBS(1)
      FITWIN_MJD8(2) = MJDatFLUXMAX(0) + CUTWIN_TOBS(2)

      DO 200 ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         MJD8      = DBLE( MJDatFLUXMAX(ifilt_obs) )
         F8        = DBLE ( FLUXMAX(IFILT_OBS) ) 

         if ( MJD8      .LT. MJDMIN_LC    ) GOTO 200
         if ( ifilt_obs .EQ. ifilt_snrmin ) GOTO 200

         USEFILT(ifilt_obs) = .TRUE.
          
         CALL MNFIT_PKMJD(IFILT_OBS, FITWIN_MJD8, F8, MJD8,   ! inputs
     &              PKMJD8, PKMJD8ERR, PKFLUX8, PKFLUX8ERR)   ! return args

c store result for each filter.

           PKFLUX_FIT(ifilt_obs) = SNGL(PKFLUX8)
           PKFLUX_ERR(ifilt_obs) = SNGL(PKFLUX8ERR)

           PKMJD_FIT(ifilt_obs) = SNGL(PKMJD8)
           PKMJD_ERR(ifilt_obs) = SNGL(PKMJD8ERR)
           NPKMJD = NPKMJD + 1

c check option to interpolate flux
+SELF,IF=SNANA.
           CALL SNMJD_INTERP_ANYLC(ifilt_obs)
+SELF.

200   CONTINUE

      IF ( NPKMJD .EQ. 0 ) then

         NOABORT = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_NOABORT)
     &        .or. (OPT_REFORMAT_FITS > 0)
     &        .or. (.not. ABORT_ON_NOPKMJD)  ! 7.29.2014

         LABORT  = (.NOT. NOABORT)

         IF ( LABORT ) then         
            C1err = 'NMJD=0 => no estimate of PKMJD !!!'
            c2err = 'Check SN ' // CCID
            CALL MADABORT(FNAM, c1err, c2err)  
         ELSE
            write(6,240) CCID
 240        format(T8,'Could not estimate PKMJD for CID=',A)
            call flush(6)
            PKMJD = -1.
            GOTO 800
         ENDIF
      ENDIF

c convert sum of 1/err^2 into wgted error.
      IF  ( PKMJD_ERRWGT .GT. 0.0 ) THEN
         PKMJD_ERRWGT  = SQRT(1.0/PKMJD_ERRWGT)
      ENDIF
      IF ( PKFLUX_ERRWGT .GT. 0.0 ) THEN
         PKFLUX_ERRWGT = SQRT(1.0/PKFLUX_ERRWGT)
      ENDIF

c if there are more than 2 filters, check for
c crazy outlier.

      IFILT_REJECT    = -9
      IFILT_OUTLIER   = -9

      IF ( NPKMJD .GE. 3 ) THEN
      DO 252 ifilt_obs2 = 1, MXFILT_ALL  ! ignore this filter in average
         if ( .not. USEFILT(ifilt_obs2) ) goto 252
         PKMJDSUM = 0.0
         WGTSUM = 0.0

      DO 250 ifilt_obs  = 1, MXFILT_ALL
         if ( .not. USEFILT(ifilt_obs) ) goto 250
         if ( ifilt_obs2 .NE. ifilt_obs ) then
           PKMJDSUM = PKMJDSUM + (PKMJD_FIT(ifilt_obs)-SNGL(MJDOFF))
           WGTSUM   = WGTSUM + 1.0
         endif
250   CONTINUE

c test average against filter that was excluded

         PKMJDAVG = (PKMJDSUM/WGTSUM + SNGL(MJDOFF) )
         PKMJDDIF = abs(PKMJDAVG - PKMJD_FIT(ifilt_obs2))

         if ( PKMJDDIF .GT. PKMJDDIF_MAX ) then
            PKMJDDIF_MAX  = PKMJDDIF
            IFILT_OUTLIER = ifilt_obs2            
         endif

252   CONTINUE

         if ( PKMJDDIF_MAX .GT. PKMJD_OUTLIER ) then
           USEFILT(ifilt_outlier) = .FALSE.
           IFILT_REJECT = IFILT_OUTLIER

c            print*,' xxx REJECT FILT=',IFILT_OUTLIER, 
c     &       '  for CID=',CCID,'  PKMJDDIF=', PKMJDDIF_MAX
         endif

      ENDIF

c ---------------------------------------
c Finally, take PKMJD-wgted average of remaining filters.

      PKMJDSUM = 0.0
      WGTSUM   = 0.0
      NPKMJD   = 0

      DO 300 ifilt_obs = 1, MXFILT_ALL
         if ( .not. USEFILT(ifilt_obs) ) goto 300
      
           PKMJD8    = PKMJD_FIT(ifilt_obs)
           PKMJD8ERR = PKMJD_ERR(ifilt_obs)

           WGT    = SNGL(1.0/PKMJD8ERR) ! * 10.0/MAX(PKMJDDIF,10.0)

           PKMJDDIF = SNGL(PKMJD8 - MJDOFF)
       
           PKMJDSUM = PKMJDSUM + WGT*PKMJDDIF
           WGTSUM = WGTSUM + WGT
           NPKMJD = NPKMJD + 1

300   CONTINUE

      PKMJDAVG = PKMJDSUM/WGTSUM + SNGL(MJDOFF)
      PKMJD    = PKMJDAVG

      if ( STDOUT_UPDATE ) THEN
        write(6,50) CCID(1:ISNLC_LENCCID), PKMJD, METHOD
50      format(T8,'SET_PEAKMJD(',A,') --> ', F9.3, 3x, A )
        call flush(6)
      endif

c -----------------------------------------------

      LDMP_USER =  BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_DUMP)
      LDMP      = LDMP_USER

      IF ( LDMP ) THEN
        print*,'  --------------------------------------------- '
        print*,'  BEGIN DUMP of SET_PEAKMJD for SN ', CCID
        print*,'  '
        print*,'                  MJDat    SNRat      PKMJD  PKMJD  '
        print*,'  filt  FLUXMAX   FLUXMAX  FLUXMAX    fit    err    '
        print*,'  --------------------------------------------------'

        DO 660 ifilt_obs = 1, MXFILT_ALL
           if ( .not. USEFILT(ifilt_obs) ) goto 660
           cfilt =  filtdef_string(ifilt_obs:ifilt_obs) 
           write(6,661) cfilt
     &       , FLUXMAX(ifilt_obs)
     &       , MJDatFLUXMAX(ifilt_obs)
     &       , SNRatFLUXMAX(ifilt_obs)
     &       , PKMJD_FIT(ifilt_obs)
     &       , PKMJD_ERR(ifilt_obs)
661        format( T5,A, T7,F10.1, F11.2, F6.1, F11.2, F7.2 )

660      CONTINUE
         print*, ' '

        if ( ifilt_snrmin .GT. 0 ) then
          cfilt =  filtdef_string(ifilt_snrmin:ifilt_snrmin) 
        else
          cfilt = 'none'
        endif
        print*,'    Filter with min SNR at max: ', cfilt

        if ( ifilt_reject .GT. 0 ) then
          cfilt =  filtdef_string(ifilt_reject:ifilt_reject) 
        else
          cfilt = 'none'
        endif
        print*,'    PKMJD-outlier filter rejected : ', cfilt

        print*,'    PEAKMJD(CALC,SEARCH)  = ', 
     &            PKMJD, SNLC_SEARCH_PEAKMJD

        print*,'    CALC-SEARCH PKMJD DIF = ', DIF
        print*,'  END DUMP of SET_PEAKMJD for SN ', CCID
        print*,'  --------------------------------------------- '
      ENDIF
     
c -----------------------------------------    
800   CONTINUE

      PKMJD = PKMJD + SHIFT_SETPKMJD
      SNLC_SNANAFIT_PEAKMJD = PKMJD
      SNLC_SEARCH_PEAKMJD   = PKMJD

      RETURN
      END  ! end SET_PEAKMJD


C =========================================
+DECK,MNFIT_PKMJD.
      SUBROUTINE MNFIT_PKMJD(ifilt_obs, FITWIN_MJD,
     &        FLUXatMAX, MJDatMAX, PKMJD,PKMJDERR, PKFLUX, PKFLUXERR )

c -----------------------------------------------
c Created Oct 29, 2009 by R.Kessler
c Fit FCNANYLC (any LC function) to estimate PKMJD.
c
c METHOD:
c First get  approx PEAKMJD = filter-average of MJDs at max flux.
c Then grid-minimize Eq. 1 of  Bazin et al., (SNLC CC rate)
c from astro-ph 0904.1066. 
c
c               exp[ -(t-t0)/Tfall ]
c  f(t) = A * --------------------------  +  B
c              1 + exp[ -(t-t0)/Trise ]
c
c where t0, Trise, Tfall, A, & B=0 are the five
c fit-parameters for each filter. We only care about
c getting an approximate function, so we don't care
c about errors.
c
c Note that the exponent in their denomintor is missing a 
c minus sign (with Trise > 0). The t0 parameter is not really 
c the time at peak; after the fit has converged, the true Tpeak  
c is found by setting the derivative=0.
c
c Jun 6, 2010: for POLYCOR option, do BTEST on OPT_SETPKMJD
c
c Oct 26, 2010: remove "SET PRint" command so that we get
c               correlation matrix printed to screen.
c
c Dec 9, 2011: keep track of min-error and  wgted error for 
c              T0 and F0err/F0.
c
c May 28 2019: add FITWIN_MJD argument to restrict range of epochs fit.
c Sep 22 2020: MNARG -> MNARG(10) to avoid warnings with gcc v10
c ----------------------------

      IMPLICIT NONE

c function args

      INTEGER IFILT_OBS   ! (I) SN index and obs filter to fit

      REAL*8
     &   FITWIN_MJD(2) ! (I) MJD window to fit observations
     &  ,MJDatMAX      ! (I) MJD at epoch with max flux
     &  ,FLUXatMAX     ! (I) flux at MJD with max flux
     &  ,PKMJD      ! (O) MJD at peak of function
     &  ,PKMJDERR   ! (O) approx error on PKMJD (used for wgted avg)
     &  ,PKFLUX     ! (O) peak flux from fit
     &  ,PKFLUXERR  ! (O) error on above

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PKMJDCOM.

c MINUIT stuff

      INTEGER IERR, IPAR, IVARBL

      INTEGER 
     &   IUNIN, IUOUT, IUWRI
     &  ,NFIXPAR, IFILT
     
      EXTERNAL FCNANYLC, ANYLCFUN
      DOUBLE  PRECISION  ANYLCFUN

      LOGICAL USE_ANYFUN, USE_POLYCOR 

      REAL*8 
     &   MNARG(10)  
     &  ,FIXLIST(NPAR_ANYLC)
     &  ,INIBND(2,NPAR_ANYLC)
     &  ,INISTP(NPAR_ANYLC)
     &  ,INIVAL(NPAR_ANYLC)
     &  ,TMPVAL(10), TMPERR(10), BND1, BND2
     &  ,T0, TRISE, TFALL, ARG, T0ERR
     &  ,INIVAL_TMP, COV
     &  ,ERRTMP

c functions
      REAL*8 COVPKFLUXFUN

C ---------------- BEGIN -------------

      USE_ANYFUN  = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_ANYFUN)
      USE_POLYCOR = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_POLYCOR)

      IUNIN = 5
      IUOUT = LUNPKMJD   ! write to file instead of STDOUT=6 
      IUWRI = 7

      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 

c ---------------------------------
c write header to log file so we know what CID and filter

      write(LUNPKMJD,20) 
     &   SNLC_CCID
     &  ,filtdef_string(ifilt_obs:ifilt_obs) 
20    format(/, T2, 60('#'), 
     &       /, T10,'MNFIT_PKMJD for CID=',A8,' FILTER=',A,
     &       /, T2, 60('#'), / )

c ------------------------

+SELF,IF=MINUIT.
      CALL MNINIT(IUNIN,IUOUT,IUWRI)  ! init MINUIT

      MNARG(1) = dble(0.0) 
      CALL MNEXCM(FCNANYLC, 'SET NOWarnings', MNARG,0,IERR, ANYLCFUN)

      MNARG(1) = DBLE(MINUIT_PRINT_LEVEL)
      CALL MNEXCM(FCNANYLC, 'SET PRI', MNARG, 1, IERR, ANYLCFUN )
+SELF.


c init each parameter
      INIBND(1,IPAR_ISN) = 0
      INIBND(2,IPAR_ISN) = 9999999.
      INIVAL(IPAR_ISN)   = DBLE(SNLC_CID) 
      INISTP(IPAR_ISN)   = 0.0       ! fixed parameter

      INIBND(1,IPAR_FILT) = 0
      INIBND(2,IPAR_FILT) = 100
      INIVAL(IPAR_FILT)   = DBLE(IFILT_OBS)
      INISTP(IPAR_FILT)   = 0.0     ! fixed parameter

      INIBND(1,IPAR_MJDMIN) = 0
      INIBND(2,IPAR_MJDMIN) = 150000
      INIVAL(IPAR_MJDMIN)   = FITWIN_MJD(1)
      INISTP(IPAR_MJDMIN)   = 0.0     ! fixed parameter

      INIBND(1,IPAR_MJDMAX) = 0
      INIBND(2,IPAR_MJDMAX) = 150000
      INIVAL(IPAR_MJDMAX)   = FITWIN_MJD(2)
      INISTP(IPAR_MJDMAX)   = 0.0     ! fixed parameter

      INIBND(1,IPAR_T0) = MJDatMAX - 50.0
      INIBND(2,IPAR_T0) = MJDatMAX + 50.0
      INIVAL(IPAR_T0)   = MJDatMAX
      INISTP(IPAR_T0)   = 2.0

      INIBND(1,IPAR_TRISE) =  1.0
      INIBND(2,IPAR_TRISE) =  40.
      INIVAL(IPAR_TRISE)   =  5.0
      INISTP(IPAR_TRISE)   =  2.0

      INIBND(1,IPAR_TFALL) = 1.0
      INIBND(2,IPAR_TFALL) = 100.0
      INIVAL(IPAR_TFALL)   = 10.0
      INISTP(IPAR_TFALL)   = 2.0

      INIBND(1,IPAR_A0) = FLUXatMAX * 0.2
      INIBND(2,IPAR_A0) = FLUXatMAX * 5.0
      INIVAL(IPAR_A0)   = FLUXatMAX * 1.2
      INISTP(IPAR_A0)   = FLUXatMAX * 0.1

      IF ( USE_POLYCOR ) THEN
         INIVAL_TMP = 0.1
      ELSE
         INIVAL_TMP = 0.0
      ENDIF

      INIBND(1,IPAR_A1)   = -20.0
      INIBND(2,IPAR_A1)   =  20.0
      INIVAL(IPAR_A1)     =   0.0
      INISTP(IPAR_A1)     = INIVAL_TMP

      INIBND(1,IPAR_A2)   = -20.0
      INIBND(2,IPAR_A2)   =  20.0
      INIVAL(IPAR_A2)     =   0.0
      INISTP(IPAR_A2)     = INIVAL_TMP
c      PKPARNAME(IPAR_A2)  =  'A2'


      CHI2_FITPKMJD(IFILT) = -9.0
      NDOF_FITPKMJD(IFILT) = -9

      NFIXPAR = 0
      DO IPAR = 1, NPAR_ANYLC

+SELF,IF=MINUIT.
         CALL MNPARM(IPAR,    PKPARNAME(IPAR)
     &       ,INIVAL(IPAR),   INISTP(IPAR)
     &       ,INIBND(1,IPAR), INIBND(2,IPAR)
     &       ,IERR   ) 
+SELF.

         IF ( IERR .NE. 0 ) THEN
            WRITE (6,'(A,A10,A)') '  ERROR initializing ', 
     &            PKPARNAME(ipar), '  with MNPARM '
            RETURN
         ENDIF

c keep track of fixed parameters
        if ( INISTP(IPAR) .EQ. 0.0 ) then
           NFIXPAR =  NFIXPAR + 1
           FIXLIST(NFIXPAR) = DBLE ( IPAR )
        endif

      ENDDO  ! end of IPAR loop

      CALL FLUSH(6)

+SELF,IF=MINUIT.
      CALL MNEXCM(FCNANYLC, 'FIX', FIXLIST, NFIXPAR, IERR, ANYLCFUN )

      MNARG(1) = dble(30000.0)  ! MAXCALLS
      CALL MNEXCM(FCNANYLC, 'MINIMIZE', MNARG, 0, IERR, ANYLCFUN )
+SELF.

      DO IPAR = 1,  NPAR_ANYLC

+SELF,IF=MINUIT.
        CALL MNPOUT(  IPAR, PKPARNAME(IPAR)
     &              , TMPVAL(IPAR), TMPERR(IPAR)
     &              , BND1, BND2, IVARBL )
+SELF.

        SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar) = SNGL(TMPVAL(IPAR))
        SNLC_SNANAFIT_PEAKMJD_FITERR(ifilt,ipar) = SNGL(TMPERR(IPAR))

      ENDDO

+SELF,IF=MINUIT.
      MNARG(1) = ZERO8
      CALL MNEXCM ( FCNANYLC, 'EXIT',  MNARG, 0, IERR, ANYLCFUN )
**      PRINT *,'  MNFIT_PKMJD: EXIT returns IERR = ', IERR
+SELF.

c compute PKMJD from setting 1st deriviate = 0
      Tfall = TMPVAL(IPAR_TFALL)
      Trise = TMPVAL(IPAR_TRISE)
      T0    = TMPVAL(IPAR_T0)
      T0ERR = TMPERR(IPAR_T0)

      arg = (Tfall - Trise)/Trise
      if ( ARG .GT. 0.1 ) then 
         PKMJD = T0 + Trise * DLOG(ARG)
         PKMJDERR = MIN(T0ERR,4.0)  ! max error is 4 days
      else
         PKMJD = MJDatMAX
         PKMJDERR = 4.0
      endif


      if ( OPT_REFORMAT_SALT2 .GT. 0 ) then
         PKMJDERR = T0ERR
      endif

c get error on peak flux from fit


+SELF,IF=MINUIT.
      CALL MNEMAT(FITERRMAT_PKMJD(1,1,ifilt_obs),NPAR_ANYLC)
+SELF.
      COV = COVPKFLUXFUN(ifilt_obs,PKMJD,PKMJD)

      PKFLUX    = ANYLCFUN(PKMJD,TMPVAL)
      PKFLUXERR = SQRT(COV)

c Dec 9, 2011
c keep track of min error and wgted error
      ERRTMP  = T0ERR
      IF ( ERRTMP .LT. PKMJD_ERRMIN .and. ERRTMP .GT. 0.0 ) THEN
         PKMJD_ERRMIN = SNGL(ERRTMP)
         PKMJD_ERRWGT = PKMJD_ERRWGT + 1.0/SNGL(ERRTMP*ERRTMP)
      ENDIF

      ERRTMP  = PKFLUXERR/PKFLUX
      IF ( ERRTMP .LT. PKFLUX_ERRMIN .and. 
     &     ERRTMP .GT. 0.0   .and.
     &     ERRTMP .NE. 1.0 ) THEN
        PKFLUX_ERRMIN = SNGL(ERRTMP)
        PKFLUX_ERRWGT = PKFLUX_ERRWGT + 1.0/SNGL(ERRTMP*ERRTMP)
      ENDIF

      RETURN
      END

C =========================================
+DECK,FCNANYLC.
      SUBROUTINE FCNANYLC(NVAR,GRAD,CHI2,XVAL,IFLAG, ANYLCFUN )
c
c Created Oct 25, 2009
c MINUIT-callable function to return data-model CHI2
c using the "ANY LC" model from Bazin et al.
c See comments at top of MNFIT_PKMJD.
c
c May 28, 2019: Use MJDMIN/MJDMAX to restrict epoch range.
c
c --------------------------------------------
      IMPLICIT NONE

      INTEGER NVAR, IFLAG
      REAL*8 
     &   XVAL(*)  ! (I) T0, Trise, Tfall, A, B
     &  ,GRAD(*)
     &  ,CHI2
     &  ,ANYLCFUN

      EXTERNAL ANYLCFUN
  
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PKMJDCOM.  Oct 2014

c local var

      INTEGER 
     &   ISN, IFILT_OBS, IFILT
     &  ,NEWMJD, EPMIN, EPMAX, EP, NDOF

      REAL*8
     &   MJDMIN, MJDMAX, FLUX, FLUXERR, MJD, SQDIF, SQERR, SNR 
     &  ,MODEL_FLUX, MODEL_FLUXERR

      REAL*8 MODEL_MAGERR
      PARAMETER ( MODEL_MAGERR = 0.05 )

C --------------- BEGIN -------------

      ISN         = INT ( XVAL(1) + 0.0001 )
      IFILT_OBS   = INT ( XVAL(2) + 0.0001 )
      MJDMIN      = XVAL(3)
      MJDMAX      = XVAL(4)

      CHI2 = 0.0
      NDOF = 0 

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        MJD   = SNLC8_MJD(EPMIN)

        if ( MJD < MJDMIN ) goto 200
        if ( MJD > MJDMAX ) goto 200

        MODEL_FLUX    = ANYLCFUN(MJD,XVAL)
        MODEL_FLUXERR = MODEL_FLUX * MODEL_MAGERR

        DO 201 EP = EPMIN, EPMAX

            if ( IFILT_OBS .NE. ISNLC_IFILT_OBS(ep) ) GOTO 201

            FLUX      = SNLC_FLUXCAL(ep)
            FLUXERR   = SNLC_FLUXCAL_ERRTOT(ep)

c SNR requirement makes things worse ??
            SNR = FLUX/FLUXERR
            
            SQDIF = (FLUX - MODEL_FLUX)**2
            SQERR = FLUXERR*FLUXERR + MODEL_FLUXERR*MODEL_FLUXERR
            CHI2  = CHI2 + SQDIF/SQERR
            NDOF = NDOF + 1

201     CONTINUE   ! ep
200   CONTINUE  ! end of NEWMJD

c --------------------------------------
c load chi2 and NDOF in global array

      IF (IFLAG == FCNFLAG_LAST ) THEN
        IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
        CHI2_FITPKMJD(IFILT) = SNGL(CHI2)
        NDOF_FITPKMJD(IFILT) = NDOF
      ENDIF

      RETURN
      END

C ======================================
+DECK,ANYLCFUN.
      DOUBLE PRECISION FUNCTION ANYLCFUN(MJD,XVAL)
c
c Created Dec 5, 2009 by R.Kessler
c Any light curve function based on Bazin et al,, 2009 (SNLS CC rate)
c
c May 28 2019: replace hard-code XVAL-indices with IPAR_XXX
c ------------
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,PKMJDCOM. 

c function args

      REAL*8 MJD, XVAL(*)

c local args

      REAL*8 
     &   T0, TRISE, TFALL, A0, A1, A2
     &  ,ARG1, ARG2, DUM1, DUM2, TDIF, POLYCOR
     &  ,MODEL_FLUX

C ---------- BEGIN ---------

      T0    = XVAL(IPAR_T0)
      TRISE = XVAL(IPAR_TRISE)
      TFALL = XVAL(IPAR_TFALL)
      A0    = XVAL(IPAR_A0)
      A1    = XVAL(IPAR_A1)
      A2    = XVAL(IPAR_A2)
 
      TDIF  = MJD - T0

c numerator
      ARG1  = TDIF / Tfall
      DUM1  = EXP(-ARG1)

c denominator
      ARG2  = TDIF / Trise
      DUM2  = 1.0 + EXP(-ARG2)

c polynominal correction
      POLYCOR = A0 * ( 1.0 + A1*TDIF + A2*TDIF*TDIF )

c final flux

      MODEL_FLUX = POLYCOR * (DUM1/DUM2)

c Aug 31 2019: protect against crazy values.
      if ( MODEL_FLUX > +1.0E20 ) MODEL_FLUX =  1.0E20
      if ( MODEL_FLUX < -1.0E20 ) MODEL_FLUX = -1.0E20

      ANYLCFUN = MODEL_FLUX

      RETURN
      END

C =====================================
+DECK,COVPKFLUX.
      REAL*8 FUNCTION COVPKFLUXFUN(ifilt_obs, MJD1, MJD2)

c
c Created April 12, 2010 by R.Kessler
c
c Similar to COVARFLUX in snlc_fit.car, but this is
c for the PKMJD fit to estimate error on peak flux.
c Since the user-function calls are different than
c in snlc_fit.car, we must have a separate COV function
c here to evaluate errors.
c
c Using full fitpar covariance, FITERRMAT(ipar1,ipar2)
c  ( see eq. 32.24 in PDG statistics section)
c
c                           dF1   dF2
c U12       = \sum_{k,l}  ------ ------ * FITERRMAT_PKMJD(k,l)
c                         dPAR_k dPAR_l
c
c  where PAR_k = fit-parameter with index 'k'.
c  and F1,F2 are fluxes at days with index 1,2.
c
c If T1 = T2,  then U12 = square of model
c uncertainty at this epoch.
c
c
c
c Jan 9, 2012: fix bug : use IFILT in SNLC_SNANAFIT_PEAKMJD_FITPAR
c -------------------------------

      IMPLICIT NONE

c subroutine args:

      INTEGER
     &   IFILT_OBS  ! (I) ifilt_obs 
  
      REAL*8  MJD1, MJD2  ! (I) MJDs to get covariance
  
c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNLCINP.
+CDE,FILTCOM. 
+CDE,PKMJDCOM.

      INTEGER 
     &   ipar, ipar_k, ipar_l, isp_k, isp_l, IFILT

      REAL*8 
     &   XVAL(NPAR_ANYLC), XERR(NPAR_ANYLC)
     &  ,FLUX1, FLUX2
     &  ,FTMP1, FTMP2
     &  ,SAVEVAL_k, SAVEVAL_l
     &  ,ERRPAR_k,  ERRPAR_l
     &  ,dF1dVAL_k, dF2dVAL_l, FF
     &  ,V_kl, U12

c functions
      REAL*8  ANYLCFUN

C -------------- BEGIN -------------

      COVPKFLUXFUN = 0.0
      U12 = 0.0   ! init output

c get reference fluxes to computer deriviates below.

      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
      DO ipar = 1, NPAR_ANYLC
        XVAL(ipar) = SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar)
        XERR(ipar) = SNLC_SNANAFIT_PEAKMJD_FITERR(ifilt,ipar)
      ENDDO
      Flux1   =  ANYLCFUN ( MJD1, XVAL )
      Flux2   =  ANYLCFUN ( MJD2, XVAL )

      isp_k = 0
      DO 301 ipar_k = 1, NPAR_ANYLC
         IF ( XERR(ipar_k) .LE. 0.0 ) goto 301
         isp_k = isp_k + 1  ! for COV matrix

      isp_l = 0
      DO 302 ipar_l = 1, NPAR_ANYLC
         IF ( XERR(ipar_l) .LE. 0.0 ) goto 302
         isp_l = isp_l + 1 ! for COV matrix

         SAVEVAL_k = XVAL(ipar_k) 
         SAVEVAL_l = XVAL(ipar_l)  

         ERRPAR_k  = XERR(ipar_k)
         ERRPAR_l  = XERR(ipar_l) 

c change fitpar values by +1 sigma and re-evaluate Flux.

         XVAL(ipar_k) = XVAL(ipar_k) + ERRPAR_k
         Ftmp1  = ANYLCFUN ( MJD1, XVAL )
         XVAL(ipar_k) = SAVEVAL_k

c repeat for 2nd fitpar ...
         XVAL(ipar_l) = XVAL(ipar_l) + ERRPAR_l
         Ftmp2   = ANYLCFUN ( MJD2, XVAL )
         XVAL(ipar_l) = SAVEVAL_l

c make sure that errors are non-zero before dividing.

         c2err = ' '
         if ( ERRPAR_k .EQ. 0.0 ) then
           write(c1err,662) PARNAME_STORE(ipar_k)
           CALL MADABORT("COVPKFLUXFUN", c1err, c2err )
         endif
         if ( ERRPAR_l .EQ. 0.0 ) then
           write(c1err,662) PARNAME_STORE(ipar_l)
           CALL MADABORT("COVPKFLUXFUN", c1err, c2err )
         endif
662      format('Cannot compute FLUXERR with ERR(',A,') = 0' )

c evaluate partial deriviates for flux
         dF1dVAL_k = (Ftmp1 - Flux1) / ERRPAR_k
         dF2dVAL_l = (Ftmp2 - Flux2) / ERRPAR_l

         FF   = dF1dVAL_k * dF2dVAL_l 
         V_kl = FITERRMAT_PKMJD(isp_k,isp_l,ifilt_obs)
         U12 = U12 + FF * V_kl

c         print*,'  xxxx V_(',ipar_k,ipar_l, ') = ', V_kl,
c     &      '   RHO=', V_kl/(ERRPAR_k*ERRPAR_l)

302   CONTINUE
301   CONTINUE

      COVPKFLUXFUN = U12

      RETURN
      END

C ============================
+DECK,INTERPANYLC.
      SUBROUTINE SNMJD_INTERP_ANYLC(ifilt_obs)
c
c
c Jan 9, 2012: write output to LUNINTERP if SNMJD_OUT_FILE is defined.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,INTERPCM.

      INTEGER ifilt_obs   ! (I) absolute filter index

c local args

      INTEGER  NMJD, imjd,  LENCCID, ipar, IFILT, LUN

      REAL*8  
     &   FLUX, FLUXERR, MJD, COV, MJDLIST(MXINTERP)
     &  ,XVAL(NPAR_ANYLC)
     &  ,XERR(NPAR_ANYLC)

      CHARACTER cfilt*1, ccid*(MXCHAR_CCID)
 
      LOGICAL ADDFLAG  ! dummy arg

c functions
      REAL*8 COVPKFLUXFUN, ANYLCFUN

C ---------------- BEGIN --------------

      IF ( N_INTERP_MJDLIST .LE. 0 ) RETURN

      CCID = SNLC_CCID
      LENCCID = INDEX(CCID,' ') - 1

c get NMJD and MJDLIST; 
      CALL GET_INTERP_MJDLIST(CCID, NMJD, MJDLIST, ADDFLAG)

      IF ( NMJD .EQ. 0 ) RETURN

      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
      cfilt     = filtdef_string(ifilt_obs:ifilt_obs)

      IF ( SNMJD_OUT_FILE .EQ. ' ' ) THEN
         LUN = -1
      ELSE
         LUN = LUNINTERP
      ENDIF

      DO 200 imjd = 1, NMJD

        MJD  = MJDLIST(imjd)

c IF MJD=0, then replace with PEAKMJD (Aug 20, 2012)
        IF ( MJD .LT. 1.0  ) THEN
            MJD = SNLC_SEARCH_PEAKMJD
        ENDIF

        DO ipar = 1, NPAR_ANYLC
          XVAL(ipar) = SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar)
          XERR(ipar) = SNLC_SNANAFIT_PEAKMJD_FITERR(ifilt,ipar)
        ENDDO

        COV     = COVPKFLUXFUN(ifilt_obs,MJD,MJD)
        FLUX    = ANYLCFUN(MJD,XVAL)
        FLUXERR = SQRT(COV)
       
        write(6,60) SNLC_CCID(1:LENCCID), 
     &       cfilt, MJD, FLUX, FLUXERR
60      format(T4,'INTERP-FLUX(CID=',A, '-', A,
     &         ' MJD=', F9.3, ')= ', G10.4, ' +- ', G10.4 )

        IF ( LUN .GT. 0 ) THEN
           write(LUN,70) SNLC_CCID(1:12), 
     &       cfilt, MJD, FLUX, FLUXERR
70         format('INTERP:',2x, A, 2x,A, 3x, F9.3, 2x, G12.4, G12.4)
        ENDIF

200   CONTINUE

      RETURN 
      END  ! end of SNMJD_INTERP_ANYLC

C ======================

C =======================
+PATCH,*TESTFUNS.
C =======================

+DECK,TEST_GET_SNFITSIO_INFO.
      SUBROUTINE TEST_GET_SNFITSIO_INFO()

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

c Aug 2018
c  Test new C function GET_SNFITSIO_INFO to return 
c  current FITS file being read.

      CHARACTER VERSION*80, FILENAME_PHOT*80, FILENAME_HEAD*80
      INTEGER IFILE

C ----------- BEGIN ------------------

      if ( DEBUG_FLAG == 0 ) RETURN
 
      CALL GET_SNFITSIO_INFO(VERSION,FILENAME_HEAD,FILENAME_PHOT,IFILE,
     &      80,80,80 )

      print*,' xxx =================================== '
      print*,' xxx TEST_GET_SNFITSIO_INFO for CID = ', SNLC_CCID
      print*,' xxx VERSION       = ', VERSION(1:60)
      print*,' xxx FILENAME_HEAD = ', FILENAME_HEAD(1:60)
      print*,' xxx FILENAME_PHOT = ', FILENAME_PHOT(1:60)
      print*,' xxx IFILE         = ', IFILE
      CALL FLUSH(6)

      RETURN
      END

+DECK,TESTFBIT.
      SUBROUTINE TEST_FILTBIT
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      integer ibit
      INTEGER*8  MSK8(2)
      LOGICAL LTMP, FILTBTEST
C ----------- BEGIN -----------

      ibit = 2
      CALL FILTBSET(MSK8,ibit)
      ibit = 61
      CALL FILTBSET(MSK8,ibit)

      print*,'  MSK8=', MSK8

      LTMP = FILTBTEST(MSK8,2)
      print*,'  FILTBTEST(2) = ', LTMP
      LTMP = FILTBTEST(MSK8,3)
      print*,'  FILTBTEST(3) = ', LTMP

      LTMP = FILTBTEST(MSK8,61)
      print*,'  FILTBTEST(61) = ', LTMP
      LTMP = FILTBTEST(MSK8,62)
      print*,'  FILTBTEST(62) = ', LTMP

      CALL EXIT(EXIT_ERRCODE)
      RETURN
      END

C ======================
+DECK,TEST_MAG.
      SUBROUTINE TEST_MAG
      IMPLICIT NONE
c ------------------
c
c Jan 31, 2008: illustrate extinction calculation
c               for unwarped vs. warped SED (for cosmo paper)
c
c -----------------

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER 
     &   IFILT_OBS
     &  ,IFILT_REST1, IFILT_REST2
     &  ,I, ISTAT

      REAL*8  
     &    Z8, Z0, T8, AV8, AVWARP8, MWEBV8
     &   ,MAG8, MWXT8
     &   ,MAG8_REST1, MAG8_REST2
     &   ,AV8TMP(2)
     &   ,XMAG8_REST1, XMAG8_REST2

c function

      REAL*8  GET_MAGLC8, GET_AVWARP8
      INTEGER FILTINDX

C --------------- BEGIN --------------

      CALL prbanner ( " TEST_MAG " )

c for illustration in cosmology paper,
c commpute AV for unwarped and warped SED.

      T8          = DBLE(0.0)
      Z8          = DBLE(0.2)
      Z0          = Zat10pc
      IFILT_OBS   = FILTINDX('r ')  ! => K_Vr and V-B to warp
      IFILT_REST1 = FILTINDX('V ')
      IFILT_REST2 = FILTINDX('B ')

c xxxxxxxxxxxxxxxx
c 6/08/2009 : set values that cause 'nan' for non1a in v8_13
     
       T8 = 7.7
       mag8_rest1 = -15.58
       mag8_rest2 = -13.61
       ifilt_rest1 = 30
       ifilt_rest2 = 29

       LDMP_AVWARP = .TRUE.

       AVWARP8 = GET_AVWARP8(T8, Z0, mag8_rest1, mag8_rest2, 
     &                      ifilt_rest1, ifilt_rest2, ISTAT )

      print*,' xxxxx AVwarp8 = ', AVwarp8
      CALL EXIT(EXIT_ERRCODE)
c xxxxxxxxxxxxxxxx

c compute unextincted V-B volor
      AV8         =  0.0 
      MAG8_REST1  = GET_MAGLC8(ifilt_rest1, T8, Z0, AV8 )
      MAG8_REST2  = GET_MAGLC8(ifilt_rest2, T8, Z0, AV8 )
      MAG8_REST1  = MAG8_REST1 - MAG8_REST2
            
      AV8         = 1.0  ! test with 1 mag extinction

      print*,' '
      print*,'      rest                                 ' 
      print*,'      color        AVwarp        XV  '
      print*,' ---------------------------------------------------'

      DO I = -10, 10
        MAG8_REST2 = DBLE(I)/10.0 ! SN B mag before extinction

        AVWARP8 = GET_AVWARP8(T8, Z0, mag8_rest1, mag8_rest2, 
     &                      ifilt_rest1, ifilt_rest2, ISTAT )

        AV8TMP(1) = AVWARP8
        AV8TMP(2) = AVWARP8 + AV8

        XMAG8_REST1  = GET_MAGLC8(ifilt_rest1, T8, Z0, AV8TMP(1) )
        XMAG8_REST2  = GET_MAGLC8(ifilt_rest1, T8, Z0, AV8TMP(2) )

        write(6,23) 
     &      MAG8_REST2 - MAG8_REST1    ! unextincted color
     &     ,AVWARP8                    ! AV warp parameter
     &     ,XMAG8_REST2 - XMAG8_REST1  ! extincted R

23       format(T2,3F12.4)

      ENDDO

      print*,' '
      print*,'  TEST COMPLETE: STOP PROGRAM '
      CALL EXIT(EXIT_ERRCODE)

      RETURN
      END

C ================================
+DECK,TEST_KCOR.
      SUBROUTINE TEST_KCOR
c
c Nov 1, 2006
c Plot Kcor and AVwarp on a grid of Color vs. epoch
c in order to compare with Jha's K-corrections.
c Hard-wire Z8 and IFILT_x variables for each test-case.
c
c Also check extinction calc for each filter.
c
c Aug 27, 2009; look for Kcor-kink as Trest varies
c
c ------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IERR

      INTEGER iz, it, ic, iav
      INTEGER 
     &   ifiltr, ifilto
     &  ,ifilt_rest, ifilt_obs, istat

      REAL*8 Z8, Z0, T8, C8, AVWARP8, MAG8_a, MAG8_b, KCOR8
      REAL*8 T8obs, KCOR8_LAST, DKDZ8,  DZ8, Z8ref
      REAL*8 XT8(2)

c function
      REAL*8 GET_KCOR8, GET_AVWARP8, GET_MAGLC8
      INTEGER FILTINDX

C ------------ BEGIN --------------  

      CALL PRBANNER("TEST_KCOR")

cc      if ( NFIT_ITERATION .LE. 0 ) RETURN

      ifilt_rest = FILTINDX('B ')
      ifilt_obs  = FILTINDX('i ')
  
      AVWARP8    = 0.5924
      Z8ref      = 0.59653
      T8obs      = 34.0144 * ( 1. + Z8ref )
      DZ8        = 0.0004

c loop over T8

      DO iz = -5, 5
         Z8 = Z8ref + DZ8 * DBLE(iz)

         T8 = T8obs/(1+Z8)
         KCOR8 = GET_KCOR8(ifilt_rest, ifilt_obs, T8, Z8, AVWARP8 )

         DKDZ8 = (KCOR8-KCOR8_LAST) / DZ8

         write(6,20) 
     &     filtdef_string(ifilt_rest:ifilt_rest)
     &    ,filtdef_string(ifilt_obs:ifilt_obs)
     &    ,Z8,T8, AVWARP8, KCOR8, DKDZ8

20       format(T5,'K_',A,A, '(Z=',F7.5,' Tr=',F7.4,
     &        ' AVwarp=',F6.3,') =',G12.5, 2x,'dK/dz=',F7.3)

         KCOR8_LAST = KCOR8
      ENDDO

      print*,' '
      print*,' ================================================ '
      print*,' '

      RETURN
      END

 
C =========================================
+DECK,TESTFUN1.
      DOUBLE PRECISION FUNCTION TESTFUN1(X)
      REAL*8 X
      TESTFUN1 = DSIN(0.5*X)
      RETURN
      END
+DECK,TESTFUN2.
      DOUBLE PRECISION FUNCTION TESTFUN2(X,Y)
      REAL*8 X,Y
      TESTFUN2 = DSIN(0.5*X) * Y
      RETURN
      END

C =======================

+PATCH,*FITUTIL.

C =======================

+KEEP,NOTES.

 General fit-related utilites to use with any fitter.
 Includes marginalization and histograms.

C ==============================================
+DECK,MNFIT_DRIVER.
      SUBROUTINE MNFIT_DRIVER ( 
     &   CCID        ! (I) cand id
     &  ,NFITPAR     ! (I) number of fit parameters
     &  ,INIVAL      ! (I) initial parmater values
     &  ,INISTP      ! (I) initial step sizes (0=> fixed parameter)
     &  ,INIBND      ! (I) parameter bounds (0,0 => no bound)
     &  ,PARNAME     ! (I) list of parmater names     
     &  ,USE_MINOS   ! (I) T=> use minos
     &  ,PRINT_LEVEL ! (I) integer print level (-1=none)
     &  ,FITVAL       ! (O) final fit values
     &  ,FITERR_PLUS  ! (O) final fit errors, positive
     &  ,FITERR_MINUS ! (O) final fit errors, negative
     &  ,FITCHI2      ! (O) min chi2
     &  ,NFIXPAR      ! (O) number of fixed parameters
     &  ,ERRTYPE      ! (O) error types (MINOS vs. PARABOLIC)
     &  ,MNSTAT_COV   ! (O) status of cov matrix (see minuit manual)
     &  ,IERR         ! (O) 0=>OK
     &      )
c
c Created 2 Feb 28, 2006 by D.Cinabro and R.Kessler
c 
c Interface for minuit fitting
C
c This is a SNANA routine ... not a MINUIT routine
C
C Note that the non-integer/characater inputs are Double Precision!!!!
C For more information on using MINUIT, type minuit in Google and follor 
c the URL with cern in it.
c
c
c Aug 31,  2009: Add USE_MINOS argument.
c
c May 21, 2012: set print level using SNLCINP namelist MINUIT_PRINT_LEVEL
c
c Jan 03 2016: pass new output arg MNSTAT_COV
c Apr 19 2022: set DO_PRINT for printing to suppress STDOUT for batch jobs
c May 08 2024: return IERR !=0  on NaN for any fit par value
c
c -------------------------------------------------

      IMPLICIT NONE

c arguments

      CHARACTER CCID*(*)
      INTEGER   NFITPAR, NFIXPAR, PRINT_LEVEL 

      LOGICAL USE_MINOS  ! (I) 

      DOUBLE PRECISION 
     &   INIVAL(NFITPAR)
     &  ,INISTP(NFITPAR)
     &  ,INIBND(2,NFITPAR)      ! (I) fit bounds (zero=> no bound)
     &  ,FITVAL(NFITPAR)        ! (O) final fit values
     &  ,FITERR_PLUS(NFITPAR)   ! (O) final fit errors
     &  ,FITERR_MINUS(NFITPAR)  ! (O) final fit errors
     &  ,FITCHI2                ! (O) min chi2 value

      CHARACTER PARNAME(NFITPAR)*20  ! (MXCHAR_PARNAME)

      INTEGER ERRTYPE(NFITPAR), MNSTAT_COV
      INTEGER IERR, N_NAN

c local var

+CDE,SNPAR.
+CDE,CTRLCOM.

      EXTERNAL FCNSNLC, USRFUN
      DOUBLE PRECISION  USRFUN

      INTEGER 
     &   IPAR, IVARBL, i, IFLAG, NARG
     &  ,NPARI, NPARX, ISTAT

      DOUBLE PRECISION 
     &   FIXLIST(NFITPAR)
     &  ,BND1, BND2
     &  ,STRATEGY(4), PARG(4)
     &  ,MAXCALLS(4)
     &  ,GRAD(NFITPAR)
     &  ,CHI2
     &  ,ARGLIST(20)
     &  ,EPLUS, EMINUS, EPARAB, GLOBCC
     &  ,FEDM, ERRDEF
     &  ,ERRSYM      ! local SYMMMETRIC fiterr

      LOGICAL LFIX, DO_PRINT

C Unit numbers for input and output

      INTEGER IUNIN,IUOUT,IUWRI
      DATA IUNIN/5/
      DATA IUOUT/6/
      DATA IUWRI/7/

C -------------------- BEGIN -------------------------

      IERR = 0
      N_NAN   = 0
      NFIXPAR = 0       
      FITCHI2 = 0.0
      DO_PRINT = STDOUT_UPDATE
C  
C Initialize MINUIT, input unit, output unit, save unit
C
      
+SELF,IF=MINUIT.
      CALL MNINIT(IUNIN,IUOUT,IUWRI)

      PARG(1) = DBLE(PRINT_LEVEL)
      CALL MNEXCM(FCNSNLC, 'SET PRI', PARG, 1, IERR, USRFUN )
+SELF.

C Define parameters in MINUIT

      DO IPAR = 1, NFITPAR

+SELF,IF=MINUIT.
         CALL MNPARM(IPAR, PARNAME(IPAR)
     &       ,INIVAL(IPAR), INISTP(IPAR)
     &       ,INIBND(1,IPAR)   ! lo-bound
     &       ,INIBND(2,IPAR)   ! hi-bound
     &       ,IERR   ) 
+SELF.
         IF ( IERR .NE. 0 ) THEN
	    IERR = ERRFLAG_MNFIT_INITPAR
            WRITE (6,'(A,A10,A)') '  ERROR initializing ', 
     &            PARNAME(ipar), '  with MNPARM '
            RETURN
         ENDIF

c init fit params
         FITVAL(ipar)       = 0.0
         FITERR_PLUS(ipar)  = 0.0
         FITERR_MINUS(ipar) = 0.0
         ERRTYPE(ipar)      = 0

C Set list of fixed parameters with step size = 0

         IF ( INISTP(IPAR) .EQ. 0.0 ) THEN
            NFIXPAR = NFIXPAR + 1
            FIXLIST(NFIXPAR) = DFLOAT(IPAR)
         ENDIF

      ENDDO

      CALL FLUSH(6)

c --------------------------------------------
c fix param if its step size is zero

      IF ( NFIXPAR .GT. 0 ) THEN

+SELF,IF=MINUIT.
         CALL MNEXCM(FCNSNLC,'FIX',FIXLIST, NFIXPAR,IERR,USRFUN)
+SELF.
         IF ( IERR .NE. 0 ) THEN
            IERR = ERRFLAG_MNFIT_FIXPAR
            WRITE (6,'(A)') '  ERROR fixing parameters'
            RETURN
         ENDIF
      ENDIF

c call FCN function with init flag: IFLAG=2
      IFLAG = 2
+SELF,IF=MINUIT.
      CALL FCNSNLC ( NFITPAR, GRAD, chi2, FITVAL, IFLAG, USRFUN )
+SELF.

C Set Strategy 2 for more accurate derivative calculation

      NARG = 1
      STRATEGY(1) = DBLE(2.0)   ! 1=default,  2 => better results 

      IF ( DO_PRINT ) THEN
        print*,'  Set MINUIT STRATEGY = ', int(STRATEGY(1))
      ENDIF

+SELF,IF=MINUIT.
      CALL MNEXCM(FCNSNLC,'SET STR', STRATEGY, NARG, IERR, USRFUN )
+SELF.
      MAXCALLS(1) = dble(30000.0)

C Actually do the fit

      IF ( DO_PRINT ) THEN
        PRINT *,' '
        PRINT *,' ------------------------------------------------ '
      ENDIF

+SELF,IF=MINUIT.
      IF ( USE_MINOS ) THEN
        CALL MNEXCM(FCNSNLC, 'MINOS', MAXCALLS, NARG, IERR, USRFUN)
        IF ( DO_PRINT ) THEN
          PRINT *,'  MNFIT_DRIVER: MINOS returns IERR = ', IERR
        ENDIF
      ELSE
        CALL MNEXCM(FCNSNLC, 'MINIMIZE', MAXCALLS, 0, IERR, USRFUN)
        IF ( DO_PRINT ) THEN
          PRINT *,'  MNFIT_DRIVER: MIGRAD returns IERR = ', IERR
        ENDIF
      ENDIF
+SELF.

      IF ( DO_PRINT ) THEN
         PRINT *,' ------------------------------------------------ '
      ENDIF

c -------------------------------------------
c get the fit result
  
      IF ( DO_PRINT ) THEN
        PRINT *,' ' 
        PRINT *,'   MNFIT_DRIVER: extract fit parameters with MNPOUT' 
        CALL FLUSH(6)
      ENDIF

      DO 44 IPAR = 1, NFITPAR

        LFIX = ( INISTP(ipar) .EQ. 0.0 ) 

+SELF,IF=MINUIT.
        CALL MNPOUT(  IPAR, PARNAME(IPAR)
     &              , FITVAL(IPAR), ERRSYM
     &              , BND1,BND2, IVARBL )

        IF ( ISNAN(FITVAL(IPAR))  ) THEN
	   N_NAN = N_NAN + 1
	   write(6,644) PARNAME(IPAR), CCID
644	   format(' MNFIT_DRIVER ERROR: ', A,' = NaN for CID = ', A)
           call flush(6)
        ENDIF
	
        CALL MNERRS( IPAR, EPLUS, EMINUS, EPARAB, GLOBCC )
+SELF.

c xxxxxxxxxxxxxxxxxxxxxxxx
c        print*, IPAR, ': ERR(EPARAB)=', sngl(EPARAB)
c     &            ,'  ERR(+-) = ', sngl(EPLUS), sngl(EMINUS)
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxx

c take average of +- errors (note that EMINUS is negative)
c If MINOS errors are zero, then use parabolic error above.

        if ( EPLUS .GT. 0.0 .and. EMINUS .LT. 0.0 ) THEN
           FITERR_PLUS(IPAR)   = EPLUS
           FITERR_MINUS(IPAR)  = EMINUS
           ERRTYPE(ipar)       = ERRTYPE_MINOS
        else
           FITERR_PLUS(IPAR)   = +ERRSYM
           FITERR_MINUS(IPAR)  = -ERRSYM
           ERRTYPE(ipar)       = ERRTYPE_PARAB
        endif

44    CONTINUE  ! end of loop over IPAR


      IF ( N_NAN > 0 ) THEN
         IERR = ERRFLAG_MNFIT_NAN
         RETURN  ! May 2024
      ENDIF
      
+SELF,IF=MINUIT.
c -------------------------------------------------------
c get chi2 and status; fill FITCHI2 return arg
c From Minuit manual, here are the ISTAT values from MNSTAT:
c
c ISTAT  meaning
c  0    Not calculated at all
c  1    Diagonal approximation only, not accurate
c  2    Full matrix, but forced positive-definite
c  3    Full accurate covariance matrix 
c          (After MIGRAD, this is the indication of normal convergence.)

      CALL MNSTAT(FITCHI2, FEDM, ERRDEF, NPARI, NPARX, ISTAT)
      MNSTAT_COV = ISTAT  ! 3=OK
+SELF.

c ----------------------------------


c Stop fit and make LAST call to function

+SELF,IF=MINUIT.
      PARG(1) = 0.0
      CALL MNEXCM(FCNSNLC, 'EXIT',  PARG, 0, IERR, USRFUN )
+SELF.
      IF ( DO_PRINT ) THEN
        PRINT *,'   MNFIT_DRIVER: EXIT returns IERR = ', IERR
        CALL FLUSH(6)
      ENDIF

c ---------------------------------
      RETURN
      END  ! end MNFIT_DRIVER

C ===========================
+DECK,MNFIT_STOREPAR.
      SUBROUTINE MNFIT_STOREPAR(iter,IERR)
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

c
c Nov 17, 2011: replace CERNLIB's PROB with snana's PROB_CHI2NDOF
c Jan 04, 2016: protect sqrt(negative SQERR8)
c May 05, 2018: init FITERRMAT=0 instead of -9. Allows USESIM_xxx=T
c May 23, 2018: set LCFRACERRDIF_STORE(ipar)
c Feb 22, 2020: set NDOF_PRIOR=0  here on each iteration.
c Apr 16, 2024: write FITPROB to stdout
c Jul 30, 2024: protect EPLUS/EMINUS when EMINUS=0

c subroutine args

      INTEGER 
     &   iter   ! (I) iterationn
     &  ,IERR   ! (O) error flag; 0=> OK

c local variables

      INTEGER ipar, NDOF, ipar1, ipar2, i
      INTEGER J, JPAR(MXFITPAR), J1, J2, etmp
      REAL EPLUS, EMINUS, PCHI2
      LOGICAL LBADERR, FLOATBOTH
      
      REAL*8  
     &   CHI8, GRAD8(MXFITPAR)
     &  ,EMAT8, ERR8(2), SQERR8(2), ERR_FINAL, ERR_LAST, ERR_AVG

c function

      REAL*8   PROB_CHI2NDOF
      REAL*8   USRFUN
      EXTERNAL USRFUN

C -------------- BEGIN ------------------

      IERR = 0   ! set output flag to OK
    
c store chi2

      FITCHI2_STORE(1)     = FITCHI2_MIN ! total chi2

c get prior-chi2 using special flag

+SELF,IF=MINUIT.
      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, FITVAL(1,iter),
     &       FCNFLAG_PRIOR_ONLY, USRFUN)
+SELF.

c determine effective Ndof for prior.
   
      if ( CHI8 .GT. 0.01 ) then
        NDOF_PRIOR = 1
      else
        NDOF_PRIOR = 0
      endif

      FITCHI2_STORE(3) = CHI8  ! prior chi2
      FITCHI2_STORE(2) = 
     &     FITCHI2_STORE(1) - FITCHI2_STORE(3)  ! total - prior

c store chi2 from ln(sigma) terms
+SELF,IF=MINUIT.
      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, FITVAL(1,iter),
     &       FCNFLAG_SIGMA_ONLY, USRFUN)
+SELF.
      FITCHI2_STORE(4) = CHI8

c store number of degrees of freedom

      NDOF          = NEPOCH_FIT(0) - (NFITPAR_MN - NFIXPAR)
      NDOF_STORE(1) = NDOF + NDOF_PRIOR  ! full chi2
      NDOF_STORE(2) = NDOF               ! chi2 excluding prior
      NDOF_STORE(3) = NDOF_PRIOR         ! prior chi2 only
      NDOF_STORE(4) = 1                  ! ln(sigma)

c Convert fitchi2 into fitprobs.

      DO i     = 1, 4
        NDOF   = NDOF_STORE(i)
        CHI8   = DBLE(FITCHI2_STORE(i))

        if ( NDOF .GT. 0 .and. CHI8 .GT. 0.0 ) THEN
           PCHI2  = SNGL( PROB_CHI2NDOF(CHI8,NDOF) )
        ELSE
           PCHI2  = 1.0
        ENDIF

        FITPROBCHI2_STORE(i) = PCHI2      
        LCCHI2_STORE(i)      = FITCHI2_STORE(i)
        LCPROBCHI2_STORE(i)  = FITPROBCHI2_STORE(i)
      ENDDO
      
      IF ( ITER==1 ) FITPROB_ITER1 = FITPROBCHI2_STORE(1)  ! July 2024
      

c now store fit parameters.

      DO 444 ipar = 1, NFITPAR_MN

         FLOATPAR(ipar) = ( INISTP(ipar) .NE. 0.0 )

c if there are no floated params, then set errors
c to user-initialized values: FITERR(ipar)

         if ( NFIXPAR .EQ. NFITPAR_MN  ) then
           FITERR_PLUS(ipar,iter)   = FITERR(ipar,iter)
           FITERR_MINUS(ipar,iter)  = FITERR(ipar,iter)
         endif

         EPLUS  = FITERR_PLUS(ipar,iter) 
         EMINUS = ABS ( FITERR_MINUS(ipar,iter) )

c if fit error is way too small, set error to INISTP 
c and set error type to BAD

         LBADERR = Eplus  .LT. ERRMAX_BAD(ipar)
     &     .and.   Eminus .LT. ERRMAX_BAD(ipar)

c 9/22/2007: allow tiny errors when the exposure time is large.
         IF ( SIM_EXPOSURE_TIME(1) .GT. 10.0 ) then
            LBADERR = .FALSE.
         endif

c set bad-error flag of fit-value has not moved from initial value.
         LBADERR = LBADERR .or. 
     &            ( INIVAL(ipar) .EQ. FITVAL(ipar,iter) )

         if ( FLOATPAR(ipar) .and. LBADERR ) then
            FITERR_PLUS(ipar,iter)  = +INISTP(ipar)
            FITERR_MINUS(ipar,iter) = -INISTP(ipar)
            EPLUS              = FITERR_PLUS(ipar,iter) 
            EMINUS             = ABS ( FITERR_MINUS(ipar,iter) )
            ERRTYPE(ipar)      = ERRTYPE_BAD
         endif

         FITERR_RATIO(ipar,iter)   = EPLUS / (EMINUS+1.0E-10)
         FITERR(ipar,iter)         = 0.5 * ( EPLUS + EMINUS )

         FITVAL_STORE(ipar)    = FITVAL(ipar,iter)
         FITERR_STORE(ipar)    = FITERR(ipar,iter)
         INIVAL_STORE(ipar)    = INIVAL(ipar)
         ERRTYPE_STORE(ipar)   = ERRTYPE(ipar)
      
c store FITVCAL in 'LC' array (might get over-written later by PDFVAL

         LCVAL_STORE(ipar) = FITVAL_STORE(ipar)
         LCERR_STORE(ipar) = MIN(99.9,FITERR_STORE(ipar))

c print results for floated parameters only

         if ( FLOATPAR(ipar)
     &     .or. NFIXPAR .EQ. NFITPAR_MN 
     &     .or .IPAR    .EQ. 1             ! IPAR_ITER - Nov 2014
     &           ) then
            CALL PRINT_FITPAR(SNLC_CCID, iter, ipar, 'fit' )
         endif

c do stuff on last iteration
         IF ( iter .EQ. NFIT_ITERATION .and. FLOATPAR(ipar) ) then
            etmp = ERRTYPE(ipar)
            NERRTYPE(etmp) = NERRTYPE(etmp) + 1

            if ( iter > 1 ) then
              ERR_FINAL = FITERR(ipar,iter)
              ERR_LAST  = FITERR(ipar,iter-1)
              ERR_AVG   = 0.5*(ERR_FINAL+ERR_LAST)
              if ( ERR_AVG > 1.0E-12 ) then
                LCFRACERRDIF_STORE(ipar) = (ERR_FINAL-ERR_LAST)/ERR_AVG
              endif
            endif
         ENDIF

444   CONTINUE   ! end loop over IPAR


c - - - - - -
      if ( STDOUT_UPDATE ) then
         write(6,446) SNLC_CCID(1:ISNLC_LENCCID),
     &                iter, FITPROBCHI2_STORE(1)
446      format(T8, 'CID ', A, 3x, 'ITER=',I1, 3x, 'FITPROB = ', E10.3 )
         CALL FLUSH(6)
      endif
	
c ----------------------
c 9/29/2007: get error matrix

+SELF,IF=MINUIT.
      IF ( LREPEAT_MINOS ) MNSTAT_COV = MNSTAT_COV + 10
      CALL MNEMAT(FITERRMAT_SPARSE,MXFITPAR)
+SELF.

c compute correlation matrix from error matrix

      J = 0
      DO ipar = 1, NFITPAR_MN
        if ( FLOATPAR(ipar) ) then
           j = j + 1
           JPAR(ipar) = j
        endif
      ENDDO

      DO ipar1 = 1, NFITPAR_MN
      DO ipar2 = 1, NFITPAR_MN

         FITERRMAT(ipar1,ipar2) = 0.0
         FITCORMAT(ipar1,ipar2) = 0.0
 
         FLOATBOTH = ( FLOATPAR(ipar1) .and. FLOATPAR(ipar2) )
         if ( FLOATBOTH ) then
           J1 = JPAR(ipar1)
           J2 = JPAR(ipar2)
           EMAT8     = FITERRMAT_SPARSE(J1,J2)
           SQERR8(1) = FITERRMAT_SPARSE(J1,J1)
           SQERR8(2) = FITERRMAT_SPARSE(J2,J2)

           IF  ( SQERR8(1) > 0.0 .and. SQERR8(2) > 0.0 ) then
             ERR8(1) = sqrt ( SQERR8(1) )
             ERR8(2) = sqrt ( SQERR8(2) )
             FITCORMAT(ipar1,ipar2) = EMAT8/(ERR8(1) * ERR8(2) )
             FITERRMAT(ipar1,ipar2) = EMAT8
           else
+SELF,IF=XXXDBUG.
             print*,' xxx ==================================== '
             print*,' xxx CID = ', SNLC_CCID
             print*,' xxx ipar1,ipar2 = ', ipar1, ipar2
             print*,' xxx SQERR = ', SQERR8
             call flush(6)
+SELF.
           endif

         endif
      ENDDO
      ENDDO

      RETURN
      END   ! end MNFIT_STOREPAR

C ======================================
+DECK,ERRTYPE_STR.
      FUNCTION ERRTYPE_STR(ERRTYPE)
      IMPLICIT NONE

      INTEGER ERRTYPE  ! (I) error type

      CHARACTER ERRTYPE_STR*1

+CDE,SNPAR.

C --------------- BEGIN -------------

      if ( ERRTYPE .EQ. ERRTYPE_MINOS ) then
        ERRTYPE_STR = 'M'
      else if ( ERRTYPE .EQ. ERRTYPE_PARAB ) then
        ERRTYPE_STR = 'P'
      else if ( ERRTYPE .EQ. ERRTYPE_MARG ) then
        ERRTYPE_STR = 'm'
      else if ( ERRTYPE .EQ. ERRTYPE_BAD ) then
        ERRTYPE_STR = '?'
      else if ( ERRTYPE .EQ. 0 ) then
        ERRTYPE_STR = ' '
      else
        ERRTYPE_STR = '?'
      endif

      RETURN
      END

C =======================================
+DECK,PRINT_FITPAR.
      SUBROUTINE PRINT_FITPAR(CCID, iter, ipar, type )
c
c standard print-line for fit-result or pdf-result.
c
c type = 'fit' : uses current FITVAL and FITERR
c type = 'pdf' : uses current PDFVAL and PDFERR
c
c Note that ITER is used only for 'fit' option
c
c Jun 2013: return if we are no longer in VERBOSE mode and iter < NFIT_ITER
c            (to reduce output for BIG jobs)
c
      IMPLICIT NONE

c subroutine args

      INTEGER  ITER, IPAR  ! (I) SN cand id and IPAR to print
      CHARACTER 
     &    CCID*(*)   ! (I) char string cand id
     &   ,type*(*)   ! (I) 'fit' or 'pdf' type of result

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER LL
      REAL*8  VAL, ERR
      LOGICAL LQUIET
      CHARACTER STRING_VAL*12

c function
      CHARACTER ERRTYPE_STR*1

C --------------- BEGIN -------------

      LQUIET = .NOT. STDOUT_UPDATE

      IF ( LQUIET ) RETURN
      
      IF ( type .EQ. 'fit' ) then
        VAL = FITVAL(ipar,iter)
        ERR = FITERR(ipar,iter)
      ELSE IF ( type .EQ. 'pdf' ) then
        VAL = PDFVAL(ipar)
        ERR = PDFERR(ipar)
      ELSE

      ENDIF

c write par value into string using format
      WRITE(STRING_VAL,211) VAL
211   FORMAT(G11.5)
      IF ( VAL > 1.0E4 ) THEN  ! this is PEAKMJD
        WRITE(STRING_VAL,212) VAL
212     FORMAT(F11.3)
      ENDIF

      LL = INDEX(CCID,' ') - 1
      IF ( LL .LE. 0 ) LL = MXCHAR_CCID
      WRITE (6,430)  CCID(1:LL), type, IPAR
     &    , PARNAME_STORE(IPAR), STRING_VAL, ERR
     &    , ERRTYPE_STR ( ERRTYPE(IPAR) )

 430    FORMAT (T8,'CID ',A,2x, A,'par(', I2, '):',A14,' = ', 
     &                 A11,' +/- ', G10.4, '(',A,')' )

     
      CALL FLUSH(6)

      RETURN
      END    ! end of PRINT_FITPAR


C ======================================
+DECK,PDF_INIT.
      SUBROUTINE PDF_INIT()
c
c Created Nov 24, 2009 by R.Kessler
c
c Init PDFXXX arrays before marginalizing or before running
c the MCMC option.  The main issue here is to make sure that
c fixed parameters (like ITER) get transfered to 
c the PDFVAL array.
c
c ---------------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

c local var
      INTEGER IPAR, IPAR2

C --------------- BEGIN -----------------

      DO 40 ipar = 1, NFITPAR_MN
         PDFVAL(ipar) = FITVAL(ipar,NFIT_ITERATION)

c reset PDF-marginalized values for floated parameters
         IF ( FLOATPAR(ipar) ) then
            PDFERR(ipar)  = -9.0 
            PDFVAL(ipar)  = -9.0 
         ENDIF

c zero the covariance matrix

         DO ipar2 = 1, NFITPAR_MN
           PDFERRMAT(ipar,ipar2) = 0.0
           PDFCORMAT(ipar,ipar2) = 0.0
         ENDDO
40    CONTINUE

      RETURN
      END
C ======================================
+DECK,PDF_STORE.
      SUBROUTINE PDF_STORE()
c
c Created Nov 11, 2009 by R.Kessler
c 
c Utility to store marginalized/MCMC PDF values,
c and re-compute chi2 and fit-probs.
c [Code moved from end of MARG_DRIVER]
c
c Nov 17, 2011: replace CERNLIB's PROB() with PROB_CHI2NDOF
c
c -----------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

c local var

      INTEGER IPAR, NDOF, i

      DOUBLE PRECISION
     &    GRAD8(MXFITPAR)
     &   ,CHI8, USRFUN
 
      REAL  PCHI2
      EXTERNAL USRFUN 

c function
      REAL*8 PROB_CHI2NDOF

C ----------------- BEGIN -----------

c print/store results

      DO 30 ipar = 1, NFITPAR_MN

         PDFVAL_STORE(ipar)   = PDFVAL(ipar)
         PDFERR_STORE(ipar)   = PDFERR(ipar)
         PDFPROB2_STORE(ipar) = PDFPROB2(ipar)

c over-write LCVAL[ERR] array with pdf-avarges

         LCVAL_STORE(ipar) = PDFVAL_STORE(ipar)
         LCERR_STORE(ipar) = MIN(99.9,PDFERR_STORE(ipar))

         if ( .NOT. FLOATPAR(ipar)  ) goto 30

         CALL PRINT_FITPAR( SNLC_CCID, 0, ipar, 'pdf' )
         CALL FLUSH(6)

30    CONTINUE

c ----------------------------------------------------
c re-compute chi2, prior-chi2 and prob with marginalized values.

c start with PRIOR-only chi2.
      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, PDFVAL,
     &       FCNFLAG_PRIOR_ONLY, USRFUN)
      LCCHI2_STORE(3) = CHI8

c now get contribution from ln(sigma)-terms

      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, PDFVAL,
     &       FCNFLAG_SIGMA_ONLY, USRFUN)
      LCCHI2_STORE(4) = CHI8

c Now get full chi2 ...

      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, PDFVAL,
     &      FCNFLAG_LAST, USRFUN)
      LCCHI2_STORE(1) = CHI8

c data-only chi2 if full-prior chi2.
      LCCHI2_STORE(2) = CHI8 - LCCHI2_STORE(3)

c compute fit-probs.

      DO i     = 1, 4
        chi8   = LCCHI2_STORE(i)
        NDOF   = NDOF_STORE(i)

        if ( NDOF .GT. 0 .and. CHI8 .GT. 0.0 ) then
           PCHI2  = SNGL( PROB_CHI2NDOF(CHI8,NDOF) )
        else
           PCHI2 = 1.0
        endif

        LCPROBCHI2_STORE(i) = PCHI2
      ENDDO

      CALL FLUSH(6)

      RETURN
      END

 
C =============================================
+DECK,RDMCMCNML.   
      SUBROUTINE RDMCMCNML(IERR)   
      IMPLICIT NONE   
c   
c Created Nov 11, 2009 by R.Kessler   
c Read optional &MCMCINP namelist.   
c If &MCMCINP is not in the namelist file,   
c just exit quietly. If MCMCNML is there,   
c read it and print a few comments   
c     
c --------------------------   
   
+CDE,SNDATCOM.   
+CDE,SNLCINP.   
+CDE,MCMCCOM.   
+CDE,MCMCTUP.
   
      INTEGER IERR   ! 0=>OK,  else error   
   
c local ars   
   
      integer LL, iocheck, ISEED

      EXTERNAL RANDOMINIT
   
C -------------- BEGIN -----------   
      IERR = 0   
   
c ----------------------------------------   
c set namelist defaults   
  
      NMCMC_EVAL      = 10000   
      IMCMC_FLAG      = -1   
      NMCMC_CHAINS    = 1   
      NMCMC_BURN      = 1000  
      MCMC_NSIG_STEP  = 0.5   
      CHOPT_MCMC      = ''   
      LMCMC           = .FALSE.   
      LTUP_MCMC       = .FALSE.         
      IMCMC_STORE     = 1   
      NSIG_MCMC_START = 3.0  
  
c misc. init
      NCALL_MCMCTUP = 0
c --------------------------------   
   
      LL = INDEX(nmlfile,' ' ) - 1   
   
      OPEN (   
     &    UNIT   = LUNNML   
     &   ,file   = nmlfile   
     &   ,status = 'OLD'   
     &   ,ERR    = 900    
     &       )   
   
c try reading MCMCINP; if not there, just return quietly.   
c Danger here is that a namelist bug is not distinguished   
c from a missing namelist.   
   
      READ ( LUNNML, NML = MCMCINP, ERR = 900, IOSTAT = iocheck )         
      CLOSE ( UNIT = LUNNML ) 

      if ( iocheck .NE. 0 ) return   
   
      CALL PRBANNER ( " FOUND and READ MCMCINP NAMELIST. " )   
   
         
      WRITE ( 6 , NML = MCMCINP )   
         
c check for namelist over-rides from command line.   
   
      CALL MCMCINP_OVERRIDE(IERR)   
        IF ( IERR .NE. 0 ) RETURN   
   

      IF ( LMCMC ) THEN
        ISEED = 12345
      ENDIF

C #################################################   
   
         GOTO 999   
   
C #################################################   
   
900   CONTINUE   
      C1err = 'Could not read  &MCMCINP namelist '   
      C2err = 'Check ' // nmlfile   
      CALL  MADABORT("RDMCMCNML", C1ERR, C2ERR)   
    
999   CONTINUE
      RETURN   
      END  ! end of RDMCMCNML   



C =======================================
+DECK,MARG_DRIVER.
      SUBROUTINE MARG_DRIVER( HOFF_MARG, OPT, 
     &           MAX_INTEGPDF, NGRID_FINAL, NSIGMA)
c
c Created Aug 3, 2006 by R.Kessler
c
c Utility to compute pdf-averaged quantity for each fitpar.
c
c Call this routine AFTER fit is done ...
c this routine uses current FITVAL and FITERR,
c and fills PDFVAL(ipar) and PDFERR(ipar).
c
c Histograms book/filled:
c   HOFF:         PDF value for each FCNPDF function call
c   HOFF + ipar : 1-dim PDF distribution for each fitted ipar
c
c
c  May 5, 2007: fix dumb bug. Need to init PDVAL(ipar) = FITVAL(ipar)
c               before integration to make sure that fixed parameters
c               are set in PDFVAL
c
c Oct 16, 2009: call INTEGPDF twice. First time set NGRID=7 to get
c               better estimate of errors. Second time set
c               NGRID = NGRID_FINAL. Change should run faster 
c               if there are fewer iterations needed with NGRID_FINAL.
c
c Nov 24, 2009: call PDF_INIT() to init PDFXXX arrays
c
c -------------------------------------------

      IMPLICIT NONE

c input args

      INTEGER 
     &    HOFF_MARG      ! (I) fill plots with hbook offset = HOFF
     &   ,OPT            ! (I) options
     &   ,MAX_INTEGPDF   ! (I) max number of iterations
     &   ,NGRID_FINAL    ! (I) # bins for each integrated dimension

      REAL  NSIGMA     ! (I) integrate +_ NSIGMA for exact pdf.

c -------------
c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER 
     &   ipar, ipar2
     &  ,JTIME1, JTIME2, JDIFTIME
     &  ,NEVAL        ! number of function evaluations
     &  ,LL, NDOF
     &  ,i, IERR
     &  ,NGRID, HOFF, NHDIM, HID_PDF, NBPDF(2)

      character chis*80, copt*6

      REAL*8 XMIN(2), XMAX(2), TMP
      LOGICAL LSYMERR

c functions
      CHARACTER ERRTYPE_STR*1
      REAL*8  PROB

c FCN args

      DOUBLE PRECISION
     &    GRAD8(MXFITPAR)
     &   ,CHI8
     &   ,USRFUN
 
      EXTERNAL USRFUN

c ------------------ BEGIN ------------

c require at least a few bins ...

      if ( NGRID_FINAL .LE. 0 ) RETURN

c set chi2 value for FCN function to quit

      IF ( PDFMIN .GT. 0.0 .and. 
     &        OPT .EQ. OPT_INTEGPDF_QUITCHI2 ) THEN
        FITCHI2_QUIT = -2.0*DLOG(PDFMIN) + FITCHI2_MIN
      ELSE
        FITCHI2_QUIT = 1.0E20
      ENDIF

      COPT = 'GRID'   ! only option so far

c -----------------

      write(6,19) SNLC_CCID, NSIGMA, copt
19    format(/,T5,'MARG_DRIVER(CID ',A6,'): ', 
     &      'compute P.D.F(+- ',F3.1,' sigma)', 2x, 'method=',A)

      IF ( FITCHI2_QUIT .LT. 1.0E19 ) then
        print*,'   CPU-saver ON  => FCNSNLC quits when CHI2 > ', 
     &         FITCHI2_QUIT
      ELSE
        print*,'   CPU-saver OFF => FCNSNLC always computes full CHI2.'
      ENDIF

      CALL FLUSH(6)

      USEPDF_MARG  = .TRUE.
      ISTAGE_SNANA = ISTAGE_TEST

c --------------------------------------


c init PDFVAL = FITVAL so that fixed parameters get transfered.

      CALL PDF_INIT()

c ---------------------
c get exact pdf by integrating over other fit-parameters

      JTIME1 = TIME()

c First marginalize with just 7 grid-points per variable.

      OPT   = 1   ! 1st round estimate 
      NGRID = 7
      HOFF  = 0   ! skip histograms
      CALL INTEGPDF( OPT, HOFF, 
     &        MAX_INTEGPDF, NGRID, DBLE(NSIGMA), NEVAL, IERR )

c final marginalization; use previous PDF for grid size estimate

      OPT   = 2       
      NGRID = NGRID_FINAL
      HOFF  = HOFF_MARG
      CALL INTEGPDF( OPT, HOFF, 
     &        MAX_INTEGPDF, NGRID, DBLE(NSIGMA), NEVAL, IERR )

c compute integration time.

      JTIME2   = TIME()
      JDIFTIME = JTIME2 - JTIME1

      LL = INDEX(SNLC_CCID,' ') - 1
      write(6,80) NEVAL, JDIFTIME, SNLC_CCID(1:LL)
80    format(T5,'MARG_DRIVER: Finished ',I7,' function calls in ', 
     &         I4,' seconds  (SN ', A,')'   )
      print*,' '

c keep track of integration times.

      NCALL_INTEGPDF     = NCALL_INTEGPDF + 1
      TIME_INTEGPDF      = JDIFTIME
      TIMESUM_INTEGPDF   = TIMESUM_INTEGPDF + JDIFTIME
      tmp                = DBLE(TIMESUM_INTEGPDF)/DBLE(NCALL_INTEGPDF)
      TIMEAVG_INTEGPDF   = INT(TMP+0.5)

      if ( mod(NCALL_INTEGPDF,5) .EQ. 0 ) then
         print*,' '
         print*,'   (AVERAGE INTEGPDF TIME: ', 
     &              TIMEAVG_INTEGPDF,'  seconds)'
         print*,' '
      endif

c call utility to store PDF results
      CALL PDF_STORE()

      RETURN
      END   ! end of MARG_DRIVER


C =======================================
+DECK,INTEGPDF.
      SUBROUTINE INTEGPDF(OPT, HOFF,
     &           MAX_INTEGPDF, NGRID, NSIGMA, NEVAL, IERR )
c ---------------------
c  Retruns p.d.f(DLMAG) integratged over other parameters;
c  integration is from +-NSIGMA * FITERR over each
c  dimension with non-zero INISTP.
c
c  The calling routine must set FITVAL(IPAR_DLMAG) = DLMAG,
c  and also set INISTP(IPAR_DLMAG) = 0.0 so that FCNPDF
c  knows to ignore the DLMAG-dimension in the integration.
c
c  OPT=1 => first estimate with small NGRID
c  OPT=2 => final estimate with final NGRID
c
c
c histograms are booked / filled for
c
c  HOFF          : function value for each call
c  HOFF + ipar   : pdf for each floated "ipar"
c
c
c  Feb 24, 2007: major upgrade to iterate if problem
c                is detected. See LREDO logic.
c
c                PDFERR(ipar) is now the RMS of the pdf distribution.
c
c Apr 28, 2007: 
c  on 2nd iteration when prob at edge is too high, make more robust 
c  estimate of integration region. Previously, integ-region was extended
c  by three times the shift in PDFVAL. Now, a Gaussian profile is
c  assumed, and an effective SIGMA is computed based on prob(at edge)
c  and current PDFVAL(ipar).  The integration limmit is then
c  changed to PDFVAL + NSIGMA*SIGMA
c  This improvement should help when MINUIT returns an error that 
c  is way too small, but is still not flagged by BADERR.
c
c May 3, 2007: accept MAX_INTEGPDF as argument
c
c Aug 20, 2008: change MXPAR from 8 to 10
c               (to accomodate IPAR_LUMIPAR2 in STRETCH2 model)
c
c Oct 16, 2009: 
c      use OPT=1,2 to determine which NGRID-iteration
c      Compute covariance & correlations: PDFCORMAT(ipar1,ipar2)
c
c      Fill PDRPROB2(ipar)
c
c Jan 4, 2010: add IERR argument. For PDF=0 error, abort only
c              if OPT=2. This gives both NGRID values a chance
c              to  succeed.
c
c Oct 01, 2012: use LCPLOT utility instead of HBOOK1 and HPAK
c
c Feb 06, 2013: replace LCPLOT util with SNHIST
c
c Jun 10 2013: protect ABORT when LPDFZERO=T using user namelist 
c              ABORT_ON_MARGPDF0
c
c -------------------------------------------------

      IMPLICIT NONE

c function aarguments

      INTEGER 
     &   OPT      ! (I) option 
     &  ,MAX_INTEGPDF  ! (I) max # times to integrate
     &  ,NGRID    ! (I) # grid-bins for each dimension
     &  ,HOFF     ! (I) hbook offset
     &  ,NEVAL    ! (O) number of function calls.
     &  ,IERR     ! (O) 0=>OK
     
      REAL*8  NSIGMA   ! (I) integrate +- NSIGMA in each dimension

c local args

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER MXPAR, MXGRID

      PARAMETER (  
     &    MXPAR   = 10   ! max number of fit paramters/dimensions
     &   ,MXGRID  = 30
     &     )

      INTEGER 
     &   IPAR, IPAR2
     &  ,NBINTOT
     &  ,IBIN
     &  ,IBIN_OFF
     &  ,IGRID
     &  ,NDIM, IDIM, IDIM2
     &  ,IPAR_DIM(MXPAR)  ! IPAR for each dimension to integrate
     &  ,IBIN_DIM(MXPAR)  ! local grid-bin for each dimension
     &  ,NN, i
     &  ,NPASS
     &  ,HID, NHDIM, LL, NUM
     &  ,ITER
     &  ,NPDF, IBIN_PLOT, NB(2)

      REAL*8
     &   PARVAL_MIN(MXPAR)
     &  ,PARVAL_MAX(MXPAR)
     &  ,PARVAL_BINSIZE(MXPAR)
     &  ,PARDIF_MIN(MXPAR)
     &  ,PARDIF_MAX(MXPAR)
     &  ,PARVAL(MXPAR)
     &  ,PARVAL_GRID(MXGRID,MXPAR)
     &  ,TMP, TMPVAL
     &  ,DVOL
     &  ,X8(MXPAR)
     &  ,PDF, XPDF(2), WGT
     &  ,PDFWSUMCOR(0:MXPAR,0:MXPAR)   ! wgted sum for correlations
     &  ,PDFSUMCOR
     &  ,PDFWSUM(0:MXPAR)          ! wgted sum for each ipar
     &  ,PDFSUM                    ! PDF sum for each ipar
     &  ,PDFSUM_GRID(MXGRID,MXPAR)  ! PDF vs. par to plot 1-d pdf
     &  ,PDFMAX(MXPAR)             ! max over grid for each ipar
     &  ,TMP_RANGE(2,MXPAR)
     &  ,PDF1D(MXGRID,MXPAR)
     &  ,SUM0, SUM1, SUM2, XN, XTMP
     &  ,SQERR, E12, E1xE2, PDFTMP
     &  ,PDF_NBR1, PDF_NBR2
     &  ,XMIN(2), XMAX(2), XVAL(2)


      LOGICAL 
     &   LTMP
     &  ,LPDFZERO
     &  ,LREDO
     &  ,LREDO_ALL
     &  ,LDMP_DEBUG

      CHARACTER chis*80, choice*12

c function

      REAL*8   FCNPDF
      EXTERNAL FCNPDF

c ----------------- BEGIN ------------

      NEVAL    = 0  ! init output arg
      IERR     = 0

      NPASS    = 0

      ITER = NFIT_ITERATION

      DO ipar = 1, NFITPAR_MN
         PARVAL_MIN(ipar) = 0.0
         PARVAL_MAX(ipar) = 0.0
         PARDIF_MIN(ipar) = 0.0
         PARDIF_MAX(ipar) = 0.0
      ENDDO
 
      LDMP_DEBUG = .FALSE.

      NHDIM    = 1  ! 1D histo

C =====================================
2     CONTINUE
      NPASS = NPASS + 1

c init some useful things.

      DVOL      = 1.0
      NBINTOT   = 1
      NDIM      = 0  ! number of dimensions to integrate PDF
      PDFSUM    = 0.0
      PDFSUMCOR = 0.0
      LREDO_ALL = .FALSE.

C set up integration limits for each parameter

      DO 30 ipar = 1, NFITPAR_MN

         PDFWSUM(ipar) =  0.0
         PDFMAX(ipar)  =  0.0

         do ipar2 = 1, NFITPAR_MN
            PDFWSUMCOR(ipar,ipar2) = 0.0
         enddo

         do igrid = 1, NGRID
            PDFSUM_GRID(igrid,ipar) = 0.0
         enddo

         if ( .not. FLOATPAR(ipar)  ) goto 30 ! skip fixed params

         NBINTOT = NBINTOT * NGRID

c keep track of which parameters to integrate
c (i.e., to ignore fixed parameters)

         NDIM = NDIM + 1
         IPAR_DIM(NDIM) = IPAR
         TMP_RANGE(1,ipar) = PARVAL_MIN(ipar)
         TMP_RANGE(2,ipar) = PARVAL_MAX(ipar)

         CALL INTEGRANGE(IPAR,NGRID,NSIGMA,PDF1D(1,ipar),  ! inputs
     &          LREDO, TMP_RANGE(1,ipar) ) ! outputs are LREDO & RANGE(1:2)

c set global REDO flag if any parameter-range is adjusted.
  
         LREDO_ALL = LREDO_ALL .OR. LREDO

30    CONTINUE  ! end of IPAR loop

c --------------------------------------------
c check if integration should proceed.
c Allow no more than three tries ... give "BEWARE" warning
c after 3 tries.

      IF ( NPASS .GT. 1 ) THEN

        IF ( LREDO_ALL ) THEN
           LL = INDEX(SNLC_CCID,' ') - 1

           if ( NPASS .LE. MAX_INTEGPDF ) then
              print*,'  ==> Integrate ',SNLC_CCID(1:LL), 
     &            ' again with NGRID=', NGRID
              CALL FLUSH(6)
           else if ( OPT .EQ. 1 ) then 
              goto 800

           else if ( OPT .EQ. 2 ) then  ! warn on final NGRID only

              print*,'  ==> Store ',SNLC_CCID(1:LL), 
     &          ' result, but BEWARE !!!'
              CALL FLUSH(6)
c              print*,'  ==> Cannot converge for ',SNLC_CCID(1:LL)
c              IERR = -9  ! Dec 16, 2011

              GOTO 800  ! skip integration
           endif

        ELSE
           GOTO 800  ! skip integration
        ENDIF
      ENDIF

        CALL FLUSH(6)

c ----
c if we get here, then adjust integration range

      DO 31 ipar = 1, NFITPAR_MN

        if ( .not. FLOATPAR(ipar)  ) goto 31 ! skip fixed params

        PARVAL_MIN(ipar) = TMP_RANGE(1,ipar)
        PARVAL_MAX(ipar) = TMP_RANGE(2,ipar)

        TMP = FITVAL(ipar,ITER)
        PARDIF_MIN(ipar) = PARVAL_MIN(ipar) - TMP
        PARDIF_MAX(ipar) = PARVAL_MAX(ipar) - TMP

        TMP = PARVAL_MAX(ipar) - PARVAL_MIN(ipar) 
        PARVAL_BINSIZE(ipar) = TMP / float(NGRID)

c compute volume element (used in brute-force method)

        DVOL = DVOL *  PARVAL_BINSIZE(ipar)

31    CONTINUE


c Now do the integration 

      LPDFZERO = .TRUE.

      DO 770 IBIN = 1, NBINTOT

c determine local grid-bin for each dimension to integrate;
c the load local PARVAL with value at each grid-point.

         ibin_off = 0
         do idim  = 1, NDIM
            NN    = NGRID**(NDIM-idim)
            ibin_dim(idim) = (ibin - 1 - ibin_off)/NN + 1
            ibin_off       = ibin_off + (ibin_dim(idim) - 1) * NN

            ipar     = ipar_dim(idim)  ! fetch fit par index
            igrid    = ibin_dim(idim)
            TMP      = float( igrid ) - 0.5
 
            XTMP     = PARVAL_MIN(ipar) 
     &               + PARVAL_BINSIZE(ipar) * TMP 

            PARVAL(ipar)            = XTMP
            PARVAL_GRID(igrid,ipar) = XTMP

         enddo  ! end loop of NDIM

c get X8 array that contains only parameters to integrate
c (fixed parameters are weeded out from PARVAL)

         CALL FITVAL_FLOAT(PARVAL, NDIM, X8) ! returns NDIM and X8

         PDF   = FCNPDF(NDIM,X8)   ! evaluate normalized PDF

         NEVAL = NEVAL + 1         ! increment # function calls

         IF ( PDF .EQ. 0.0 ) goto 771

         LPDFZERO = .FALSE.

         PDFSUM   = PDFSUM + PDF  ! increment total integral

         do idim  = 1, NDIM
            ipar  = ipar_dim(idim)  ! fetch fit par index

            PDFWSUM(ipar) = PDFWSUM(ipar) + PDF * PARVAL(ipar)

            do idim2 = 1, NDIM
               ipar2 = ipar_dim(idim2) 
               PDFWSUMCOR(ipar,ipar2) = PDFWSUMCOR(ipar,ipar2) 
     &                + PDF * PARVAL(ipar) * PARVAL(ipar2)
            enddo

c sum pdf separately for each grid point and for each IPAR
c so that 1-dim PDF can be plotted for each IPAR.

            igrid = ibin_dim(idim)
            PDFSUM_GRID(igrid,ipar) = 
     &      PDFSUM_GRID(igrid,ipar) + PDF 

            if ( PDFSUM_GRID(igrid,ipar) .GT. PDFMAX(ipar) ) then
              PDFMAX(ipar) = PDFSUM_GRID(igrid,ipar)
            endif
         enddo  ! end of idim loop

          if ( PDF > 0.0 .and. HOFF > 0 ) then
            xpdf(1)   = DLOG10(PDF)
            xpdf(1)   = max ( -19.999, xpdf(1) )
            wgt       = 1.0
            CALL SNHIST_FILL(NHDIM, HOFF, XPDF, WGT ) 
          endif

771       continue
          if ( MOD(IBIN,10000)  .EQ. 0 ) then
             print*,'      Processing grid-bin ', 
     &           ibin,'/', NBINTOT
             CALL FLUSH(6)
          endif

770   CONTINUE

      IF ( LPDFZERO ) THEN
        print*,' '
        print*,'  WARNING: INTEGPDF ERROR for CID=', SNLC_CCID
        print*,'  pdf function is zero everywhere with NGRID=',NGRID
        print*,' '
        IERR = -9

        IF ( OPT .EQ. 2 .and. ABORT_ON_MARGPDF0 ) THEN
          print*,' ***** ABORT ***** '
          CALL EXIT(EXIT_ERRCODE)
        ELSE
          RETURN
        ENDIF

      ENDIF

c ---------------------------------------
c fill histograms and PDFVAL_STORE array

      DO idim  = 1, NDIM
         ipar  = ipar_dim(idim)  ! fetch fit par index

         PDFVAL(ipar) = PDFWSUM(ipar) / PDFSUM 

         DO igrid = 1, NGRID
            PDF = PDFSUM_GRID(igrid,ipar) / PDFMAX(ipar)

            if ( PDF .LT. 1.0E-30 ) THEN
              PDF1D(igrid,ipar) = 1.0E-20  ! avoid hbook bit problems
            else
              PDF1D(igrid,ipar) = PDF
            endif

         ENDDO  ! end of igrid loop
  
      ENDDO  ! end of IDIM loop   
  
c determine PDF error (RMS) without using hbook so 
c that we can pass HOFF=0 and skip histograms

      DO idim  = 1, NDIM
         ipar  = ipar_dim(idim)  ! fetch fit par index
         SUM0 = 0.0
         SUM1 = 0.0
         SUM2 = 0.0
         NPDF = 0
         PDFPROB2(ipar) = 0.0

      DO igrid = 1, NGRID

         XTMP   = PARVAL_GRID(igrid,ipar)
         PDFTMP = PDF1D(igrid,ipar)
         if ( PDFTMP .GT. 1.0E-6 ) NPDF = NPDF + 1

         SUM0   = SUM0 + PDFTMP
         SUM1   = SUM1 + PDFTMP * XTMP
         SUM2   = SUM2 + PDFTMP * XTMP * XTMP

         PDF_NBR1 = 0.0
         PDF_NBR2 = 0.0
         if ( igrid .GT. 1     )  PDF_NBR1 = PDF1D(igrid-1,ipar)
         if ( igrid .LT. NGRID )  PDF_NBR2 = PDF1D(igrid+1,ipar)

c check for 2nd local maximum
         if (    PDFTMP .LT. .99 
     &     .and. PDFTMP .GT. PDF_NBR1
     &     .and. PDFTMP .GT. PDF_NBR2 ) then
            PDFPROB2(ipar) = PDFTMP
         endif
      ENDDO  ! igrid

        SQERR = SUM2/SUM0 - (SUM1/SUM0)**2

        if ( SQERR .LT. -0.00001 ) THEN ! allow for numerical rounding
                print*,' '
                print*,' SUM[0,1,2] = ', SUM0, SUM1, SUM2
                print*,' (SUM2/SUM0)     = ', SUM2/SUM0
                print*,' (SUM1/SUM0)**2  = ', (SUM1/SUM0)**2
                print*,' SQERR           = ', SQERR
                print*,' NPASS=',NPASS,'  OPT=',OPT
                c1err = ' SWERR < 0 for ' // PARNAME_STORE(ipar)
                CALL MADABORT("INTEGPDF", c1err, "  ")
         endif

c to compute error from RMS, require more than 1 PDF bin to be non-zero 
c (to avoid pathologies from PDFERR -> 0)

         if ( SQERR .GT. 0.0 .and. NPDF .GT. 1 ) then
            PDFERR(ipar) = SQRT( SQERR )         
         else
            PDFERR(ipar) = FITERR(ipar,iter)  ! PDF err = fit err for now
         endif

         ERRTYPE(ipar) = ERRTYPE_MARG 
      ENDDO  ! idim


C -------------------------------------------------
C evaluate covariances

      DO 400 idim  = 1, NDIM
         ipar      = ipar_dim(idim) 
      DO 401 idim2 = 1, NDIM
         ipar2     = ipar_dim(idim2) 

         E12   = PDFWSUMCOR(ipar,ipar2)/PDFSUM 
         E1xE2 = PDFVAL(ipar)*PDFVAL(ipar2)
         PDFERRMAT(ipar,ipar2) = E12 - E1xE2

         SQERR = PDFERR(ipar)*PDFERR(ipar2)
         PDFCORMAT(ipar,ipar2) = PDFERRMAT(ipar,ipar2)/SQERR

+SELF,IF=XXXDBG.
         if ( ipar2 .GT. ipar .and. OPT .EQ. 2) then
            write(6,466) 
     &      PARNAME_STORE(ipar), PARNAME_STORE(ipar2)
     &     ,FITCORMAT(ipar,ipar2)
     &     ,PDFCORMAT(ipar,ipar2)
     &     ,NPASS, NGRID

466         format(T5,'xxx RHO(',A6,',', A6,')= ', F6.3, ' ', F6.3,
     &         ' at NPASS=',I1,'  NGRID=',I2 )
         endif
+SELF.
401   CONTINUE
400   CONTINUE


c ------------------------
       IF ( LDMP_DEBUG ) THEN

          print*,' xxx ====================================== '
          PRINT*,' xxx NPASS = ', NPASS

         DO idim  = 1, NDIM
            ipar  = ipar_dim(idim) 
          
            print*,' - - - - - - - - - - - - - - - - - '
            write(6,665) PARNAME_STORE(ipar),
     &      PDFVAL(ipar), PDFERR(ipar), PDFPROB2(ipar)

            write(6,666) PARNAME_STORE(ipar),
     &      PARVAL_MIN(ipar), PARVAL_MAX(ipar)

            write(6,667) 'PARVAL', 
     &           ( PARVAL_GRID(igrid,ipar), igrid=1,11)
            write(6,667) 'PDFVAL', 
     &           ( PDF1D(igrid,ipar), igrid=1,11)

665        format(T3, 'xxx ',A6, 2x, 'PDFVAL = ',
     &          G10.3,' +- ', G10.3, 3x, 'PROB2=',F5.3 )
666        format(T3, 'xxx ',A6, 2x, 'PARDIF(MIN,MAX)=',2F9.3)

667        format(T3,'xxx ',A, '=', 11F7.3 )
           CALL FLUSH(6)
         ENDDO
       ENDIF
c ------------------------

c  ------------------------------------------------------
c always go back to start to check if we have converged

           goto 2

c ==================================================
c Check option to plot PDF for each floated parameter

800   CONTINUE
      CALL FLUSH(6)

      IF ( HOFF .LE. 0 ) RETURN

      DO idim  = 1, NDIM
         ipar  = ipar_dim(idim)  ! fetch fit par index
         hid   = HOFF + ipar
 
         LL = index ( PARNAME_STORE(ipar), ' ' ) - 1
         write(chis,21)  
     &          PARNAME_STORE(IPAR)(1:LL)
     &        , PARNAME_STORE(IPAR)(1:LL)
     &        , SNLC_CCID(1:ISNLC_LENCCID), char(0)

21       format(' margin. PDF( ',A,'-',A,'(fit) ) for CID=',A, A)


         TMPVAL    = FITVAL(ipar,NFIT_ITERATION)
         xmin(1)   = PARVAL_MIN(ipar) - TMPVAL 
         xmax(1)   = PARVAL_MAX(ipar) - TMPVAL
         NB(1)     = NGRID

         CALL SNHIST_INIT(NHDIM, HID, CHIS//char(0), 
     &           NB, XMIN, XMAX, LEN(chis) )

         DO igrid = 1, NGRID
           TMP      = DBLE(igrid) - 0.5
           XVAL(1)  = XMIN(1) + PARVAL_BINSIZE(ipar) * TMP
           WGT      = PDF1D(igrid,ipar)
           CALL SNHIST_FILL( NHDIM, HID, XVAL, WGT )
         ENDDO

      ENDDO

      RETURN
      END   ! end of INTEGPDF


C =======================================
+DECK,INTEGRANGE.
      SUBROUTINE INTEGRANGE(IPAR,NGRID,NSIGMA,PDFLAST,
     &      LREDO,RANGE)

c
c Created Apr 30, 2007 by R.Kessler
c
c Determine integration range for IPAR parameter based on
c 1-dim PDF values from previous integration.
c
c On first pass, RANGE(1)=RANGE(2)=0 and integration range
c is just based on NSIGMA * FITERR from MINUIT.
c
c Oct 23, 2007: TMP_PROB -> min (0.98, GRIDPROB)
c               to avoid dividing by ln(near 1)
c
c Dec 3, 2007:  min(0.98,GRIDPROB) -> min(0.95,GRIDPROB) 
c               so that integ-range is not opened so much
c               (short-term fix for photoZ fit to 14888)
c
c Oct 17, 2009: define PDFLAST_MAX = .95 with mutiple PDF bins,
c               or =.5 with just one PDF bin. Avoids severe bin-
c               extensions when there is just one non-zero PDF bin.
c
c               Makes sure that RANGE(1:2) is withing INIBND
c
c Dec 16, 2011: 
c    - write more info on PDFPROBLEM at endge of 1 dim PDF.
c    - for PHOTOZ, skip upper INIBND check on RANGE(2)
c
c -----------------------------------

      IMPLICIT NONE

c subroutine args

      INTEGER
     &   IPAR   ! (I) parameter to determine integration range
     &  ,NGRID  ! (I) number of grid points to integrate
     
      REAL*8
     &   NSIGMA          ! (I) 
     &  ,PDFLAST(NGRID)  ! (I) 1-dim PDF at grid points of last integration
     &  ,RANGE(2)        ! (I,O) integration limits: old -> new

      LOGICAL LREDO      ! (I) flag to redo integration

c local args

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      LOGICAL   
     &   LSYMERR
     &  ,LTMP
     &  ,LPDFMAX
     &  ,BADEDGE(2)
     &  ,LFIRST 
     &  ,USE_PDFERR

      INTEGER 
     &   NREDO
     &  ,N1D_TOT           ! total number of 1D bins = NGRID
     &  ,N1D_PROB0         ! number of 1D bins with negligible prob
     &  ,NPDF_GOOD
     &  ,igrid
     &  ,igrid_min
     &  ,igrid_max
     &  ,L1, L2, i
     &  ,ITER

      REAL*8
     &   XNSIG, XNGRID, xgrid
     &  ,RANGE_OLD(2)
     &  ,RANGE_NEW(2)
     &  ,BINSIZE_OLD
     &  ,BINSIZE_NEW
     &  ,TMP_PLUS
     &  ,TMP_MINUS
     &  ,TMP_SIG
     &  ,TMP_PROB
     &  ,TMP_EDGE
     &  ,TMP_PDF
     &  ,TMP_VAL
     &  ,SHIFT, BND
     &  ,PDFMAX_atEDGE
     &  ,PDFLAST_MAX
     
      CHARACTER PDFPROBLEM(40)*48

C -------------- BEGIN -------------

      ITER = NFIT_ITERATION

c init a bunch of stuff.

      XNSIG         = NSIGMA
      XNGRID        = FLOAT(NGRID)

      LFIRST = (RANGE(1) .EQ. 0.0 .and. RANGE(2) .EQ. 0.0)

c store old integration range since it gets over-written later.
      RANGE_OLD(1) = RANGE(1)
      RANGE_OLD(2) = RANGE(2)
      BINSIZE_OLD  = (RANGE_OLD(2)-RANGE_OLD(1))/XNGRID

      NREDO        = 0
      LREDO        = .FALSE.  ! output arg !!
      TMP_PLUS     = 0.0
      TMP_MINUS    = 0.0

      IF ( LFIRST ) THEN  

         USE_PDFERR = PDFERR(ipar) .GT. 0.0
         LSYMERR = abs(FITERR_RATIO(ipar,ITER)-1.0) .LT. 0.20 

         IF ( USE_PDFERR ) THEN  ! PDF error gives better estimate
           TMP_PLUS    =  XNSIG * PDFERR(ipar)
           TMP_MINUS   = -XNSIG * PDFERR(ipar)  ! neg number
         ELSE IF ( LSYMERR ) THEN
           TMP_PLUS    =  XNSIG * FITERR(ipar,ITER)
           TMP_MINUS   = -XNSIG * FITERR(ipar,ITER)  ! neg number
         ELSE
           TMP_PLUS    =  XNSIG * FITERR_PLUS(ipar,ITER)
           TMP_MINUS   =  XNSIG * FITERR_MINUS(ipar,ITER)  ! neg number
         ENDIF

         RANGE(1) = FITVAL(ipar,ITER) + TMP_MINUS
         RANGE(2) = FITVAL(ipar,ITER) + TMP_PLUS

         LREDO = .TRUE.
         RETURN

      ENDIF

c ---------------------------------------------------
c loop over grid points and find bin with first,last 
c non-negligible PDF value.
c Also count NPDF_GOOD = number of bins with PDF > PDFMIN

      N1D_TOT    = 0 
      N1D_PROB0  = 0
      LPDFMAX    = .FALSE.
      igrid_min  = 1
      igrid_max  = NGRID

      DO 100 igrid = 1, NGRID

         TMP_PDF = PDFLAST(igrid)
         if ( TMP_PDF .GT. 0.90 ) LPDFMAX = .TRUE.

         N1D_TOT = N1D_TOT + 1

         if ( TMP_PDF .GT. PDFMIN_GOOD ) then
             NPDF_GOOD = NPDF_GOOD + 1
         else
             N1D_PROB0 = N1D_PROB0 + 1

             if ( LPDFMAX .and. IGRID_MAX .EQ. NGRID ) then
                igrid_max = igrid  ! first negligible pdf past max
             endif

             if ( .not. LPDFMAX ) then
                igrid_min = igrid  ! last negligible pdf before max
             endif
         endif

100   CONTINUE  ! end of igrid loop

      IF ( NPDF_GOOD .GT. 1 ) THEN
          PDFLAST_MAX = 0.95
      ELSE
          PDFLAST_MAX = 0.80  ! Guass approx is bad with just one bin
      ENDIF


c -----------------------------------------------------------
c if PDF at edge is too big, then compute adjustment to extend edge.
c Adjustent is based on assumption of Gaussian profile.

      SHIFT      = PDFVAL(ipar) - FITVAL(ipar,ITER)
      BADEDGE(1) = .FALSE.
      BADEDGE(2) = .FALSE.
      PDFMAX_atEDGE = MAX ( PDFLAST(1), PDFLAST(NGRID) )

      LTMP = PDFLAST(1) .GT. PDFMAX_EDGE
      IF ( LTMP  ) THEN
         BADEDGE(1) = .TRUE.
         TMP_PROB   = min ( PDFLAST(1), PDFLAST_MAX )
         TMP_EDGE   = RANGE_OLD(1) - PDFVAL(ipar) ! distance to min edge
         TMP_SIG    = TMP_EDGE / SQRT ( -2.0 * DLOG(TMP_PROB) )
         TMP_MINUS  = XNSIG * TMP_SIG - TMP_EDGE

c avoid making integration window smaller
         if ( TMP_MINUS .GT. 0.0 ) then
              TMP_MINUS = -abs(3.*SHIFT)
         endif
      ENDIF



      LTMP = PDFLAST(NGRID) .GT. PDFMAX_EDGE
      IF ( LTMP ) THEN
          BADEDGE(2) = .TRUE.
          TMP_PROB   = min ( PDFLAST(NGRID), PDFLAST_MAX )
          TMP_EDGE   = RANGE_OLD(2) - PDFVAL(ipar) ! distance to edge
          TMP_SIG    = TMP_EDGE / SQRT ( -2.0 * DLOG(TMP_PROB) )
          TMP_PLUS   = XNSIG * TMP_SIG - TMP_EDGE

c avoid making integration window smaller
          if ( TMP_PLUS .LT. 0.0 ) then
               TMP_PLUS = +abs(3.*SHIFT)
          endif
      ENDIF

c ----------------------------
c update new integration range to account for 
c extended range(s).

      RANGE_NEW(1) = RANGE_OLD(1) + TMP_MINUS
      RANGE_NEW(2) = RANGE_OLD(2) + TMP_PLUS
      BINSIZE_NEW  = (RANGE_NEW(2)-RANGE_NEW(1))/XNGRID

c -------------------------------------
c check for bins that have ~0 prob, and reduce integration
c range to eliminate these 0-prob bins.

      if ( igrid_min .GT. 1 ) then
         xgrid        = float(igrid_min) - 0.5
         TMP_VAL      = RANGE_OLD(1) + BINSIZE_OLD * xgrid
         RANGE_NEW(1) = TMP_VAL - BINSIZE_NEW/2.0
      endif

      if ( igrid_max .LT. NGRID ) then
         xgrid        = float(igrid_max) - 0.5
         TMP_VAL      = RANGE_OLD(1) + BINSIZE_OLD * xgrid
         RANGE_NEW(2) = TMP_VAL + BINSIZE_NEW/2.0
      endif

c store NEW integration range in output subroutine arg.

      RANGE(1) = RANGE_NEW(1)
      RANGE(2) = RANGE_NEW(2)

c ---------------------------------------------------
c check of there is any reason that integration needs to be redone.
c  - Prob(edge) is too high
c  - Only 1 bin in 1D PDF
c  - Too many Zero-prob bins'
c 
c  Set LREDO flag = T if there is a problem.

      IF ( BADEDGE(1)  ) then
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),441) PDFLAST(1), 'lo'
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),1441) RANGE_OLD, RANGE_NEW
      ENDIF
      IF ( BADEDGE(2)  ) then
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),441) PDFLAST(NGRID), 'hi'
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),1441) RANGE_OLD, RANGE_NEW
      ENDIF

441        format('PROB=',F6.4, ' at ',A,' edge of 1 dim PDF')
1441       format('RANGE=(', F6.2, ',', F6.2, ')' , ' -> ',
     &                  '(', F6.2, ',', F6.2, ')'   )  ! Dec 2011

      IF ( NPDF_GOOD .LT. 3  ) then
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),442) 
442        format('<= 2 non-zero PDF bins.' )
      ENDIF

      IF ( N1D_PROB0 .GT. 3 ) THEN
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),443) N1D_PROB0, N1D_TOT
443        format('PROB=0 for ', I3, '/' , I3, 2x,
     &           'PDF bins' )
      ENDIF

c ----------------------------------------------
c print list of PDF-problems to STDOUT

      IF ( NREDO .GT. 0 ) THEN

         LREDO = .TRUE.

         L1 = index ( PARNAME_STORE(ipar), ' ' ) - 1
         L2 = index ( SNLC_CCID, ' ' ) - 1

         do i = 1, NREDO
            write(6,449) 
     &          PARNAME_STORE(ipar)(1:L1)
     &        , SNLC_CCID(1:L2)
     &        , PDFPROBLEM(i)
449         format(T8,A,'-PDF PROBLEM(',A,') : ', A)
         enddo

      ENDIF

c don't allow range to go outside of official INIBND range.

      BND = INIBND(1,IPAR)
      IF (RANGE(1) .LT. BND ) RANGE(1) = BND

c special exception for PHOTOZ
      IF ( PARNAME_STORE(IPAR)(1:6) .NE. 'PHOTOZ' ) THEN
        BND = INIBND(2,IPAR)
        IF (RANGE(2) .GT. BND ) RANGE(2) = BND
      ENDIF

      RETURN
      END

C =======================================
+DECK,FCNPDF.
      DOUBLE PRECISION FUNCTION FCNPDF(NDIM,X)
c
c  Retruns exp[ - (chi2 - chi2min) / 2 ]
c
c  where CHI2 is returned from a call to FCNSNLC.
c  This function is designed to accept only the
c  floated parameters so that it can be used by
c  more generic integration routines that don't
c  know about fixed parameters.
c
c Example: fit-params 1,2 are fixed and 3-6 float.
c          Then pass NDIM=4 and X(4) = array of floated parameters.
c
c -----------------------
      IMPLICIT NONE

c function input

      INTEGER NDIM     ! (I) number of dimensions
      REAL*8  X(NDIM)  ! (I) args for chi2-function

c local args

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER 
     &   ipar_all
     &  ,ipar_float
     &  ,ipar

c FCNSNLC args

      INTEGER IFLAG

      DOUBLE PRECISION
     &    GRAD(MXFITPAR)
     &   ,FITVAL_LOC(MXFITPAR)
     &   ,CHI2, DELCHI2
     &   ,USRFUN
 
      EXTERNAL USRFUN

C ---------- BEGIN -----------------

      FCNPDF  = 0.0
      IFLAG   = FCNFLAG_FAST

c restore input parameters X to local FITVAL array;
c note that fixed parameters are loaded from FITVAL_STORE array.

      ipar_float = 0

      DO ipar_all = 1, NFITPAR_MN

        if ( FLOATPAR(ipar_all)  ) then  ! is a floated param
           ipar_float = ipar_float + 1
           FITVAL_LOC(ipar_all) = X(ipar_float)
        else
           FITVAL_LOC(ipar_all) = FITVAL(ipar_all,NFIT_ITERATION) 
        endif

      ENDDO

c      write(6,20) (FITVAL_LOC(ipar), ipar=1, 6)

      CALL FCNSNLC(NFITPAR_MN,GRAD,CHI2,FITVAL_LOC,IFLAG,USRFUN)

c set FCNPDF only if FCN function did not have its
c chi2 got too big.

      if ( chi2 .LE. FITCHI2_QUIT ) then
         DELCHI2 = chi2 - FITCHI2_MIN
         FCNPDF  = dexp(-DELCHI2/2.0)
      endif

      RETURN
      END  ! end of FCNPDF


C ==============================================
+DECK,FITVAL_FLOAT.
      SUBROUTINE FITVAL_FLOAT(FITVAL_LOC,NDIM,X)
c
c FITVAL is the array of NFITPAR_MN parameters.
c Returns NDIM = number of floated parmaters,
c and X(NDIM) = array of floated paramters.
c i.e, the fixed paramters are ignored.
c
c -----------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

c declare function args

      REAL*8  FITVAL_LOC(*)     ! (I) fit parameters
      INTEGER NDIM              ! (O) number of floated params
      REAL*8  X(*)              ! (O) array of floated params

c local args
      INTEGER ipar
C --------------- BEGIN -------------

      NDIM = 0
      DO ipar = 1, NFITPAR_MN
        if ( FLOATPAR(ipar) ) then
           NDIM    = NDIM + 1
           X(NDIM) = FITVAL_LOC(ipar)
        endif
      ENDDO

      RETURN
      END


C END:




