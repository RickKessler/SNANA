+KEEP,HISTORY.
c
c Program to read light curves and apply user selection
c cuts specified in the &SNLCINP namelist.
c Can also fit function to estimate time of peak brightness.
c
c

                     CHANGES
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
  Jan 6 2017: remove ZEXTRA_SOURCE

  Feb 18 2017: new SNLCINP variables CUTWIN_LAMREST and CUTWIN_LAMOBS
  
  Dec 28 2017: CUTBIT_CLOUDAVG -> CUTBIT_PSF
  Feb 27 2018: CUTBIT_CLOUDSIG -> CUTBIT_ZP

  Jun 27 2018: MXSNLC -> 4 milliom (was 3 million)
               Remove obsolete ISN_FITSROW(MXSNLC) 

  Oct 23 2018: CUTBIT_MOONPHASE -> CUTBIT_PHOTPROB

+PATCH,*SNCOM.

+KEEP,SNPAR.

      CHARACTER  SNTABLE_LIST_DEFAULT*60

c parameters used by snana code

      INTEGER 
     &   MXVERS, MXSURVEY, MXSNLC,MXCID, MXCID_CHECK,MXEPOCH, MXITER
     &  ,MXFILT_ALL, MXFILT_OBS, MXFILT_REST, ONE
     &  ,MXFILT_KCOR, MXFILT_SNRMAX, MXEP_MODELGRID
     &  ,MXIDTEL, MXIDFIELD, MXFIELD_OVP, MXSEASON, MXSNHOST
     &  ,MXTABLE1D_KCOR,MXTABLE1D_LCMAG,MXTABLE1D_MWXT,MXTABLE1D_AVWARP
     &  ,MXZBIN_KCOR, MXTBIN_KCOR, MXAVBIN_KCOR, MXCBIN_AVWARP
     &  ,MNTYPE, MXTYPE, MXLISTNML, MXCCID_LIST, MXIGNORE_LIST
     &  ,MXVAR_PRIVATE, MXCUT_PRIVATE, MXVAR_TERSE
     &  ,HOFF_NOCUTS, HOFF_CUTS, HOFF_SIM
     &  ,LUNHIS, LUNNML, LUNDAT, LUNTMP, LUNFIT, LUNPKMJD, LUNDMP
     &  ,LUNCID, LUNOUT
     &  ,LUNRES1, LUNRES2, LUNINTERP, LUNLIST, LUNIGNORE, LUNSALT2
     &  ,ISTAGE_INIT, ISTAGE_RDSN, ISTAGE_CUTS, ISTAGE_USRANA
     &  ,ISTAGE_TEST
     &  ,INTERP_LINEAR, INTERP_SMOOTH, INTERP_ZSMOOTH
     &  ,MXERRTYPE, ERRTYPE_MINOS, ERRTYPE_PARAB, ERRTYPE_MARG
     &  ,ERRTYPE_BAD
     &  ,FCNFLAG_USER, FCNFLAG_FAST, FCNFLAG_LAST, FCNFLAG_USESIM
     &  ,FCNFLAG_PRIOR_ONLY, FCNFLAG_SIGMA_ONLY
     &  ,OPT_INTEGPDF_QUITCHI2, OPT_INTEGPDF_FULL
     &  ,OPT_SNXT_CCM89, OPT_SNXT_SJPAR
     &  ,OPT_MWCOLORLAW_DEFAULT, OPT_MWEBV_DEFAULT
     &  ,OPT_KCORERR_SJ, OPT_KCORERR_SJ5, OPT_KCORERR_SMOOTH
     &  ,MXLINE_ARGS, MXEPOCH_IGNORE
     &  ,NPAR_ANYLC, MXPAR_SIMSED, MXPAR_LCLIB
     &  ,MXLAMBIN_SNSED, MXCUTBIT
     &  ,OPT_FILTUPD_EACHSN, OPT_FILTUPD_MAP, OPT_FILTUPD_SAMEFILT
     &  ,OPT_FILTOBS, OPT_FILTREST
     &  ,ISTAT_READAGAIN, ISTAT_SKIP
     &  ,IDTABLE_MCMC, NFIT_VERBOSE
     &  ,ITABLE_SNANA,  ITABLE_FITRES, ITABLE_SNLCPAK, ITABLE_SPECPAK
     &  ,ITABLE_MODELSPEC, MXTABLE
     &  ,IDTABLE_SNANA, IDTABLE_FITRES, IDTABLE_MODELSPEC
     &  ,IDTABLE_CIDPTR
     &  ,OPT_PARSTORE_TEXTTABLE
     &  ,MSKOPT_PARSE_WORDS_STRING
     &  ,MSKOPT_PARSE_WORDS_FILE
     &  ,MSKOPT_PARSE_WORDS_IGNORECOMMA
c
     &  ,MODEL_STRETCH
     &  ,MODEL_STRETCH2
     &  ,MODEL_MLCS2k2
     &  ,MODEL_SNOOPY
     &  ,MODEL_SALT2, MODEL_SALT3
     &  ,MODEL_SIMSED
     &  ,MODEL_BYOSED
     &  ,MODEL_NON1A
     &  ,MODEL_LCLIB    ! Sep 2017
     &  ,MODEL_FIXMAG   ! force mags to user-value
     &  ,MXMODEL_INDEX
c
     &  ,MXCHAR_CCID, MXCHAR_VERSION, MXCHAR_SURVEY
     &  ,MXCHAR_PATH, MXCHAR_FILENAME, MXCHAR_MODELNAME
     &  ,MXCHAR_FIELDNAME, MXCHAR_PARNAME, MXCHAR_CUTNAME
     &  ,MXCHAR_FILEWORD
c
     &  ,SNLCPAK_EPFLAG_FLUXDATA     ! DATA flux per epoch
     &  ,SNLCPAK_EPFLAG_REJECT   ! REJECT flag (1=> excluded from fit)
     &  ,SNLCPAK_EPFLAG_CHI2     ! data-fit chi2 per epoch
     &  ,SNLCPAK_EPFLAG_FITFUN   ! smooth  fitfun curve
     &  ,SNLCPAK_EPFLAG_FLUXSIM  ! SIM flux per epoch
     &  ,SNLCPAK_EPFLAG_FLUXREST ! rest-frame flux per epoch (optional)
     &  ,SNLCPAK_EPFLAG_KCOR     ! rest-frame kcor (Jan 2020)
     &  ,SNLCPAK_EPFLAG_AVWARP   ! rest-frame AVWARP
     &  ,SNLCPAK_EPFLAG_SIMFLUXREST ! idem for sim truth
     &  ,SNLCPAK_EPFLAG_ERRCALC    ! FLUX-ERROR calculated from PSF,ZP,SKY
     &  ,SNLCPAK_BANDFLAG_PKFLUX   ! peak flux vs. filter
     &  ,SNLCPAK_BANDFLAG_PKMJD    ! peak MJD  vs. filter
     &  ,SNLCPAK_BANDFLAG_NDOF     ! Ndof vs. filter
     &  ,SNLCPAK_BANDFLAG_CHI2     ! chi2 vs. filter
c
     &  ,IFLAG_INI, IFLAG_ANA, IFLAG_END
     &  ,MAG_SATURATE
     &  ,MASK_FLUXCOR_SNANA, MASK_FLUXERRCOR_SNANA
c
     &  ,EXIT_ERRCODE_SNANA, EXIT_ERRCODE_SNFIT, EXIT_ERRCODE_PSNID

      REAL*8 
     &   ZERO8, ONE8, TEN8,  PI, LOGTEN
     &  ,PDFMIN, PDFMAX_EDGE, PDFMIN_GOOD
     &  ,KCORPACK
     &  ,XTMW_FRACERR
     &  ,MJDOFF
     &  ,ZEROPOINT_FLUXCAL_DEFAULT
     &  ,RV_MWCOLORLAW_DEFAULT
     &  ,CUTVAL_OPEN, IGNORE_HEADVAL

      REAL NULLVAL

      PARAMETER (                   ! BEGIN SNANA PARAMS
     &   SNTABLE_LIST_DEFAULT = 'SNANA  FITRES  LCPLOT'
     &  ,MXVERS        = 50         ! max number of versions to read
     &  ,MXSURVEY      = 100        ! max number of SURVEY_NAMEs to store
     &  ,MXITER        = 12         ! max # fit iterations
     &  ,NFIT_VERBOSE  = 500        ! Number of fits for verbose printouts
     &  ,MXSNLC        = 4000000    ! max number of SNe (fits format)
     &  ,MXCCID_LIST   = 20000      ! max size of SNCCID_LIST_ALL 
     &  ,MXIGNORE_LIST = 500        ! max size of IGNORE_LIST
     &  ,MXCID       = 299 999 999  ! max CID = 300 million -1 (9 digits)
     &  ,MXCID_CHECK =  99 999 999  ! MXCID to check duplicates
     &  ,MXEPOCH     = 2000        ! max number of filter-epochs per SN
     &  ,MXEP_MODELGRID = 200     ! max model grid for SNANA+SIM_MAGOBS table
     &  ,MXIDTEL     = 200        ! max telescope ID in SURVEY.DEF
     &  ,MXIDFIELD   = 200        ! max FIELD ID in SURVEY.DEF
     &  ,MXFIELD_OVP = 12         ! max number of overlapping fields
     &  ,MXSEASON    = 100        ! max number of seasons
     &  ,MXSNHOST    = 2          ! max number of host matches to read/write
     &  ,MXVAR_PRIVATE = 40       ! max number of private variables
     &  ,MXCUT_PRIVATE = 10        ! max number of cuts on private var
     &  ,MXVAR_TERSE   = 30       ! max number of text-data  columms
     &  ,MXLISTNML   = 52    ! max list size for some NML lists    
     &  ,MXFILT_OBS  = 62    ! max number of used observer filters
     &  ,MXFILT_ALL  = 100   ! max number of all possible filter defs
     &  ,MXFILT_REST = 40    ! max number of rest-frame filter types (was 12)
     &  ,MXFILT_KCOR = MXFILT_REST ! max number of filters used in Kcor table
     &  ,MXFILT_SNRMAX =  8       ! no more than this many SNRMAX(filt) cuts
     &  ,MNTYPE       =   1       ! min sn "type"
     &  ,MXTYPE       = 1000      ! max sn "type"
     &  ,MXZBIN_KCOR  = 100       ! max # Z-bins for KCOR tables
     &  ,MXTBIN_KCOR  = 150       ! max # Epochs for KCOR tables
     &  ,MXAVBIN_KCOR = 100       ! max # AV bins for KCOR tables
     &  ,MXCBIN_AVWARP = 100      ! max color index for AVWARP table
     &  ,MXTABLE1D_KCOR   = 10 000 000  ! max number of KCOR bins
     &  ,MXTABLE1D_AVWARP =  1 000 000  ! max number of bins for AVWARP table
     &  ,MXTABLE1D_LCMAG  =  2 000 000  ! idem for LCMAG  table
     &  ,MXTABLE1D_MWXT   =  2 000 000  ! idem for MWXT table
     &  ,KCORPACK      = 1000.  ! store KCOR * KCORPACK as I*2
     &  ,XTMW_FRACERR  = 0.16   ! error on MW Xtinc is 16% of XTMW
c
     &  ,HOFF_NOCUTS = 100
     &  ,HOFF_CUTS   = 200
     &  ,HOFF_SIM    = 20000
     &  ,LUNHIS    = 21  ! LUN for hbook output file
     &  ,LUNNML    = 22  ! LUN for input namelist
     &  ,LUNDAT    = 23  ! LUN for data      
     &  ,LUNTMP    = 24
     &  ,LUNOUT    = 25
     &  ,LUNFIT    = 26
     &  ,LUNLIST   = 27  
     &  ,LUNIGNORE = 28  
     &  ,LUNDMP    = 29
     &  ,LUNRES1   = 31  ! for DMP_FITRES 
     &  ,LUNRES2   = 32
     &  ,LUNINTERP = 33  ! for FLUX,MAGs interpolated at SN,MJD
     &  ,LUNSALT2  = 34  ! for SALT2 dictFile
     &  ,LUNPKMJD  = 35
     &  ,LUNCID    = 36  ! reserved for reading SNCID_LIST_FILE
     &  ,ISTAGE_INIT    = 10       ! init has finished
     &  ,ISTAGE_RDSN    = 20       ! SN have been read
     &  ,ISTAGE_CUTS    = 30       ! cuts have been applied
     &  ,ISTAGE_USRANA  = 40       ! USRANA has been called.
     &  ,ISTAGE_TEST    = 90       ! set for testing
     &  ,ZERO8          = 0.0
     &  ,ONE8           = 1.0
     &  ,ONE            = 1
     &  ,TEN8           = 10.0
     &  ,LOGTEN         = 2.302585092994
     &  ,INTERP_LINEAR  = 1    ! option flag to use linear DFINT
     &  ,INTERP_SMOOTH  = 2    ! option flag to use smoothing
     &  ,INTERP_ZSMOOTH = 3    ! linear DFINT, but smooth along z
c
     &  ,MXERRTYPE      = 10
     &  ,ERRTYPE_MINOS  = 1
     &  ,ERRTYPE_PARAB  = 2
     &  ,ERRTYPE_MARG   = 3  ! marginalized error
     &  ,ERRTYPE_BAD    = 6
C
     &  ,FCNFLAG_LAST     = 3    ! last MINUIT call
     &  ,FCNFLAG_USER     = 90   ! pass this IFLAG for user-FCNSNLC calls
     &  ,FCNFLAG_FAST     = 91   ! go as fast as possible (no LAST if-block)
     &  ,FCNFLAG_PRIOR_ONLY = 92
     &  ,FCNFLAG_SIGMA_ONLY = 93
     &  ,FCNFLAG_USESIM   = 99   ! pass this IFLAG to use SIM params
c     
     &  ,PI     = 3.1415926535898
     &  ,PDFMIN      = 1.0E-5   ! used to speed up PDF integration
     &  ,PDFMAX_EDGE = 0.03     ! max allowed PDF value at edges
     &  ,PDFMIN_GOOD = 1.0E-4   ! PDF > PDFMIN_GOOD counts as good point
     &  ,OPT_INTEGPDF_QUITCHI2 = 2  ! abort FCNSNLC if chi2 > quitchi2
     &  ,OPT_INTEGPDF_FULL     = 1  ! do full FCNSNLC evaluation
c 
     &  ,OPT_SNXT_CCM89   = 1  ! exact SN etinction using INIT_XTHOST
     &  ,OPT_SNXT_SJPAR   = 2  ! SN extinction with Jha's parameters
     &  ,OPT_KCORERR_SMOOTH = 1 ! use smooth half-Gaussian 
     &  ,OPT_KCORERR_SJ     = 2   ! use Saurabh's Kcor error 
     &  ,OPT_KCORERR_SJ5    = 5  ! x5 Saurabh's Kcor error 
c
     &  ,RV_MWCOLORLAW_DEFAULT  = 3.1   ! A_V/E(B-V)
     &  ,OPT_MWCOLORLAW_DEFAULT = 94    ! ODonnel 94
     &  ,OPT_MWEBV_DEFAULT      =  1    ! whatever is in the data file
c
     &  ,MXLINE_ARGS      = 100
     &  ,ZEROPOINT_FLUXCAL_DEFAULT  = 27.5
     &  ,MXEPOCH_IGNORE   = 1000
     &  ,NPAR_ANYLC       = 10   ! for MNFIT_PKMJD 
     &  ,MXPAR_SIMSED     = 100  ! max number of SIMSED parameters
     &  ,MXPAR_LCLIB      = 40   ! should be same as in genmag_LCLIB.h
     &  ,MXLAMBIN_SNSED   = 4000 ! Jan 2017: raised from 3000
     &  ,MXCUTBIT         = 64   ! max number of cut bits
c
     &  ,OPT_FILTUPD_EACHSN   = 1  ! default filter-updates
     &  ,OPT_FILTUPD_MAP      = 2  ! default filter-updates
     &  ,OPT_FILTUPD_SAMEFILT = 3  ! test: use same filter each SN
     &  ,OPT_FILTREST         = 1
     &  ,OPT_FILTOBS          = 2
     &  ,ISTAT_READAGAIN      = 7 
     &  ,ISTAT_SKIP           = -1
c
     &  ,ITABLE_SNANA=1, ITABLE_FITRES=2, ITABLE_SNLCPAK=3
     &  ,ITABLE_SPECPAK=4, ITABLE_MODELSPEC=5
     &  ,MXTABLE = 10
     &  ,IDTABLE_SNANA   = 7100
     &  ,IDTABLE_FITRES  = 7788 
     &  ,IDTABLE_MODELSPEC = 8000  ! SALT2 model spectra from LC fit
     &  ,IDTABLE_CIDPTR  = 1600  
     &  ,IDTABLE_MCMC    = 7711
     &  ,OPT_PARSTORE_TEXTTABLE = 1  ! tag subset for TEXT table.
     &  ,MSKOPT_PARSE_WORDS_FILE    = 1   ! parse file
     &  ,MSKOPT_PARSE_WORDS_STRING  = 2   ! for store_PARSE_WORDS: string
     &  ,MSKOPT_PARSE_WORDS_IGNORECOMMA = 4 ! ignore comma for string
c 
     &  ,MODEL_STRETCH    = 1
     &  ,MODEL_STRETCH2   = 2
     &  ,MODEL_MLCS2k2    = 3
     &  ,MODEL_SNOOPY     = 4
     &  ,MODEL_SALT2      = 6
     &  ,MODEL_SALT3      = 9 ! May 31 2019
     &  ,MODEL_SIMSED     = 7
     &  ,MODEL_BYOSED     = 8 
     &  ,MODEL_NON1A      = 10
     &  ,MODEL_LCLIB      = 12
     &  ,MODEL_FIXMAG     = 20
     &  ,MXMODEL_INDEX    = 20
     &  ,NULLVAL          = -99999.
     &  ,IGNORE_HEADVAL   = -5555.
c
     &  ,MXCHAR_CCID       = 20   ! max len of CCID string (i.e, SN name)
     &  ,MXCHAR_VERSION    = 72   ! max len of VERSION_PHOTOMETRY
     &  ,MXCHAR_SURVEY     = 40   ! max len of SURVEY_NAME
     &  ,MXCHAR_PATH       = 160  ! max len of path
     &  ,MXCHAR_FILENAME   = 200  ! max len of filename with full path
     &  ,MXCHAR_MODELNAME  = 72   ! max len of model name
     &  ,MXCHAR_FIELDNAME  = 20   ! max len of field name
     &  ,MXCHAR_PARNAME    = 20   ! max len of parameter name
     &  ,MXCHAR_CUTNAME    = 160  ! to define cut names
     &  ,MXCHAR_FILEWORD   =  60  ! size of FILEWORD_LIST
c
     &  ,SNLCPAK_EPFLAG_FLUXDATA    = 1    ! epoch-dependent
     &  ,SNLCPAK_EPFLAG_REJECT      = 2
     &  ,SNLCPAK_EPFLAG_CHI2        = 3
     &  ,SNLCPAK_EPFLAG_FITFUN      = 4
     &  ,SNLCPAK_EPFLAG_FLUXSIM     = 5    ! epoch-dependent
     &  ,SNLCPAK_EPFLAG_FLUXREST    = 6
     &  ,SNLCPAK_EPFLAG_KCOR        =   7
     &  ,SNLCPAK_EPFLAG_AVWARP      =   8
     &  ,SNLCPAK_EPFLAG_SIMFLUXREST = 9
     &  ,SNLCPAK_EPFLAG_ERRCALC     = 10
     &  ,SNLCPAK_BANDFLAG_NDOF    = 100
     &  ,SNLCPAK_BANDFLAG_PKFLUX  = 101  ! filter-dependent 
     &  ,SNLCPAK_BANDFLAG_PKMJD   = 102
     &  ,SNLCPAK_BANDFLAG_CHI2    = 103
c
     &  ,IFLAG_INI=1, IFLAG_ANA=2, IFLAG_END=3
     &  ,MAG_SATURATE = -7.0    ! for sim only
     &  ,CUTVAL_OPEN  = 1.0E12  ! cutwin value to accept everything.
     &  ,MASK_FLUXCOR_SNANA    = 1
     &  ,MASK_FLUXERRCOR_SNANA = 2
c
     &  ,EXIT_ERRCODE_SNANA = 21
     &  ,EXIT_ERRCODE_SNFIT = 22
     &  ,EXIT_ERRCODE_PSNID = 23
     &      )

c physical constants

      REAL*8  
     &   PARSEC, CLIGHT, PEAKMAG_AT_10PC
     &  ,Zat10pc
     &  ,OMAT_DEFAULT, OMATERR_DEFAULT
     &  ,OLAM_DEFAULT, OLAMERR_DEFAULT
     &  ,ORAD_DEFAULT
     &  ,H0_DEFAULT,   H0ERR_DEFAULT
     &  ,W0_DEFAULT,   W0ERR_DEFAULT
     &  ,DWDA_DEFAULT, DWDAERR_DEFAULT

      PARAMETER (
     &   PARSEC        = 3.085678E13  ! 1 parsec (km)
     &  ,CLIGHT        = 2.998E5      ! c (km/sec)
c
     &  ,H0_DEFAULT        = 70.0 / ( 1.0E6 * Parsec )  ! standard value
     &  ,W0_DEFAULT        = -1.0
     &  ,DWDA_DEFAULT      =  0.0
     &  ,OMAT_DEFAULT      =  0.3
     &  ,OLAM_DEFAULT      =  0.7
     &  ,ORAD_DEFAULT      =  1.2E-5
c
     &  ,H0ERR_DEFAULT        =  7.0 / ( 1.0E6 * Parsec ) 
     &  ,W0ERR_DEFAULT        =  0.1
     &  ,DWDAERR_DEFAULT      =  0.0
     &  ,OMATERR_DEFAULT      =  0.03
     &  ,OLAMERR_DEFAULT      =  0.03
c
     &  ,PEAKMAG_AT_10PC   = -19.6  
     &  ,Zat10pc           = 2.34E-9   ! magic redshift at 10 pc
     &  ,MJDOFF            = 0.0       ! 53000.
     &     )


+KEEP,SNFILECOM.

c Sep 9, 2010: Pulled out of SNDATACOM 

c define HEADER MASK BITS for required variables.
      INTEGER    
     &   HEADBIT_SNID,   HEADBIT_IAUC, HEADBIT_CIDSEL
     &  ,HEADBIT_SURVEY, HEADBIT_FILTERS
     &  ,HEADBIT_RA,    HEADBIT_DEC
     &  ,HEADBIT_MWEBV, HEADBIT_Z
     &  ,NBIT_HEADMASK
     &  ,HEADMASK_REQUIRED
c
     &  ,HEADMASK  ! reset for reach SN
     
      PARAMETER (
     &    HEADBIT_SNID    = 0  ! MASK = 1
     &   ,HEADBIT_IAUC    = 1  ! MASK = 2  ! added Dec 2015
     &   ,HEADBIT_CIDSEL  = 2  ! MASK = 4  ! added Dec 2015
     &   ,HEADBIT_SURVEY  = 3 
     &   ,HEADBIT_FILTERS = 4 
     &   ,HEADBIT_RA      = 5
     &   ,HEADBIT_DEC     = 6
     &   ,HEADBIT_MWEBV   = 7
     &   ,HEADBIT_Z       = 8
     &   ,NBIT_HEADMASK   = 9
     &   ,HEADMASK_REQUIRED  = 2**(NBIT_HEADMASK)-1 - 2 ! don't require IAUC
     &      )

      CHARACTER
     &   SNDATA_ROOT*(MXCHAR_PATH)
     &  ,SNANA_DIR*(MXCHAR_PATH)
     &  ,SNDATA_PATH*(MXCHAR_PATH)      ! subdir with data or sim files
     &  ,SNLIST_FILE*(MXCHAR_FILENAME)  ! input list of SNDATA Files
     &  ,SNREADME_FILE(MXVERS)*(MXCHAR_FILENAME)   ! name of EVERY README file
     &  ,SNDATA_FILE_CURRENT*(MXCHAR_FILENAME)     ! current file being read
     &  ,GLOBAL_BANNER*120
     &  ,SNDATA_PREFIX*(MXCHAR_FILENAME)  ! $SNDATA_ROOT/lcmerge/$VERSION
     &  ,C1ERR*88, C2ERR*88    ! generic error strings

      INTEGER 
     &  ABSO_INDEX(MXSNLC) ! absolute (IFILE or IROW) vs. ISN index
    
      LOGICAL LFLAG_RDHEAD_ONLY

      COMMON / SNFILECOM / 
     &   SNDATA_ROOT, SNANA_DIR, SNLIST_FILE
     &  ,SNDATA_FILE_CURRENT
     &  ,GLOBAL_BANNER, SNDATA_PREFIX, SNREADME_FILE, SNDATA_PATH
     &  ,C1ERR, C2ERR, ABSO_INDEX, HEADMASK, LFLAG_RDHEAD_ONLY
     

+KEEP,SNDATCOM.

+CDE,SNPAR.
+CDE,SNFILECOM.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,KCORCOM,IF=R4KCOR,I2KCOR.
+CDE,SNHOSTCOM.
cc +CDE,PARSECOM.
+CDE,SNSIMCOM.

+KEEP,CTRLCOM.

c control variables and counters.

      INTEGER 
     &   ISTAGE_SNANA       ! current stage of processing
     &  ,NACCEPT_CUT(MXCUTBIT) ! Number of SN that pass each cut
     &  ,NACCEPT_CID           ! # SN with valid CID
     &  ,NACCEPT_TYPE          ! # SN with valid TYPE
     &  ,NACCEPT_Z             ! idem with valid redshift
     &  ,NACCEPT_ZERR          ! idem with valid redshift error
     &  ,APPLY_HEADER_CUTMASK  ! mask of applied header cuts
c
     &  ,JTIME_START
     &  ,JTIME_LOOPSTART        ! time at start of fits with TIME()
     &  ,JTIME_LOOPEND          ! time and end
     &  ,NCALL_SNANA_DRIVER  
c
     &  ,NPASSCUT_INCREMENT(-1:MXTYPE,100)  ! 100 > NCUTBIT_SNLC 
     &  ,NPASSCUT_FIT(-1:MXTYPE)
     &  ,NVAR_NEARNBR          ! Number of NEARNBR variables to analyze
     &  ,NSTORE_MAGCOR         ! number of stored MAGCOR values
     &  ,NUSE_MAGCOR           ! number of used MAGCOR values
     &  ,SIGN_MAGCOR           ! add or subtract
     &  ,FORCEMASK_FLUXCOR   ! mask to force fluxCor, even if already applied  
     &  ,EXIT_ERRCODE        ! used for abort

      LOGICAL 
     &   DO_FIT
     &  ,DO_FLUXERRCALC    ! T => compute error from PSF,SKY & ZPT  
     &  ,LSIM_SNANA    ! simulated with SNANA
     &  ,LSIM_MAGOBS   ! data-like, but with SIM_MAGOBS (e.g. fakes on images)
     &  ,ISJOB_SNANA          ! =T for snana.exe only.
     &  ,ISJOB_PSNID
     &  ,REFORMAT_SAVE_BADEPOCHS  ! set if bit2 is set on any OPT_REFORMAT
     &  ,STDOUT_UPDATE         ! T => update event to screen
     &  ,DOFUDGE_HOSTNOISE     ! T => FUDGE_HOSTNOISE_FILE is set
     &  ,DOFUDGE_NONLIN        ! T => NONLINEARITY_FILE is set
     &  ,DOFUDGE_FLUXERRMODEL  ! T => FLUXERRMODEL_FILE

      CHARACTER SNANA_VERSION*12

c global survey info
      CHARACTER
     &   SURVEY_NAME*(MXCHAR_SURVEY)
     &  ,SURVEY_NAME_LIST(MXSURVEY)*(MXCHAR_SURVEY) ! in SURVEY.DEF file
     &  ,SUBSURVEY_NAME*(MXCHAR_SURVEY)  ! e.g.,  SURVEY:  BLA(SUBSURVEY)
     &  ,SUBSURVEY_NAME_LIST*(MXCHAR_FILENAME) ! comma-sep list
     &  ,SURVEY_FILTERS*(MXFILT_ALL)  ! read from data file 
     &  ,SURVEY_FIELDNAME(MXIDFIELD)*(MXCHAR_FIELDNAME) ! from SURVEY.DEF

      INTEGER 
     &   NFIELD_SURVEY             ! number of survey fields in SURVEY.DEF
     &  ,SURVEY_IDFIELD(MXIDFIELD) ! integer ID for each field

      REAL
     &   ZEROPOINT_FLUXCAL(MXFILT_OBS)  ! defines calibrated flux

      INTEGER*4
     &   N_VERSION             ! number of photometry version to read
     &  ,N_SNLC                ! number of SN lightcurves read
     &  ,N_SNLC_CUTS           ! Number of SN after cuts (bookkeeping only)
     &  ,N_SNLC_FIT            ! Number of fitted SN
     &  ,N_SNLC_FITCUTS        ! Number of fitted SN after fit cuts
     &  ,N_SNLC_COVFIX         ! Number of SN with fixed COV to be invertible
     &  ,N_DUPLICATE_CID       ! Number of duplicate CIDs 
     &  ,N_DUPLICATE_MJD       ! Number of duplicate MJD+BAND (Jun 2017)
     &  ,NSTORE_DUPLICATE_MJD  ! Number stored
     &  ,N_SNFILE              ! # of SN files to read per version
     &  ,N_SNFILE_LAST         ! idem, as of last version
     &  ,NEPOCH_TOT            ! total number of epochs read
     &  ,NEPOCH_CUT            ! total number of epochs passing cuts
     &  ,NEPOCH_BADPHOT        ! # epochs with bad PHOTFLAG (per event)
     &  ,NEPOCH_BADPHOT_SUM    ! # epochs with bad PHOTFLAG (summed)
     &  ,IDSURVEY              ! survey ID from SURVEY.DEF
     &  ,IDSUBSURVEY           ! =IDSURVEY unless subSurvey is different
     &  ,IDSURVEY_LIST(MXSURVEY) ! corresponds to SURVEY_NAME_LIST
     &  ,NSURVEY_LIST          ! size of SURVEY_NAME_LIST & IDSURVEY_LIST

      LOGICAL*1 
     &    EXIST_FILT(MXFILT_OBS)  ! T => at least one point per filt
     &   ,FOUND_SURVEY
     &   ,FORMAT_TEXT    ! ascii/txt for input data
     &   ,FORMAT_TERSE   ! terse-text for input data
     &   ,FORMAT_VERBOSE ! verbose-text for ...
     &   ,FORMAT_FITS    ! snfitsio for input data.

      INTEGER   
     &   NVAR_TERSE          ! Number variables for terse format
     &  ,ITERSE_MJD          ! index of MJD in TERSE variable list
     &  ,ITERSE_FILTER       ! idem for filter
     &  ,ITERSE_FIELD   
     &  ,ITERSE_FLUXCAL
     &  ,ITERSE_FLUXCALERR
     &  ,ITERSE_PHOTFLAG
     &  ,ITERSE_PHOTPROB
     &  ,ITERSE_ZPFLUX     ! mag <-> native flux zeropoint
     &  ,ITERSE_ZPERR      ! error on ZPFLUX, Jan 2020
     &  ,ITERSE_PSFSIG     ! added July 18, 2013
     &  ,ITERSE_SKYSIG     ! idem
     &  ,ITERSE_SKYSIG_T   ! added Aug 7 2014
     &  ,ITERSE_XPIX       ! added Aug 7 2014
     &  ,ITERSE_YPIX       ! added Aug 7 2014
     &  ,ITERSE_GAIN       ! added Oct 2015 to compute FLUXCAL_ERRCALC
     &  ,ITERSE_MAGOBS
     &  ,ITERSE_CCDNUM     ! added Oct 16 2017
     &  ,ITERSE_SIM_EPFILTREST  
     &  ,ITERSE_SIM_EPMAGOBS
     &  ,ITERSE_SIM_EPMAGREST

      INTEGER N_SNLC_PLOT
      LOGICAL MADE_LCPLOT  ! SAVE:  T if LC plot was made

      CHARACTER VARLIST_TERSE(MXLISTNML)*(MXCHAR_CCID) ! TERSE variable names

      COMMON / CTRLCOM / 
     &     SNANA_VERSION, SURVEY_NAME, SURVEY_NAME_LIST
     &    ,SUBSURVEY_NAME, SUBSURVEY_NAME_LIST
     &    ,NSURVEY_LIST, IDSURVEY, IDSUBSURVEY, IDSURVEY_LIST
     &    ,SURVEY_FILTERS
     &    ,SURVEY_FIELDNAME, SURVEY_IDFIELD, NFIELD_SURVEY
     &    ,ISJOB_SNANA, ISJOB_PSNID, ZEROPOINT_FLUXCAL
     &    ,NACCEPT_CUT, NACCEPT_CID, NACCEPT_TYPE
     &    ,NACCEPT_Z, NACCEPT_ZERR
     &    ,DO_FIT, DO_FLUXERRCALC, NVAR_NEARNBR 
     &    ,NSTORE_MAGCOR, NUSE_MAGCOR, SIGN_MAGCOR, FORCEMASK_FLUXCOR
     &    ,LSIM_SNANA, LSIM_MAGOBS, APPLY_HEADER_CUTMASK
     &    ,ISTAGE_SNANA
     &    ,N_VERSION, N_SNLC, N_SNLC_CUTS, N_SNLC_FIT, N_SNLC_FITCUTS
     &    ,N_SNLC_COVFIX, N_SNFILE, N_SNFILE_LAST, N_DUPLICATE_CID
     &    ,N_DUPLICATE_MJD, NSTORE_DUPLICATE_MJD
     &    ,NEPOCH_TOT, NEPOCH_CUT, NEPOCH_BADPHOT, NEPOCH_BADPHOT_SUM
     &    ,REFORMAT_SAVE_BADEPOCHS, STDOUT_UPDATE
     &    ,DOFUDGE_HOSTNOISE, DOFUDGE_NONLIN, DOFUDGE_FLUXERRMODEL
     &    ,NVAR_TERSE, VARLIST_TERSE
     &    ,ITERSE_MJD, ITERSE_FILTER, ITERSE_FIELD   
     &    ,ITERSE_FLUXCAL, ITERSE_FLUXCALERR
     &    ,ITERSE_PHOTFLAG, ITERSE_PHOTPROB
     &    ,ITERSE_ZPFLUX, ITERSE_ZPERR, ITERSE_PSFSIG
     &    ,ITERSE_SKYSIG, ITERSE_SKYSIG_T
     &    ,ITERSE_MAGOBS, ITERSE_XPIX, ITERSE_YPIX, ITERSE_GAIN
     &    ,ITERSE_CCDNUM, ITERSE_SIM_EPFILTREST
     &    ,ITERSE_SIM_EPMAGOBS, ITERSE_SIM_EPMAGREST
     &    ,JTIME_START, JTIME_LOOPSTART, JTIME_LOOPEND
     &    ,NCALL_SNANA_DRIVER, NPASSCUT_INCREMENT, NPASSCUT_FIT
     &    ,N_SNLC_PLOT, MADE_LCPLOT
     &    ,EXIT_ERRCODE

c logical *1 stuff

      COMMON / SNDATCOM1 / EXIST_FILT, FOUND_SURVEY
     &    ,FORMAT_TEXT, FORMAT_TERSE, FORMAT_VERBOSE
     &    ,FORMAT_FITS

c SNTABLE control variables (May 2014)
      LOGICAL
     &   USE_TABLEFILE_HBOOK  ! write table in HBOOK format
     &  ,USE_TABLEFILE_ROOT   ! write table in ROOT format
     &  ,USE_TABLEFILE_TEXT   ! write table in TEXT format
     &  ,USE_TABLEFILE        ! T if either any of the above are set
     &  ,WRTABLEFILE_IAUC     ! T-> SNID -> IAUC (for writing tables)
     &  ,WRTABLEFILE_SIMVAR   ! T-> include SIM_XXX vars for simulation
     &  ,WRTABLEFILE_ZPHOT    ! T-> include ZPHOT info for PHOTOZ fit
     &  ,WRTABLEFILE_HOST_TEXT! T-> add HOST info in SNNA TEXT table 
     &  ,WRTABLEFILE_ERRCALC_TEXT! T-> add ERRCALC info in LCPLOT TEXT table 

      INTEGER
     &   OPT_TABLE(MXTABLE)       ! option(s) for each table
     &  ,CUTMASK_SNANA_TABLE      ! select CUTFLAG_SNANA for SNANA table

      REAL*8
     &   PRESCALE_TABLE(MXTABLE)  ! table pre-scale (to reduce size)

      CHARACTER 
     &   TEXTFORMAT_TABLE(MXTABLE)*8
     
c arrays for TABLE_FILTER_REMAP (Feb 2017)
      INTEGER NFILT_REMAP_TABLE, IFILTLIST_REMAP_TABLE(MXFILT_ALL)
      CHARACTER FILTLIST_REMAP_TABLE*(MXFILT_ALL)

c Sep 23 2017: allow user codes to add private variables to SNTABLE
      INTEGER   NTABLEVAR_USER  ! e.g., set in snana_private.cra
      CHARACTER TABLEVARNAME_USER(MXVAR_PRIVATE)*40
      REAL      TABLEVALUE_USER(MXVAR_PRIVATE)
 
      COMMON / SNTABLECOM / 
     &     USE_TABLEFILE_HBOOK, USE_TABLEFILE_ROOT
     &    ,USE_TABLEFILE_TEXT, USE_TABLEFILE
     &    ,OPT_TABLE, TEXTFORMAT_TABLE
     &    ,CUTMASK_SNANA_TABLE, WRTABLEFILE_IAUC, WRTABLEFILE_SIMVAR
     &    ,WRTABLEFILE_ZPHOT, WRTABLEFILE_HOST_TEXT
     &    ,WRTABLEFILE_ERRCALC_TEXT 
c
     &    ,NFILT_REMAP_TABLE, IFILTLIST_REMAP_TABLE
     &    ,FILTLIST_REMAP_TABLE
     &    ,NTABLEVAR_USER, TABLEVARNAME_USER
     &    ,TABLEVALUE_USER

      COMMON / SNTABLECOM8 / PRESCALE_TABLE 

c May 6, 2008: define lists for epochs to ignore
 
      INTEGER NEPOCH_IGNORE, NEPOCH_IGNORE_WRFITS
      CHARACTER 
     &   EPOCH_IGNORE_CCID(MXEPOCH_IGNORE)*(MXCHAR_CCID)
     &  ,EPOCH_IGNORE_FILT(MXEPOCH_IGNORE)*4
     &  ,EPOCH_IGNORE_LASTFILE*(MXCHAR_FILENAME)

      REAL*8 
     &   EPOCH_IGNORE_MJD(MXEPOCH_IGNORE)

      COMMON / EPIGNORE_COM / NEPOCH_IGNORE, NEPOCH_IGNORE_WRFITS
     &  ,EPOCH_IGNORE_CCID, EPOCH_IGNORE_FILT, EPOCH_IGNORE_LASTFILE
      COMMON / EPIGNORE_COM8 / EPOCH_IGNORE_MJD


      REAL*8  DUPLICATE_MJDLIST(200)
      COMMON / DUPMJDCOM / DUPLICATE_MJDLIST

+KEEP,USRTAGCM.

      INTEGER MXUSERTAG
      PARAMETER ( MXUSERTAG = 1000 ) ! max number of user tags

      INTEGER
     &   N_USERTAGS           ! number of tags in USERTAGS_FILE
     &  ,USERTAG_VALUELIST(MXUSERTAG)  ! list of user tags
     &  ,USERTAG                   ! USERTAG value  for current SN

      BYTE
     &   USERTAG_USED(MXUSERTAG)   ! mark when each USERTAG is used

      CHARACTER 
     &   USERTAG_CCIDLIST(MXUSERTAG)*(MXCHAR_CCID)  ! list of CCID

      COMMON / USERTAGCOM / 
     &   N_USERTAGS, USERTAG_VALUELIST, USERTAG_CCIDLIST
     &  ,USERTAG, USERTAG_USED


+KEEP,REQEPCOM.
      CHARACTER FILTLIST_REQEP*(MXFILT_ALL)
      INTEGER NFILT_REQEP, IFILTLIST_REQEP(MXFILT_ALL)
      REAL  TRANGE_REQEP(3), SNRMIN_REQEP
      LOGICAL ISFRAME_REST_REQEP, ISFRAME_OBS_REQEP

      COMMON / REQEPINP / 
     &    NFILT_REQEP, FILTLIST_REQEP, IFILTLIST_REQEP
     &   ,TRANGE_REQEP, SNRMIN_REQEP
     &   ,ISFRAME_REST_REQEP, ISFRAME_OBS_REQEP

      REAL NDAYS_ABOVE_SNRMIN_REQEP
      COMMON / REQEPCOM / NDAYS_ABOVE_SNRMIN_REQEP


+KEEP,EARLYCOM.

      REAL DT_SAMENIGHT
ccc   PARAMETER (DT_SAMENIGHT = 0.333) ! same night within 1/3 day = 8 hr
      PARAMETER (DT_SAMENIGHT = 0.400) ! same night within 0.4 day

c variables for selecting the early part of a light curve
      INTEGER    NOBS_EARLYLC, NNIGHT_EARLYLC
      INTEGER    NPHOTMASK_START_EARLYLC
      REAL       NSNR_START_EARLYLC
      REAL       MJDLAST_EARLYLC, MJDLAST_SELECT
  
      COMMON / EARLYCOM / 
     &   NOBS_EARLYLC, NNIGHT_EARLYLC, 
     &   NPHOTMASK_START_EARLYLC, NSNR_START_EARLYLC,
     &   MJDLAST_EARLYLC, MJDLAST_SELECT

c parameters parsed from EARLYLC_STRING:
      INTEGER  MAXOBS_EARLYLC, MAXNIGHT_EARLYLC, PHOTMASK_EARLYLC,
     &         NDAYADD_EARLYLC, PHOTMASK_START_EARLYLC
      REAL  SNRMIN_EARLYLC, PHOTPROBMIN_EARLYLC, SNR_START_EARLYLC
      CHARACTER  FILTERS_EARLYLC*(MXFILT_ALL)

      COMMON / EARLYINP / 
     &   MAXOBS_EARLYLC, MAXNIGHT_EARLYLC, NDAYADD_EARLYLC
     &  ,FILTERS_EARLYLC
     &  ,SNRMIN_EARLYLC, PHOTPROBMIN_EARLYLC, PHOTMASK_EARLYLC
     &  ,PHOTMASK_START_EARLYLC, SNR_START_EARLYLC

+KEEP,INTERPCM.

c arrays for interpolation

      INTEGER MXINTERP
      PARAMETER ( MXINTERP = 1000) ! ->1000 Nov 19 2019 (was 100)

      INTEGER*4 
     &   N_INTERP_MJDLIST        ! # SN MJDs to interpolate
     
      REAL*8    
     &   INTERP8_MJDLIST(MXINTERP)

      CHARACTER 
     &   INTERP_CCIDLIST(MXINTERP)*(MXCHAR_CCID)

      INTEGER N_INTERP_MJDLIST_DONE
      LOGICAL INTERP_MJDLIST_DONE(MXINTERP)

      COMMON / SNMJD_INTERPCOM /
     &    N_INTERP_MJDLIST, INTERP_CCIDLIST
     &   ,INTERP_MJDLIST_DONE, N_INTERP_MJDLIST_DONE

      COMMON / SNMJD_INTERPCOM8 / INTERP8_MJDLIST

+KEEP,SNLCCOM.

c Main common block variables for light curves and
c analysis-related variables.    

      INTEGER
     &   SNLC_CID               ! integer CID 
     &  ,ISNLC_SNRECON_USE(MXEPOCH)  ! 1 -> epoch used in SNRECON
     &  ,ISNLC_PHOTFLAG(MXEPOCH) ! photomety flags
     &  ,ISNLC_LENCCID     ! char-len of CCID
     &  ,ISNLC_LENIAUC     ! char-len of IAUC name
     &  ,ISNLC_VERSION     ! photometry version index vs. ISN     
     &  ,ISNLC_TYPE        ! type (120=confirmed Ia, etc ...)
     &  ,ISNLC_ABSO_INDEX  ! absolute index (row or file number)
     &  ,ISNLC_IFILE       ! ifile index, text format only
     &  ,ISNLC_IFILT_OBS(MXEPOCH) ! filt-index for each epoch/SN
     &  ,ISNLC_NEWMJD_HEAD   ! Number of NEWMJDs in header
     &  ,ISNLC_NEWMJD_FOUND  ! Number of NEWMJDs found in file
     &  ,ISNLC_NEWMJD_STORE  ! Number of NEWMJDs stored
     &  ,ISNLC_NEWMJD_CUTS   ! Number of NEWMJDs after cuts
     &  ,ISNLC_EPOCH_RANGE_NEWMJD(2,MXEPOCH)
     &  ,ISNLC_NFILT_NEWMJD(MXEPOCH)   ! # observed filters per NEWMJD
     &  ,ISNLC_NFILT_SNRMAX      ! number of filters passing SNR cut
     &  ,ISNLC_NFILT_SNRMAX2     ! idem for 2nd SNRMAX cut
     &  ,ISNLC_NFILT_TRESTMIN     ! Nfilt passing TRESTMIN cut
     &  ,ISNLC_NFILT_TRESTMAX     ! idem for TRESTMAX
     &  ,ISNLC_NFILT_TREST2       ! Nfilt passing CUTWIN_TREST2 cut
cc xxx    &  ,ISNLC_NFILT_THRESH(MXEPOCH)
     &  ,ISNLC_NEPOCH_FOUND  ! actual number of epochs found
     &  ,ISNLC_NEPOCH_STORE  ! number of epochs stored in memory
     &  ,ISNLC_NEPOCH_USE       ! used after PHOTMASK cuts
     &  ,ISNLC_NEPOCH_PHOTPROB  ! NEPOCH with PHOTPROB >= 0
     &  ,ISNLC_NEPOCH_DETECT    ! NEPOCH with detection
     &  ,ISNLC_NEPOCH_FILT(MXFILT_OBS)  ! NEPOCH vs. filter
     &  ,ISNLC_NEPOCH_PRESN(MXFILT_OBS) ! pre-explosion epochs
     &  ,ISNLC_NMJD_INCLUDE             ! NOBS in CUTWIN_MJD_INCLUDE window
c
     &  ,ISNLC_FAKE             ! => real data, else it's a fake
     &  ,ISNLC_CCDNUM(MXEPOCH)  ! read from header (May 2017)
     &  ,ISNLC_IDTEL(MXEPOCH)   ! integer telescope id      
     &  ,ISNLC_IDFIELD(MXEPOCH) ! integer field id      
     &  ,ISNLC_NFIELD_OVP       ! number of fields (>=2 for overlap)
     &  ,ISNLC_CUTFLAG_REQEP        ! idem
     &  ,ISNLC_CUTFLAG_PRIVATE      ! idem for private var cuts
     &  ,ISNLC_CUTFLAG_USRCUTS      ! idem for USRCUTS
     &  ,ISNLC_CUTFLAG_SIMVAR       ! idem for SIMVAR cuts
     &  ,ISNLC_WRMASK_FLUXCOR_SNANA   ! write if fudges applied to data
     &  ,ISNLC_RDMASK_FLUXCOR_SNANA   ! read if SNANA fudges applied to data
      
      REAL*8
     &   SNLC8_RA        ! RA   vs. SN
     &  ,SNLC8_DEC       ! DEC  vs. SN
     &  ,SNLC8_MJD(MXEPOCH)  ! MJD for each epoch
     &  ,SNLC8_MJDMIN        !   min MJD among all measurements
     &  ,SNLC8_MJDMAX        !   max MJD ...
     &  ,SNLC8_MJD_TRIGGER   ! MJD of trigger bit (see PHOTFLAG_TRIGGER)
     &  ,SNLC8_FLUXCAL(MXEPOCH) ! to call functions requiring double
     &  ,SNLC8_FLUXCAL_ERRTOT(MXEPOCH)

      REAL 
     &   SNLC_ZHELIO        ! redshift used for final analysis 
     &  ,SNLC_ZHELIO_ERR    ! error on above 
     &  ,SNLC_ZCMB          ! redshift used for final analysis 
     &  ,SNLC_ZCMB_ERR      ! error on above 
     &  ,SNLC_ZHD           ! redshift used for Hubble diagram 
     &  ,SNLC_ZHD_ERR       ! error on above
     &  ,SNLC_ZSN           ! redshift of SN only (ignoring host-z)
     &  ,SNLC_ZSN_ERR       ! error on above
     &  ,SNLC_REDSHIFT      ! redshift used for light curve fit
     &  ,SNLC_REDSHIFT_ERR  ! error on above 
     &  ,SNLC_VPEC          ! pec. velocity
     &  ,SNLC_VPEC_ERR      ! error on above
     &  ,SNLC_ZPEC
     &  ,SNLC_ZPEC_ERR
     &  ,SNLC_Trestmin  ! earliest epoch, rest frame days since peak
     &  ,SNLC_Trestmax  ! latest   epoch, rest frame days since peak
     &  ,SNLC_TrestRange
     &  ,SNLC_Tobsmin   ! earliest epoch, obs frame days since peak
     &  ,SNLC_Tobsmax   ! latest   epoch, obs frame days since peak
     &  ,SNLC_TGAPMAX     ! max gap within TREST-range
     &  ,SNLC_T0GAPMAX    ! max gap near peak 
     &  ,SNLC_SNRMAX_FILT(0:MXFILT_OBS)   ! max S/N per filter/SN
     &  ,SNLC_SNRMAX_SORT(MXFILT_OBS)     ! 1st, 2nd ... SNRMAX by filt
     &  ,SNLC_FLUXCALMAX(MXFILT_OBS)    ! max flux per filter/SN
     &  ,SNLC_SNANAFIT_PEAKMJD     ! SNANA-estimate of PEAKKMJD
     &  ,SNLC_SNANAFIT_PEAKMJD_FITPAR(MXFILT_OBS,NPAR_ANYLC)
     &  ,SNLC_SNANAFIT_PEAKMJD_FITERR(MXFILT_OBS,NPAR_ANYLC)
     &  ,SNLC_PHOTPROB(MXEPOCH)   ! generic 'fit probability' per epoch
     &  ,SNLC_PHOTPROB_MIN        ! min photprob for PHOTPROB>0
     &  ,SNLC_TOBS(MXEPOCH)        ! MJD-SET_PEAKMJD
     &  ,SNLC_TREST(MXEPOCH)       !  MJD-SET_PEAKMJD)/(1+z)
     &  ,SNLC_GAIN(MXEPOCH)      ! e/AUD
     &  ,SNLC_RDNOISE(MXEPOCH)   ! read noise per pix, e-
     &  ,SNLC_PIXSIZE            ! pixel size
     &  ,SNLC_NXPIX              ! total number of X-pixels (Aug 7 2014)
     &  ,SNLC_NYPIX              ! total number of Y-pixels
     &  ,SNLC_XPIX(MXEPOCH)      ! pixel location
     &  ,SNLC_YPIX(MXEPOCH)      ! pixel location
     &  ,SNLC_AREAFRAC(MXEPOCH)  ! area-frac contained by XPIX,YPIX
     &  ,SNLC_MWEBV              ! Milky Way Galactic E(B-V)
     &  ,SNLC_MWEBV_ERR          ! error on above
     &  ,SNLC_SKYSIG(MXEPOCH)    ! sigma on above
     &  ,SNLC_SKYSIG_T(MXEPOCH)  ! sigma on template run
     &  ,SNLC_PSF_SIG1(MXEPOCH)  ! sigma, pixels
     &  ,SNLC_PSF_SIG2(MXEPOCH)
     &  ,SNLC_PSF_RATIO(MXEPOCH)
     &  ,SNLC_AREA_NOISE(MXEPOCH)  ! Noise-equivalent area (pixels)
     &  ,SNLC_FLUX_NSIG(MXEPOCH)   ! significance
     &  ,SNLC_FLUXCAL_OFF(MXFILT_OBS)    ! add SN light from template
     &  ,SNLC_FLUXCAL_ERRCALC(MXEPOCH)   ! calc a-la simulation
     &  ,SNLC_FLUXCAL_HOSTERRCALC(MXEPOCH)   ! idem for host error
     &  ,SNLC_FLUXCAL(MXEPOCH)
     &  ,SNLC_FLUXCAL_ERRTOT(MXEPOCH)
     &  ,SNLC_FLUXCAL_ERRTEST(MXEPOCH)   ! ERRCALC/ERRTRUE (Nov 2019
     &  ,SNLC_MAG(MXEPOCH)
     &  ,SNLC_MAG_ERRPLUS(MXEPOCH)
     &  ,SNLC_MAG_ERRMINUS(MXEPOCH)
     &  ,SNLC_ZEROPT(MXEPOCH)
     &  ,SNLC_ZEROPT_ERR(MXEPOCH)
     &  ,SNLC_ZEROPT_forCUT(MXEPOCH)  ! depends on CUTWIN_ZPADU or CUTWIN_ZPNPE
     &  ,SNLC_DLMAG                   ! 5*log10(10pc/DL)
     &  ,SNLC_SKYFLUXCAL(MXEPOCH)     ! calculated sky fluxcal/pixel
     &  ,SNLC_MWXT_MAG(MXFILT_OBS)        ! mag stellar extinct
     &  ,SNLC_MWXT_FLUXFRAC(MXFILT_OBS)   ! same for flux (< 1)
     &  ,SNLC_MWXT_MAGERR(MXFILT_OBS)     ! Galactic mag err per filter
     &  ,SNLC_SEARCH_PEAKMJD            ! external PEAKMJD
     &  ,SNLC_DTOBS(MXEPOCH)            ! time since last obs  
     &  ,SNLC_DTOBS_SAMEFILT(MXEPOCH)   ! idem, but same filter
     &  ,SNLC_TLIVE_DETECT     ! MJD(last detection) - MJD(1st detection)

      INTEGER 
     &   NSEASON_TOT     ! total number of seasons
     &  ,NSEASON_ACTIVE  ! total number of active seasons

      REAL*4
     &   MULTISEASON_CHI2RED(MXSEASON) ! borrow another 'MX' param
     &  ,MULTISEASON_AVGFLUX(MXSEASON)
     &  ,MULTISEASON_MJDMIN(MXSEASON)
     &  ,MULTISEASON_MJDMAX(MXSEASON)

      CHARACTER
     &   SNLC_CCID*(MXCHAR_CCID)      ! char CID 
     &  ,SNLC_IAUC*(MXCHAR_CCID)
     &  ,SNLC_CASTCID*8             ! = 'INT' or 'CHAR' to indicate cast
     &  ,SNLC_FIELD(MXEPOCH)*(MXCHAR_FIELDNAME)    ! char field name
     &  ,SNLC_FIELD_OVPLIST(MXFIELD_OVP)*(MXCHAR_FIELDNAME)  ! sparse list of overlap fields
     &  ,SNLC_FIELDLIST*(MXCHAR_FIELDNAME) ! e.g., '82S', '82N+82S'

      COMMON / SNLC8COM /
     &    SNLC8_RA, SNLC8_DEC
     &  , SNLC8_MJD, SNLC8_MJDMIN, SNLC8_MJDMAX, SNLC8_MJD_TRIGGER
     &  , SNLC8_FLUXCAL, SNLC8_FLUXCAL_ERRTOT

      COMMON / SNLCCOM /
     &     SNLC_CID, SNLC_CCID,  SNLC_CASTCID, SNLC_IAUC
     &    ,SNLC_FIELD, SNLC_FIELD_OVPLIST, SNLC_FIELDLIST
     &    ,SNLC_SNANAFIT_PEAKMJD
     &    ,SNLC_SNANAFIT_PEAKMJD_FITPAR
     &    ,SNLC_SNANAFIT_PEAKMJD_FITERR
     &    ,SNLC_SEARCH_PEAKMJD
     &    ,SNLC_ZHELIO, SNLC_ZHELIO_ERR
     &    ,SNLC_ZCMB,   SNLC_ZCMB_ERR, SNLC_ZHD, SNLC_ZHD_ERR
     &    ,SNLC_ZSN, SNLC_ZSN_ERR
     &    ,SNLC_REDSHIFT, SNLC_REDSHIFT_ERR
     &    ,SNLC_VPEC, SNLC_VPEC_ERR, SNLC_ZPEC, SNLC_ZPEC_ERR
     &    ,SNLC_TRESTMIN, SNLC_TRESTMAX, SNLC_TrestRange, SNLC_TREST
     &    ,SNLC_TGAPMAX,  SNLC_T0GAPMAX
     &    ,SNLC_Tobsmin, SNLC_Tobsmax, SNLC_TOBS
     &    ,SNLC_SNRMAX_FILT, SNLC_SNRMAX_SORT
     &    ,SNLC_FLUXCALMAX, SNLC_PHOTPROB, SNLC_PHOTPROB_MIN
     &    ,SNLC_GAIN, SNLC_RDNOISE
     &    ,SNLC_MWXT_MAG, SNLC_MWXT_FLUXFRAC, SNLC_MWXT_MAGERR
     &    ,SNLC_MWEBV, SNLC_MWEBV_ERR
     &    ,SNLC_XPIX, SNLC_YPIX, SNLC_AREAFRAC, SNLC_PIXSIZE
     &    ,SNLC_NXPIX, SNLC_NYPIX
     &    ,SNLC_SKYSIG,  SNLC_SKYSIG_T
     &    ,SNLC_PSF_SIG1, SNLC_PSF_SIG2, SNLC_PSF_RATIO
     &    ,SNLC_AREA_NOISE
c
     &    ,SNLC_FLUX_NSIG, SNLC_FLUXCAL_OFF
     &    ,SNLC_FLUXCAL_ERRCALC, SNLC_FLUXCAL_ERRTEST
     &    ,SNLC_FLUXCAL_HOSTERRCALC
     &    ,SNLC_FLUXCAL, SNLC_FLUXCAL_ERRTOT
     &    ,SNLC_MAG, SNLC_MAG_ERRPLUS, SNLC_MAG_ERRMINUS
     &    ,SNLC_ZEROPT, SNLC_ZEROPT_ERR, SNLC_ZEROPT_forCUT
     &    ,SNLC_SKYFLUXCAL, SNLC_DLMAG
     &    ,SNLC_DTOBS, SNLC_DTOBS_SAMEFILT

      COMMON / ISNCOM /      
     &     ISNLC_VERSION, ISNLC_SNRECON_USE, ISNLC_PHOTFLAG
     &    ,ISNLC_TYPE
     &    ,ISNLC_ABSO_INDEX, ISNLC_IFILE,ISNLC_LENCCID,ISNLC_LENIAUC
     &    ,ISNLC_NFILT_NEWMJD, ISNLC_IFILT_OBS
     &    ,ISNLC_NEWMJD_HEAD, ISNLC_NEWMJD_FOUND, ISNLC_NEWMJD_STORE
     &    ,ISNLC_NEWMJD_CUTS, ISNLC_EPOCH_RANGE_NEWMJD
     &    ,ISNLC_NEPOCH_FOUND, ISNLC_NEPOCH_STORE
     &    ,ISNLC_NEPOCH_USE, ISNLC_NEPOCH_PHOTPROB
     &    ,ISNLC_NEPOCH_FILT,  ISNLC_NEPOCH_PRESN, ISNLC_NMJD_INCLUDE
     &    ,ISNLC_NEPOCH_DETECT, SNLC_TLIVE_DETECT
     &    ,ISNLC_FAKE, ISNLC_CCDNUM
     &    ,ISNLC_NFILT_SNRMAX, ISNLC_NFILT_SNRMAX2
     &    ,ISNLC_NFILT_TRESTMIN, ISNLC_NFILT_TRESTMAX
     &    ,ISNLC_NFILT_TREST2
     &    ,ISNLC_IDTEL, ISNLC_IDFIELD, ISNLC_NFIELD_OVP
     &    ,ISNLC_CUTFLAG_REQEP
     &    ,ISNLC_CUTFLAG_PRIVATE, ISNLC_CUTFLAG_USRCUTS
     &    ,ISNLC_CUTFLAG_SIMVAR
     &    ,ISNLC_WRMASK_FLUXCOR_SNANA, ISNLC_RDMASK_FLUXCOR_SNANA

c - - - - -  ADDCOL stuff - - - - - - -
c ADDCOL arrays are loaded with original filter indices,
c or with REMAPed filter indices. Allows using unique
c pointer for calls to SNTABLE_ADDCOL.

      CHARACTER 
     &    ADDCOL_FILTERS*(MXFILT_ALL) ! SURVEY_FILTERS

      REAL      
     &    ADDCOL_SNHOST_MAGOBS(MXFILT_ALL,MXSNHOST)
     &   ,ADDCOL_SNHOST_SBFLUXCAL(MXFILT_ALL)
     &   ,ADDCOL_FLUXCALMAX(MXFILT_ALL)
     &   ,ADDCOL_CHI2_FITPKMJD(MXFILT_ALL)
     &   ,ADDCOL_SNRMAX(MXFILT_ALL)
     &   ,ADDCOL_XTMW(MXFILT_ALL)

      INTEGER
     &    ADDCOL_NDOF_FITPKMJD(MXFILT_ALL)

      COMMON / ADDCOL_FILTERCOM /
     &   ADDCOL_FILTERS
     &  ,ADDCOL_SNHOST_MAGOBS, ADDCOL_SNHOST_SBFLUXCAL 
     &  ,ADDCOL_FLUXCALMAX, ADDCOL_CHI2_FITPKMJD, ADDCOL_NDOF_FITPKMJD
     &  ,ADDCOL_SNRMAX, ADDCOL_XTMW


c - - - -- MULTI-SEASON STUFF - - - -
      COMMON / MULTISEASONCOM / NSEASON_TOT, NSEASON_ACTIVE
     &  ,MULTISEASON_CHI2RED, MULTISEASON_AVGFLUX
     &  ,MULTISEASON_MJDMIN,  MULTISEASON_MJDMAX

+KEEP,SPECCOM.
c  Apr 2019
c  Read spectra to pass into tables for plotting.
c  Not intended for analysis.
     
      INTEGER MXVAR_SPECTRUM, MXSPECTRUM, MXLAM_SPECTRUM     

      PARAMETER (
     &   MXVAR_SPECTRUM = 10   ! max number of variables after SPEC: key
     &  ,MXSPECTRUM     = 5    ! max number of spectra to read per event
     &  ,MXLAM_SPECTRUM = 2000 ! max number of wave bins per spectrum
     &        )

      LOGICAL RDFLAG_SPECTRUM
      CHARACTER VARNAMES_SPECTRUM(MXVAR_SPECTRUM)*40

      INTEGER 
     &    NVAR_SPECTRUM           ! number of spectrum variables to read
     &   ,NSPECTRUM                    ! Number of spectra
     &   ,ID_SPECTRUM(MXSPECTRUM)      ! ID for each spectrum
     &   ,NLAMBIN_SPECTRUM(MXSPECTRUM) ! Number of wave bins per spectrum
     &   ,NLAMBIN_READ                 ! keep track of wave index

      REAL*8 
     &    MJD_SPECTRUM(MXSPECTRUM) 
     &   ,TOBS_SPECTRUM(MXSPECTRUM)
     &   ,TEXPOSE_SPECTRUM(MXSPECTRUM)
     &   ,LAMMIN_SPECTRUM(MXLAM_SPECTRUM,MXSPECTRUM)
     &   ,LAMMAX_SPECTRUM(MXLAM_SPECTRUM,MXSPECTRUM)
     &   ,FLAM_SPECTRUM(MXLAM_SPECTRUM,MXSPECTRUM) 
     &   ,FLAMERR_SPECTRUM(MXLAM_SPECTRUM,MXSPECTRUM)  

      COMMON/SPECCOM4/ RDFLAG_SPECTRUM
     &   ,NVAR_SPECTRUM, NSPECTRUM, ID_SPECTRUM, NLAMBIN_SPECTRUM
     &   ,VARNAMES_SPECTRUM, NLAMBIN_READ

      COMMON/SPECCOM8/ 
     &    MJD_SPECTRUM, TOBS_SPECTRUM, TEXPOSE_SPECTRUM
     &   ,LAMMIN_SPECTRUM, LAMMAX_SPECTRUM
     &   ,FLAM_SPECTRUM, FLAMERR_SPECTRUM


+KEEP,SNSIMCOM.

c simulation parameters (if FAKE=2)

      REAL*8  SIM8_RA, SIM8_DECL

      REAL
     &   SIM_REDSHIFT_HELIO
     &  ,SIM_REDSHIFT_CMB
     &  ,SIM_REDSHIFT_HOST
     &  ,SIM_VPEC
     &  ,SIM_DLMAG
     &  ,SIM_LENSDMU
     &  ,SIM_MWEBV
     &  ,SIM_MWRV
     &  ,SIM_SALT2x0
     &  ,SIM_SALT2mb
     &  ,SIM_COLORPAR, SIM_COLORLAW, SIM_AV, SIM_RV
     &  ,SIM_SHAPEPAR, SIM_SHAPELAW
     &  ,SIM_PEAKMJD
     &  ,SIM_EXPOSURE_TIME(MXFILT_OBS)  ! relative exposure time
     &  ,SIM_PEAKMAG(MXFILT_OBS)
     &  ,SIM_EPMAGOBS(MXEPOCH)      ! true epoch mag at each filter/epoch
     &  ,SIM_EPFLUXCAL(MXEPOCH)     ! true fluxcal at each filter/epoch
     &  ,SIM_EPSNRMON(MXEPOCH)      ! optional SNR at MAGMONITOR
     &  ,SIM_EPMAGREST(MXEPOCH)     ! true rest-frame mag
     &  ,SIM_EPFLUXCAL_HOSTERR(MXEPOCH) ! true error from host noise
     &  ,SIMSED_PARVAL(MXPAR_SIMSED)
     &  ,BYOSED_PARVAL(MXPAR_SIMSED)    ! Dec 10 2018
     &  ,LCLIB_PARVAL(MXPAR_LCLIB)
     &  ,SIM_HOSTLIB_PARVAL(MXPAR_SIMSED) ! HOSTLIB params
     &  ,SIM_MAGSMEAR_COH
     &  ,SIM_SALT2gammaDM             ! usually this is gamma or gamma/2
     &  ,SIM_TEMPLATEMAG(MXFILT_ALL)  ! image-sub template, not LCLIB template
     &  ,SIM_LCWIDTH(MXFILT_ALL)      ! computed from SIM_EPFLUXCAL
c 
     &  ,SIM_MODELGRID_TOBS(MXEP_MODELGRID)    ! for SNANA+SIM_MAGOBS table
     &  ,SIM_MODELGRID_MAGOBS(MXEP_MODELGRID,MXFILT_OBS/2) ! idem

      INTEGER
     &   SIM_MODEL_INDEX      ! model index (MLCS,SALT2,NON1a ...)
     &  ,SIM_GENTYPE          ! generated SNTYPE; SIM_TYPE_INDEX
     &  ,SIM_TEMPLATE_INDEX   ! template index for NON1ASED, SIMSED, LCLIB ...
     &  ,SIM_SEARCHEFF_MASK   ! bits 1,2 => found by software,humans
     &  ,SIM_LIBID            ! LIBID for each event
     &  ,SIM_NGEN_LIBID       ! NGEN for this LIBID (usually 1)
     &  ,SIM_NOBS_UNDEFINED   ! NOBS where model is undefined
     &  ,SIM_NSUBSAMPLE_MARK  ! Number of marked sub-samples
     &  ,SIM_SUBSAMPLE_INDEX  ! sub-sample index
     &  ,SIM_REDSHIFT_FLAG    ! points to source of redshift
     &  ,SIMOPT_MWCOLORLAW    ! option for MW color law
     &  ,SIMOPT_MWEBV         ! option to modify MWEBV_SFD map
     &  ,NPAR_SIMSED
     &  ,NPAR_BYOSED
     &  ,NPAR_LCLIB
     &  ,NPAR_SIM_HOSTLIB
     &  ,SIM_EPFILTREST(MXEPOCH)
     &  ,SIMLIB_MSKOPT        ! SIMLIB option mask (Dec 2015)
     &  ,NEP_SIM_MODELGRID
     &  ,NEP_SIM_MAGOBS          ! number of sim epochs with MAGOBS < 99

      INTEGER*8  SIM_HOSTLIB_GALID

      CHARACTER 
     &   SIMNAME_MODEL*40     ! SALT2, mlcs2k2, NON1A, etc ...
     &  ,SIMNAME_TYPE*12      ! Ia, Ib, II, IIN, etc ...
     &  ,SIMNAME_SHAPEPAR*40  ! DELTA, x1, stretch ...
     &  ,SIMNAME_SHAPELAW*40  ! alpha ...
     &  ,SIMNAME_COLORPAR*40  ! AV, c ...
     &  ,SIMNAME_COLORLAW*40  ! RV,  beta ...
     &  ,SIMLIB_FILENAME*200  ! SIMLIB file used to generate sim
     &  ,SIMSED_KEYWORD(MXPAR_SIMSED)*80 ! full keyname in header
     &  ,SIMSED_PARNAME(MXPAR_SIMSED)*20 ! parname for fitres and ntuple
     &  ,BYOSED_KEYWORD(MXPAR_SIMSED)*80 ! full keyname in header
     &  ,BYOSED_PARNAME(MXPAR_SIMSED)*20 ! parname for fitres and ntuple
     &  ,LCLIB_KEYWORD(MXPAR_LCLIB)*80 ! full keyname in header
     &  ,LCLIB_PARNAME(MXPAR_LCLIB)*20 ! parname for fitres and ntuple
     &  ,SIM_HOSTLIB_KEYWORD(MXPAR_SIMSED)*60 ! full keyname
     &  ,SIM_HOSTLIB_PARNAME(MXPAR_SIMSED)*60 ! parname 
     &  ,SIMNAME_SNRMON*40

      COMMON / SNSIMCOM / SIMNAME_MODEL, SIM_MODEL_INDEX
     &  ,SIM_REDSHIFT_HELIO, SIM_REDSHIFT_CMB, SIM_REDSHIFT_HOST
     &  ,SIM_REDSHIFT_FLAG
     &  ,SIM_VPEC, SIM_DLMAG, SIM_LENSDMU, SIM_SALT2x0, SIM_SALT2mb
     &  ,SIM_COLORPAR, SIM_COLORLAW, SIM_AV, SIM_RV
     &  ,SIM_SHAPEPAR, SIM_SHAPELAW, SIM_PEAKMJD, SIM_MWEBV,SIM_MWRV
     &  ,SIM_EXPOSURE_TIME, SIM_TEMPLATE_INDEX, SIM_TEMPLATEMAG
     &  ,SIM_GENTYPE, SIMNAME_TYPE, SIM_LCWIDTH
     &  ,SIM_SEARCHEFF_MASK, SIM_LIBID, SIM_NGEN_LIBID
     &  ,SIM_NOBS_UNDEFINED, SIM_NSUBSAMPLE_MARK, SIM_SUBSAMPLE_INDEX
     &  ,SIM_PEAKMAG, SIM_EPMAGOBS, SIM_EPFLUXCAL, NEP_SIM_MAGOBS
     &  ,SIM_EPSNRMON, SIM_EPFLUXCAL_HOSTERR
     &  ,SIMNAME_SHAPEPAR,  SIMNAME_SHAPELAW
     &  ,SIMNAME_COLORPAR,  SIMNAME_COLORLAW, SIMNAME_SNRMON
     &  ,SIMLIB_FILENAME, SIMLIB_MSKOPT
     &  ,SIMOPT_MWCOLORLAW, SIMOPT_MWEBV
     &  ,SIM_EPFILTREST, SIM_EPMAGREST,  SIM_MAGSMEAR_COH
     &  ,SIM_SALT2gammaDM
     &  ,NEP_SIM_MODELGRID, SIM_MODELGRID_TOBS, SIM_MODELGRID_MAGOBS

      COMMON / SIMSEDCOM /
     &  NPAR_SIMSED, SIMSED_PARVAL, SIMSED_PARNAME, SIMSED_KEYWORD

      COMMON / BYOSEDCOM /
     &   NPAR_BYOSED, BYOSED_PARVAL, BYOSED_PARNAME, BYOSED_KEYWORD

      COMMON / LCLIBCOM / 
     &   NPAR_LCLIB, LCLIB_PARVAL, LCLIB_KEYWORD, LCLIB_PARNAME

      COMMON / SIMHOSTCOM / 
     &    NPAR_SIM_HOSTLIB, SIM_HOSTLIB_PARVAL
     &   ,SIM_HOSTLIB_PARNAME, SIM_HOSTLIB_KEYWORD

      COMMON / SNSIMCOM8 / 
     &         SIM8_RA, SIM8_DECL, SIM_HOSTLIB_GALID

+KEEP,PRIVCOM.

c Nov 2012: PRIVATE_VAR variables in data files
c Aug 2014: MXVAR_PRIVATE -> 28 (was 20)

      REAL*8  PRIVATE_NULL
      PARAMETER ( PRIVATE_NULL = -999.0909 )

      INTEGER   
     &   NVAR_PRIVATE        ! Number of private  variables
     &  ,NCUT_PRIVATE       
     &  ,IVAR_PRIVATE_REDSHIFT  ! July 2015

c for  the following header key
c    PRIVATE(BLA): 44.4
c we have
c   VARANME = 'BLA'
c   KEYWORD = 'PRIVATE(BLA)'
c   VALUE   = 44.4

      CHARACTER 
     &   PRIVATE_VARNAME(MXVAR_PRIVATE)*(MXCHAR_FILEWORD)
     &  ,PRIVATE_KEYWORD(MXVAR_PRIVATE)*(MXCHAR_FILEWORD)

      REAL*8   
     &    PRIVATE_VALUE(MXVAR_PRIVATE)    ! value for each var
     &   ,PRIVATE_CUTWIN(2,MXVAR_PRIVATE) ! cut-window on each var

      INTEGER USE_PRIVATE_CUTWIN(MXCUT_PRIVATE)  ! logical

      COMMON / PRIVATE_VARCOM  / 
     &     NVAR_PRIVATE, PRIVATE_VARNAME, PRIVATE_KEYWORD
     &    ,NCUT_PRIVATE, USE_PRIVATE_CUTWIN, IVAR_PRIVATE_REDSHIFT

      COMMON / PRIVATECOM8 / PRIVATE_VALUE, PRIVATE_CUTWIN
    
+KEEP,KCORCOM.
+CDE,KTABLECM,IF=R4KCOR,I2KCOR.

      INTEGER 
     &    LUNKCOR, MXKCOR
     &   ,NKDIM, N4DIM
     &   ,IDMAP_KCOR, IDMAP_AVWARP, IDMAP_LCMAG, IDMAP_MWXT
     &   ,KDIM_T, KDIM_Z, KDIM_AV, KDIM_ifiltr, KDIM_ifilto

      PARAMETER (
     &   LUNKCOR      = 98  ! log unit number to read
     &  ,MXKCOR       = 100 ! max number of KCOR tables to read
     &  ,KDIM_T       = 1  ! epoch KCOR index
     &  ,KDIM_Z       = 2  ! redshift KCOR index
     &  ,KDIM_AV      = 3  ! AV kcor index
     &  ,KDIM_ifiltr  = 4  ! rest-filter KCOR index
     &  ,KDIM_ifilto  = 5  ! obs-filter KCOR index    
     &  ,NKDIM        = 5  ! number of KCOR dimensions in map
     &  ,IDMAP_KCOR   = 10 ! for INIT_1DINDEX (any integer is OK)
     &  ,IDMAP_AVWARP = 11
     &  ,IDMAP_LCMAG  = 12
     &  ,IDMAP_MWXT   = 13
     &  ,N4DIM        = 4  ! for 4-d tables
     &   )

c K-cor & photometry-template info
 
      INTEGER
     &   NCALL_RDKCOR ! # times RDKCOR is called
     &  ,NKCOR_STORE  ! number of stored K-corr tables
     &  ,NZBIN_KCOR   ! # Z-bins in each K-cor table
     &  ,NTBIN_KCOR   ! # T-bins "    "
     &  ,NAVBIN_KCOR  ! # AV bins
     &  ,IAV0         ! IAV index with AV=0
     &  ,IZ0          ! IZ with Z=0
     &  ,NLbin_SNSED      ! # lambda bins for SN SED
     &  ,NTbin_SNSED      ! # epoch bins for SN SED
     &  ,NERR_AVWARP      ! # errors trapped in GET_AVWARP
c
     &  ,NBINTOT_KCOR     ! Total KCOR bins
     &  ,NBINTOT_AVWARP
     &  ,NBINTOT_LCMAG
     &  ,NBINTOT_MWXT
     &  ,NBIN_KCOR(NKDIM)
     &  ,NBIN_AVWARP(NKDIM)
     &  ,NBIN_LCMAG(NKDIM)
     &  ,NBIN_MWXT(NKDIM)

      REAL 
     &   Zrange_Kcor(2)    ! min,max redshift in KCOR table
     &  ,Zrange_Kcor_LU(2) ! min,max redshift for lookup
     &  ,Trange_Kcor(2)  ! min,max rest-epoch (days) in KCOR table
     &  ,AVrange_Kcor(2) ! min,max AV
     &  ,ZBINSIZE_KCOR   ! redshift binsize
     &  ,TBINSIZE_KCOR   ! epoch bin size (days)
     &  ,AVbinsize_KCOR  ! 
     &  ,Cbinsize_AVWARP ! 
     &  ,GRIDVAL_AV(MXAVBIN_KCOR)  ! store AV(iav) for convenience
     &  ,GRIDVAL_Z(MXZBIN_KCOR)    ! store Z(iz)   for convenience
     &  ,GRIDVAL_T(MXTBIN_KCOR)    ! store Trest(it) for convenience
     &  ,GRIDVAL_C(MXCBIN_AVWARP)  ! store color for AVWARP table
     &  ,Lrange_SNSED(2), LBINSIZE_SNSED
     &  ,Trange_SNSED(2), TBINSIZE_SNSED
     &  ,FLUX_SNSED(MXLAMBIN_SNSED*MXTBIN_KCOR)

      REAL*4  
     &   AVWARP_TABLE1D(MXTABLE1D_AVWARP)
     &  ,LCMAG_TABLE1D(MXTABLE1D_LCMAG)
     &  ,MWXT_TABLE1D(MXTABLE1D_MWXT)  ! MilkyWay extinction table

      INTEGER   
     &   HIDMAG(MXAVBIN_KCOR,MXFILT_ALL)
     &  ,HIDKCOR(MXFILT_ALL,MXFILT_ALL)

      LOGICAL 
     &   USE_AVWARPTABLE
     &  ,LRDZPOFF
     &  ,RDKCOR_STANDALONE
     &  ,EXIST_KCOR(MXFILT_ALL,MXFILT_ALL)
      
      CHARACTER RESTKCOR_FILTERS*20    ! rest-frame filters from KCOR file

      REAL RVMW_RDKCOR ! RV used for MW table extension
      INTEGER OPT_MWCOLORLAW_RDKCOR

      COMMON / KCORCOM / NCALL_RDKCOR, NKCOR_STORE, RDKCOR_STANDALONE
     &      ,NBIN_KCOR,   NBINTOT_KCOR
     &      ,NBIN_AVWARP, NBINTOT_AVWARP
     &      ,NBIN_LCMAG,  NBINTOT_LCMAG
     &      ,NBIN_MWXT,   NBINTOT_MWXT
     &      ,NZBIN_KCOR,    NTBIN_KCOR,    NAVBIN_KCOR
     &      ,Zrange_KCOR,   Trange_KCOR,   AVrange_KCOR
     &      ,ZBINSIZE_KCOR, TBINSIZE_KCOR, AVbinsize_KCOR
     &      ,CBINSIZE_AVWARP, IAV0, IZ0
     &      ,GRIDVAL_Z, GRIDVAL_T, GRIDVAL_AV, GRIDVAL_C
     &      ,HIDKCOR, HIDMAG
     &      ,Zrange_KCOR_LU, RESTKCOR_FILTERS
     &      ,USE_AVWARPTABLE, LRDZPOFF, NERR_AVWARP
     &      ,NLbin_SNSED, Lrange_SNSED, LBINSIZE_SNSED
     &      ,NTbin_SNSED, Trange_SNSED, TBINSIZE_SNSED
     &      ,FLUX_SNSED
     &      ,LCMAG_TABLE1D, MWXT_TABLE1D, AVWARP_TABLE1D
     &      ,EXIST_KCOR
     &      ,RVMW_RDKCOR, OPT_MWCOLORLAW_RDKCOR

c  July 2016 - define optional spectrograph info
      CHARACTER 
     &   SPECTROGRAPH_INSTRUMENT*80
     &  ,SPECTROGRAPH_FILTERLIST*(MXFILT_ALL)
      INTEGER 
     &   NFILTDEF_SPECTROGRAPH
     &  ,IFILTDEF_SPECTROGRAPH(MXFILT_ALL)

      COMMON / SPECTROGRAPH_COM /
     &   SPECTROGRAPH_INSTRUMENT, SPECTROGRAPH_FILTERLIST
     &  ,NFILTDEF_SPECTROGRAPH,   IFILTDEF_SPECTROGRAPH

c define temporary 'XXX_RDKCOR' arrays that are used only
c for reading and parsing.

      CHARACTER 
     &   PRIMARY_NAME_RDKCOR(10)*40          ! e.g, AB, BD17 ..
     &  ,FILTER_NAME_RDKCOR(MXFILT_ALL)*40   ! e.g, SDSS-g, Bessell90-V
     &  ,KCORINFO_STRING_RDKCOR(MXKCOR)*60   ! Kcor K_xy obsfilt restfilt
     
      INTEGER
     &   IVER_RDKCOR
     &  ,NPRIM_RDKCOR, NKCOR_RDKCOR
     &  ,INDX_PRIMARY_RDKCOR(MXFILT_ALL)
     &  ,NFILTDEF_RDKCOR               ! Number of all filters
     &  ,IFILTDEF_RDKCOR(MXFILT_ALL)   ! vs. ifilt_rdkcor
     &  ,NFILTOBS_RDKCOR               ! number of obs filters
     &  ,IFILTOBS_RDKCOR(MXKCOR)       ! vs. ikcor
     &  ,IFILT2_RDKCOR(2,MXKCOR)       ! 1=rest:2=obs, 1:NKCOR_STORE
     &  ,MASKFILT_RDKCOR(MXFILT_ALL)   ! bit0,1 -> rest,obs
     &  ,NFILT_DUPLICATE_RDKCOR        ! keep count of duplicate filters
     &  ,IKCOR_RDKCOR(MXKCOR)          ! ikcor vs. istore           
     &  ,IPRIM_REF_RDKCOR              ! index for primary  ref.
     &  ,NERR_PRIM_RDKCOR              ! number of invalude PRIMARY errors
     &  ,IPRIM_FIRST2_RDKCOR(2)        ! for error message

      REAL 
     &   MAG_PRIMARY_RDKCOR(MXFILT_ALL)    ! native mags
     &  ,ZPOFF_PRIMARY_RDKCOR(MXFILT_ALL)  ! mag(native) - mag(synth)
     &  ,ZPOFF_SNPHOT_RDKCOR(MXFILT_ALL)   ! apply to data (from ZPOFF.DAT)

      LOGICAL 
     &   ISFITS_RDKCOR
     &  ,LVERBOSE_RDKCOR
     &  ,ISLAMSHIFT_RDKCOR(0:MXFILT_ALL)

      REAL      NULLF_RDKCOR
      INTEGER   NULLI_RDKCOR
      CHARACTER NULLS_RDKCOR*20
      LOGICAL   ANYF_RDKCOR

      COMMON / RDKCORCOM / 
     &   IVER_RDKCOR, ISFITS_RDKCOR,LVERBOSE_RDKCOR,ISLAMSHIFT_RDKCOR
     &  ,NKCOR_RDKCOR
     &  ,NPRIM_RDKCOR, INDX_PRIMARY_RDKCOR, PRIMARY_NAME_RDKCOR
     &  ,FILTER_NAME_RDKCOR, KCORINFO_STRING_RDKCOR
     &  ,IFILTDEF_RDKCOR,  NFILTDEF_RDKCOR
     &  ,IFILTOBS_RDKCOR,  NFILTOBS_RDKCOR
     &  ,IFILT2_RDKCOR
     &  ,NFILT_DUPLICATE_RDKCOR, IKCOR_RDKCOR, MASKFILT_RDKCOR
     &  ,IPRIM_REF_RDKCOR, NERR_PRIM_RDKCOR, IPRIM_FIRST2_RDKCOR
c
     &  ,MAG_PRIMARY_RDKCOR
     &  ,ZPOFF_PRIMARY_RDKCOR
     &  ,ZPOFF_SNPHOT_RDKCOR
c
     &  ,NULLF_RDKCOR,NULLI_RDKCOR,NULLS_RDKCOR,ANYF_RDKCOR

+KEEP,KTABLECM,IF=R4KCOR.
      REAL*4  R4KCORTABLE1D(MXTABLE1D_KCOR)
      COMMON / R4KCORCOM / R4KCORTABLE1D
+SELF.

+KEEP,KTABLECM,IF=I2KCOR.
      INTEGER*2  I2KCORTABLE1D(MXTABLE1D_KCOR)
      COMMON / I2KCORCOM / I2KCORTABLE1D
+SELF.


+KEEP,SNHOSTCOM.

c Host galaxy parameters.
c Dec 17, 2012 - add SNHOST_MAGOBS


c logical flags for CWNT
      LOGICAL 
     &   EXIST_SNHOST_ANGSEP
     &  ,EXIST_SNHOST_DDLR
     &  ,EXIST_SNHOST_CONFUSION
     &  ,EXIST_SNHOST_ZPHOT
     &  ,EXIST_SNHOST_LOGMASS
     &  ,EXIST_SNHOST_sSFR
     &  ,EXIST_SNHOST_MAGOBS
     &  ,EXIST_SNHOST_SB

      INTEGER*8  SNHOST_OBJID(MXSNHOST)    ! int id
      REAL*8    DSNHOST_OBJID(MXSNHOST)   ! for tables only

      REAL
     &   SNHOST_ANGSEP(MXSNHOST)      ! SN-host sep, arcsec
     &  ,SNHOST_DDLR(MXSNHOST)        ! SNSEP/DLR
     &  ,SNHOST_CONFUSION             ! HC analog from Gupta 2016
     &  ,SNHOST_ZPHOT(MXSNHOST), SNHOST_ZPHOT_ERR(MXSNHOST)
     &  ,SNHOST_ZSPEC(MXSNHOST), SNHOST_ZSPEC_ERR(MXSNHOST)
     &  ,SNHOST_LOGMASS(MXSNHOST)
     &  ,SNHOST_LOGMASS_ERR(MXSNHOST)
     &  ,SNHOST_sSFR(MXSNHOST)
     &  ,SNHOST_sSFR_ERR(MXSNHOST)
     &  ,SNHOST_SBFLUXCAL(MXFILT_ALL)  ! surface brightness FLUXCAL /asec^2
     &  ,SNHOST_MAGOBS(MXFILT_ALL,(MXSNHOST))       ! observer-frame mags
     &  ,SNHOST_MAGOBS_ERR(MXFILT_ALL,(MXSNHOST))   ! error on above

      REAL*8 
     &    SNHOST8_RA(MXSNHOST)
     &   ,SNHOST8_DEC(MXSNHOST)

c quantites which do not depend on which host
      INTEGER*4 
     &    SNHOST_NMATCH   ! number of host matches, e.g., d_DLR<4
     &   ,SNHOST_NMATCH2  ! number of host matches, e.g., d_DLR<7

      REAL
     &   SNHOST_SBFLUXCAL_ERR(MXFILT_ALL)
     &  ,SNHOST_SBMAG(MXFILT_ALL)        ! surface brightness mag/asec^2

      COMMON / SNHOSTCOM / 
     &   EXIST_SNHOST_ANGSEP, EXIST_SNHOST_DDLR, EXIST_SNHOST_CONFUSION
     &  ,EXIST_SNHOST_ZPHOT,  EXIST_SNHOST_LOGMASS, EXIST_SNHOST_sSFR
     &  ,EXIST_SNHOST_MAGOBS, EXIST_SNHOST_SB
c
     &  ,SNHOST_NMATCH, SNHOST_NMATCH2
     &  ,SNHOST_ANGSEP, SNHOST_DDLR, SNHOST_CONFUSION
     &  ,SNHOST_ZPHOT,   SNHOST_ZPHOT_ERR 
     &  ,SNHOST_ZSPEC,   SNHOST_ZSPEC_ERR 
     &  ,SNHOST_LOGMASS, SNHOST_LOGMASS_ERR
     &  ,SNHOST_sSFR,    SNHOST_sSFR_ERR
     &  ,SNHOST_SBFLUXCAL, SNHOST_SBFLUXCAL_ERR, SNHOST_SBMAG
     &  ,SNHOST_MAGOBS, SNHOST_MAGOBS_ERR

      COMMON / SNHOSTCOM8 / 
     &   SNHOST_OBJID, DSNHOST_OBJID, SNHOST8_RA, SNHOST8_DEC

+KEEP,SIMLIBCOM.

c Feb 2017: common block for writing SIMLIB file to SIMLIB_OUT

      INTEGER MXLIST_SKY
      PARAMETER ( MXLIST_SKY = 20)
      INTEGER  NLIST_SKY 
      REAL*8   SKYLAM_LIST(MXLIST_SKY), SKYMAG_LIST(MXLIST_SKY)
      REAL*8   PSF_FWHM_GUESS, PIXSIZE_GUESS, ADD_SKYSIG_PIX
   
      LOGICAL ISGROUND  ! T=> ground based survey
      REAL    SIMLIB_ZPERR(MXFILT_ALL)

      COMMON/SIMLIBCOM4/ NLIST_SKY, ISGROUND, SIMLIB_ZPERR
      COMMON/SIMLIBCOM8/ 
     &   SKYLAM_LIST, SKYMAG_LIST
     &  ,PSF_FWHM_GUESS, PIXSIZE_GUESS, ADD_SKYSIG_PIX


c --- hard-wire ground based array of SKYMAG vs. lambda
      INTEGER  NLIST_SKY_GROUND
      PARAMETER ( NLIST_SKY_GROUND = 7 )
      REAL*8 SKYLAM_GROUND_LIST(NLIST_SKY_GROUND)
      REAL*8 SKYMAG_GROUND_LIST(NLIST_SKY_GROUND)
      
c ugrizY mag/asec^2 are from LSST DEEP-drill cadence; 
c v is made up to extend bluer.
      DATA SKYLAM_GROUND_LIST / 
     &              2700.0, 3714.0, 4790.0, 6220.0,  ! v,u,g,r
     &              7544.0, 8679.0, 10095   /        ! i,z,Y
      DATA SKYMAG_GROUND_LIST / 
     &            23.8,   22.7,   21.0,   20.4,    ! v,u,g,r 
     &            19.4,   18.1,   17.9  /          ! i,z,Y

c --- hard-write space based array pf SKYMAG vs. lambda

      INTEGER  NLIST_SKY_SPACE
      PARAMETER ( NLIST_SKY_SPACE = 9 )
      REAL*8 SKYLAM_SPACE_LIST(NLIST_SKY_SPACE)
      REAL*8 SKYMAG_SPACE_LIST(NLIST_SKY_SPACE)
      
c from WFIRST sims
      DATA SKYLAM_SPACE_LIST / 
     &        1000.0,  4330.0,  6258.0,  8052.0,          ! x,B,R,I
     &        8745.0, 10653.0, 12976.0, 15848.0, 20000. / ! Z,Y,J,H,FUDGE
      DATA SKYMAG_SPACE_LIST / 
     &        23.5,    23.0,     22.3,   22.5,
     &        22.7,    22.6,     22.6,   22.7, 22.6  /

+KEEP,OVRIDECOM.

c Nov 2016: define which variables can be over-written
c           in user-input HEADER_OVERRIDE_FILE

c define hard-wired list of valid over-rides
      CHARACTER VARLIST_ALL_HEADER_OVERRIDE*400
      PARAMETER ( VARLIST_ALL_HEADER_OVERRIDE = 
     &   'HOSTGAL_OBJID,HOSTGAL_LOGMASS,HOSTGAL_LOGMASS_ERR,' // 
     &   'HOSTGAL_sSFR,HOSTGAL_sSFR_ERR,HOSTGAL_DDLR,' // 
     &   'HOSTGAL_PHOTOZ,HOSTGAL_PHOTOZ_ERR,' // 
     &   'VPEC,VPEC_ERR,REDSHIFT_FINAL,REDSHIFT_FINAL_ERR,' //
     &   'SIM_SALT2x1,SIM_SALT2c,SIM_x1,SIM_c,'      //
     &   'PEAKMJD,PKMJDINI,PEAKMJDINI,' //
     &   'MWEBV,MWEBV_ERR '      )
      
      INTEGER MXVAR_HEADER_OVERRIDE
      PARAMETER ( MXVAR_HEADER_OVERRIDE = 10 )

      INTEGER NVAR_HEADER_OVERRIDE  ! also a flag to use this option
      CHARACTER VARLIST_HEADER_OVERRIDE(MXVAR_HEADER_OVERRIDE)*40
      COMMON / OVRIDECOM / 
     &     NVAR_HEADER_OVERRIDE, VARLIST_HEADER_OVERRIDE

+KEEP,SNCUTS.

c Define cut-window for each variables
c and cut-mask for each epoch.
c User must fill cutwin_XXX arrays in main routine.

      INTEGER 
     &   CUTBIT_CID, CUTBIT_SNTYPE
     &  ,CUTBIT_REDSHIFT, CUTBIT_REDSHIFT_ERR
     &  ,CUTBIT_RA,  CUTBIT_DEC
     &  ,CUTBIT_HOSTSEP
     &  ,CUTBIT_Trestmin, CUTBIT_Trestmax, CUTBIT_TrestRange
     &  ,CUTBIT_TREST2
     &  ,CUTBIT_Tgapmax,  CUTBIT_T0gapmax
     &  ,CUTBIT_Tobsmin,  CUTBIT_Tobsmax
     &  ,CUTBIT_SEARCH           ! sim only
     &  ,CUTBIT_PEAKMJD
     &  ,CUTBIT_NMJD_INCLUDE    ! Aug 11 2015
     &  ,CUTBIT_NEPOCH
     &  ,CUTBIT_SNRMAX         ! global SNRMAX cut; any filter(s)
     &  ,CUTBIT_SNRMAX2        ! 2nd global SNRMAX cut; any filter(s)
     &  ,CUTBIT_NFIELD         ! cut on number of fields used by SN
     &  ,CUTBIT_MWEBV          ! cut on Galactic extinct (May 8 2012)
     &  ,CUTBIT_NSEASON_ACTIVE ! Nseason with activity
     &  ,CUTBIT_REQEP          ! required epochs (to select short events)
     &  ,CUTBIT_PRIVATE        ! all private-var cuts together (Nov 3 2014)
     &  ,CUTBIT_SIMVAR         ! SIMVAR cuts
     &  ,CUTBIT_USRCUTS        ! user cuts from private code (Aug 2015)
     &  ,CUTBIT_OFFSET_SBFLUX  ! host surface brightness
     &  ,CUTBIT_OFFSET_SNRMAX  ! SNRMAX cuts in each filter     
     &  ,CUTBIT_MJD_MARKER     ! things above do NOT depend on epoch
     &  ,CUTBIT_PSF,  CUTBIT_ZP
     &  ,CUTBIT_PHOTPROB
     &  ,CUTBIT_TREST, CUTBIT_TOBS, CUTBIT_MJD
     &  ,CUTBIT_ERRTEST          ! epoch cut on ERRCALC/ERRTRUE
     &  ,CUTBIT_NFILT_SNRMAX
     &  ,CUTBIT_NFILT_SNRMAX2
     &  ,CUTBIT_NFILT_TRESTMIN
     &  ,CUTBIT_NFILT_TRESTMAX
     &  ,CUTBIT_NFILT_TREST2
     &  ,CUTBIT_OFFSET
     &  ,NCUTBIT
     &  ,NCUTBIT_SNLC

      PARAMETER (
     &   CUTBIT_CID            = 1
     &  ,CUTBIT_SNTYPE         = 2
     &  ,CUTBIT_REDSHIFT       = 3
     &  ,CUTBIT_REDSHIFT_ERR   = 4
     &  ,CUTBIT_RA             = 5
     &  ,CUTBIT_DEC            = 6
     &  ,CUTBIT_HOSTSEP        = 7
     &  ,CUTBIT_TrestMIN       = 8
     &  ,CUTBIT_TrestMAX       = 9
     &  ,CUTBIT_TrestRange     = 10  ! Dec 2017 (TrestMax-TrestMin)
     &  ,CUTBIT_Trest2         = 11  ! Oct 2012
     &  ,CUTBIT_Tgapmax        = 12
     &  ,CUTBIT_T0gapMAX       = 13
     &  ,CUTBIT_TobsMIN        = 14 
     &  ,CUTBIT_TobsMAX        = 15
     &  ,CUTBIT_PEAKMJD        = 16
     &  ,CUTBIT_NMJD_INCLUDE   = 17
     &  ,CUTBIT_NEPOCH         = 18  ! total # of measurements
     &  ,CUTBIT_SEARCH         = 19  ! found by search (SIM only)
     &  ,CUTBIT_NFILT_SNRMAX   = 20
     &  ,CUTBIT_NFILT_SNRMAX2  = 21
     &  ,CUTBIT_NFILT_TRESTMIN = 22
     &  ,CUTBIT_NFILT_TRESTMAX = 23
     &  ,CUTBIT_NFILT_TREST2   = 24
     &  ,CUTBIT_SNRMAX         = 25
     &  ,CUTBIT_SNRMAX2        = 26
     &  ,CUTBIT_NFIELD         = 27
     &  ,CUTBIT_MWEBV          = 28  ! May 2012
     &  ,CUTBIT_NSEASON_ACTIVE = 29  ! May 2019
     &  ,CUTBIT_REQEP          = 30  ! required epochs (9/17/2017)
     &  ,CUTBIT_PRIVATE        = 31  ! all private-var cuts
     &  ,CUTBIT_SIMVAR        = 32  ! 
     &  ,CUTBIT_USRCUTS        = 33  ! PASS_USRCUTS=T
     &  ,CUTBIT_OFFSET_SBFLUX  = 34  ! Mar 2012
     &  ,CUTBIT_OFFSET_SNRMAX  = 34 + MXFILT_SNRMAX
     &  ,CUTBIT_MJD_MARKER     = CUTBIT_OFFSET_SNRMAX + MXFILT_SNRMAX
     &  ,NCUTBIT_SNLC          = CUTBIT_MJD_MARKER
c SN-dependent cuts above
c MJD-dependent cuts below
     &  ,CUTBIT_PSF          = CUTBIT_MJD_MARKER + 1  ! PSF cut
     &  ,CUTBIT_ZP           = CUTBIT_MJD_MARKER + 2  ! ZP  cut (Feb 2018)
     &  ,CUTBIT_PHOTPROB     = CUTBIT_MJD_MARKER + 3
cc xxx mark delete     &  ,CUTBIT_NBAND_THRESH = CUTBIT_MJD_MARKER + 4
     &  ,CUTBIT_Trest        = CUTBIT_MJD_MARKER + 4
     &  ,CUTBIT_Tobs         = CUTBIT_MJD_MARKER + 5
     &  ,CUTBIT_MJD          = CUTBIT_MJD_MARKER + 6  
     &  ,CUTBIT_ERRTEST      = CUTBIT_MJD_MARKER + 7
cc xxx mark delete     &  ,CUTBIT_IDTEL        = CUTBIT_MJD_MARKER + 8
c
     &  ,CUTBIT_OFFSET       = CUTBIT_ERRTEST
     &  ,NCUTBIT             = CUTBIT_OFFSET 
     &      )

c Define cut-masks with 64-BIT integers

      INTEGER*8
     &   CUTMASK8_SN             ! cutmask for each SN
     &  ,CUTMASK8_MJD(MXEPOCH)   ! cutmask vs. MJD, isn
     &  ,CUTMASK8_SN_ALL         ! all bits for SN cuts
     &  ,CUTMASK8_MJD_ALL        ! all bits for MJD cuts

      BYTE MJDMASK(MXEPOCH)  ! logical for each epoch,SN

      LOGICAL
     &   LSNCUTS       ! T=> passes cuts 1 to CUTBIT_MJD_MARKER
     &  ,PASS_USRCUTS  ! T=> user cuts with private code (Oct 2014)
     &  ,PASS_PRIVCUTS ! T=> pass cuts on private var in data header
     &  ,PASS_SIMCUTS  ! T=> pass cuts on SIMVAR
    
      INTEGER 
     &   NCCID_LIST      ! size of SNCCID_LIST
     &  ,NCID_LIST       ! size of SNCID_LIST
     &  ,NCCID_IGNORE    ! size of SNCCID_IGNORE
     &  ,NCID_IGNORE     ! size of NCID_IGNORE
     &  ,CUTFLAG_SNANA   ! bits 0,1 -> LSNCUTS,LSNFITOK=T (for ntuple)
     &  ,ERRFLAG_FIT     ! error flag from fit (0=OK)

c stuff for hbook
      CHARACTER CUTVAR_NAME(NCUTBIT)*28

c define namelist cuts

      INTEGER 
     &   SNTYPE_LIST(MXLISTNML)    ! (I) user list of types to select
     &  ,SNTYPE_IGNORE(MXLISTNML)  ! (I) types to ignore
     &  ,SNCID_LIST(MXLISTNML)     ! (I) user-list of integer CIDs
     &  ,MXEVT_PROCESS             ! (I) max number of events to process
     &  ,CCDNUM_LIST(MXLISTNML)    ! (I) user-list of CCDNUMs (Dec 2017)
     &  ,SIM_TEMPLATE_INDEX_LIST(MXLISTNML)
     &  ,SNCID_IGNORE(MXLISTNML)   ! (I) list of CIDs to ignore
     &  ,PHOTFLAG_MSKREJ(5)        ! (I) PHOTFLAG mask-bits to reject
     &                             !     1,2 => logical OR,AND
     &  ,IDTEL_LIST(MXLISTNML)     ! computed from SNTEL_LIST
     &  ,IDFIELD_LIST(MXLISTNML)   ! 
     &  ,NIDTEL_LIST               ! size of list
     &  ,NIDFIELD_LIST
     &  ,NSNTYPE_LIST           ! size of SNTYPE_LIST
     &  ,NCCDNUM_LIST           ! size of CCDNUM list
     &  ,NSIM_TEMPLATE_INDEX_LIST
     &  ,NSNTYPE_IGNORE
     &  ,NFILT_SNRMAX           ! number of CUTWIN_SNRMAX_FILT cuts
     &  ,IFILT_SNRMAX(MXFILT_SNRMAX) ! store filt index for SNRMAX cuts
     &  ,NFILT_HOST_SBFLUX      ! Nfilt to cut on HOST_SBFLUX
     &  ,IFILT_HOST_SBFLUX(MXFILT_SNRMAX)

      LOGICAL DOALL_SNTEL, DOALL_SNFIELD

      character 
     &    SNTEL_LIST(MXLISTNML)*20    ! (I) list of telescopes (or ALL)
     &   ,SNFIELD_LIST(MXLISTNML)*60  ! (I) list of fields to use (or 'ALL')
     &   ,SNCCID_LIST(MXLISTNML)*(MXCHAR_CCID)   ! (I) list of CIDs to process
     &   ,SNCCID_LIST_ALL(MXCCID_LIST)*(MXCHAR_CCID) ! combined list to process
     &   ,SNCCID_IGNORE(MXLISTNML)*(MXCHAR_CCID) ! (I) list of CIDs to ignore
     &   ,SNCID_IGNORE_FILE*(MXCHAR_FILENAME) ! (I) file with CIDs to ignore
     &   ,SNCCID_IGNORE_ALL(MXIGNORE_LIST)*(MXCHAR_CCID)

      REAL
     &   snlc_cutvar(NCUTBIT_SNLC)
     &  ,snep_cutvar(CUTBIT_MJD_MARKER:NCUTBIT,MXEPOCH)
     &  ,cutwin_var(2,NCUTBIT)   
     &  ,cutwin_cid(2)           ! candidate id
     &  ,cutwin_redshift(2)
     &  ,cutwin_redshift_err(2)
     &  ,cutwin_ra(2)
     &  ,cutwin_dec(2)
     &  ,cutwin_hostsep(2)      ! cut on host-SN sep, arcsec
     &  ,cutwin_sbflux_filt(2,MXFILT_SNRMAX)
     &  ,cutwin_Nepoch(2)       ! 
     &  ,cutwin_snrmax_filt(2,MXFILT_SNRMAX)   ! filled from SNCUT_SNRMAX
     &  ,cutwin_snrmax(2)       ! global SNRMAX cut
     &  ,cutwin_snrmax2(2)       ! 2nd global SNRMAX cut
     &  ,cutwin_nfield(2)        ! number of fields (usually 1)
     &  ,cutwin_mwebv(2)         ! Galactic extinction
     &  ,cutwin_nseason_active(2) 
     &  ,cutwin_cutflag_reqep(2)       ! for internal use only
     &  ,cutwin_cutflag_private(2)     ! for internal use only
     &  ,cutwin_cutflag_simvar(2)      ! for internal use only
     &  ,cutwin_cutflag_usrcuts(2)     ! for internal use only
     &  ,cutwin_nfilt_snrmax(2)  ! Nfilt passing global SNRMAX cut
     &  ,cutwin_nfilt_snrmax2(2) ! Nfilt passing 2nd-best SNRMAX
     &  ,cutwin_nfilt_trestmin(2)! Nfilt passing Trestmin cut
     &  ,cutwin_nfilt_trestmax(2)! Nfilt passing Trestmax cut
     &  ,cutwin_nfilt_trest2(2)  ! Nfilt passinng Trest2 cut
     &  ,cutwin_nband_thresh(2)  ! number of ugriz bands above $band_THRESH
     &  ,cutwin_Trestmin(2)      ! window for earliest epoch, rest frame days
     &  ,cutwin_Trestmax(2)      ! window for latest epoch, rest frame day
     &  ,cutwin_TrestRange(2)    ! window on Trestmax - Trestmin
     &  ,cutwin_Trest2(2)        ! window for CUTWIN_NFILT_TREST2
     &  ,cutwin_Tgapmax(2)       ! max Trest-gap within cutwin_TREST(2)
     &  ,cutwin_T0gapmax(2)      ! max Trest-gap near peak 
     &  ,cutwin_Tobsmin(2)  
     &  ,cutwin_Tobsmax(2) 
     &  ,cutwin_peakmjd(2)       ! cut on search peakMJD (for rates)
c  
c  Below are Epoch-dependent cuts

     &  ,cutwin_psf(2)           ! PSF cut, FWHM, ARCSEC
     &  ,cutwin_zp(2)            ! ZEROPT cut, ADU or NPE
     &  ,cutwin_zpADU(2)         ! ZEROPT cut, ADU
     &  ,cutwin_zpNPE(2)         ! ZEROPT cut, NPE
     &  ,cutwin_photprob(2)
     &  ,cutwin_errtest(2)       ! cut on ERRCALC/ERRTRUE
     &  ,cutwin_Trest(2)         ! window for all epochs, rest frame days
     &  ,cutwin_Tobs(2)          ! window for all epochs, obs-frame days
     &  ,cutwin_MJD(2)           ! MJD window
     &  ,CUTWIN_MJD_EXCLUDE(2)          ! MJD window to exclude
     &  ,CUTWIN_MJD_INCLUDE(2)          ! require  MJD in this window
     &  ,CUTWIN_NMJD_INCLUDE(2)         ! for internal use only
     &  ,cutwin_SEARCHEFF_MASK(2) ! for SIM only
     &  ,cutwin_snrmin_filt(2,MXFILT_OBS) ! filled from EPCUT_SNRMIN
     &  ,cutwin_restlam(2)                ! cut on <LAMREST>, no cutBit
     &  ,cutwin_lamrest(2)                ! same as above
     &  ,cutwin_lamobs(2)                 ! cut on <LAMOBS>, no cutBit
c
c define character strings to specify cuts and filters
c 'SNCUT' specifies cut on each SN
c 'EPCUT' specifies selection cut on each epoch

      CHARACTER*(MXCHAR_CUTNAME)
     &  SNCUT_SNRMAX  ! max SNR required in each passband
                      ! example: 'u 10.  g 5.0  r 5.0  i 5.0  z -10.'
c
     & ,EPCUT_SNRMIN  ! min SNR accepted for each epoch/filter
                      ! example: 'u 20000.  g -4.  r -4.  i -4.  z 20000.'
c
     & ,EPCUT_SKYSIG  ! max SKY noise accepted each epoch/filter
                      ! example: 'u 20.  g 50.  r 80.  i 120.  z 200.'
c
     & ,EPCUT_PSFSIG  ! max PSF (arcsec) accepted each epoch/filter
                      ! example: 'u 1.8  g 1.5  r 1.6  i 1.8  z 2.0'
c
     & ,SNCUT_HOST_SBFLUX ! max allows surface brightness,
                          ! example 'r 1000.' -> SBFLUX < 1000

c ----------
c systematic tests for calibration:
c 'U 01 B -0.01' => shift U & B mags of primary

     &  ,MAGOBS_SHIFT_PRIMARY  ! shift primary mags  (for syst test)
     &  ,MAGOBS_SHIFT_ZP       ! shift zero points (e.g.,AB off for SDSS)
     &  ,MAGREST_SHIFT_PRIMARY ! idem for rest-frame mags 
     &  ,MAGREST_SHIFT_ZP      ! idem for rest-frame filters
     &  ,FILTER_LAMSHIFT       ! e.g., 'r -2.4  i 6.2'  ! in Angstroms
c -------
c Fluxcal fudges for systematic tests (fudge photometry offsets and errors)
c Note that error is added in quadrature; ERROR<0 is subtracted in quadrature.
     &  ,FUDGE_FLUXCAL_OFFSET
     &  ,FUDGE_FLUXCAL_ERROR   ! fudge net FLUXCAL error in each band
     &  ,FUDGE_FLUXCAL_ERRPIX  ! per-pixel error --> FLUXCAL error propto PSF
     &  ,FUDGE_MAG_ERROR       ! Oct 2013: add stat error per band
     &  ,FUDGE_MAG_COVERR      ! Feb 2015: add covariant error per band

      REAL
     &   MAGOBS_SHIFT_PRIMARY_FILT(MXFILT_ALL) ! shift mag of primary ref
     &  ,MAGOBS_SHIFT_ZP_USER(MXFILT_ALL)      ! user ZP shift
     &  ,MAGOBS_SHIFT_ZP_FILT(MXFILT_ALL)      ! user ZP shift + system ZP
     &  ,FLUXSCALE_ZP_FILT(MXFILT_ALL)         ! corresponding flux scale
     &  ,MAGREST_SHIFT_PRIMARY_FILT(MXFILT_ALL) ! shift mag of primary ref
     &  ,MAGREST_SHIFT_ZP_USER(MXFILT_ALL)      ! shift zero points
     &  ,MAGREST_SHIFT_ZP_FILT(MXFILT_ALL)      ! shift zero points
     &  ,FILTER_LAMSHIFT_FILT(MXFILT_ALL)       ! shift filter trans
c
     &  ,MAGOBS_SHIFT_PRIMARY_PARAMS(3)       ! poly-fun of lambda;
     &  ,MAGOBS_SHIFT_ZP_PARAMS(3)            ! A0 + A1*LAM + A2*LAM^2
     &  ,FUDGE_FLUXCAL_OFFSET_FILT(MXFILT_ALL)
     &  ,FUDGE_FLUXCAL_ERROR_FILT(MXFILT_ALL)
     &  ,FUDGE_FLUXCAL_ERRPIX_FILT(MXFILT_ALL)
     &  ,FUDGE_MAG_ERROR_FILT(MXFILT_ALL)
     &  ,FUDGE_MAG_COVERR_FILT(MXFILT_ALL)
     &  ,MWEBV_SCALE        ! scale MW extinc for syst test
     &  ,MWEBV_SHIFT        ! shift MW extinc

      REAL 
     &   RV_MWCOLORLAW   ! (I) RV for Galactic extinction 

      INTEGER 
     &   OPT_MWCOLORLAW    ! (I) MW color law opt (89, 94, 99 ...)
     &  ,OPT_MWEBV         ! (I) option to modify SFD maps

      LOGICAL 
     &   USE_MWCOR          ! (I) T=> correct data flux for MW extinc;
                            !     F=> leave data, correct fit model for MW.
     &  ,DOBUG_LAMRANGE     ! (I) implement old lambda-range bug

      REAL 
     &   REDSHIFT_FINAL_SHIFT    ! artificial shift
     &  ,FLUXERRCALC_ZPTERR 

      COMMON / SNCUTCOM / CUTMASK8_SN, CUTMASK8_MJD
     &   ,CUTMASK8_SN_ALL, CUTMASK8_MJD_ALL
     &   ,cutwin_var, cutvar_name
     &   ,snlc_cutvar, snep_cutvar
     &   ,cutwin_snrmin_filt, LSNCUTS
     &   ,PASS_USRCUTS, PASS_PRIVCUTS, PASS_SIMCUTS
     &   ,CUTFLAG_SNANA , ERRFLAG_FIT 
     &   ,NCCID_LIST, NCCID_IGNORE, NCID_LIST, NCID_IGNORE
     &   ,SNTYPE_LIST, SNCID_LIST, SNCCID_LIST, SNCCID_LIST_ALL
     &   ,SNCCID_IGNORE,SNCID_IGNORE_FILE,SNCID_IGNORE,SNCCID_IGNORE_ALL
     &   ,MXEVT_PROCESS
     &   ,SNTYPE_IGNORE, CCDNUM_LIST, SIM_TEMPLATE_INDEX_LIST
     &   ,SNTEL_LIST,   IDTEL_LIST,   NIDTEL_LIST,   DOALL_SNTEL
     &   ,SNFIELD_LIST, IDFIELD_LIST, NIDFIELD_LIST, DOALL_SNFIELD
     &   ,NSNTYPE_LIST, NCCDNUM_LIST, NSIM_TEMPLATE_INDEX_LIST
     &   ,NSNTYPE_IGNORE, NFILT_SNRMAX, IFILT_SNRMAX
     &   ,NFILT_HOST_SBFLUX, IFILT_HOST_SBFLUX
     &   ,PHOTFLAG_MSKREJ
     &   ,USE_MWCOR, DOBUG_LAMRANGE
     &   ,MAGOBS_SHIFT_PRIMARY, MAGOBS_SHIFT_PRIMARY_FILT
     &   ,MAGOBS_SHIFT_ZP, MAGOBS_SHIFT_ZP_FILT, FLUXSCALE_ZP_FILT
     &   ,MAGOBS_SHIFT_ZP_USER
     &   ,MAGOBS_SHIFT_PRIMARY_PARAMS, MAGOBS_SHIFT_ZP_PARAMS
     &   ,MAGREST_SHIFT_PRIMARY, MAGREST_SHIFT_PRIMARY_FILT
     &   ,MAGREST_SHIFT_ZP, MAGREST_SHIFT_ZP_FILT
     &   ,MAGREST_SHIFT_ZP_USER
     &   ,FILTER_LAMSHIFT, FILTER_LAMSHIFT_FILT
     &   ,FUDGE_FLUXCAL_OFFSET,FUDGE_FLUXCAL_ERROR,FUDGE_FLUXCAL_ERRPIX
     &   ,FUDGE_FLUXCAL_OFFSET_FILT
     &   ,FUDGE_FLUXCAL_ERROR_FILT, FUDGE_FLUXCAL_ERRPIX_FILT
     &   ,FUDGE_MAG_ERROR, FUDGE_MAG_ERROR_FILT
     &   ,FUDGE_MAG_COVERR, FUDGE_MAG_COVERR_FILT
     &   ,RV_MWCOLORLAW, OPT_MWCOLORLAW, OPT_MWEBV
     &   ,MWEBV_SCALE, MWEBV_SHIFT
     &   ,REDSHIFT_FINAL_SHIFT, FLUXERRCALC_ZPTERR 
     &   ,CUTWIN_MJD_EXCLUDE, CUTWIN_MJD_INCLUDE

      COMMON / BYTEMASKCOM / MJDMASK
ccc mark delete      COMMON / CIDMASKCOM / MJDMASK,CIDMASK

      EQUIVALENCE 
     &    ( cutwin_var(1,cutbit_cid),       cutwin_cid )
     &   ,( cutwin_var(1,cutbit_redshift),  cutwin_redshift )
     &   ,( cutwin_var(1,cutbit_redshift_err),cutwin_redshift_err )
     &   ,( cutwin_var(1,cutbit_ra),        cutwin_ra )
     &   ,( cutwin_var(1,cutbit_dec),       cutwin_dec )
     &   ,( cutwin_var(1,cutbit_hostsep),   cutwin_hostsep )
     &   ,( cutwin_var(1,cutbit_Nepoch),    cutwin_Nepoch )
     &   ,( cutwin_var(1,cutbit_psf),       cutwin_psf )
     &   ,( cutwin_var(1,cutbit_zp),        cutwin_zp  )
     &   ,( cutwin_var(1,cutbit_photprob),  cutwin_photprob  )
     &   ,( cutwin_var(1,cutbit_errtest),   cutwin_errtest   )
     &   ,( cutwin_var(1,cutbit_Nfilt_snrmax), cutwin_nfilt_snrmax )
     &   ,( cutwin_var(1,cutbit_Nfilt_snrmax2),cutwin_nfilt_snrmax2 )
     &   ,( cutwin_var(1,cutbit_Nfilt_trestmin),cutwin_nfilt_trestmin)
     &   ,( cutwin_var(1,cutbit_Nfilt_trestmax),cutwin_nfilt_trestmax)
     &   ,( cutwin_var(1,cutbit_Nfilt_trest2),  cutwin_nfilt_trest2)
     &   ,( cutwin_var(1,cutbit_Trestmin),  cutwin_Trestmin )
     &   ,( cutwin_var(1,cutbit_Trestmax),  cutwin_Trestmax )
     &   ,( cutwin_var(1,cutbit_TrestRange),cutwin_TrestRange )
     &   ,( cutwin_var(1,cutbit_Trest2),    cutwin_Trest2 )
     &   ,( cutwin_var(1,cutbit_Tgapmax),   cutwin_Tgapmax )
     &   ,( cutwin_var(1,cutbit_T0gapmax),  cutwin_T0gapmax )
     &   ,( cutwin_var(1,cutbit_Tobsmin),   cutwin_Tobsmin )
     &   ,( cutwin_var(1,cutbit_Tobsmax),   cutwin_Tobsmax )
     &   ,( cutwin_var(1,cutbit_Trest),     cutwin_Trest )
     &   ,( cutwin_var(1,cutbit_Tobs),      cutwin_Tobs )
     &   ,( cutwin_var(1,cutbit_MJD),       cutwin_MJD   )
     &   ,( cutwin_var(1,cutbit_peakmjd),   cutwin_peakmjd )
     &   ,( cutwin_var(1,cutbit_NMJD_INCLUDE),  cutwin_NMJD_INCLUDE )
     &   ,( cutwin_var(1,cutbit_search),        cutwin_searcheff_mask )
     &   ,( cutwin_var(1,cutbit_snrmax),        cutwin_snrmax  )
     &   ,( cutwin_var(1,cutbit_snrmax2),       cutwin_snrmax2  )
     &   ,( cutwin_var(1,cutbit_nfield),        cutwin_nfield  )
     &   ,( cutwin_var(1,cutbit_mwebv),         cutwin_mwebv  )
     &   ,( cutwin_var(1,cutbit_nseason_active),cutwin_nseason_active)
     &   ,( cutwin_var(1,cutbit_reqep),        cutwin_cutflag_reqep)
     &   ,( cutwin_var(1,cutbit_private),      cutwin_cutflag_private)
     &   ,( cutwin_var(1,cutbit_simvar),       cutwin_cutflag_simvar)
     &   ,( cutwin_var(1,cutbit_usrcuts),      cutwin_cutflag_usrcuts)
     &   ,( cutwin_var(1,cutbit_offset_sbflux+1), cutwin_sbflux_filt)
     &   ,( cutwin_var(1,cutbit_offset_snrmax+1), cutwin_snrmax_filt)
c
     &   ,( cutwin_restlam(1), cutwin_lamrest(1) )


+KEEP,SNLCINP.

c define general input to program: 
c SN flux version, hbook files, cut-windows, etc ...
c Dec 30 2012: add KCOR_FILE for fits-formatted tables (same name as in sim)

      CHARACTER*(MXCHAR_FILENAME)  ! user input files
     &   NMLFILE          ! name of input namelist file
     &  ,HFILE_OUT        ! output hbook filename
     &  ,ROOTFILE_OUT     ! output filename for root
     &  ,TEXTFILE_PREFIX  ! prefix for ascii tables
     &  ,SNTABLE_LIST     ! list of SNTABLEs to create
     &  ,SNTABLE_FILTER_REMAP ! remap filters in tables
     &  ,KCOR_FILE            ! fits-formatted KCOR tables
     &  ,EPOCH_IGNORE_FILE    ! file with epochs to ignor
     &  ,SNMJD_LIST_FILE      ! list of "CID MJD" to process
     &  ,SNMJD_OUT_FILE       ! MJD_LIST out file
     &  ,MNFIT_PKMJD_LOGFILE  ! separate log for PKMJD fits
cc     &  ,ZPOFF_FILE           ! AB (ZP) off for obs-frame mags
     &  ,USERTAGS_FILE        ! optional int user tag per SN
     &  ,VPEC_FILE            ! pec. velocity corrections
     &  ,HEADER_OVERRIDE_FILE ! header-var overrides
     &  ,SNCID_LIST_FILE      ! list of CID's to process
     &  ,SIMLIB_OUT           ! write simlib entry for each event
     &  ,SIMLIB_ZPERR_LIST    ! 'abc .01 def .02 ghi .005'
     &  ,NONLINEARITY_FILE    ! non-linearity map (Apr 2017)
c
     &  ,FUDGE_HOSTNOISE_FILE  ! legacy: inflate error vs.  hostSB (Mar 2015)
     &  ,FLUXERRMODEL_FILE     ! DATA ONLY: err-fudge maps
     &  ,SIM_FLUXERRMODEL_FILE ! idem, SIM only
     &  ,MAGCOR_FILE           ! DATA ONLY: mag-cor for each CID-MJD-band
     &  ,SIM_MAGCOR_FILE       ! idem, SIM only

      CHARACTER  ! versions
     &   VERSION_PHOTOMETRY(MXVERS)*(MXCHAR_VERSION)   ! SN versions to read
     &  ,VERSION_REPLACE*(MXCHAR_VERSION)  ! replace previous cmd-line VERSION
     &  ,VERSION_REFORMAT_FITS*(MXCHAR_VERSION)   ! output version for
                                                  ! for translating -> FITS

      CHARACTER ! paths
     &   PRIVATE_DATA_PATH*(MXCHAR_PATH)    ! private data subdir 
     &  ,FILTER_UPDATE_PATH*(MXCHAR_PATH)   ! SN-dependent filter response

      CHARACTER  ! misc
     &   LINE_ARGS(MXLINE_ARGS)*(MXCHAR_FILENAME)    ! command line args
     &  ,REFORMAT_KEYS*(MXCHAR_FILENAME)  ! global reformat info
     &  ,NONSURVEY_FILTERS*(MXFILT_ALL)   ! non-survey filters to add
     &  ,SNRMAX_FILTERS*(MXFILT_ALL)      ! list of filters for SNRMAX cuts
     &  ,FILTER_REPLACE*(MXFILT_ALL)      ! e.g., 'UGRIZ -> ugriz' 
     &  ,FILTLIST_LAMSHIFT*(MXFILT_ALL)   ! list of lam-shifted filters
     &  ,PRIVATE_CUTWIN_STRING(MXCUT_PRIVATE)*(MXCHAR_CUTNAME)
     &  ,PRIVATE_REDSHIFT_CMB*60          ! use PRIVATE variable for redshift
     &  ,SIMVAR_CUTWIN_STRING*(MXCHAR_CUTNAME) ! cuts on SIM_XXX
     &  ,EARLYLC_STRING*(MXCHAR_CUTNAME)  ! see manual
     &  ,REQUIRE_EPOCHS_STRING*100  ! e.g., 'riz 10 7 20' ! uses CUTWIN_SNRMAX
     &  ,DUMP_STRING*100             ! 'funName CID-list'

      INTEGER 
     &   NFIT_ITERATION       ! (I) number of fit iterations
     &  ,MINUIT_PRINT_LEVEL   ! -1 -> none
     &  ,INTERP_OPT           ! (I)  interp option (see INTERP_XXX params)
     &  ,NLINE_ARGS       
     &  ,OPT_REFORMAT_TEXT       ! T=> re-write SNDATA files in text format
     &  ,OPT_REFORMAT_TERSE      ! T=> legacy key for text format
     &  ,OPT_REFORMAT_FITS       ! T=> re-write  in FITSformat (data only)
     &  ,OPT_REFORMAT_SALT2      ! T=> re-write SNDATA files in SALT2 format
     &  ,OPTSIM_LCWIDTH          ! T=> option to compute LC width
     &  ,OPT_DEBUG               ! T=> for internal debug
     &  ,JOBSPLIT(2)             ! process (1)-range of (2)=TOTAL
     &  ,JOBSPLIT_EXTERNAL(2)    ! passed by split_and_fit for text format 
     &  ,MXLC_FIT                ! stop after this many fits passing all cuts
     &  ,PHOTFLAG_DETECT         ! used to count NOBS_DETECT and TLIVE_DETECT
     &  ,PHOTFLAG_TRIGGER        ! determine MJD(trigger) for survey
     &  ,APPLY_FLUXCOR_BUG       ! see calling sequence in SNRECON
     &  ,FLUXERRMODEL_OPTMASK
     &  ,OPT_SIMLIB_OUT          ! bit mask of SIMLIB_OUT options

      LOGICAL 
     &   LSIM_SEARCH_SPEC   ! (I) T => require simulated SPEC-tag
     &  ,LSIM_SEARCH_ZHOST  ! (I) T => require simulated zHOST
     &  ,LTEST_INTERP  ! (I) T => calls TEST_KCOR
     &  ,LTEST_KCOR    ! (I) T => calls TEST_INTERP
     &  ,LTEST_MAG     ! (I) T => test GET_MAGLC  and GET_MWXT
     &  ,LTEST_U3BAND  ! (I) T => require exactly 3 bands that include U
     &  ,USE_LINE_ARGS(MXLINE_ARGS)
     &  ,USE_SNHOST_ZPHOT    ! (I) T=> replace SNLC_REDSHIFT -> SNHOST_ZPHOT
c
     &  ,ABORT_ON_NOEPOCHS   ! T=> abort if there are no epochs to fit
     &  ,ABORT_ON_BADAVWARP  ! T=> abort if AVwarp cannot be determined
     &  ,ABORT_ON_BADZ       ! T=> abort on bad z in GET_KCOR8
     &  ,ABORT_ON_BADKCOR    ! T=> affects only the init stage (RDKCOR)
     &  ,ABORT_ON_BADSURVEY  ! T=> abort if SURVEY changes
     &  ,ABORT_ON_BADFILTER  ! T=> abort if fit band is not in SURVEY filters
     &  ,ABORT_ON_MARGPDF0   ! T=> abort if marginalized pdf=0 everywhere
     &  ,ABORT_ON_TRESTCUT   ! T=> abort if any Trest cut is set (for photoz)
     &  ,ABORT_ON_DUPLCID    ! T=> abort on duplicate CID
     &  ,ABORT_ON_DUPLMJD    ! T=> abort on repeat MJD+band (Jun 2017)
     &  ,ABORT_ON_NOPKMJD    ! T=> abort if no PKMJDINI (see OPT_SETPKMJD)
     &  ,ABORT_ON_BADHEADER  ! T=> abort if missing header info(HEADMASK_CHECK)
     &  ,USE_MINOS           ! T=> use MINOS instead of MINIMIZE
     &  ,LDMP_SNFAIL         ! T => dump reason for each SN failure
     &  ,LDMP_SNANA_VERSION  ! T => dump SNANA version and SNANA_DIR
     &  ,LDMP_AVWARP         ! dump GET_AVWARP8 (debug only)
     &  ,LDMP_KCORFUN        ! dump KCORFUN8 (debug only)
     &  ,USESIM_SNIA         ! default True -> process simulated SNIa
     &  ,USESIM_SNCC         ! default True -> process simulated SNCC
     &  ,USESIM_TRUEFLUX     ! SNLC_FLUXCAL -> SIM_FLUXCAL 
     &  ,RESTORE_DES3YR      ! restore code from DES3YR

c LC plot info

      INTEGER  
     &  MXLC_PLOT      ! (I) max number of plots to make with SNLCPAK
     & ,NCCID_PLOT     ! (I) size of SNCCID_PLOT array
      CHARACTER 
     &  SNCCID_PLOT(MXLISTNML)*(MXCHAR_CCID) ! (I) string-list of CCIDs to plot

      REAL 
     &  DTOBS_MODEL_PLOT  ! (I) binning (days) for overlaid best-fit model

c Oct 2014: variables to check for multi-season transient activity

      INTEGER  
     &   MULTISEASON_OPTMASK      ! option(s) for GET_MULTISEASON
      REAL
     &   MULTISEASON_TGAP              ! new season if time-gap > this
     &  ,MULTISEASON_NREJECT_OUTLIER   ! num outliers to reject per season
     &  ,MULTISEASON_CHI2RED_ACTIVE    ! min chi2red for active season

      REAL  
     &   SIM_PRESCALE        ! pre-scale applied only to SIM
     &  ,VPEC_ERR_OVERRIDE   ! override VPEC_ERR in data header (km/sec)

c variables to control estimate of PEAKMJD
      INTEGER
     &   OPT_SETPKMJD            ! bit-mask options  to determined PKMJD
      REAL
     &   SNRCUT_SETPKMJD         ! define SNR for Fmax in clump method
     &  ,MJDWIN_SETPKMJD         ! MJD window for Fmax in clump method

c define reference cosmological parameters (double precision!)
c Aug 7, 2009: each parameter has dimension 2 for value & error

      REAL*8
     &   H0_REF(2)    ! reference H0  (70 => 70 MPc^-1)
     &  ,OLAM_REF(2)  ! omega_matter
     &  ,OMAT_REF(2)  ! omega_lamgda
     &  ,ORAD_REF(2)  ! omega_rad
     &  ,W0_REF(2)    ! w = p/rho
     &  ,DWDA_REF(2)  ! dw/da [a = 1/(1+z)]

      INTEGER   NSIMVAR_CUTWIN
      REAL      SIMVAR_CUTWIN(2,MXCUT_PRIVATE)
      CHARACTER SIMVAR_CUTWIN_LIST(MXCUT_PRIVATE)*40      

      COMMON   / SNLCINP /  
     &      NLINE_ARGS, LINE_ARGS, USE_LINE_ARGS, nmlfile
     &    , VERSION_PHOTOMETRY, VERSION_REPLACE, VERSION_REFORMAT_FITS
     &    , JOBSPLIT, JOBSPLIT_EXTERNAL, SIM_PRESCALE, MXLC_FIT
     &    , PRIVATE_DATA_PATH, FILTER_UPDATE_PATH
     &    , NONSURVEY_FILTERS, SNRMAX_FILTERS, VPEC_ERR_OVERRIDE
     &    , FILTER_REPLACE, FILTLIST_LAMSHIFT
     &    , OPTSIM_LCWIDTH, OPT_REFORMAT_TERSE, OPT_REFORMAT_TEXT
     &    , OPT_REFORMAT_SALT2, REFORMAT_KEYS, OPT_REFORMAT_FITS
     &    , SNMJD_LIST_FILE, SNMJD_OUT_FILE, MNFIT_PKMJD_LOGFILE
     &    , EPOCH_IGNORE_FILE, SNCID_LIST_FILE, NONLINEARITY_FILE
     &    , SIMLIB_OUT, SIMLIB_ZPERR_LIST, OPT_SIMLIB_OUT
     &    , hfile_out, rootfile_out, textfile_prefix
     &    , SNTABLE_LIST, SNTABLE_FILTER_REMAP
     &    , KCOR_FILE, USERTAGS_FILE  ! ZPOFF_FILE, 
     &    , VPEC_FILE, HEADER_OVERRIDE_FILE
     &    , FLUXERRMODEL_FILE,SIM_FLUXERRMODEL_FILE,FLUXERRMODEL_OPTMASK
     &    , MAGCOR_FILE, SIM_MAGCOR_FILE,  FUDGE_HOSTNOISE_FILE
     &    , NFIT_ITERATION, MINUIT_PRINT_LEVEL, INTERP_OPT, USE_MINOS
     &    , OPT_SETPKMJD
     &    , SNRCUT_SETPKMJD, MJDWIN_SETPKMJD, OPT_DEBUG
     &    , LSIM_SEARCH_SPEC, LSIM_SEARCH_zHOST
     &    , LDMP_AVWARP, LDMP_KCORFUN, LDMP_SNFAIL, LDMP_SNANA_VERSION
     &    , LTEST_KCOR, LTEST_INTERP, LTEST_MAG, LTEST_U3BAND
     &    , USESIM_SNIA, USESIM_SNCC, USESIM_TRUEFLUX, USE_SNHOST_ZPHOT
     &    , RESTORE_DES3YR
     &    , ABORT_ON_NOEPOCHS, ABORT_ON_BADAVWARP, ABORT_ON_NOPKMJD
     &    , ABORT_ON_BADZ, ABORT_ON_BADKCOR, ABORT_ON_BADSURVEY
     &    , ABORT_ON_MARGPDF0, ABORT_ON_TRESTCUT
     &    , ABORT_ON_DUPLCID, ABORT_ON_DUPLMJD
     &    , ABORT_ON_BADHEADER, ABORT_ON_BADFILTER
     &    , SNCUT_SNRMAX, SNCUT_HOST_SBFLUX
     &    , EPCUT_SNRMIN, EPCUT_SKYSIG, EPCUT_PSFSIG
     &    , CUTWIN_LAMREST, CUTWIN_LAMOBS
     &    , PRIVATE_CUTWIN_STRING, PRIVATE_REDSHIFT_CMB
     &    , SIMVAR_CUTWIN_STRING
     &    , NSIMVAR_CUTWIN, SIMVAR_CUTWIN, SIMVAR_CUTWIN_LIST
     &    , EARLYLC_STRING, REQUIRE_EPOCHS_STRING, DUMP_STRING
     &    , MXLC_PLOT, NCCID_PLOT, SNCCID_PLOT, DTOBS_MODEL_PLOT
     &    , MULTISEASON_OPTMASK, MULTISEASON_TGAP
     &    , MULTISEASON_NREJECT_OUTLIER, MULTISEASON_CHI2RED_ACTIVE
     &    , APPLY_FLUXCOR_BUG, PHOTFLAG_DETECT, PHOTFLAG_TRIGGER
     &    , CUTWIN_ZPADU, CUTWIN_ZPNPE

      COMMON / SNLCINP8 /
     &    H0_REF, OLAM_REF, OMAT_REF, ORAD_REF, W0_REF, DWDA_REF

      NAMELIST / SNLCINP / 
     &      VERSION_PHOTOMETRY, VERSION_REPLACE, VERSION_REFORMAT_FITS
     &    , PRIVATE_DATA_PATH, FILTER_UPDATE_PATH
     &    , NONSURVEY_FILTERS, SNRMAX_FILTERS, VPEC_ERR_OVERRIDE
     &    , FILTER_REPLACE, FILTLIST_LAMSHIFT
     &    , JOBSPLIT, JOBSPLIT_EXTERNAL, SIM_PRESCALE, MXLC_FIT
     &    , OPTSIM_LCWIDTH, OPT_REFORMAT_TERSE, OPT_REFORMAT_TEXT
     &    , OPT_REFORMAT_SALT2, REFORMAT_KEYS, OPT_REFORMAT_FITS
     &    , SNMJD_LIST_FILE, SNMJD_OUT_FILE, MNFIT_PKMJD_LOGFILE
     &    , hfile_out, rootfile_out, textfile_prefix
     &    , SNTABLE_LIST, SNTABLE_FILTER_REMAP
     &    , KCOR_FILE, USERTAGS_FILE  ! , ZPOFF_FILE
     &    , VPEC_FILE, HEADER_OVERRIDE_FILE
     &    , EPOCH_IGNORE_FILE, SNCID_LIST_FILE, NONLINEARITY_FILE
     &    , SIMLIB_OUT, SIMLIB_ZPERR_LIST, OPT_SIMLIB_OUT
     &    , NFIT_ITERATION, MINUIT_PRINT_LEVEL, INTERP_OPT, USE_MINOS
     &    , OPT_SETPKMJD
     &    , SNRCUT_SETPKMJD, MJDWIN_SETPKMJD, OPT_DEBUG
     &    , LSIM_SEARCH_SPEC, LSIM_SEARCH_ZHOST
     &    , LDMP_SNFAIL, LDMP_SNANA_VERSION
     &    , LTEST_KCOR, LTEST_INTERP, LTEST_MAG, LTEST_U3BAND
     &    , USESIM_SNIA, USESIM_SNCC, USESIM_TRUEFLUX, USE_SNHOST_ZPHOT
     &    , RESTORE_DES3YR
     &    , ABORT_ON_NOEPOCHS, ABORT_ON_BADAVWARP, ABORT_ON_NOPKMJD
     &    , ABORT_ON_BADZ, ABORT_ON_BADKCOR, ABORT_ON_BADSURVEY
     &    , ABORT_ON_MARGPDF0, ABORT_ON_TRESTCUT
     &    , ABORT_ON_DUPLCID, ABORT_ON_DUPLMJD
     &    , ABORT_ON_BADHEADER, ABORT_ON_BADFILTER
     &    , H0_REF, OLAM_REF, OMAT_REF, W0_REF, DWDA_REF
     &    , USE_MWCOR, DOBUG_LAMRANGE
     &    , MXLC_PLOT, NCCID_PLOT, SNCCID_PLOT, DTOBS_MODEL_PLOT
     &    , MULTISEASON_OPTMASK, MULTISEASON_TGAP
     &    , MULTISEASON_NREJECT_OUTLIER, MULTISEASON_CHI2RED_ACTIVE
     &    , APPLY_FLUXCOR_BUG, PHOTFLAG_DETECT, PHOTFLAG_TRIGGER
c
c Below are cut-variables defined in SNCUTS
c
     &   ,SNTYPE_LIST, SNCID_LIST, SNCCID_LIST, MXEVT_PROCESS
     &   ,SNCCID_IGNORE, SNCID_IGNORE_FILE, SNCID_IGNORE
     &   ,SNTYPE_IGNORE, CCDNUM_LIST, SIM_TEMPLATE_INDEX_LIST
     &   ,SNFIELD_LIST, SNTEL_LIST
     &   ,PHOTFLAG_MSKREJ, cutwin_cid
     &   ,cutwin_redshift, cutwin_redshift_err
     &   ,cutwin_ra, cutwin_dec
     &   ,cutwin_hostsep,   cutwin_Nepoch
     &   ,cutwin_snrmax,    cutwin_snrmax2, cutwin_nfield
     &   ,cutwin_mwebv,     cutwin_nseason_active
     &   ,cutwin_Trestmin,   cutwin_Trestmax
     &   ,cutwin_TrestRange, cutwin_Trest, cutwin_Tobs
     &   ,cutwin_Tgapmax,  cutwin_T0gapmax
     &   ,cutwin_Tobsmin,  cutwin_Tobsmax
     &   ,cutwin_peakmjd,  cutwin_mjd
c
     &   ,cutwin_psf,       cutwin_zp,  CUTWIN_ZPADU, CUTWIN_ZPNPE
     &   ,cutwin_photprob,  cutwin_errtest
     &   ,cutwin_nband_thresh
     &   ,cutwin_nfilt_snrmax,   cutwin_nfilt_snrmax2
     &   ,cutwin_nfilt_trestmin, cutwin_nfilt_trestmax
     &   ,cutwin_trest2, cutwin_nfilt_trest2
     &   ,cutwin_restlam, cutwin_lamrest, cutwin_lamobs
     &   ,PRIVATE_CUTWIN_STRING, PRIVATE_REDSHIFT_CMB
     &   ,SIMVAR_CUTWIN_STRING
     &   ,EARLYLC_STRING, REQUIRE_EPOCHS_STRING, DUMP_STRING
c
     &   ,SNCUT_SNRMAX, SNCUT_HOST_SBFLUX
     &   ,EPCUT_SNRMIN, EPCUT_SKYSIG, EPCUT_PSFSIG
     &   ,MAGOBS_SHIFT_PRIMARY,  MAGOBS_SHIFT_ZP
     &   ,MAGREST_SHIFT_PRIMARY, MAGREST_SHIFT_ZP, FILTER_LAMSHIFT
     &   ,MAGOBS_SHIFT_PRIMARY_PARAMS, MAGOBS_SHIFT_ZP_PARAMS
     &   ,FUDGE_FLUXCAL_OFFSET,FUDGE_FLUXCAL_ERROR,FUDGE_FLUXCAL_ERRPIX
     &   ,FUDGE_MAG_ERROR, FUDGE_MAG_COVERR
     &   ,FLUXERRMODEL_FILE,SIM_FLUXERRMODEL_FILE,FLUXERRMODEL_OPTMASK
     &   ,MAGCOR_FILE, SIM_MAGCOR_FILE, FUDGE_HOSTNOISE_FILE
     &   ,RV_MWCOLORLAW, OPT_MWCOLORLAW, OPT_MWEBV  
     &   ,MWEBV_SCALE, MWEBV_SHIFT
     &   ,REDSHIFT_FINAL_SHIFT, FLUXERRCALC_ZPTERR 
     &   ,CUTWIN_MJD_EXCLUDE, CUTWIN_MJD_INCLUDE, CUTWIN_NMJD_INCLUDE


c ---------- end of SNLCINP ---------

+KEEP,NNCOM.

c Created Apr 2013 for Nearest Neighbor method.
c Define namelist inputs so that main snana job can
c check NN option and call init routines in sntools_nearnbr.c .

      INTEGER  NNFLAG_IGNORE,  NNFLAG_TRAIN, NNFLAG_APPLY, NN_MXVAR
      INTEGER  NN_MXTYPE
      PARAMETER ( NNFLAG_IGNORE=0, NNFLAG_TRAIN=1,  NNFLAG_APPLY=2)
      PARAMETER ( NN_MXVAR=10, NN_MXTYPE=10 )
      INTEGER  FLAG_NEARNBR

      CHARACTER 
     &   NEARNBR_TRAINFILE_PATH*(MXCHAR_FILENAME)
     &  ,NEARNBR_TRAINFILE_LIST*(MXCHAR_FILENAME)  ! training set file
     &  ,NEARNBR_SEPMAX_VARDEF*(MXCHAR_FILENAME)  ! list of 'VAR min max bin'
     &  ,NEARNBR_SEPMAX_VARNAME(NN_MXVAR)*20   ! list of varnames
     &  ,NEARNBR_SEPMAX_IGNORE*40        ! list of VAR to IGNORE
     &  ,NEARNBR_TRUETYPE_VARNAME*60

      LOGICAL NEARNBR_TRAIN_ODDEVEN ! odd SNID from ref; even from train
    
      INTEGER 
     &   NN_ITYPE_FIX       ! fix NN_ITYPE for spec-confirmed sample
     &  ,NN_ITYPE_SNIA      ! NN type for SNIa

c results
      INTEGER 
     &   NN_ITYPE, NN_NCELL
     &  ,NNSUM_UNKNOWN, NNSUM_IA, NNSUM_NON1A 

      REAL  
     &   NN_PROB_Ia, NN_PROB_II, NN_PROB_IBC
     &  ,NEARNBR_TRAINFILE_SCALE_NON1A

      COMMON / NNCOM /
     &    NEARNBR_TRAINFILE_PATH, NEARNBR_TRAINFILE_LIST
     &   ,NEARNBR_TRAINFILE_SCALE_NON1A
     &   ,NEARNBR_SEPMAX_VARDEF,  NEARNBR_SEPMAX_IGNORE
     &   ,NEARNBR_SEPMAX_VARNAME
     &   ,NEARNBR_TRUETYPE_VARNAME, NEARNBR_TRAIN_ODDEVEN
     &   ,NN_ITYPE_FIX, NN_ITYPE_SNIa
     &   ,NNSUM_UNKNOWN, NNSUM_IA, NNSUM_NON1A
c results
     &   ,FLAG_NEARNBR
     &   ,NN_ITYPE, NN_NCELL, NN_PROB_Ia, NN_PROB_II, NN_PROB_IBC

      NAMELIST / NNINP /
     &    NEARNBR_TRAINFILE_PATH, NEARNBR_TRAINFILE_LIST
     &   ,NEARNBR_TRAINFILE_SCALE_NON1A
     &   ,NEARNBR_SEPMAX_VARDEF, NEARNBR_SEPMAX_IGNORE
     &   ,NEARNBR_TRUETYPE_VARNAME, NEARNBR_TRAIN_ODDEVEN
     &   ,NN_ITYPE_FIX, NN_ITYPE_SNIa

+KEEP,FITSCOM.

c define external C functions to read from fits files

c max length of catenated strings from all epochs;
c e.g., FIELD, TELESCOPE ...

      INTEGER MXLEN_EPSTRING
      PARAMETER (MXLEN_EPSTRING = 20000 ) 

      INTEGER  
     &   RD_SNFITSIO_INIT
     &  ,RD_SNFITSIO_STR  ! read string
     &  ,RD_SNFITSIO_INT  ! read int
     &  ,RD_SNFITSIO_SHT  ! read short int
     &  ,RD_SNFITSIO_FLT  ! read float
     &  ,RD_SNFITSIO_DBL  ! read double

      EXTERNAL 
     &   RD_SNFITSIO_INIT
     &  ,RD_SNFITSIO_STR
     &  ,RD_SNFITSIO_INT
     &  ,RD_SNFITSIO_SHT
     &  ,RD_SNFITSIO_FLT
     &  ,RD_SNFITSIO_DBL
     &  ,SET_RDMASK_SNFITSIO ! void
     &  ,RD_SNFITSIO_CLOSE   ! void function

c Define index-lookup arrays used for faster reading of fits files
      INTEGER MXFITSPAR
      PARAMETER ( MXFITSPAR = 400 )

      INTEGER
     &   INDXFITS_HEAD(MXFITSPAR)    ! used in RDSNFITS_HEAD
     &  ,INDXFITS_EPCUTS(MXFITSPAR)  ! used in RDSNFITS_EPCUTS
     &  ,INDXFITS_PHOT(MXFITSPAR)    ! used in RDSNFITS_PHOT
     &  ,IPARFITS_HEAD
     &  ,CODE_IVERSION     ! version used to write data

c defin epoch mask for which 
     
      INTEGER 
     &   EPOCH_RDMASK_SNFITSIO(MXEPOCH)  ! epochs to keep/reject


c define long fits-string returned by RD_SNFITSIO_STR
      CHARACTER STRFITS*(MXLEN_EPSTRING)

      COMMON / FITSCOM /  CODE_IVERSION
     &  ,INDXFITS_HEAD, INDXFITS_EPCUTS, INDXFITS_PHOT
     &  ,IPARFITS_HEAD
     &  ,EPOCH_RDMASK_SNFITSIO, STRFITS


+KEEP,FILTCOM.

c filter bandpasses.
c Jan 16 2017: MXLAMBIN_FILT -> 4000 (was 3000) for JWST test

      INTEGER MXLAMBIN_FILT, MXLAMBIN_PRIM
      PARAMETER ( 
     &   MXLAMBIN_FILT = 4000   ! max number of lambda bins to store
     &  ,MXLAMBIN_PRIM = 4000  ! max lambda bins for primary
     &    )

c Define filter chars A-Z, a-z and 0-9, but do not change order of 
c original FILTDEF characters so that we can still use older Kcor files.
c
      CHARACTER FILTDEF_STRING*100
      PARAMETER (FILTDEF_STRING = 
     &  'ugrizYJHK UBVRIXy0123456789 abcdef ' //  !  32
     &  'ACDEFGLMNOPQSTWZ ' //                    ! +16
     &  'hjklmnopqstvwx '   //                    ! +14 = 62
     &  '&'                             ! +1(autoSynFilter for spectrograph)
     &         )

      CHARACTER
     &   FILTOBS_NAME(MXFILT_ALL)*40   ! full filternames
     &  ,FILTREST_NAME(MXFILT_ALL)*40  ! full filternames
     &  ,PRIMARY_NAME*40               ! name of primary
     &  ,NONSURVEY_FILTERS_ADD*80      ! NONSURVEY_FILTERS that were added

      LOGICAL 
     &   LFILTDEF_OBS(MXFILT_ALL)  ! filter-trans define in KCOR file
     &  ,LFILTDEF_REST(MXFILT_ALL) ! filter-trans define in KCOR file
     &  ,LFILTDEF_NONSURVEY(MXFILT_ALL) ! part of NONSURVEY_FILTERS
     &  ,LFILTDEF_SNRMAX(MXFILT_ALL)    ! use for SNRMAX cut
     &  ,FREEZE_SURVEY_FILTERS     ! T=> do not re-read on 2nd version
     &  ,EXIST_BXFILT_OBS          ! T=> observer BX exists
     &  ,EXIST_BXFILT_REST         ! T=> idem for rest-frame

c define indices for legacy filters
      INTEGER
     &   IFILT_SDSS_u, IFILT_SDSS_g, IFILT_SDSS_r
     &  ,IFILT_SDSS_i, IFILT_SDSS_z
     &  ,IFILT_BESS_U, IFILT_BESS_B, IFILT_BESS_V
     &  ,IFILT_BESS_R, IFILT_BESS_I, IFILT_BESS_BX
     &  ,IFILT_Y, IFILT_J, IFILT_H, IFILT_K

c define filter set for survey (observer) and for rest-frame.
c Each set goes 1 - NFILTDEF_[SURVEY,REST]

      INTEGER
     &   NFILTDEF_SURVEY          ! no. survey (obs) filters
     &  ,NFILTDEF_READ            ! no. filters to read (excludes BX)
     &  ,IFILTDEF_MAP_SURVEY(MXFILT_OBS)  ! IFILT_OBS vs. sparse filter index
     &  ,IFILTDEF_INVMAP_SURVEY(MXFILT_ALL) ! sparse index vs. IFILT_OBS
c
     &  ,NFILTDEF_REST                 ! no. rest-filts defined in Kcor file
     &  ,IFILTDEF_MAP_REST(MXFILT_OBS) ! IFILT_REST vs. sparse filter index
     &  ,IFILTDEF_INVMAP_REST(MXFILT_ALL) ! sparse index vs. IFILT_REST
c
     &  ,NFILTDEF_IGNORE_REST
     &  ,IFILTDEF_IGNORE_REST(MXFILT_OBS)  ! nearest rest-filters to ignore

c variables used in fitter; these variables are over-written
c in FITPAR_PREP for each SN

      INTEGER
     &   IFILT_REST_MAP(MXFILT_OBS)  ! idem for rest-frame filter
     &  ,NFILT_OBS_USEFIT                ! number of filters used in fit
  
      INTEGER*8
     &  IFILT_OBS_EVAL_MASK(2,MXFILT_ALL) ! set for each filter

      character FILTLIST_FIT_USE*64  ! filter-list USED each fit

c define filter properties using MXFILT_ALL
c Nov 12, 2010: split FILT_XXX into FILTOBS_XXX and FILTREST_XXX
c
      INTEGER
     &   NLAMBIN_FILTOBS(MXFILT_ALL)   ! number of bins per transmission curve
     &  ,NLAMBIN_FILTREST(MXFILT_ALL)  ! number of bins per transmission curve
     &  ,NLAMBIN_PRIMARY               ! lambda bins for primary spec


      REAL 
     &   FILTOBS_TRANS(MXLAMBIN_FILT,MXFILT_ALL)   ! filter transmissions
     &  ,FILTOBS_TRANSMAX(MXFILT_ALL)              ! max trans
     &  ,FILTOBS_LAMBDA(MXLAMBIN_FILT,MXFILT_ALL)  ! corresponding lambda's (A)
     &  ,FILTOBS_LAMAVG(MXFILT_ALL)           ! effective central lambda
     &  ,FILTOBS_LAMRMS(MXFILT_ALL)           ! lambda-RMS
     &  ,FILTOBS_LAMRANGE(2,MXFILT_ALL)       ! min,max range in obs-frames
     &  ,FILTOBS_MAG_PRIMARY(MXFILT_ALL)      ! primary mag vs. ifilt_obs
     &  ,FILTOBS_ZPOFF_PRIMARY(MXFILT_ALL)    ! mag(native) - mag(synth)
     &  ,FILTOBS_ZPOFF_SNPHOT(MXFILT_ALL)     ! apply these ZPOFF to SNphot
     &  ,FILTOBS_LAMSHIFT(MXFILT_ALL)         ! lambda shift per filter
c
     &  ,FILTREST_TRANS(MXLAMBIN_FILT,MXFILT_ALL)   ! filter transmissions
     &  ,FILTREST_TRANSMAX(MXFILT_ALL)              ! max trans
     &  ,FILTREST_LAMBDA(MXLAMBIN_FILT,MXFILT_ALL)  !  lambda's (A)
     &  ,FILTREST_LAMAVG(MXFILT_ALL)           ! effective central lambda
     &  ,FILTREST_LAMRMS(MXFILT_ALL)           ! lambda-RMS
     &  ,FILTREST_LAMRANGE(2,MXFILT_ALL)       ! min,max range in rest-frames
     &  ,FILTREST_MAG_PRIMARY(MXFILT_ALL)      ! primary mag vs. ifilt
     &  ,FILTREST_ZPOFF_PRIMARY(MXFILT_ALL)    ! mag(native) - mag(synth)
     &  ,FILTREST_LAMSHIFT(MXFILT_ALL)         ! lambda shift per filter
c
     &  ,PRIMARY_FLUX(MXLAMBIN_PRIM)       ! primary spec for obs filters
     &  ,PRIMARY_LAM(MXLAMBIN_PRIM)   


c for remap
      INTEGER NFILT_REPLACE, IFILTOBS_REPLACE(MXFILT_ALL) 
      
      COMMON / FILTCOM / FILTOBS_NAME, FILTREST_NAME
     &   ,IFILT_SDSS_u, IFILT_SDSS_g, IFILT_SDSS_r
     &   ,IFILT_SDSS_i, IFILT_SDSS_z
     &   ,IFILT_BESS_U, IFILT_BESS_B, IFILT_BESS_V
     &   ,IFILT_BESS_R, IFILT_BESS_I, IFILT_BESS_BX
     &   ,IFILT_Y, IFILT_J, IFILT_H, IFILT_K
c
     &   ,NFILTDEF_SURVEY,        NFILTDEF_REST, NFILTDEF_READ
     &   ,FREEZE_SURVEY_FILTERS
     &   ,EXIST_BXFILT_OBS,       EXIST_BXFILT_REST
     &   ,IFILTDEF_MAP_SURVEY,    IFILTDEF_MAP_REST
     &   ,IFILTDEF_INVMAP_SURVEY, IFILTDEF_INVMAP_REST
     &   ,NFILTDEF_IGNORE_REST,   IFILTDEF_IGNORE_REST
     &   ,LFILTDEF_OBS, LFILTDEF_REST
     &   ,LFILTDEF_NONSURVEY, NONSURVEY_FILTERS_ADD
     &   ,LFILTDEF_SNRMAX
c
     &   ,NLAMBIN_FILTOBS, FILTOBS_TRANS, FILTOBS_TRANSMAX
     &   ,FILTOBS_LAMBDA, FILTOBS_LAMAVG, FILTOBS_LAMRMS
     &   ,FILTOBS_LAMRANGE
     &   ,FILTOBS_MAG_PRIMARY, FILTOBS_ZPOFF_PRIMARY
     &   ,FILTOBS_ZPOFF_SNPHOT, FILTOBS_LAMSHIFT
c
     &   ,NLAMBIN_FILTREST, FILTREST_TRANS, FILTREST_TRANSMAX
     &   ,FILTREST_LAMBDA,  FILTREST_LAMAVG, FILTREST_LAMRMS
     &   ,FILTREST_MAG_PRIMARY, FILTREST_ZPOFF_PRIMARY
     &   ,FILTREST_LAMSHIFT, FILTREST_LAMRANGE
c
     &   ,IFILT_REST_MAP
     &   ,FILTLIST_FIT_USE, NFILT_OBS_USEFIT
     &   ,PRIMARY_FLUX, PRIMARY_LAM, NLAMBIN_PRIMARY, PRIMARY_NAME
c
     &   ,NFILT_REPLACE, IFILTOBS_REPLACE

      COMMON / FILTCOM8 / IFILT_OBS_EVAL_MASK

+KEEP,FILTUPDCM.

c Nov 2010
c information related to updating filter transmissions for each SN
c

      INTEGER  
     &  OPT_FILTER_UPDATE   ! global flag for filter update
     & ,DOFLAG_FILTER_UPDATE(MXFILT_ALL)  ! track which filters to update

      CHARACTER 
     &  FILTER_UPDATE_TOPDIR*(MXCHAR_FILENAME)  !full path to filt-trans files

      COMMON / FILTUPDCOM / 
     &   OPT_FILTER_UPDATE, DOFLAG_FILTER_UPDATE, FILTER_UPDATE_TOPDIR

c ------------------------------------

c define updated filt-tran for SN and REF;
c the FILTOBS_TRANS arrays change for each SN
      REAL
     &  FILTOBS_TRANSSN_UPD(MXLAMBIN_FILT,MXFILT_ALL)
     & ,FILTOBS_TRANSREF_UPD(MXLAMBIN_FILT,MXFILT_ALL)
     & ,FILTOBS_ZPOFF_UPD(MXFILT_ALL)

c filter subdir is
c    [PREFIX_UPD_FILTDIR][SNID][SUFFIX_UPD_FILTDIR]
c and filter filenames are
c    [PREFIX_TRANSSN][filt][SUFFIX_UPD_TRANSSN]

      character   
     &   PREFIX_UPD_TRANSSN*80         ! Filename prefix for SN trans
     &  ,PREFIX_UPD_TRANSREF*80
     &  ,PREFIX_UPD_FILTDIR*80
     &  ,SUFFIX_UPD_TRANSSN*80
     &  ,SUFFIX_UPD_TRANSREF*80
     &  ,SUFFIX_UPD_FILTDIR*80
     &  ,FILTER_UPDATE_DIR*(MXCHAR_PATH)  ! directory with filter updates
 
      LOGICAL FILTINFO_UPD_SN, FILTINFO_UPD_REF

c define common for filter-set per SN
      COMMON / FILTUPDCOM2 / 
     &   FILTOBS_TRANSSN_UPD, FILTOBS_TRANSREF_UPD
     &  ,FILTOBS_ZPOFF_UPD
     &  ,PREFIX_UPD_FILTDIR,  SUFFIX_UPD_FILTDIR
     &  ,PREFIX_UPD_TRANSSN,  SUFFIX_UPD_TRANSSN
     &  ,FILTINFO_UPD_SN
     &  ,PREFIX_UPD_TRANSREF, SUFFIX_UPD_TRANSREF
     &  ,FILTINFO_UPD_REF
     &  ,FILTER_UPDATE_DIR


c Define common for filter set mapping.
c There are two maps:
c   MAP1: subdir name vs. index
c   MAP2: indx vs. SNID

      INTEGER MXMAP1_FILTER_UPDATE, MXSNLC_FILTUPD
      PARAMETER ( MXMAP1_FILTER_UPDATE = 20 )
      PARAMETER ( MXSNLC_FILTUPD = 20000 ) ! replaces MXSNLC_FILES

c MAP1:
      INTEGER 
     &   NMAP1_FILTER_UPDATE
     &  ,MAP1_FILTER_UPDATE_INDX(MXMAP1_FILTER_UPDATE) 
      CHARACTER  
     &   MAP1_FILTER_UPDATE_SUBDIR(MXMAP1_FILTER_UPDATE)*100

c MAP2:
c WARNING: works only up to MXSNLC_FILTUPD << MXSNLC

      INTEGER 
     &   NMAP2_FILTER_UPDATE
     &  ,MAP2_FILTER_UPDATE_PTRMAP1(MXSNLC_FILTUPD)  ! points to MAP1 index
      CHARACTER
     &   MAP2_FILTER_UPDATE_CCID(MXSNLC_FILTUPD)*(MXCHAR_CCID)  ! CCID list

      COMMON / FILTUPD_MAPCOM / 
     &   NMAP1_FILTER_UPDATE
     &  ,MAP1_FILTER_UPDATE_INDX, MAP1_FILTER_UPDATE_SUBDIR
c
     &  ,NMAP2_FILTER_UPDATE
     &  ,MAP2_FILTER_UPDATE_PTRMAP1, MAP2_FILTER_UPDATE_CCID


+KEEP,SNANAFIT.

c store fit results for use in snana
c define arrays used in fit.

      INTEGER MXFITPAR, MXFITSTORE

      PARAMETER ( 
     &   MXFITPAR    =  12    ! max number of fit parameters
     &  ,MXFITSTORE  =  500   ! max number of storage params 
     &     )

      INTEGER 
     &   NFITPAR(0:MXFILT_OBS)   ! Nfitpar for 0=all, or 'ifilt'
     &  ,NFITPAR_MN         ! Minuit NFITPAR includes NFIXPAR
     &  ,NFIXPAR            ! Number of fixed parameters (i.e, INISTP=0)
     &  ,NPLOTPAR            ! Number of extra FITVAL parameters to plot
     &  ,NEPOCH_ALL(0:MXFILT_OBS)    ! fit+rejected epochs per filter
     &  ,NEPOCH_FIT(0:MXFILT_OBS)    ! number of epochs fit per filter
     &  ,NEPOCH_REJECT(0:MXFILT_OBS) ! number of epochs rejected by fit 
     &  ,ERRTYPE(MXFITPAR)  ! MINOS or PARAB
     &  ,PARPTR_CHI2
     &  ,PARPTR_IFILT_REST(MXFILT_ALL)
     &  ,PARPTR_FITRESTMAG

      DOUBLE PRECISION 
     &   INIVAL(MXFITPAR)
     &  ,INISTP(MXFITPAR)
     &  ,INIBND(2,MXFITPAR)
c
     &  ,FITVAL(MXFITPAR,0:MXITER)
     &  ,FITERR(MXFITPAR,0:MXITER)
     &  ,FITERR_PLUS(MXFITPAR,MXITER)
     &  ,FITERR_MINUS(MXFITPAR,MXITER)
     &  ,FITERR_RATIO(MXFITPAR,MXITER)  ! abs(EPLUS/Eminus)
c
cc xxx obsolete  &  ,FITCOR(MXFITPAR,MXFITPAR) 
     &  ,FITCHI2_MIN   ! min chi2 after minimization
     &  ,FITCHI2_QUIT  ! quit FCN calc if chi2 exceeds this value
     &  ,SIMCHI2_CHEAT ! chi2 using exact sim values
     &  ,FITERRMAT_SPARSE(MXFITPAR,MXFITPAR)
     &  ,FITERRMAT(MXFITPAR,MXFITPAR)
     &  ,FITCORMAT(MXFITPAR,MXFITPAR)
c
     &  ,PDFVAL(MXFITPAR)
     &  ,PDFERR(MXFITPAR)
     &  ,PDFPROB2(MXFITSTORE) 
     &  ,PDFERRMAT(MXFITPAR,MXFITPAR)
     &  ,PDFCORMAT(MXFITPAR,MXFITPAR)

c declare fit-storage arrays for all SN

      REAL 
     &   FITVAL_STORE(MXFITSTORE)
     &  ,FITERR_STORE(MXFITSTORE)
     &  ,PDFVAL_STORE(MXFITSTORE)  ! from average over PDF integral
     &  ,PDFERR_STORE(MXFITSTORE)  !
     &  ,PDFPROB2_STORE(MXFITSTORE)  !
     &  ,LCVAL_STORE(MXFITSTORE)   !  either FITVAL or PDFVAL
     &  ,LCERR_STORE(MXFITSTORE)   !  either FITERR or PDFERR
     &  ,LCFRACERRDIF_STORE(MXFITSTORE)  ! frac change on last 2 iter
c
     &  ,LCCHI2_STORE(4)        !  1,2,3,4=> TOTAL,data,prior,sigma
     &  ,LCPROBCHI2_STORE(4)    !  idem for prob
     &  ,FITCHI2_STORE(4)       !  idem for fit minimum
     &  ,FITPROBCHI2_STORE(4)
c
     &  ,INIVAL_STORE(MXFITSTORE)  ! store all inital values  
     &  ,SIMVAL_STORE(MXFITPAR)     ! sim values
c
     &  ,ERRMAX_BAD(MXFITPAR)     ! err < ERRMAX_BAD labelled bad
     &  ,MAG_XTMW_REF(MXFILT_ALL) ! ref MWXT mags subtracted from data
c
c ------ define FITANA_CUTWIN_XXX that depend on spec-vs-photoz fit
     &  ,FITANA_CUTWIN_TREST(2)
     &  ,FITANA_CUTWIN_TRESTMIN(2)
     &  ,FITANA_CUTWIN_TRESTMAX(2)
     &  ,FITANA_CUTWIN_TREST2(2)
     &  ,FITANA_CUTWIN_TGAPMAX(2)
     &  ,FITANA_CUTWIN_T0GAPMAX(2)
c ------ SNLC_XXX -> XXX_FIT re-evaluated after final fit
     &  ,TRESTMIN_FIT, TRESTMAX_FIT, TRESTRANGE_FIT
     &  ,TOBSMIN_FIT,  TOBSMAX_FIT
     &  ,TGAPMAX_FIT,  T0GAPMAX_FIT
     &  ,SNRMAX_FILT_FIT(MXFILT_OBS)      ! sparse ordering
     &  ,SNRMAX_SORT_FIT(MXFILT_OBS)

      INTEGER
     &   ERRTYPE_STORE(MXFITPAR)  ! MINOS or PARABOLIC
     &  ,NERRTYPE(MXERRTYPE)      ! # params per error type
     &  ,NDOF_STORE(4)            ! 1,2,3 => TOTAL, DATA, PRIOR, SIGMA
     &  ,NDOF_PRIOR
     &  ,NCALL_INTEGPDF
     &  ,TIME_INTEGPDF
     &  ,TIMESUM_INTEGPDF
     &  ,TIMEAVG_INTEGPDF
c ---- ISNLC_XXX  -> XXX_FIT  re-evaluated after fitting
     &  ,NFILT_TRESTMIN_FIT
     &  ,NFILT_TRESTMAX_FIT
     &  ,NFILT_TREST2_FIT
     &  ,NFILT_SNRMAX_FIT    ! added Sep 30 2012
     &  ,NFILT_SNRMAX2_FIT   ! added Sep 20 2012
     &  ,MNSTAT_COV          ! ISTAT returned from MNSTAT: see minuit manual

      CHARACTER 
     &   PARNAME_STORE(MXFITSTORE)*(MXCHAR_PARNAME)  ! stored parameter names
      INTEGER
     &   PAROPT_STORE(MXFITSTORE)  ! storage options for output

      LOGICAL 
     &   FLOATPAR(MXFITPAR)   ! T => ipar is floated in fit
     &  ,USEPDF_MARG          ! T => use margin. pdf-avg instead of fit-values
     &  ,LREPEAT_ITER         ! internal flag for repeated iteration
     &  ,LREPEAT_MINOS        ! repeat entire fit with MINOS (May 2018)

      COMMON / SNANAFIT4 / 
     &   NFITPAR_MN, NFITPAR, NFIXPAR, PARNAME_STORE, PAROPT_STORE
     &  ,NEPOCH_ALL, NEPOCH_FIT, NEPOCH_REJECT
     &  ,NPLOTPAR, ERRTYPE, FLOATPAR, USEPDF_MARG
     &  ,PARPTR_CHI2, PARPTR_IFILT_REST, PARPTR_FITRESTMAG
     &  ,FITVAL_STORE, FITERR_STORE
     &  ,FITCHI2_STORE, FITPROBCHI2_STORE
     &  ,PDFVAL_STORE, PDFERR_STORE, PDFPROB2_STORE
     &  ,LCVAL_STORE,  LCERR_STORE, LCFRACERRDIF_STORE
     &  ,LCCHI2_STORE, LCPROBCHI2_STORE
     &  ,INIVAL_STORE
     &  ,ERRTYPE_STORE, NERRTYPE, ERRMAX_BAD
     &  ,NDOF_STORE, NDOF_PRIOR, SIMVAL_STORE
     &  ,NCALL_INTEGPDF, TIME_INTEGPDF
     &  ,TIMESUM_INTEGPDF, TIMEAVG_INTEGPDF
c
     &  ,FITANA_CUTWIN_TREST
     &  ,FITANA_CUTWIN_TRESTMIN, FITANA_CUTWIN_TRESTMAX
     &  ,FITANA_CUTWIN_TREST2
     &  ,FITANA_CUTWIN_TGAPMAX,  FITANA_CUTWIN_T0GAPMAX
     &  ,TRESTMIN_FIT, TRESTMAX_FIT, TRESTRANGE_FIT
     &  ,TobsMIN_FIT, TobsMAX_FIT, TGAPMAX_FIT, T0GAPMAX_FIT
     &  ,SNRMAX_FILT_FIT, SNRMAX_SORT_FIT
     &  ,NFILT_TRESTMIN_FIT,NFILT_TRESTMAX_FIT,NFILT_TREST2_FIT
     &  ,NFILT_SNRMAX_FIT,   NFILT_SNRMAX2_FIT
     &  ,LREPEAT_ITER, LREPEAT_MINOS,  MNSTAT_COV

      COMMON / SNANAFIT8 / 
     &   INIVAL, INISTP, INIBND, FITVAL
     &  ,FITERR, FITERR_PLUS, FITERR_MINUS, FITERR_RATIO
     &  ,FITCHI2_MIN, FITCHI2_QUIT, SIMCHI2_CHEAT
     &  ,FITERRMAT_SPARSE, FITERRMAT, FITCORMAT
     &  ,PDFVAL, PDFERR, PDFPROB2, PDFERRMAT, PDFCORMAT
     &  ,MAG_XTMW_REF

C =============================================
+KEEP,MCMCCOM.  
  
c Created Nov 2009 for Ben Dilday's  MCMC method  
  
c a bunch of MCMC stuff  
      LOGICAL LMCMC  
     &  ,LTUP_MCMC    ! book/fill special ntuple  
  
      INTEGER   
     &   NMCMC_EVAL        ! number of total evaluations for MCMC  
     &  ,IMCMC_FLAG        ! a generic flag for MCMC variations  
     &  ,NMCMC_CHAINS      ! number of chains to run  
     &  ,NMCMC_BURN        ! size of burn in  
     &  ,IMCMC_STORE       ! store every nth chi2 in the ntuple  
   
      CHARACTER   
     &  CHOPT_MCMC*16     ! ??  
        
      REAL   
     &   MCMC_NSIG_STEP   ! ??  
     &  ,NSIG_MCMC_START  ! ??  
  
      COMMON / SNFMCMC / NMCMC_EVAL, IMCMC_FLAG  
     &     ,NMCMC_CHAINS, NMCMC_BURN,MCMC_NSIG_STEP  
     &     ,CHOPT_MCMC, LMCMC, LTUP_MCMC        
     &     ,IMCMC_STORE, NSIG_MCMC_START  
       
      NAMELIST / MCMCINP / NMCMC_EVAL, IMCMC_FLAG  
     &     ,NMCMC_CHAINS, NMCMC_BURN, MCMC_NSIG_STEP  
     &     ,CHOPT_MCMC, LMCMC, LTUP_MCMC        
     &     ,IMCMC_STORE, NSIG_MCMC_START  
  
 
C =============================================
+KEEP,MCMCTUP. 
c MCMCTUP parameters (created Nov 2009 by B.Dilday)  
  
      INTEGER 
     &   MXNTVAR  
     &  ,MAX_NMCMC_TOT   
     &  ,NTID  
     &  ,NCALL_MCMCTUP
        
      PARAMETER (     
     &     MXNTVAR = 100   
     &   , MAX_NMCMC_TOT = 2000000 ! max entries for mcmc ntuple   
     &   , NTID = IDTABLE_MCMC 
     &     )   
        
c     common block for ntuple stuff  
      CHARACTER MCMCTUPNAMES(MXNTVAR)*8   
      REAL MCMCTUPVALS(MXNTVAR)  
        
      COMMON / MCMCTUPCOM / MCMCTUPNAMES  
     &     ,MCMCTUPVALS, NCALL_MCMCTUP  
 
c ----------------------------


+KEEP,XTCOM.
c
c Created Nov 16, 2006
c extinction parameters:
c  XTmag = zeta(t) * [alpha + beta/RV] * AV
c XTPAR are Saurabh's parameters.
c
c Aug 30, 2010: add newer XTHOST - exact calculation

      INTEGER NRVBIN_XTHOST
      PARAMETER ( NRVBIN_XTHOST = 5 )

      REAL
     &   XTPAR_ZETA(MXFILT_ALL,MXTBIN_KCOR)
     &  ,XTPAR_ALPHA(MXFILT_ALL)
     &  ,XTPAR_BETA(MXFILT_ALL)
     &  ,XTHOST(MXFILT_ALL,MXTBIN_KCOR,NRVBIN_XTHOST)
     &  ,RVINV_XTHOST(NRVBIN_XTHOST)

      COMMON / XTCOM / XTPAR_ZETA, XTPAR_ALPHA, XTPAR_BETA, 
     &                 XTHOST, RVINV_XTHOST

+KEEP,SNCONTCM.

      INTEGER  MXPLOT_CONT, MXBIN_CONT
      PARAMETER ( 
     &   MXPLOT_CONT  = 5    ! max number of contour plots per SN
     &  ,MXBIN_CONT   = 100  ! max number of contour bins
     &     )

c define arrays to hold MNCONT informatino for contour plots

      INTEGER 
     &   NPLOT_CONT                 ! number of user-contour plots
     &  ,HID_CONT(2,MXPLOT_CONT)    ! store hbook ids for vectors
     &  ,IPAR_CONT(2,MXPLOT_CONT)   ! stores which IPAR for contours
     &  ,NPT_CONT(MXPLOT_CONT)      ! stores Npt per contour plot
     &  ,NPT_FOUND(MXPLOT_CONT)

      REAL*8
     &   VCONT8(MXBIN_CONT,2,MXPLOT_CONT)  ! vector array for IPAR1

      COMMON / CONTOURCOM4 / NPLOT_CONT
     &   ,HID_CONT, IPAR_CONT, NPT_CONT, NPT_FOUND

      COMMON / CONTOURCOM8 /  VCONT8


+KEEP,PKMJDCOM.

c define bits for user option-mask OPT_SETPKMJD  (lsb = 0 )
      INTEGER 
     &   OPTBIT_SETPKMJD_ANYFUN
     &  ,OPTBIT_SETPKMJD_POLYCOR
     &  ,OPTBIT_SETPKMJD_NOABORT
     &  ,OPTBIT_SETPKMJD_FLUXMAX
     &  ,OPTBIT_SETPKMJD_SAVEPAR
     &  ,OPTBIT_SETPKMJD_FLUXMAX2
     &  ,OPTBIT_SETPKMJD_TRIGGER
     &  ,OPTBIT_SETPKMJD_DUMP

      PARAMETER ( 
     &  OPTBIT_SETPKMJD_ANYFUN  = 0  ! (=1) use exact function from Bazin 09
     & ,OPTBIT_SETPKMJD_POLYCOR = 1  ! (=2) include POLY cor in Bazin function
     & ,OPTBIT_SETPKMJD_NOABORT = 2  ! (=4) do not abort if can't find PKMJD 
     & ,OPTBIT_SETPKMJD_FLUXMAX = 3  ! (=8) PEAKMJD=MJD(maxFlux) like JG
     & ,OPTBIT_SETPKMJD_FLUXMAX2= 4  ! (=16) PKMJD for Fmax clump
     & ,OPTBIT_SETPKMJD_TRIGGER = 5  ! (=32) PKMJD = MJD_TRIGGER 
     & ,OPTBIT_SETPKMJD_SAVEPAR = 9  ! (=512) save fit params to SNANA table
     & ,OPTBIT_SETPKMJD_DUMP    =10  !(=1024) extra screen dump per SN/filter
     &   )

c Define fit params

      INTEGER 
     &   IPAR_ISN, IPAR_FILT, IPAR_MJDMIN, IPAR_MJDMAX
     &  ,IPAR_T0, IPAR_TRISE, IPAR_TFALL
     &  ,IPAR_A0, IPAR_A1, IPAR_A2
     
      REAL SNRMIN_forFLUXMAX

      PARAMETER (
     &   IPAR_ISN    = 1  ! fixed param
     &  ,IPAR_FILT   = 2  ! fixed param
     &  ,IPAR_MJDMIN = 3  ! fixed param (May 2019)
     &  ,IPAR_MJDMAX = 4  ! fixed param (May 2019)
     &  ,IPAR_T0     = 5
     &  ,IPAR_TRISE  = 6
     &  ,IPAR_TFALL  = 7
     &  ,IPAR_A0     = 8
     &  ,IPAR_A1     = 9
     &  ,IPAR_A2     = 10
     &  ,SNRMIN_forFLUXMAX  = 3.0   ! min SNR to consider for fluxmax
     &     )

       CHARACTER  PKPARNAME(NPAR_ANYLC)*16 
       DATA  PKPARNAME /
     &     'ISN', 'IFILTOBS', 'MJDMIN', 'MJDMAX', 
     &     'T0', 'TRISE', 'TFALL','A0', 'A1', 'A2' /

c -----
      REAL*8 FITERRMAT_PKMJD(NPAR_ANYLC,NPAR_ANYLC,MXFILT_ALL)

      COMMON / PKMJDCOM8 / FITERRMAT_PKMJD 

      REAL*4
     &   PKMJD_FIT(MXFILT_ALL)
     &  ,PKMJD_ERR(MXFILT_ALL)
     &  ,PKMJD_ERRMIN, PKMJD_ERRWGT  ! min and weighted error
     &  ,PKFLUX_FIT(MXFILT_ALL)
     &  ,PKFLUX_ERR(MXFILT_ALL)
     &  ,PKFLUX_ERRMIN, PKFLUX_ERRWGT  ! min and weighted error
     &  ,CHI2_FITPKMJD(MXFILT_ALL)

      INTEGER NFIT_PKMJD, NDOF_FITPKMJD(MXFILT_ALL)

      COMMON / PKMJDCOM4 /
     &   PKMJD_FIT, PKMJD_ERR, PKMJD_ERRMIN, PKMJD_ERRWGT
     &  ,PKFLUX_FIT, PKFLUX_ERR, PKFLUX_ERRMIN, PKFLUX_ERRWGT
     &  ,NFIT_PKMJD
     &  ,CHI2_FITPKMJD, NDOF_FITPKMJD

+KEEP,WRS2COM.

c Nov 03, 2011:
c common block for translating SNANA format into SALT2 format.

      INTEGER
     &   LEN_SURVEY, LEN_INST, LEN_MAGSYS,  LEN_PREFIX
     &  ,NREPLACE, IMAP_REPLACE(MXFILT_ALL)
     &  ,NEWKEY

      CHARACTER
     &   NAMEof_INSTRUMENT*(MXCHAR_FILEWORD)
     &  ,NAMEof_MAGSYS*(MXCHAR_FILEWORD)
     &  ,NAMEof_SURVEY*(MXCHAR_FILEWORD)
     &  ,NAMEof_PREFIX*(MXCHAR_FILEWORD)
     &  ,NAMEof_REPLACE(2)*(MXCHAR_FILEWORD)
     &  ,NEWKEY_NAME(20)*(MXCHAR_FILEWORD)
     &  ,NEWKEY_ARG(20)*(MXCHAR_FILEWORD)

      COMMON / WRS2COM /
     &   LEN_SURVEY, LEN_INST, LEN_MAGSYS, LEN_PREFIX
     &  ,NREPLACE, IMAP_REPLACE, NEWKEY
     &  ,NAMEof_INSTRUMENT, NAMEof_MAGSYS
     &  ,NAMEof_SURVEY, NAMEof_PREFIX
     &  ,NAMEof_REPLACE, NEWKEY_NAME, NEWKEY_ARG

C =================================================
+PATCH,*SNANA.

+USE,P=*SNMAIN,T=EXE.
+USE,P=*SNUTIL,T=EXE.
+USE,P=*SNTABLE,T=EXE.
+USE,P=*CALIB,T=EXE,IF=R4KCOR,I2KCOR.
+USE,P=*FITPKMJD,T=EXE.
+USE,P=*SPLINE,T=EXE.


C =============================================
+PATCH,*SNMAIN.
C =============================================

C =============================================
+DECK,MAIN.
      PROGRAM SNANA
c
c Main snana program.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

      INTEGER   IERR, IVERS, NFIT_PER_SN
      LOGICAL   LKCOR      

c funtions

+SELF,IF=SNANA.
      INTEGER SNANA_GET_NLCPLOT
+SELF.

+SELF,IF=PSNID.
      INTEGER PSNID_GET_NFIT
+SELF.

C ------------------- BEGIN -------------------

      JTIME_START = TIME()

      CALL PARSE_SNANA_ARGS()

      ISTAGE_SNANA = 0

c init some variables

      CALL INIT_SNVAR ( IERR )
        IF ( IERR .NE. 0 ) GOTO 666 

      CALL WARN_OLDINPUTS("init"//char(0), 0);

c read namelist
      CALL RDSNNML(IERR) 
        IF ( IERR .NE. 0 ) GOTO 666 

      ISTAGE_SNANA = ISTAGE_INIT

c check for dump flags (call to C code)
      CALL INIT_SNANA_DUMP(DUMP_STRING//char(0) )

c check if format is FITS or ASCII (set logicals  FORMAT_FITS[TEXT])
      CALL CHECK_FORMAT(IERR)
         IF ( IERR .NE. 0 ) GOTO 666 

c ------------------------------------------------
c            Misc. inits for options

c check option to read list of CIDs from text file (Nov 2013)
      CALL RD_SNCIDLIST()
     
c check for SN,MJD list from file ... used for interpolation
      CALL RD_SNMJDLIST()

c read optional tags
      CALL RD_USERTAGS()

c read optional header-override (can include vpec) 
      CALL INIT_HEADER_OVERRIDE()     ! Nov 29 2016

c Oct 2013: read optional peculiar-velocity corrections 
c Dec 2016: should use the HEADER_OVERRIDE feature instead.
      CALL RD_VPEC_FILE(-1)

c init multi-season analysis
      CALL MULTISEASON(IFLAG_INI)  ! 1 = init flag

c -----------------------------------------------
c read header of 1st light curve to get global info
c (SURVEY, FILTERS ..) needed for initialization
      LFLAG_RDHEAD_ONLY = .TRUE.
      IVERS = 1

      CALL GETINFO_PHOTOMETRY(IVERS)

      IF ( FORMAT_FITS ) THEN
         CALL RDVERSION_FITS ( IVERS, IERR )
      ELSE
         CALL RDVERSION_TEXT ( IVERS, IERR )
      ENDIF
      LFLAG_RDHEAD_ONLY = .FALSE.
      N_SNFILE          = 0  ! reset 

c continue with initialization that may depend on SURVEY and FILTERS.

c process namelist strings after we know
c the filters and survey 

      CALL PROCSNNML(IERR) 
        IF ( IERR .NE. 0 ) GOTO 666 

      CALL INIT_FUDGE_FLUXCAL(IERR) ! fudge fluxes and/or errors
        IF ( IERR .NE. 0 ) GOTO 666 

c intialize cutmask after reading data
      CALL INIT_CUTMASK(IERR)
        IF ( IERR .NE. 0 ) GOTO 666 

c init early-LC selection
      CALL PARSE_EARLYLC_STRING()

c init REQUIRE_EPOCHS (Sep 2017)
      CALL PARSE_REQUIRE_EPOCHS_STRING()

c init cut-names now that we have the filter names 
      CALL INIT_CUTNAMES(IERR)
        IF ( IERR .NE. 0 ) GOTO 666 

c always read K correction tables if KCOR_FILE is given;
c Only SNANA job allows NULL kcor file

      LKCOR = .TRUE.
+SELF,IF=SNANA,PSNID.
      IF ( KCOR_FILE .EQ. 'NULL' ) LKCOR = .FALSE.
+SELF.


+SELF,IF=R4KCOR,I2KCOR.
      IF ( LKCOR ) THEN 
        CALL ENVreplace(KCOR_FILE)  ! Mar 2016
        CALL RDKCOR ( KCOR_FILE, IERR )
        IF ( IERR .NE. 0 ) GOTO 666 
      ENDIF

c check for option to update filter trans for each SN
      CALL FILTER_UPDATE_INIT(IERR)
+SELF.

c option to create SIMLIB from data (call after RDKCOR, Feb 2017)
      CALL MAKE_SIMLIB_FILE(1)

c check for valid MW GALextinct option  and print message
      CALL INIT_GALextinct()

      ISTAGE_SNANA = ISTAGE_RDSN

c parse SNTABLE_LIST string to know what tables & LCPLOTs to make
      CALL INIT_SNTABLE_OPTIONS()

c --------------------------------------------
c init output file; set OPTFIT based on program.
+SELF,IF=SNANA.
      NFIT_PER_SN = SNANA_GET_NLCPLOT()
      ISJOB_SNANA = .TRUE.
      CALL MNDUMMY()   ! just to require minuit library.
+SELF,IF=SNFIT.
      NFIT_PER_SN = 1  ! only 1 fit per SN
      CALL MNDUMMY()   ! just to require minuit library.
+SELF,IF=PSNID.
      NFIT_PER_SN = PSNID_GET_NFIT()
      ISJOB_PSNID = .TRUE.
      IF ( OPT_SETPKMJD == 0 ) THEN  ! if default, then ...
        OPT_SETPKMJD = -1  ! DON'T estimate PKMJD before psnid (4/22/2014)
      ENDIF
+SELF.

      CALL INIT_OUTFILES(NFIT_PER_SN)

c Mar 2013, create subdir for monitor-init (CDTOPDIR below)
      CALL MAKEDIR_OUTPUT("MONINIT"//char(0), -1, 7 ) 

c --------------------------------------------
c plot a few Hubble diagrams for references
      IF ( USE_TABLEFILE )  CALL MON_HUBBLEREF ( IERR )

+SELF,IF=SNFIT.
c initialize fitter before SN are selected
      CALL PRBANNER ( "CALL FITPAR_INI" )
      CALL FITPAR_INI ( IERR )
         IF ( IERR .NE. 0 ) GOTO 666 
+SELF.

      CALL CDTOPDIR_OUTPUT()  ! climb out of MONINIT subdir (Mar 2013)

+SELF,IF=PSNID.
      CALL PRBANNER ( "CALL PSNIDINI" )
      CALL PSNIDINI(IERR)
+SELF.

c -------------------------------------------------
c Let user initialize their stuff before SN are selected
c Aug 14 2014: move after CDTOPDIR call.
 
      CALL PRBANNER ( "CALL USRINI" )
      CALL USRINI ( IERR )
         IF ( IERR .NE. 0 ) GOTO 666 
           
c check command-line args after all inits
      CALL CHECK_LINE_ARGS 

c pak global survey info after all initialization (Mar 24 2013)
      IF ( USE_TABLEFILE .and. NFIT_PER_SN>0 ) CALL SNLCPAK_SURVEY() 


+SELF,IF=TESTFUNS.
      IF ( LTEST_MAG    ) CALL TEST_MAG
      IF ( LTEST_KCOR   ) CALL TEST_KCOR   
cc      IF ( LTEST_INTERP ) CALL TEST_INTERP(INTERP_OPT)
+SELF.

c initialize format translations
      IF ( OPT_REFORMAT_SALT2 .EQ. 2 ) CALL INI_WRSALT2_2
      IF ( OPT_REFORMAT_FITS  >    0 ) CALL INI_WRFITS

c ######################################################
c
c   Read and process SN data : USRANA and MINUIT FIT
c
c ######################################################


c ------------------------------
      JTIME_LOOPSTART = TIME()
c ------------------------------

      DO ivers = 1, N_VERSION

c first get VERSION path and name of list file
         CALL GETINFO_PHOTOMETRY(ivers)

         CALL DMP_README(ivers,IERR)
         CALL RDEPIGNORE(ivers,IERR)

         IF ( FORMAT_FITS ) THEN
           CALL RDVERSION_FITS ( IVERS, IERR )
         ELSE
           CALL RDVERSION_TEXT ( IVERS, IERR )
         ENDIF

         IF ( IERR .NE. 0 ) GOTO 666 
      ENDDO

c ------------------------------
      JTIME_LOOPEND = TIME()
c ------------------------------

       CALL SNANA_END()

c ###################
c  graceful end here

ccc      STOP
      CALL EXIT(0)
c ###################


c abort-end here

666   CONTINUE
      c1err = 'Fatal error in MAIN'
      CALL MADABORT("MAIN", c1err, "Check what gaver abort.")

cc      STOP
      CALL EXIT(0)

      END  ! end MAIN program



C ==========================================

+PATCH,*SNUTIL.

C ==========================================


+DECK,PARSE_SNANA_ARGS.
      SUBROUTINE PARSE_SNANA_ARGS()
c
c Nov 08, 2012
c Parse command-line arguments and store in LINE_ARGS array. 
c (code moved from main)
c
c May 2019: check option to call DUMP_SNANA_VERSION

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i

C ------------------- BEGIN ---------------

      NLINE_ARGS = IARGC()
      IF ( NLINE_ARGS .GT. MXLINE_ARGS ) THEN
         write(c1err,661) NLINE_ARGS
         write(c2err,662) MXLINE_ARGS

661      format(I3,' command-line arguments exceeds bound of')
662      format('MXLINE_ARGS = ', I4)

         CALL  MADABORT("PARSE_SNANA_ARGS", C1ERR, C2ERR)
      ENDIF

      DO i = 1, NLINE_ARGS
        CALL GETARG(i, LINE_ARGS(i) )  ! read command-line args
        USE_LINE_ARGS(i) = .FALSE.
      ENDDO

c check option to dump SNANA version and SNANA_DIR 
c (for SNANA_CodeTests.py)
c    snana.exe --snana_version

      IF ( LINE_ARGS(1) .EQ. '--SNANA_VERSION' .or.
     &     LINE_ARGS(1) .EQ. '--snana_version'  ) THEN
         CALL DUMP_SNANA_VERSION()
      ENDIF

c snana.exe GETINFO <VERSION_PHOTOMETRY>
      IF ( LINE_ARGS(1) .EQ. 'GETINFO' ) THEN
         VERSION_PHOTOMETRY(1) = LINE_ARGS(2)
         CALL DUMP_INFO_VERSION_PHOTOMETRY()
      ENDIF

      RETURN
      END   ! end PARSE_SNANA_ARGS


C ==================================
+DECK,DUMP_SNANA_VERSION.
      SUBROUTINE DUMP_SNANA_VERSION()

c Created May 2019
c Dump SNANA version and SNANA_DIR, then quit.

      IMPLICIT NONE
      INTEGER LL
      CHARACTER SNANA_VERSION*40, SNANA_DIR*200
      
      call GET_SNANA_VERSION(SNANA_VERSION,LL)
      LL = index(SNANA_VERSION, char(0) ) - 1
      print*,'SNANA_VERSION: ', SNANA_VERSION(1:LL)
      
      CALL GETENV ( 'SNANA_DIR', SNANA_DIR )
      LL = INDEX(SNANA_DIR,' ') - 1
      print*,'SNANA_DIR: ', SNANA_DIR(1:LL)

      CALL EXIT(0)

      RETURN
      END

C ======================================
+DECK,DUMP_INFO_VER_PHOT.
      SUBROUTINE DUMP_INFO_VERSION_PHOTOMETRY()

c Created Aug 29 2019
c dump path and format for VERSION_PHOTOMETRY; then quit.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.      

c local var
      CHARACTER VERSION*(MXCHAR_FILENAME) 
      INTEGER IERR, LEN
C -------------- BEGIN ------------   

      CALL CHECK_FORMAT(IERR)
      CALL GETINFO_PHOTOMETRY(1)

c - - - - - - - - - - - -
      VERSION = VERSION_PHOTOMETRY(1)
      LEN     = INDEX(VERSION,' ')-1
      write(6,20) 'VERSION:', VERSION(1:LEN)

      LEN = INDEX(SNDATA_PATH,' ') - 1
      write(6,20) 'SNDATA_PATH:', SNDATA_PATH(1:LEN)

      LEN = INDEX(SNLIST_FILE,' ') - 1
      write(6,20) 'LIST_FILE:', SNLIST_FILE(1:LEN)

 20   format(A, 2x, A)
c - - - - - - - - - - - -
      if ( FORMAT_TEXT ) then
         write(6,20) 'FORMAT:', 'TEXT'
      else
         write(6,20) 'FORMAT:', 'FITS'
      endif


      CALL FLUSH(6)
      CALL EXIT(0)

      RETURN
      END

C ==================================
+DECK,RDSNNML.
      SUBROUTINE RDSNNML(IERR)
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.

c
c Jan 5 2016: if NMLFILE = 'NOFILE', then skip reading file
c             and jump to SNLCINP_OVERRIDE. Allows running snana
c             with only command-line options and no nml file.
c
c Feb 27 2018: check CUTWIN_ZP
c
c ---------------

      INTEGER IERR   ! 0=>OK,  else error

c local ars

      integer i, ifilt, LL, ipar, NZPCUT
      character nmlfile_default*40, FNAM*8

c function
      INTEGER PARSE_NML_STRINGLIST

C -------------- BEGIN -----------
      IERR = 0

      CALL PRBANNER ( " READ SNLCINP NAMELIST. " )

      FNAM = 'RDSNNML'

c ----------------------------------------
c set namelist defaults

      DO i = 1, MXVERS
        VERSION_PHOTOMETRY(i) = 'NULL'
      ENDDO
      VERSION_REPLACE       = 'NULL'
      VERSION_REFORMAT_FITS = 'NULL'

      PRIVATE_DATA_PATH  = ' '
      FILTER_UPDATE_PATH = ' '
      OPT_REFORMAT_SALT2    = 0 
      OPT_REFORMAT_TERSE    = 0
      OPT_REFORMAT_TEXT     = 0
      OPT_REFORMAT_FITS     = 0 ! +=1 => write fits; +=2 =>save bad epochs
      REFORMAT_SAVE_BADEPOCHS = .FALSE.

      REFORMAT_KEYS     = 'NULL'

      NONSURVEY_FILTERS = ''
      SNRMAX_FILTERS    = ''  ! blank -> use all filters
      FILTER_REPLACE    = ''
      FILTLIST_LAMSHIFT = '' 

      VPEC_ERR_OVERRIDE = 0.0 

      JOBSPLIT(1) = 1
      JOBSPLIT(2) = 1

      JOBSPLIT_EXTERNAL(1) = 1
      JOBSPLIT_EXTERNAL(2) = 1

      SIM_PRESCALE   = 1.0
      OPTSIM_LCWIDTH = 0

      MNFIT_PKMJD_LOGFILE = 'MNFIT_PKMJD.LOG'

      SNMJD_LIST_FILE = ' '
      SNMJD_OUT_FILE  = ' '

      CUTWIN_MJD_EXCLUDE(1) = 0.0 
      CUTWIN_MJD_EXCLUDE(2) = 0.0 

      CUTWIN_MJD_INCLUDE(1) = -CUTVAL_OPEN
      CUTWIN_MJD_INCLUDE(2) = +CUTVAL_OPEN

      SNCUT_HOST_SBFLUX = ''
      SNCUT_SNRMAX = '' 
      EPCUT_SNRMIN = ''
      EPCUT_SKYSIG = ''
      EPCUT_PSFSIG = ''

      CUTWIN_NFIELD(1) = 1.0
      CUTWIN_NFIELD(2) = 999.0

      CUTWIN_NFILT_SNRMAX(1) = 1.0
      CUTWIN_NFILT_SNRMAX(2) = 100.

      CUTWIN_NFILT_SNRMAX2(1) = 1.0
      CUTWIN_NFILT_SNRMAX2(2) = 100.

      CUTWIN_NFILT_TRESTMIN(1) =   1.
      CUTWIN_NFILT_TRESTMIN(2) = 100.
      CUTWIN_NFILT_TRESTMAX(1) =   1.
      CUTWIN_NFILT_TRESTMAX(2) = 100.
      CUTWIN_NFILT_TREST2(1)   =   1.
      CUTWIN_NFILT_TREST2(2)   = 100.

      CUTWIN_LAMREST(1)      =  2000.  ! Angstroms
      CUTWIN_LAMREST(2)      = 25000.
      CUTWIN_LAMOBS(1)       =  2000.
      CUTWIN_LAMOBS(2)       = 25000.

      CUTWIN_NBAND_THRESH(1) = -9.0 !  obsolete as of Nov 15 2019
      CUTWIN_NBAND_THRESH(2) = -9.0

      do ifilt = 1, MXFILT_OBS
         CUTWIN_SNRMIN_FILT(1,ifilt) = -CUTVAL_OPEN
         CUTWIN_SNRMIN_FILT(2,ifilt) = +CUTVAL_OPEN
      enddo

c Setting ignore file to 'NONE' => do not read any file.
c Setting INGORE file to 'DEFAULT' is a flag to read
c epochs-to-ignore from $SNDATA_ROOT/lcmerge/[version].IGNORE

      EPOCH_IGNORE_FILE = 'DEFAULT' 

      KCOR_FILE   = 'NULL'

      hfile_out         = ' '
      rootfile_out      = ' '
      textfile_prefix   = ' '

      SNCID_LIST_FILE   = ' '
      MXEVT_PROCESS      = 999888777
      SIMLIB_OUT = ''
      SIMLIB_ZPERR_LIST = ''
      OPT_SIMLIB_OUT    = 1

      NONLINEARITY_FILE = ''

      DO i = 1, MXLISTNML
         SNTYPE_LIST(i)    = 0
         SNTYPE_IGNORE(i)  = 0
         CCDNUM_LIST(i)    = 0 
         SNCID_LIST(i)     = 0
         SNCID_IGNORE(i)   = 0
         SIM_TEMPLATE_INDEX_LIST(i) = 0 

         SNCCID_LIST(i)    = ''
         SNCCID_IGNORE(i)  = ''        
         SNCCID_PLOT(i)    = ''

         SNTEL_LIST(i)     = ''
         IDTEL_LIST(i)     = -9

         SNFIELD_LIST(i)     = ''
         IDFIELD_LIST(i)     = -9
      ENDDO

c set default telescope & field to ALL
      SNTEL_LIST(1)     = 'ALL'
      SNFIELD_LIST(1)   = 'ALL'

      NSNTYPE_LIST = 0
      NCCDNUM_LIST = 0
      NSNTYPE_IGNORE = 0

      NIDTEL_LIST = 0
      NIDFIELD_LIST = 0
      NCCID_LIST = 0
      NCID_LIST  = 0

      SNCID_IGNORE_FILE = ''

c set photometry-flag bits to reject;
c default is to reject nothing (accept everything)

      PHOTFLAG_MSKREJ(1) = 0
      PHOTFLAG_MSKREJ(2) = 0
      PHOTFLAG_MSKREJ(3) = 0
      PHOTFLAG_MSKREJ(4) = 0
      PHOTFLAG_MSKREJ(5) = 0

      SNCID_IGNORE(1)    = 0 

      MAGOBS_SHIFT_PRIMARY  = ''
      MAGOBS_SHIFT_ZP       = ''
      MAGREST_SHIFT_PRIMARY = ''
      MAGREST_SHIFT_ZP      = ''
      FILTER_LAMSHIFT       = '' 

      DO i = 1, 3
        MAGOBS_SHIFT_PRIMARY_PARAMS(i) = 0.0
        MAGOBS_SHIFT_ZP_PARAMS(i)      = 0.0
      ENDDO

      FUDGE_FLUXCAL_OFFSET = ''
      FUDGE_FLUXCAL_ERROR  = ''
      FUDGE_FLUXCAL_ERRPIX = ''
      FUDGE_MAG_ERROR      = ''
      FUDGE_MAG_COVERR     = ''
      FUDGE_HOSTNOISE_FILE = ''
      FLUXERRMODEL_FILE    = ''
      SIM_FLUXERRMODEL_FILE = ''
      FLUXERRMODEL_OPTMASK = 0 
      MAGCOR_FILE          = ''
      SIM_MAGCOR_FILE      = ''

      MWEBV_SCALE    = 1.0
      MWEBV_SHIFT    = 0.0
      OPT_MWCOLORLAW = -9   ! use default if not specified in &SNLCINP
      OPT_MWEBV      = -9   ! idem
      RV_MWCOLORLAW  = -9.0 ! idem

      REDSHIFT_FINAL_SHIFT = 0.0
      FLUXERRCALC_ZPTERR  = -9.9

      NFIT_ITERATION     = 0
      MINUIT_PRINT_LEVEL = -1  ! default is no MINUIT printing
      INTERP_OPT     = INTERP_LINEAR
      USE_MINOS      = .FALSE.  ! change from T to F, Jan 27 2017

      MXLC_FIT         = 999888777 
      MXLC_PLOT        = 100
      NCCID_PLOT       = 0
      DTOBS_MODEL_PLOT = 2.0  ! 2 day binning
 
      OPT_SETPKMJD      = 0
      SNRCUT_SETPKMJD   =  5.0 ! only for FLUXMAX2 option (Fmax-clump)
      MJDWIN_SETPKMJD   = 60.0 ! only for FLUXMAX2 option (Fmax-clump)

      OPT_DEBUG           = 0
      LDMP_SNFAIL         = .FALSE.
      LDMP_SNANA_VERSION  = .FALSE.
      LSIM_SEARCH_SPEC    = .FALSE.
      LSIM_SEARCH_ZHOST   = .FALSE.

      USESIM_SNIA   = .TRUE. 
      USESIM_SNCC   = .TRUE.
      USESIM_TRUEFLUX = .FALSE.

      RESTORE_DES3YR = .FALSE.

      USE_SNHOST_ZPHOT = .FALSE.
      USE_MWCOR        = .FALSE.  ! apply MWCOR to fit-model

c by default do NOT check for multiseason activity (Oct 2014)
      MULTISEASON_TGAP               = 1.0E9 
      MULTISEASON_NREJECT_OUTLIER    = 0
      MULTISEASON_CHI2RED_ACTIVE     =  5.0

      PHOTFLAG_DETECT   = 0 
      PHOTFLAG_TRIGGER  = 0
      APPLY_FLUXCOR_BUG = 1  ! keep bug until DES3YR papers published


      CUTWIN_NSEASON_ACTIVE(1) = -99.
      CUTWIN_NSEASON_ACTIVE(2) = +99.

      CUTWIN_CUTFLAG_REQEP(1) = 0.99
      CUTWIN_CUTFLAG_REQEP(2) = 1.01
   
c hard-wire cut on private cut-flag (Nov 4 2014)
      CUTWIN_CUTFLAG_PRIVATE(1) = 0.99
      CUTWIN_CUTFLAG_PRIVATE(2) = 1.01

      CUTWIN_CUTFLAG_SIMVAR(1) = 0.99
      CUTWIN_CUTFLAG_SIMVAR(2) = 1.01

      CUTWIN_CUTFLAG_USRCUTS(1) = 0.99
      CUTWIN_CUTFLAG_USRCUTS(2) = 1.01

c set reference cosmo params to defaults.
      H0_REF(1)   = H0_DEFAULT    * (1.0E6 * Parsec)
      H0_REF(2)   = H0ERR_DEFAULT * (1.0E6 * Parsec)
      OMAT_REF(1) = OMAT_DEFAULT
      OMAT_REF(2) = OMATERR_DEFAULT
      OLAM_REF(1) = OLAM_DEFAULT
      OLAM_REF(2) = OLAMERR_DEFAULT
      ORAD_REF(1) = ORAD_DEFAULT
      ORAD_REF(2) = 0.0
      W0_REF(1)   = W0_DEFAULT
      W0_REF(2)   = W0ERR_DEFAULT
      DWDA_REF(1) = DWDA_DEFAULT
      DWDA_REF(2) = DWDAERR_DEFAULT

c set LTEST logicals to false.

      LTEST_KCOR    = .FALSE.
      LTEST_INTERP  = .FALSE.
      LTEST_U3BAND  = .FALSE.
      LTEST_MAG     = .FALSE.

      DOBUG_LAMRANGE = .FALSE.

      ABORT_ON_NOEPOCHS  = .TRUE.
      ABORT_ON_BADAVWARP = .TRUE.
      ABORT_ON_BADZ      = .TRUE.
      ABORT_ON_BADKCOR   = .TRUE.
      ABORT_ON_BADSURVEY = .TRUE.
      ABORT_ON_BADFILTER = .TRUE.
      ABORT_ON_MARGPDF0  = .TRUE.
      ABORT_ON_TRESTCUT  = .TRUE. ! for photo-z fits only
      ABORT_ON_DUPLCID   = .TRUE.
      ABORT_ON_DUPLMJD   = .FALSE.  ! Jun 2017
      ABORT_ON_NOPKMJD   = .TRUE.
      ABORT_ON_BADHEADER = .TRUE.

      SNTABLE_LIST          = 'DEFAULT'  ! Sep 08 2014
      SNTABLE_FILTER_REMAP  = ''
      WRTABLEFILE_SIMVAR    = .TRUE.     ! Jul 17 2016
      WRTABLEFILE_ZPHOT     = .TRUE.     ! Mar 19 2018
      WRTABLEFILE_HOST_TEXT = .FALSE.    ! May 23 2019
      WRTABLEFILE_ERRCALC_TEXT = .FALSE. ! Oct 30 2019

c ----------------------------------------
c check command line arg for namelist file;
c if not given on command line, then ask for it.

      IF ( NLINE_ARGS .GE. 1 ) THEN
         CALL GETARG(1, LINE_ARGS(1) )  ! read command-line arg (namelist)
         nmlfile = LINE_ARGS(1)
         if ( nmlFile(1:6) .EQ. 'NOFILE' ) GOTO 400  ! Jan 5 2016

         goto 300
      ENDIF

c --------------------------------
c set default name based on which code.
      
+SELF,IF=SNFIT.
      nmlfile_default = 'snlc_fit.nml'
+SELF,IF=SNANA.
      nmlfile_default = 'snana.nml'
+SELF.

      LL = INDEX(nmlfile_default,' ' ) - 1

      nmlfile = ' '
      write(6,11) nmlfile_default(1:LL)
11    format(T5,'Enter namelist filename (CR=',A,') ==> ', $)

      read(5,12) nmlfile
12    format(A)
     
      IF ( nmlfile .EQ. ' ' ) THEN
           nmlfile = nmlfile_default
      ENDIF
      print*,' '

c read the nml

300   CONTINUE

      LL = INDEX(nmlfile,' ' ) - 1
      print*,'   Read namelist file: ', nmlfile(1:LL)

      OPEN (
     &    UNIT   = LUNNML
     &   ,file   = nmlfile
     &   ,status = 'OLD'
     &   ,ERR    = 900 
     &       )

      READ(LUNNML, NML=SNLCINP, ERR=901, END=902 )      
          
      CLOSE ( UNIT = LUNNML ) 

400   CONTINUE

c check for namelist over-rides from command line.

      CALL SNLCINP_OVERRIDE(IERR)
        IF ( IERR .NE. 0 ) RETURN

c check for cut on simulated search eff;
c if set, then require SEARCHEFF_MASK = 3 =>
c bits 1 & 2 are set.

      IF ( LSIM_SEARCH_SPEC ) THEN
        cutwin_searcheff_mask(1) = 2.9
        cutwin_searcheff_mask(2) = 3.1
      ENDIF

      IF ( LSIM_SEARCH_ZHOST ) THEN  ! Jun 19 2018
        cutwin_searcheff_mask(1) = 4.9
        cutwin_searcheff_mask(2) = 5.1
      ENDIF


+SELF,IF=SNANA.
      NFIT_ITERATION = 0
+SELF.

      WRITE ( 6 , NML = SNLCINP )
      CALL FLUSH(6)


+SELF,IF=SNFIT.
      IF ( NFIT_ITERATION .LE. 0 ) THEN
         write(c1err,821) NFIT_ITERATION
821      format('NFIT_ITERATION = ', I3 )
         C2ERR = 'NFIT_ITERATION must be > 0 (see &SNLCINP namelist).'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF
+SELF.

c -----------------------------------------
c Compute useful variables from namelist

c if no telescope (namelist SNTEL_LIST) is specified, 
c then use survey name by default

      NIDTEL_LIST = PARSE_NML_STRINGLIST(SNTEL_LIST,20)
      IF ( SNTEL_LIST(1) .NE. 'ALL' ) THEN
         C1ERR = 'SNTEL_LIST no longer allowed.'
         C2ERR = 'Remove SNTEL_LIST from &SNLCINP'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

      DOALL_SNTEL = ( SNTEL_LIST(1) .EQ. 'ALL' )

      NIDFIELD_LIST = PARSE_NML_STRINGLIST(SNFIELD_LIST,60)
      DOALL_SNFIELD = ( SNFIELD_LIST(1) .EQ. 'ALL' )


      i = 1 ; NSNTYPE_LIST=0
      DO WHILE ( SNTYPE_LIST(i) .GE. MNTYPE ) 
          NSNTYPE_LIST = NSNTYPE_LIST + 1
          i = i + 1
      END DO
      if ( NSNTYPE_LIST .GT. MXLISTNML ) then
          write(c1err,678) 'SNTYPE_LIST', NSNTYPE_LIST, MXLISTNML
678       format(A,2x,I3,' elements exceeds bound.')
          CALL  MADABORT(FNAM, C1ERR, ' ') 
      endif

      i = 1 ; NCCDNUM_LIST=0
      DO WHILE ( CCDNUM_LIST(i) > 0 ) 
          NCCDNUM_LIST = NCCDNUM_LIST + 1
          i = i + 1
      END DO

      i = 1 ; NSIM_TEMPLATE_INDEX_LIST=0
      DO WHILE ( SIM_TEMPLATE_INDEX_LIST(i) > 0 ) 
          NSIM_TEMPLATE_INDEX_LIST = NSIM_TEMPLATE_INDEX_LIST+1
          i = i + 1
      END DO

      i = 1 ; NSNTYPE_IGNORE=0
      DO WHILE ( SNTYPE_IGNORE(i) .GE. MNTYPE ) 
          NSNTYPE_IGNORE = NSNTYPE_IGNORE + 1
          i = i + 1
      END DO
      if ( NSNTYPE_IGNORE .GT. MXLISTNML ) then
          write(c1err,678) 'SNTYPE_IGNORE',NSNTYPE_IGNORE,MXLISTNML
          CALL  MADABORT(FNAM, C1ERR, ' ') 
      endif

c -----------------------------
c count entries in lists
      i = 1 ; NCID_LIST=0
      DO WHILE ( SNCID_LIST(i) .GE. 1 ) 
          i = i + 1
      END DO
      NCID_LIST = i - 1

      i = 1 ; 
      DO WHILE ( SNCCID_LIST(i) .NE. ' ' ) 
          CALL NMLCHECK_SNCCID("SNCCID_LIST",SNCCID_LIST(i))
          SNCCID_LIST_ALL(i) = SNCCID_LIST(i)
          i = i + 1
      END DO
      NCCID_LIST = i - 1

      if ( NCID_LIST>0 .or. NCCID_LIST>0 ) then
         CUTWIN_CID(1) = 0;  CUTWIN_CID(2) = 0
      endif

c - - - - - - - 

      i = 1 ; NCID_IGNORE=0
      DO WHILE ( SNCID_IGNORE(i) .GE. 1 ) 
          i = i + 1
      END DO
      NCID_IGNORE = i - 1

      i = 1
      DO WHILE ( SNCCID_IGNORE(i) .NE. ' ' ) 
          CALL NMLCHECK_SNCCID("SNCCID_IGNORE",SNCCID_IGNORE(i))
          i = i + 1
          SNCCID_IGNORE_ALL(i) = SNCCID_IGNORE(i)
      END DO
      NCCID_IGNORE = i - 1
      CALL  RDSNIGNORE          ! read IGNORE-list from user file


      NCCID_PLOT = PARSE_NML_STRINGLIST(SNCCID_PLOT,MXCHAR_CCID)


c ------------------------
c count number of photometry versions

      i = 1
      DO WHILE ( VERSION_PHOTOMETRY(i) .NE. 'NULL' )           
          N_VERSION = i
          if ( N_VERSION .GT. MXVERS ) then
            print*,'  ERROR: N_VERSION = ', N_VERSION,
     &                   ' exceeds array bound.'
            print*,'  ***** ABORT **** '
          CALL EXIT(EXIT_ERRCODE)
          endif
          i = i + 1
      END DO

c check units of H0

      if ( H0_REF(1) > 10.0 ) then
          H0_REF(1) = H0_REF(1) / ( 1.0E6 * Parsec )
          H0_REF(2) = H0_REF(2) / ( 1.0E6 * Parsec )
      endif

c Feb 27 2018: check ZP cut
      NZPCUT = 0
      if ( CUTWIN_ZPADU(1) > 0. ) then
         CUTWIN_ZP(1) = CUTWIN_ZPADU(1)
         CUTWIN_ZP(2) = CUTWIN_ZPADU(2)
         NZPCUT = NZPCUT+1
      endif
      if ( CUTWIN_ZPNPE(1) > 0. ) then
         CUTWIN_ZP(1) = CUTWIN_ZPNPE(1)
         CUTWIN_ZP(2) = CUTWIN_ZPNPE(2)
         NZPCUT = NZPCUT+1
      endif
      IF ( NZPCUT > 1 ) THEN
         C1ERR = 'Cannot specify both CUTWIN_ZPADU and CUTWIN_ZPNPE'
         C2ERR = 'Pick one of these CUTWIN_ZP options.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

c -----------------------------

      DO_FIT = NFIT_ITERATION .GT. 0

c init some INIXXX parameter for fit
      IF ( DO_FIT ) THEN
         do ipar = 1, MXFITPAR
            INIBND(1,ipar) =  -1.0E4  ! avoid crazy MINUIT excursions
            INIBND(2,ipar) =  +1.0E4
            INIVAL(ipar)   =  -9.0
            INISTP(ipar)   =   0.0
         enddo
      ENDIF

      IF ( MWEBV_SCALE .NE. 1.0 .or. MWEBV_SHIFT .NE. 0.0 ) THEN
         GLOBAL_BANNER = ''
         write(GLOBAL_BANNER,541) MWEBV_SCALE, MWEBV_SHIFT
541      format('Galactic MWEBV -> MWEBV *', F6.3,'  +  ', F6.3 )
        CALL PRBANNER ( GLOBAL_BANNER )
      ENDIF


c ---------------------------
      IF ( VERSION_REFORMAT_FITS .NE. 'NULL' ) THEN
        OPT_REFORMAT_FITS = IBSET(OPT_REFORMAT_FITS,0) ! set 1st bit
      ENDIF

c check for legacy key
      IF ( OPT_REFORMAT_TERSE > 0 ) THEN  ! allow legacy key
         OPT_REFORMAT_TEXT = OPT_REFORMAT_TERSE
      ENDIF

c check option to save bad epochs for OPT_REFORMAT
      IF ( BTEST(OPT_REFORMAT_FITS,1) .or. 
     &     BTEST(OPT_REFORMAT_TEXT,1) ) THEN 
         REFORMAT_SAVE_BADEPOCHS = .TRUE.
      ENDIF

c ---------------------------
c if ENV is in path, make substitution
      CALL ENVreplace(PRIVATE_DATA_PATH) 

c check 'pwd' option, which is meant to run split_and_fit on 
c different clusters using private data in your `pwd' .
c If interactive, replace invalid pwd/ with a valid './' path.

      IF ( PRIVATE_DATA_PATH .EQ. 'pwd' ) THEN
         PRIVATE_DATA_PATH = '.'
      ENDIF

c Nov 15 2019: abort on obsolete key
      IF ( CUTWIN_NBAND_THRESH(1) > -1.0 ) then
         C1ERR = 'Remove obsolete CUTWIN_NBAND_THRESH from &SNLCINP.'
         C2ERR = 'Sorry for the inconvenience.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

C #################################################

               RETURN

C #################################################

900   c1err = 'Could not open namelist file: '
      c2err = nmlfile(1:80)
      CALL  MADABORT(FNAM, C1ERR, C2ERR)
      GOTO 990

901   C1ERR = 'could not read &SNLCINP namelist'
      c2err = "Check input-namelist file."
      CALL  MADABORT(FNAM, C1ERR, C2ERR )
      GOTO 990

902   C1ERR = 'could not find &SNLCINP namelist'
      c2err = "Check input-namelist file."
      CALL  MADABORT(FNAM, C1ERR, C2ERR )
      GOTO 990


990   IERR = -1
      RETURN
      END  ! end of RDSNNML



C ======================================
+DECK,CHKBOUND.
      SUBROUTINE CHKARRBOUND(i,MIN,MAX, VARNAME, COMMENT, FUNNAME)

c Nov 2013
c One-line array bound check.
c Abort if index i is outside range MIN to MAX.
c Char input args are used for abort message.

      IMPLICIT NONE

      INTEGER i, MIN, MAX  ! (I) index, MIN,MAX of array
      CHARACTER 
     &   VARNAME*(*)  ! (I) name of variable
     &  ,COMMENT*(*)  ! (I) comment string
     &  ,FUNNAME*(*)  ! (I) name of calling function

c local var

      CHARACTER MSG1*80, MSG2*80

C ------------------- BEGIN ------------------

      IF ( i .GE. MIN .and. i .LE. MAX ) RETURN

      write(MSG1,61) VARNAME, i, MIN, MAX, FUNNAME
 61   format(A,'-index ',I4,' outside valid range ',I2,'-',I5, 3x,
     &          '(FUN=',A,')'  )

      MSG2 = COMMENT

      CALL  MADABORT("CHKARRBOUND", MSG1, MSG2)
 
      RETURN
      END

C ===================================
+DECK,CHKCCID.
      SUBROUTINE NMLCHECK_SNCCID(NMLVARNAME, CCID)

C Apr 26 2013
C Abort if CCID string contains a comma or blank space between
C strings. 
C For example, abort on strings such as
C  '04D46,05D446' ,  '04D46 05D446' 
C
C NMLVARNAME is the name of the namelist variable, 
C for error message only.
C
C ---------------- BEGIN --------------

      IMPLICIT NONE

      CHARACTER NMLVARNAME*(*)  ! (I) name of namelist variable
      CHARACTER CCID*(*)        ! (I) SN CID name
 
c local variables

+CDE,SNPAR.

      INTEGER   JCOMMA, NWD, LEN, MSKOPT
      CHARACTER MSG1*72, MSG2*72

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN -----------------

      JCOMMA   = INDEX(CCID,',')

      LEN      = INDEX(CCID,' ' ) - 1
      MSKOPT   = MSKOPT_PARSE_WORDS_STRING
      NWD      = STORE_PARSE_WORDS(MSKOPT,CCID(1:LEN)//char(0),LEN)

      IF ( JCOMMA > 0 .or. NWD > 1 ) THEN
         MSG1 = 'Invalid nml variable ' 
     &           // NMLVARNAME // ' = ' // CCID
         MSG2 = 'No blanks or commas allowed.'
         CALL  MADABORT("NMLCHECK_SNCCID", MSG1, MSG2)
      ENDIF

      RETURN
      END


C ========================================
+DECK,INIT_OUTFILES.
      SUBROUTINE  INIT_OUTFILES(NFIT_PER_SN)


c Created Feb 2012
c
c Call appropriate init function for hbook, root, etc ...
c Note that multiple output files can be initialized
c corresponding to different formats.
c If no files are opened, print warning message but do not abort.
c
c Note that NFIT_PER_SN is the max number of expected fits per SN.
c
c Apr 26 2014: replace HFILE_OPEN and ROOTFILE_OPEN with generic
c              wrapper TABLEFILE_OPEN.
c
c May  3, 2014: call SNLCPAK_INIT only if NFIT_PER_SN > 0
c May 12, 2014: overhaul the ascii format; see TEXTFILE_PREFIX.
c               rename SNFILE_OUT_INIT -> INIT_OUTFILES
c
c Sep 07, 2014: pass TEXTFORMAT to SNLCPAK_INIT()
c
c Dec 10 2017: if NFILT_REMAP_TABLE>0, pass REMAP list of filters
c              to SNLCPAK_INIT
c
c Dec 19 2019: pass SIMFLAG to SNLCPAK_INIT.
c
c ------------------------------------------------------

      IMPLICIT NONE

      INTEGER NFIT_PER_SN ! (I) max number of fits to plot per SN

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LENFILE,  IFILETYPE, SIMFLAG

      CHARACTER 
     &   FNAM*16
     &  ,COPT*20
     &  ,CFILE*(MXCHAR_FILENAME)
     &  ,TEXTFMT*20

      INTEGER LENV1, LENV2, LENSRVY, LENFILT, LENFMT, LENC
      CHARACTER 
     &   SURVEY_forC*(MXCHAR_SURVEY)
     &  ,VER_PHOT_forC*(MXCHAR_VERSION)
     &  ,VER_SNANA_forC*40
     &  ,FILTERS_forC*(MXFILT_OBS)
     &  ,TEXTFMT_forC*20
     &  ,COMMENT_forC*72

c function
      INTEGER TABLEFILE_OPEN
      
C --------------- BEGIN -------------

      FNAM = 'INIT_OUTFILES'

      CALL TABLEFILE_INIT();  ! 4/26/2014

c -----------------------------------------
c set strings needed for the SNLCPAK_INIT functio
 
      LENSRVY      = INDEX(SURVEY_NAME,' ') - 1
      SURVEY_forC  = SURVEY_NAME(1:LENSRVY) // char(0)

      LENV1         = INDEX(VERSION_PHOTOMETRY(1),' ') - 1
      VER_PHOT_forC = VERSION_PHOTOMETRY(1)(1:LENV1) // char(0)

      LENV2         = INDEX(SNANA_VERSION,' ') - 1
      VER_SNANA_forC = SNANA_VERSION(1:LENV2) // char(0)

      LENFILT      = INDEX(SURVEY_FILTERS,' ') - 1
      FILTERS_forC = SURVEY_FILTERS(1:LENFILT) // char(0)
      if ( NFILT_REMAP_TABLE > 0 ) then  ! Dec 2017
         LENFILT      = INDEX(FILTLIST_REMAP_TABLE,' ') - 1
         FILTERS_forC = FILTLIST_REMAP_TABLE(1:LENFILT) // char(0)
      endif

      TEXTFMT      = TEXTFORMAT_TABLE(ITABLE_SNLCPAK)
      LENFMT       = INDEX(TEXTFMT,' ') - 1
      TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)

      IF ( OPT_TABLE(ITABLE_SNLCPAK) > 0 ) THEN
         SIMFLAG = 0
         IF ( LSIM_SNANA .or. LSIM_MAGOBS ) SIMFLAG=1
         CALL SNLCPAK_INIT(SURVEY_forC, VER_PHOT_forC, VER_SNANA_forC,
     &        FILTERS_forC, SIMFLAG, NFIT_PER_SN, TEXTFMT_forC,
     &        LENSRVY, LENV1, LENV2, LENFILT, LENFMT )
      ENDIF

      IF ( OPT_TABLE(ITABLE_SPECPAK) > 0 ) THEN
         TEXTFMT      = TEXTFORMAT_TABLE(ITABLE_SPECPAK)
         LENFMT       = INDEX(TEXTFMT,' ') - 1
         TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)     
         CALL SPECPAK_INIT(SURVEY_forC, VER_PHOT_forC, TEXTFMT_forC,
     &          LENSRVY, LENV1, LENFMT )
      ENDIF

c -------------------------------------------

      USE_TABLEFILE        = .FALSE.
      USE_TABLEFILE_HBOOK  = .FALSE.  
      USE_TABLEFILE_ROOT   = .FALSE.      

      IF ( HFILE_OUT .NE. ' ' ) THEN
         COPT          = "new hbook" // char(0)
         USE_TABLEFILE_HBOOK = .TRUE.
         USE_TABLEFILE       = .TRUE.
         LENFILE   = INDEX(HFILE_OUT,' ') - 1
         CFILE     = HFILE_OUT(1:LENFILE) // char(0)
         IFILETYPE = TABLEFILE_OPEN(CFILE, COPT, LENFILE, 20)

         IF ( IFILETYPE < 0 ) THEN
            C1ERR = 'Could not open HBOOK table-file'
            C2ERR = HFILE_OUT(1:LENFILE)
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         ENDIF
      ENDIF

      IF ( ROOTFILE_OUT .NE. ' ' ) THEN
         COPT          = "new root" // char(0)
         USE_TABLEFILE_ROOT = .TRUE. 
         USE_TABLEFILE      = .TRUE.
         LENFILE   = INDEX(ROOTFILE_OUT,' ') - 1
         CFILE     = ROOTFILE_OUT(1:LENFILE) // char(0)
         IFILETYPE = TABLEFILE_OPEN(CFILE, COPT, LENFILE, 20)

         IF ( IFILETYPE < 0 ) THEN
            C1ERR = 'Could not open ROOT table-file'
            C2ERR = ROOTFILE_OUT(1:LENFILE)
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         ENDIF
      ENDIF


      IF ( TEXTFILE_PREFIX .NE. ' ' ) THEN
         COPT          = "new text" // char(0)
         USE_TABLEFILE_TEXT = .TRUE. 
         USE_TABLEFILE      = .TRUE.
         LENFILE   = INDEX(TEXTFILE_PREFIX,' ') - 1
         CFILE     = TEXTFILE_PREFIX(1:LENFILE) // char(0)
         IFILETYPE = TABLEFILE_OPEN(CFILE, COPT, LENFILE, 20)

         IF ( IFILETYPE < 0 ) THEN
            C1ERR = 'Could not open TEXT table-files with PREFIX='
            C2ERR = TEXTFILE_PREFIX(1:LENFILE)
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         ENDIF
      ENDIF


c ----------------------------------------
c Oct 23, 2014: store global comments

      LENC = 72

      COMMENT_forC = 'VERSION_SNANA      = ' //  VER_SNANA_forC 
      CALL STORE_TABLEFILE_COMMENT(COMMENT_forC, LENC)

      COMMENT_forC = 'VERSION_PHOTOMETRY = ' //  VER_PHOT_forC(1:40)
      CALL STORE_TABLEFILE_COMMENT(COMMENT_forC, LENC)

c ----------------------------------------
c     print warning message if there is no table file
      IF ( .not. USE_TABLEFILE ) THEN
         print*,' '
         write(6,60) 
         write(6,61) 
     &     'no table-file specified for tables and light curves'
         write(6,60) 
         print*,' '
 60      format(T3, 'WARNING: ', 30('<>') )
 61      format(T3, 'WARNING: ', A)
      ENDIF
      
      RETURN
      END   ! end of INIT_OUTFILES


C ================================================
+DECK,INIT_SNTABLE_OPT.
      SUBROUTINE INIT_SNTABLE_OPTIONS()
c
c Created May 2014 by R.Kessler
c
c Analyze user input string SNTABLE_LIST (&SNLCINP) and set the 
c following arrays vs. sparse ITABLE index:
c
c   OPT_TABLE         ! 0,1 --> on,off;  >1 --> other option
c   TEXTFORMAT_TABLE  ! key, csv, col, none
c
c This input string controls which tables are produced
c (SNANA, FITRES, SNLCPAK) and what text formats if 
c TEXTFILE_PREFIX is given. 
c
c Sep 08 2014: lots of updates
c Jul 12 2016: turn off tables if any reformat option is set.
c Jul 17 2016: 
c   + check for NOSIMVAR option (e..g, for blind tests)
c   + fix but to ensure WRTABLEFILE_IAUC is initialized to F
c
c Feb 19 2017: check SNTABLE_FILTER_REMAP
c
c Apr 26 2017: check pre-scale option: e.g.  'SNANA(ps:100)'
c Mar 19 2018: check nozphot option
c Jan 29 2019: serach for last non-null char in SNTABLE_LIST to get LENTB
c Jan 30 2019: MXTYPE -> 1000 (was 400)
c May 09 2019: 
c  + ITABLE_SPECTRA renamed to ITABLE_MODELSPEC (for SALT2 only)
c       (to avoid confusion with ITABLE_SPECPAK
c  + fix bug parsing options with comma; see new MSKOPT argument
c    to store_PARSE_WORDS()
c
c May 23 2019: add text:host    option ; see WRTABLEFILE_HOST_TEXT
c Oct 30 2019: add text:errcalc option ; see WRTABLEFILE_ERRCALC_TEXT
c
c -------------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   
     &   itab, iwd, LENS, LENTB, LENOPT, LEN1,LEN2, NOPT, iopt, 
     &   PS, NWD, i, MSKOPT

      CHARACTER USERSTRING*60, locase_STRING*60, TBNAME*60
      CHARACTER COPT_LIST(10)*20, COPT*40, FNAM*22, C_ARG*100
      CHARACTER cTMPOPT*60
      LOGICAL   MATCH, USEOPT, DO_SNTABLE

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

c ---------------- BEGIN ----------------

      FNAM = 'INIT_SNTABLE_OPTIONS'

c if reformating option is set, turn off all table output
      IF ( OPT_REFORMAT_SALT2 > 0 ) SNTABLE_LIST = ' '
      IF ( OPT_REFORMAT_FITS  > 0 ) SNTABLE_LIST = ' '
      IF ( OPT_REFORMAT_TEXT  > 0 ) SNTABLE_LIST = ' '

c init options to nothing created.

      DO itab = 1, MXTABLE
         OPT_TABLE(itab)          = 0
         PRESCALE_TABLE(itab)     = 1.0
      ENDDO

c Set default text format to output text-table for FITRES only:
c with default SNTABLE_LIST = 'SNANA  FITRES  LCPLOT' ,
c setting TEXTFILE_PREFIX  results in an ascii table for the 
c FITRES table only ... just as before. To get ascii table for 
c SNANA or LC, user must explicitly request it in the &SNLCINP
c namelist, SNTABLE_LIST = 'SNANA(text:[format])' and SNANA->LCPLOT.

      TEXTFORMAT_TABLE(ITABLE_SNANA)     = 'none'
      TEXTFORMAT_TABLE(ITABLE_FITRES)    = 'key'
      TEXTFORMAT_TABLE(ITABLE_SNLCPAK)   = 'none'
      TEXTFORMAT_TABLE(ITABLE_SPECPAK)   = 'none' ! Apr 2019
      TEXTFORMAT_TABLE(ITABLE_MODELSPEC) = 'none' 

      CUTMASK_SNANA_TABLE = 63  ! default is to add everything in snana table

c -------------------------
      CALL PRBANNER(FNAM)
c ----------------------------------------------
c If using default, replace 'DEFAULT' with actual default value.

      IF ( SNTABLE_LIST .EQ. 'DEFAULT' ) THEN
         SNTABLE_LIST = SNTABLE_LIST_DEFAULT
      ENDIF

c by default the SNID is written out as is
      WRTABLEFILE_IAUC = .FALSE.

c by default, SIM_XXX (truth) values are included for simulation
      WRTABLEFILE_SIMVAR = .TRUE.

c by default, ZPHOT[ERR] and ZPHOT-covariances are included
      WRTABLEFILE_ZPHOT  = .TRUE.

c for TEXT format, exclude HOSTGAL info by default
      WRTABLEFILE_HOST_TEXT = .FALSE.

c --------------------------------------
c bail of there is nothing to do.
      DO_SNTABLE = SNTABLE_LIST .NE. ' '
      IF ( .NOT. DO_SNTABLE    ) RETURN   

c ---------------------------------------
c parse SNTABLE_LIST string
  
      LENTB = 0
      DO i = 1, MXCHAR_FILENAME
        if ( SNTABLE_LIST(i:i) .NE. ' ' ) LENTB=i  ! last non-null char
      ENDDO
      C_ARG = SNTABLE_LIST(1:LENTB) // char(0)

      MSKOPT = MSKOPT_PARSE_WORDS_STRING+MSKOPT_PARSE_WORDS_IGNORECOMMA
      NWD   = STORE_PARSE_WORDS(MSKOPT, C_ARG, MXCHAR_FILENAME) 

      DO 100 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd, USERSTRING, LENS);

c convert everything to lower case for parsing so that
c the input is case-insensitive
         CALL loCase(USERSTRING, locase_STRING)

c split string into table name and optional option inside ().
c STRING is of the form "tbName(copt_list)".

         CALL PARSE_SNTABLE_LIST(locase_STRING, TBNAME, NOPT, COPT_LIST)

c check table-names

         if ( TBname(1:5) .EQ. 'snana' ) then
            ITAB = ITABLE_SNANA
            OPT_TABLE(ITAB) = 1
            if ( TBname(1:11) .EQ. 'snana+epoch' ) then
               OPT_TABLE(ITAB) = 2     ! include epoch info (Mar 2015)
            endif
            if ( TBname(1:16) .EQ. 'snana+sim_magobs' 
     &           .and. LSIM_SNANA) then
               OPT_TABLE(ITAB) = 4     ! include SIM_MAGOBS vs. MJD (1/2019)
            endif

         else if ( TBname(1:6) .EQ. 'fitres' ) then
            ITAB = ITABLE_FITRES
            OPT_TABLE(ITAB) = 1
            if ( TBname(1:15) .EQ. 'fitres+residual' ) then
               OPT_TABLE(ITAB) = 2     ! include epoch fit resids
            endif

         else if ( TBname(1:6) .EQ. 'lcplot' ) then 
            ITAB = ITABLE_SNLCPAK
            OPT_TABLE(ITAB) = 1

         else if ( TBname(1:8) .EQ. 'specplot' ) then  
            ITAB = ITABLE_SPECPAK  ! spectra in the data files
            OPT_TABLE(ITAB) = 1

         else if ( TBname(1:9) .EQ. 'modelspec' ) then 
            ITAB = ITABLE_MODELSPEC  ! SALT2 model spec
            OPT_TABLE(ITAB) = 1
         else if ( TBname(1:7) .EQ. 'spectra' ) then 
            ITAB = ITABLE_MODELSPEC  ! legacy key for SALT2 model spec
            OPT_TABLE(ITAB) = 1

         else if ( TBname(1:8) .EQ. 'nosimvar' ) then ! option, not a table
            WRTABLEFILE_SIMVAR = .FALSE.  ! July 2016

         else if ( TBname(1:7) .EQ. 'nozphot' ) then ! option, not a table
            WRTABLEFILE_ZPHOT = .FALSE.  ! Mar 2018

         else
            C1ERR = 'Unrecognized table name : ' // TBname(1:20)
            C2ERR = 'Check manual'
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         endif

c check for options inside ()
         DO 200 iopt = 1, NOPT
            COPT     = COPT_LIST(iopt)
            LENOPT   = index(COPT,' ') - 1
            USEOPT   = .FALSE.

            MATCH= ( copt(1:5) .EQ. 'text:' )
            if ( MATCH ) then
               cTMPOPT = copt(6:LENOPT) // ' '
               if( cTMPOPT(1:4) .EQ. 'host' ) then
                  WRTABLEFILE_HOST_TEXT = .TRUE.  ! for SNANA table  
               else if ( cTMPOPT(1:7) .EQ. 'errcalc' ) then
                  WRTABLEFILE_ERRCALC_TEXT = .TRUE.  ! for LCPLOT table
               else
                  TEXTFORMAT_TABLE(itab) = cTMPOPT(1:8) ! format
               endif
               USEOPT = .TRUE.
            endif

            MATCH = (copt(1:5) .EQ. 'mxlc:' )
            if ( MATCH  .and. ITAB .EQ. ITABLE_SNLCPAK) then
               read(copt(6:LENOPT),*) MXLC_PLOT
               USEOPT = .TRUE.
            endif

            MATCH = ( copt(1:8) .EQ. 'cutmask:' )
            if ( MATCH  .and. ITAB .EQ. ITABLE_SNANA ) then
               read(copt(9:LENOPT),*) CUTMASK_SNANA_TABLE
               USEOPT = .TRUE.
            endif

            MATCH = ( copt(1:4) .EQ. 'iauc' )
            if ( MATCH ) then
               WRTABLEFILE_IAUC = .TRUE.
               USEOPT           = .TRUE.
            endif

            MATCH = ( copt(1:2) .EQ. 'ps' ) 
            if ( MATCH ) then
               read(copt(4:LENOPT),*) PS
               PRESCALE_TABLE(itab) = DBLE(PS)
               USEOPT           = .TRUE.
            endif
          
            if ( .NOT. USEOPT ) then
               LENTB = index(TBNAME,' ') - 1
               C1ERR = 'Invalid option: ' // COPT(1:LENOPT)
               C2ERR = 'for Table = ' // TBNAME(1:LENTB)
               CALL  MADABORT(FNAM, C1ERR, C2ERR)               
            endif

 200     CONTINUE

 100  CONTINUE  ! end loop over table names

c ------------
c if LCPLOT is not specified, set MXLC_PLOT to zero.
      IF  ( OPT_TABLE(ITABLE_SNLCPAK) == 0 ) MXLC_PLOT = 0

c -------------
c summarize 

      ITAB = ITABLE_SNANA
      write(6,40) 'SNANA',  OPT_TABLE(ITAB), TEXTFORMAT_TABLE(ITAB)

      ITAB = ITABLE_FITRES
      write(6,40) 'FITRES', OPT_TABLE(ITAB), TEXTFORMAT_TABLE(ITAB)

      ITAB = ITABLE_SNLCPAK
      write(6,41) 'SNLCPAK', MXLC_PLOT, TEXTFORMAT_TABLE(ITAB)
      ITAB = ITABLE_SPECPAK
      write(6,41) 'SPECPAK', MXLC_PLOT, TEXTFORMAT_TABLE(ITAB)

      ITAB = ITABLE_MODELSPEC
      write(6,40) 'MODELSPEC', OPT_TABLE(ITAB),TEXTFORMAT_TABLE(ITAB)

 40   format(T5,A8,'-table: USE=',I1,       3x, 'TEXTFORMAT=',A4 )
 41   format(T5,A8,'-table: MXLC_PLOT=',I6, 3x, 'TEXTFORMAT=',A4 )

      write(6,51) 'SNANA', CUTMASK_SNANA_TABLE
51    format(T5,A8,'-table: select CUTFLAG_SNANA & ', I3 )

      if ( WRTABLEFILE_HOST_TEXT ) then
         print*,'   Include HOSTGAL info in TEXT tables.'
      endif

      if ( WRTABLEFILE_IAUC ) then
         print*,'    All tables: write CID=IAUC name instead of SNID '
      endif

      call flush(6)

c --------

c check option to remap filters for table output.
c e..g, multiple V-bands that are similar in different
c subsurveys can be combined into a single V band.
c See manual explanation of SNTABLE_FILTER_REMAP
      
      IF ( SNTABLE_FILTER_REMAP .EQ. '' ) THEN
        LEN1 = 0
      ELSE
        LEN1 = INDEX(SNTABLE_FILTER_REMAP,'->', BACK=.TRUE.) + 3
      ENDIF

      LEN2 = INDEX(SURVEY_FILTERS,' ') - 1

      CALL  FILTER_REMAP_INIT(
     &     SNTABLE_FILTER_REMAP(1:LEN1)//char(0),   ! (I) user-input string
     &     SURVEY_FILTERS(1:LEN2)//char(0),         ! (I) valid filters
     &     NFILT_REMAP_TABLE,           ! (O) number of remapped bands
     &     IFILTLIST_REMAP_TABLE,       ! (O) index list of remapped bands
     &     FILTLIST_REMAP_TABLE,        ! (O) string list of ...
     &     LEN1, LEN2, MXFILT_ALL )

      FILTLIST_REMAP_TABLE = 
     &  FILTLIST_REMAP_TABLE(1:NFILT_REMAP_TABLE) // ' ' 

c option to compute width variables
      CALL GET_SIM_LCWIDTH(0)

      RETURN
      END     ! end of INIT_SNTABLE_OPTIONS

C =================================
+DECK,GET_SIM_LCWIDTH.
      SUBROUTINE GET_SIM_LCWIDTH(MODE)

c Feb 2019
c For each filter, compute and store SIM_LCWIDTH(ifilt)
c
      IMPLICIT NONE
      INTEGER MODE  ! (I) 0=init, 1=get width

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER MXEP_LCWIDTH
      PARAMETER ( MXEP_LCWIDTH = 200)

      REAL*8  SIM_MAGOBS(MXEP_LCWIDTH), SIM_MJD(MXEP_LCWIDTH)
      REAL*8  WIDTH
      INTEGER 
     &  IFILT, IFILT_OBS, EP, EPMIN, EPMAX, NEWMJD, NOBS, ERRFLAG

      CHARACTER FNAM*16
c functions
      REAL*8   get_lightCurveWidth
      EXTERNAL INIT_LIGHTCURVEWIDTH, get_lightCurveWidth

C -------- BEGIN ----------
     
      FNAM = 'GET_SIM_LCWIDTH'
      IF ( OPTSIM_LCWIDTH == 0 ) RETURN
      IF ( .NOT. LSIM_SNANA    ) RETURN

      IF (MODE == 0 ) THEN
c  init only         
         CALL INIT_LIGHTCURVEWIDTH()
         RETURN
      ENDIF

c loop over each filter and strip off MJD and true MAG into
c separate array to pass to get_lightCurveWidth function.

      DO 100 ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         NOBS = 0
         DO 150  NEWMJD = 1, ISNLC_NEWMJD_STORE
            EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
            EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
            DO 151 EP = EPMIN, EPMAX
               if ( ISNLC_IFILT_OBS(ep) .NE. ifilt_obs ) goto 151
               NOBS = NOBS + 1
               SIM_MJD(NOBS)    = SNLC8_MJD(ep)
               SIM_MAGOBS(NOBS) = SIM_EPMAGOBS(ep)
151        CONTINUE
150      CONTINUE
        
         WIDTH = get_lightCurveWidth(OPTSIM_LCWIDTH,
     &               NOBS,SIM_MJD, SIM_MAGOBS, ERRFLAG, FNAM,16)
         SIM_LCWIDTH(ifilt) = SNGL(WIDTH)

c         print*,' xxx WIDTH: ', ifilt, ifilt_obs, WIDTH
 100  CONTINUE ! end IFILT loop

      RETURN
      END

C ========================================
+DECK,PARSE_SNTABLE_LIST.
      SUBROUTINE PARSE_SNTABLE_LIST(USERSTRING, TABLENAME, NOPT, COPT)

      IMPLICIT NONE

      CHARACTER  
     &   USERSTRING*(*)  ! (I) user-input string from SNTABLE_LIST
     &  ,TABLENAME*20    ! (O) name of table
     &  ,COPT(10)*20     ! (O) list of options

      INTEGER NOPT       ! (O) numbef of COPT options
  
      LOGICAL DONEXT

c local args

      INTEGER jp1, jp2, j, i, LENOPT
      CHARACTER COPT_LIST*60, CTMP*60 ! comma-separated list

C ----------------- BEGIN ----------------

c init output args
      TABLENAME = 'UNKNOWN'
      NOPT = 0
      do i = 1, 10
        COPT(i) = ''
      enddo

c ---------------------

      jp1  = index(USERSTRING,'(')
      jp2  = index(USERSTRING,')')
      if ( jp1 > 0 ) then
         TABLENAME  = USERSTRING(1:jp1-1)
         COPT_LIST  = USERSTRING(jp1+1:jp2-1)
      else
         TABLENAME  = USERSTRING
         RETURN
      endif
      
c if we get here then parse comma-separated list of options
c in COPT_LIST

      LENOPT = index(COPT_LIST,' ' ) - 1
      DONEXT = .TRUE.
      CTMP   = COPT_LIST

      DO 100 WHILE ( DONEXT ) 
         NOPT  = NOPT + 1
         j     = index(CTMP,',')
         if ( j .LE. 0  ) j = LENOPT + 1
         COPT(NOPT) = CTMP(1:j-1)
         DONEXT     = j < LENOPT
         CTMP       = CTMP(j+1:LENOPT)

         if ( NOPT > 10 ) then
            CALL  MADABORT("PARSE_SNTABLE_LIST", 
     &               'NOPT > 10 ???          ', 
     &               'Something is wrong     ' )
         endif
 100  CONTINUE

      RETURN
      END   ! end of PARSE_SNTABLE_LIST


C ================================================
+DECK,SNLCINP_OVERRIDE.
      SUBROUTINE SNLCINP_OVERRIDE(IERR)

c Feb 7, 2007
c
c Check command-line args for user-option to override
c namelist values.
c
c Nov 30, 2007: allow multiple photometry versions to 
c               be specified.
c
c Dec 4, 2009: read multiple "SNCID_IGNORE <CID>" commands
c
c Nov 12 2015: fix bug and read upper bound for CUTWIN_NFILT_SNRMAX[2]
c Apr 26 2017: add CUTWIN_PEAKMJD
c 
c Jan 25 2018: 
c   use PARSE_INTLIST to parse comma-separated lists for
c     SNCID_LIST, SNTYPE_LIST, CCDNUM_LIST, SNTYPE_IGNORE
c
c May 30 2019: call PARSE_NML_STRINGLIST for SNCCID_LIST
c
c ----------------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER IERR ! (O) 0 => OK

c local var

      INTEGER i, LL, ilast, iuse, NVERSLOC
      CHARACTER STRING_LIST*60
      LOGICAL LSNIGNORE

c functions
      INTEGER PARSE_INTLIST

C -------------- BEGIN --------------

      IERR = 0

      i = 2
      ilast = 2
      NVERSLOC = 0

      DO WHILE ( i .LT. NLINE_ARGS )

        LL = INDEX ( LINE_ARGS(i), ' ' ) - 1
        print*,'     PROCESS COMMAND LINE ARG: ', LINE_ARGS(i)(1:LL)
        CALL FLUSH(6)

         LSNIGNORE = ( LINE_ARGS(i) .EQ. 'SNCID_IGNORE' ) .or.
     &               ( LINE_ARGS(i) .EQ. 'SNCCID_IGNORE' )

         if ( LINE_ARGS(i) .EQ. 'VERSION_PHOTOMETRY' ) then
            i = i + 1   
            NVERSLOC = NVERSLOC + 1
            VERSION_PHOTOMETRY(NVERSLOC) = 
     &           LINE_ARGS(i)(1:MXCHAR_VERSION)

         else if ( LINE_ARGS(i) .EQ. 'VERSION_REPLACE' ) then
            i = i + 1   
            NVERSLOC = 1  ! ignore previous VERSION_PHOTOMETRY commands
            VERSION_PHOTOMETRY(NVERSLOC) = 
     &           LINE_ARGS(i)(1:MXCHAR_VERSION)

         else if ( LINE_ARGS(i) .EQ. 'VERSION_REFORMAT_FITS' ) then
            i = i + 1 ;
            VERSION_REFORMAT_FITS = LINE_ARGS(i)(1:MXCHAR_VERSION)
         else if ( LINE_ARGS(i) .EQ. 'OPT_REFORMAT_FITS' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) OPT_REFORMAT_FITS

         else if ( LINE_ARGS(i) .EQ. 'OPT_REFORMAT_TEXT' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) OPT_REFORMAT_TEXT

         else if ( LINE_ARGS(i) .EQ. 'PRIVATE_DATA_PATH' ) then
            i = i + 1
            PRIVATE_DATA_PATH = LINE_ARGS(i)(1:MXCHAR_PATH)

         else if ( LINE_ARGS(i) .EQ. 'PRIVATE_CUTWIN_STRING' ) then
            i = i + 1 
            PRIVATE_CUTWIN_STRING(1) = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'PRIVATE_REDSHIFT_CMB' ) then
            i = i + 1 ; PRIVATE_REDSHIFT_CMB = LINE_ARGS(i)(1:60)

         else if ( LINE_ARGS(i) .EQ. 'EARLYLC_STRING' ) then
            i = i + 1 
            EARLYLC_STRING = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'REQUIRE_EPOCHS_STRING' ) then
            i = i + 1 
            REQUIRE_EPOCHS_STRING = LINE_ARGS(i)(1:100)

         else if ( LINE_ARGS(i) .EQ. 'DUMP_STRING' ) then
            i = i + 1 
            DUMP_STRING = LINE_ARGS(i)(1:100)

         else if ( LINE_ARGS(i) .EQ. 'FILTER_UPDATE_PATH' ) then
            i = i + 1 
            FILTER_UPDATE_PATH = LINE_ARGS(i)(1:MXCHAR_PATH)

         else if ( LINE_ARGS(i) .EQ. 'NONSURVEY_FILTERS' ) then
            i = i + 1 
            NONSURVEY_FILTERS = LINE_ARGS(i)(1:MXFILT_ALL)

         else if ( LINE_ARGS(i) .EQ. 'FILTER_REPLACE' ) then
            i = i + 1 ; FILTER_REPLACE = LINE_ARGS(i)(1:MXFILT_ALL)

         else if ( LINE_ARGS(i) .EQ. 'FILTLIST_LAMSHIFT' ) then
            i = i + 1 ; FILTLIST_LAMSHIFT = LINE_ARGS(i)(1:MXFILT_ALL)

cc         else if ( LINE_ARGS(i) .EQ. 'ZPOFF_FILE' ) then
cc            i = i + 1 ; ZPOFF_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'USERTAGS_FILE' ) then
            i = i + 1 ; USERTAGS_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'VPEC_FILE' ) then
            i = i + 1 ; VPEC_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'HEADER_OVERRIDE_FILE' ) then
            i = i + 1 ; HEADER_OVERRIDE_FILE = LINE_ARGS(i)

         else if ( LSNIGNORE ) then

c add SNCID_IGNORE, using similar logic to VERSION_PHOTOMETRY
c to allow multiple specifications.

            i = i + 1   
            NCCID_IGNORE = NCCID_IGNORE + 1
            READ(LINE_ARGS(i),*) SNCCID_IGNORE_ALL(NCCID_IGNORE)
            if ( NCCID_IGNORE .GT. MXLISTNML ) then
               write(622,C1ERR) NCCID_IGNORE
622            format('NCCID_IGNORE=',I3,' exceeds array bound')
               C2ERR = 'Check SNCID_IGNORE and SNCCID_IGNORE args'
               CALL  MADABORT("SNLCINP_OVERRIDE", C1ERR, C2ERR)
            endif
 
         else if ( LINE_ARGS(i) .EQ. 'INTERP_OPT' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) INTERP_OPT

         else if ( LINE_ARGS(i) .EQ. 'KCOR_FILE' ) then
            i = i + 1 ; KCOR_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'HFILE_OUT' ) then
            i = i + 1 ; HFILE_OUT = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'ROOTFILE_OUT' ) then
            i = i + 1 ; ROOTFILE_OUT = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'TEXTFILE_PREFIX' ) then
            i = i + 1 ; TEXTFILE_PREFIX = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'SNTABLE_LIST' ) then
            i = i + 1 ; SNTABLE_LIST = LINE_ARGS(i)
         else if ( LINE_ARGS(i) .EQ. 'SNTABLE_FILTER_REMAP' ) then
            i = i + 1 ; SNTABLE_FILTER_REMAP = LINE_ARGS(i)
         else if ( LINE_ARGS(i) .EQ. 'OPTSIM_LCWIDTH' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) OPTSIM_LCWIDTH

         else if ( LINE_ARGS(i) .EQ. 'SNCID_IGNORE_FILE' ) then
            i = i + 1 ; SNCID_IGNORE_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'SNMJD_LIST_FILE' ) then
            i = i + 1 ; SNMJD_LIST_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'SNMJD_OUT_FILE' ) then
            i = i + 1 ; SNMJD_OUT_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'EPOCH_IGNORE_FILE' ) then
            i = i + 1  ; EPOCH_IGNORE_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'NFIT_ITERATION' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) NFIT_ITERATION

         else if ( LINE_ARGS(i) .EQ. 'USE_MINOS' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) USE_MINOS

         else if ( LINE_ARGS(i) .EQ. 'MINUIT_PRINT_LEVEL' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MINUIT_PRINT_LEVEL

         else if ( LINE_ARGS(i) .EQ. 'MXLC_PLOT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MXLC_PLOT

         else if ( LINE_ARGS(i) .EQ. 'DTOBS_MODEL_PLOT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) DTOBS_MODEL_PLOT

         else if ( LINE_ARGS(i) .EQ. 'PHOTFLAG_MSKREJ' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) PHOTFLAG_MSKREJ(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) PHOTFLAG_MSKREJ(2)

         else if ( LINE_ARGS(i) .EQ. 'PHOTFLAG_DETECT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) PHOTFLAG_DETECT
         else if ( LINE_ARGS(i) .EQ. 'PHOTFLAG_TRIGGER' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) PHOTFLAG_TRIGGER

         else if ( LINE_ARGS(i) .EQ. 'APPLY_FLUXCOR_BUG' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) APPLY_FLUXCOR_BUG

c -----------
         else if ( LINE_ARGS(i) .EQ. 'MULTISEASON_OPTMASK' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MULTISEASON_OPTMASK

         else if ( LINE_ARGS(i) .EQ. 'MULTISEASON_TGAP' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MULTISEASON_TGAP

         else if ( LINE_ARGS(i).EQ.'MULTISEASON_NREJECT_OUTLIER')then
            i = i + 1 ; READ(LINE_ARGS(i),*) MULTISEASON_NREJECT_OUTLIER

         else if ( LINE_ARGS(i).EQ.'MULTISEASON_CHI2RED_ACTIVE')then
            i=i+1 ; READ(LINE_ARGS(i),*) MULTISEASON_CHI2RED_ACTIVE

         else if ( LINE_ARGS(i).EQ.'CUTWIN_NSEASON_ACTIVE')then
            i=i+1 ; READ(LINE_ARGS(i),*) CUTWIN_NSEASON_ACTIVE(1)
            i=i+1 ; READ(LINE_ARGS(i),*) CUTWIN_NSEASON_ACTIVE(2)

c ----------

         else if ( LINE_ARGS(i) .EQ. 'LSIM_SEARCH_SPEC' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LSIM_SEARCH_SPEC

         else if ( LINE_ARGS(i) .EQ. 'LSIM_SEARCH_ZHOST' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LSIM_SEARCH_ZHOST
         else if ( LINE_ARGS(i) .EQ. 'LSIM_SEARCH_zHOST' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LSIM_SEARCH_ZHOST

         else if ( LINE_ARGS(i) .EQ. 'OPT_DEBUG' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) OPT_DEBUG

         else if ( LINE_ARGS(i) .EQ. 'LDMP_SNFAIL' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LDMP_SNFAIL

         else if ( LINE_ARGS(i) .EQ. 'USESIM_SNIA' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) USESIM_SNIA
         else if ( LINE_ARGS(i) .EQ. 'USESIM_SNCC' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) USESIM_SNCC
         else if ( LINE_ARGS(i) .EQ. 'USESIM_TRUEFLUX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) USESIM_TRUEFLUX

         else if ( LINE_ARGS(i) .EQ. 'RESTORE_DES3YR' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) RESTORE_DES3YR

         else if ( LINE_ARGS(i) .EQ. 'USE_MWCOR' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) USE_MWCOR

         else if ( LINE_ARGS(i) .EQ. 'USE_SNHOST_ZPHOT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) USE_SNHOST_ZPHOT

         else if ( LINE_ARGS(i) .EQ. 'LTEST_U3BAND' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LTEST_U3BAND

         else if ( LINE_ARGS(i) .EQ. 'LTEST_MAG' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LTEST_MAG

         else if ( LINE_ARGS(i) .EQ. 'LTEST_INTERP' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LTEST_INTERP

         else if ( LINE_ARGS(i) .EQ. 'LTEST_KCOR' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LTEST_KCOR

         else if ( LINE_ARGS(i) .EQ. 'OPT_SETPKMJD' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) OPT_SETPKMJD

         else if ( LINE_ARGS(i) .EQ. 'MJDWIN_SETPKMJD' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MJDWIN_SETPKMJD
         else if ( LINE_ARGS(i) .EQ. 'SNRCUT_SETPKMJD' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) SNRCUT_SETPKMJD

         else if ( LINE_ARGS(i) .EQ. 'DOBUG_LAMRANGE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) DOBUG_LAMRANGE

         else if ( LINE_ARGS(i) .EQ. 'SNCCID_LIST' ) then 
            i = i + 1 
            CALL PARSE_SNCCID_LIST(LINE_ARGS(i)) ! May 30 2019
            CUTWIN_CID(1) = 0;  CUTWIN_CID(2)=0

         else if ( LINE_ARGS(i) .EQ. 'SNCID_LIST' ) then
            i = i + 1 ; STRING_LIST = LINE_ARGS(i)(1:60)
            NCID_LIST = PARSE_INTLIST(STRING_LIST,SNCID_LIST)
            CUTWIN_CID(1) = 0;  CUTWIN_CID(2)=0

         else if ( LINE_ARGS(i) .EQ. 'SNCID_LIST_FILE' ) then
            i = i + 1 ; SNCID_LIST_FILE = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'MXEVT_PROCESS' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MXEVT_PROCESS

         else if ( LINE_ARGS(i) .EQ. 'SIM_TEMPLATE_INDEX_LIST' ) then
            i = i + 1 ; STRING_LIST = LINE_ARGS(i)(1:60)
            NSIM_TEMPLATE_INDEX_LIST = 
     &          PARSE_INTLIST(STRING_LIST,SIM_TEMPLATE_INDEX_LIST)

         else if ( LINE_ARGS(i) .EQ. 'SIMLIB_OUT' ) then
            i = i + 1 ; SIMLIB_OUT = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'SIMLIB_ZPERR_LIST' ) then
            i = i + 1 ; SIMLIB_ZPERR_LIST = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'OPT_SIMLIB_OUT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) OPT_SIMLIB_OUT

         else if ( LINE_ARGS(i) .EQ. 'NONLINEARITY_FILE' ) then
            i = i + 1 ; NONLINEARITY_FILE = LINE_ARGS(i)
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c         else if ( LINE_ARGS(i) .EQ. 'SNTEL_LIST' ) then
c           i = i + 1 ; SNTEL_LIST(1) = LINE_ARGS(i)(1:20)
c            SNTEL_LIST(2) = ' '
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
         else if ( LINE_ARGS(i) .EQ. 'SNFIELD_LIST' ) then
            i = i + 1 ; SNFIELD_LIST(1) = LINE_ARGS(i)(1:60)
            SNFIELD_LIST(2) = ' '

         else if ( LINE_ARGS(i) .EQ. 'JOBSPLIT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) JOBSPLIT(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) JOBSPLIT(2)

         else if ( LINE_ARGS(i) .EQ. 'JOBSPLIT_EXTERNAL' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) JOBSPLIT_EXTERNAL(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) JOBSPLIT_EXTERNAL(2)

         else if ( LINE_ARGS(i) .EQ. 'SIM_PRESCALE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) SIM_PRESCALE

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_CID' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_CID(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_CID(2)

         else if ( LINE_ARGS(i) .EQ. 'SNTYPE_LIST' ) then
            i = i + 1 ; STRING_LIST = LINE_ARGS(i)(1:60)
            NSNTYPE_LIST = PARSE_INTLIST(STRING_LIST,SNTYPE_LIST)

         else if ( LINE_ARGS(i) .EQ. 'CCDNUM_LIST' ) then
            i = i + 1 ; STRING_LIST = LINE_ARGS(i)(1:60)
            NCCDNUM_LIST = PARSE_INTLIST(STRING_LIST,CCDNUM_LIST)

         else if ( LINE_ARGS(i) .EQ. 'SNTYPE_IGNORE' ) then
            i = i + 1 ; STRING_LIST = LINE_ARGS(i)(1:60)
            NSNTYPE_IGNORE = PARSE_INTLIST(STRING_LIST,SNTYPE_IGNORE)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_NEPOCH' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_NEPOCH(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_NEPOCH(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TRESTMIN' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TRESTMIN(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TRESTMIN(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TRESTMAX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TRESTMAX(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TRESTMAX(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TRESTRANGE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TRESTRANGE(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TRESTRANGE(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TREST2' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TREST2(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TREST2(2)

c ---
         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TGAPMAX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TGAPMAX(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TGAPMAX(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_T0GAPMAX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_T0GAPMAX(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_T0GAPMAX(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TREST' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TREST(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TREST(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TOBS' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TOBS(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TOBS(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_PEAKMJD' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_PEAKMJD(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_PEAKMJD(2)

c -----
         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_MJD' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_MJD(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_MJD(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_MJD_EXCLUDE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_MJD_EXCLUDE(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_MJD_EXCLUDE(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_MJD_INCLUDE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_MJD_INCLUDE(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_MJD_INCLUDE(2)
c ---
         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TOBSMIN' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TOBSMIN(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TOBSMIN(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_TOBSMAX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TOBSMAX(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_TOBSMAX(2)
c ---
         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_REDSHIFT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_REDSHIFT(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_REDSHIFT(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_REDSHIFT_ERR' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) CUTWIN_REDSHIFT_ERR(1)
            i = i + 1 ;  READ(LINE_ARGS(i),*) CUTWIN_REDSHIFT_ERR(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_NFILT_TRESTMIN' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFILT_TRESTMIN(1)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_NFILT_TRESTMAX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFILT_TRESTMAX(1)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_NFILT_TREST2' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFILT_TREST2(1)

         else if ( LINE_ARGS(i) .EQ. 'SNCUT_SNRMAX' ) then
            i = i + 1
            SNCUT_SNRMAX = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'SNCUT_HOST_SBFLUX' ) then
            i = i + 1 
            SNCUT_HOST_SBFLUX = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'SIMVAR_CUTWIN_STRING' ) then
            i = i + 1 
            SIMVAR_CUTWIN_STRING = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_NFILT_SNRMAX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFILT_SNRMAX(1)
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFILT_SNRMAX(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_NFILT_SNRMAX2' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFILT_SNRMAX2(1)
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFILT_SNRMAX2(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_NFIELD' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFIELD(1)
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_NFIELD(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_MWEBV' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_MWEBV(1)
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_MWEBV(2)

c - - - - - -
         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_RESTLAM' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_RESTLAM(1)
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_RESTLAM(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_LAMREST' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_LAMREST(1)
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_LAMREST(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_LAMOBS' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_LAMOBS(1)
            i = i + 1 ; READ(LINE_ARGS(i),*)  CUTWIN_LAMOBS(2)
c - - - - - - - -

         else if ( LINE_ARGS(i) .EQ. 'EPCUT_SNRMIN' ) then
            i = i + 1 
            EPCUT_SNRMIN = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'SNRMAX_FILTERS' ) then
            i = i + 1 
            SNRMAX_FILTERS = LINE_ARGS(i)(1:MXFILT_ALL)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_SNRMAX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_SNRMAX(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_SNRMAX(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_SNRMAX2' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_SNRMAX2(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_SNRMAX2(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_PSF' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_PSF(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_PSF(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_ZPADU' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_ZPADU(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_ZPADU(2)
         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_ZPNPE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_ZPNPE(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_ZPNPE(2)

         else if ( LINE_ARGS(i) .EQ. 'CUTWIN_ERRTEST' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_ERRTEST(1)
            i = i + 1 ; READ(LINE_ARGS(i),*) CUTWIN_ERRTEST(2)

c ------------
         else if ( LINE_ARGS(i) .EQ. 'MAGOBS_SHIFT_PRIMARY' ) then
            i = i + 1 
            MAGOBS_SHIFT_PRIMARY = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'MAGOBS_SHIFT_ZP' ) then
            i = i + 1 
            MAGOBS_SHIFT_ZP = LINE_ARGS(i)(1:MXCHAR_CUTNAME)
c --
         else if ( LINE_ARGS(i) .EQ. 'MAGREST_SHIFT_PRIMARY' ) then
            i = i + 1 
            MAGREST_SHIFT_PRIMARY = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'MAGREST_SHIFT_ZP' ) then
            i = i + 1 
            MAGREST_SHIFT_ZP = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'FILTER_LAMSHIFT' ) then
            i = i + 1 
            FILTER_LAMSHIFT = LINE_ARGS(i)(1:MXCHAR_CUTNAME)
c --
         else if ( LINE_ARGS(i).EQ.'MAGOBS_SHIFT_PRIMARY_PARAMS' ) then
           i=i+1 ; READ(LINE_ARGS(i),*) MAGOBS_SHIFT_PRIMARY_PARAMS(1)
           i=i+1 ; READ(LINE_ARGS(i),*) MAGOBS_SHIFT_PRIMARY_PARAMS(2)
           i=i+1 ; READ(LINE_ARGS(i),*) MAGOBS_SHIFT_PRIMARY_PARAMS(3)

         else if ( LINE_ARGS(i) .EQ. 'MAGOBS_SHIFT_ZP_PARAMS' ) then
           i=i+1 ; READ(LINE_ARGS(i),*) MAGOBS_SHIFT_ZP_PARAMS(1)
           i=i+1 ; READ(LINE_ARGS(i),*) MAGOBS_SHIFT_ZP_PARAMS(2)
           i=i+1 ; READ(LINE_ARGS(i),*) MAGOBS_SHIFT_ZP_PARAMS(3)

c --------------
         else if ( LINE_ARGS(i) .EQ. 'FUDGE_FLUXCAL_OFFSET' ) then
            i = i + 1  
            FUDGE_FLUXCAL_OFFSET = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'FUDGE_FLUXCAL_ERROR' ) then
            i = i + 1 
            FUDGE_FLUXCAL_ERROR = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'FUDGE_FLUXCAL_ERRPIX' ) then
            i = i + 1 
            FUDGE_FLUXCAL_ERRPIX = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'FUDGE_MAG_ERROR' ) then
            i = i + 1 
            FUDGE_MAG_ERROR = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'FUDGE_MAG_COVERR' ) then
            i = i + 1 
            FUDGE_MAG_COVERR = LINE_ARGS(i)(1:MXCHAR_CUTNAME)

         else if ( LINE_ARGS(i) .EQ. 'FUDGE_HOSTNOISE_FILE' ) then
            i = i + 1 
            FUDGE_HOSTNOISE_FILE = LINE_ARGS(i)(1:MXCHAR_CUTNAME)  

         else if ( LINE_ARGS(i) .EQ. 'FLUXERRMODEL_FILE' ) then
            i = i + 1 
            FLUXERRMODEL_FILE = LINE_ARGS(i)(1:MXCHAR_FILENAME)  
         else if ( LINE_ARGS(i) .EQ. 'SIM_FLUXERRMODEL_FILE' ) then
            i = i + 1 
            SIM_FLUXERRMODEL_FILE = LINE_ARGS(i)(1:MXCHAR_FILENAME)  

         else if ( LINE_ARGS(i) .EQ. 'FLUXERRMODEL_OPTMASK' ) then
            i = i + 1 
            READ(LINE_ARGS(i),*) FLUXERRMODEL_OPTMASK

         else if ( LINE_ARGS(i) .EQ. 'MAGCOR_FILE' ) then
            i = i + 1 ; 
            MAGCOR_FILE = LINE_ARGS(i)(1:MXCHAR_FILENAME)
         else if ( LINE_ARGS(i) .EQ. 'SIM_MAGCOR_FILE' ) then
            i = i + 1 ; 
            SIM_MAGCOR_FILE = LINE_ARGS(i)(1:MXCHAR_FILENAME)
c -------------

         else if ( LINE_ARGS(i) .EQ. 'RV_MWCOLORLAW' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) RV_MWCOLORLAW
         else if ( LINE_ARGS(i) .EQ. 'OPT_MWCOLORLAW' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) OPT_MWCOLORLAW
         else if ( LINE_ARGS(i) .EQ. 'OPT_MWEBV' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) OPT_MWEBV

         else if ( LINE_ARGS(i) .EQ. 'MWEBV_SCALE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MWEBV_SCALE

         else if ( LINE_ARGS(i) .EQ. 'MWEBV_SHIFT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MWEBV_SHIFT

         else if ( LINE_ARGS(i) .EQ. 'REDSHIFT_FINAL_SHIFT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) REDSHIFT_FINAL_SHIFT

         else if ( LINE_ARGS(i) .EQ. 'VPEC_ERR_OVERRIDE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) VPEC_ERR_OVERRIDE

         else if ( LINE_ARGS(i) .EQ. 'FLUXERRCALC_ZPTERR' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) FLUXERRCALC_ZPTERR 

         else if ( LINE_ARGS(i) .EQ. 'H0_REF' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) H0_REF(1)

         else if ( LINE_ARGS(i) .EQ. 'OLAM_REF' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) OLAM_REF(1)

         else if ( LINE_ARGS(i) .EQ. 'OMAT_REF' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) OMAT_REF(1)

         else if ( LINE_ARGS(i) .EQ. 'W0_REF' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) W0_REF(1)

c ----
         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_BADSURVEY' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_BADSURVEY

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_BADFILTER' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_BADFILTER

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_NOEPOCHS' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_NOEPOCHS

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_NOPKMJD' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_NOPKMJD

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_BADAVWARP' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_BADAVWARP

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_BADKCOR' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_BADKCOR

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_MARGPDF0' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_MARGPDF0

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_TRESTCUT' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_TRESTCUT

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_DUPLCID' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_DUPLCID

         else if ( LINE_ARGS(i) .EQ. 'ABORT_ON_DUPLMJD' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) ABORT_ON_DUPLMJD

c ---

         endif

c set logical flag for used LINE_ARGS
 
         IF ( i .GT. ilast ) THEN
           DO iuse = ilast, i
              USE_LINE_ARGS(iuse) = .TRUE.
           ENDDO
         ENDIF

         i = i + 1
         ilast = i

      ENDDO

      RETURN
      END  ! end of SNLCINP_OVERRIDE

C ========================================
+DECK,MCMCINP_OVERRIDE.
      SUBROUTINE MCMCINP_OVERRIDE(IERR)

c Created Dec 4, 2009 R.Kessler
c
c Check command-line args for user-option to override
c &MCMCINP namelist values.
c
c ----------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,MCMCCOM.

      INTEGER IERR ! (O) 0 => OK

c local var
      INTEGER  i, LL, ilast, iuse

C -------------- BEGIN --------------

      IERR = 0

      i = 2
      ilast = 2

      DO WHILE ( i .LT. NLINE_ARGS )

        LL = INDEX ( LINE_ARGS(i), ' ' ) - 1

         if ( LINE_ARGS(i) .EQ. 'NMCMC_EVAL' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) NMCMC_EVAL

         else if ( LINE_ARGS(i) .EQ. 'IMCMC_FLAG' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) IMCMC_FLAG

         else if ( LINE_ARGS(i) .EQ. 'NMCMC_CHAINS' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) NMCMC_CHAINS 

         else if ( LINE_ARGS(i) .EQ. 'NMCMC_BURN' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) NMCMC_BURN

         else if ( LINE_ARGS(i) .EQ. 'MCMC_NSIG_STEP' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) MCMC_NSIG_STEP  

         else if ( LINE_ARGS(i) .EQ. 'CHOPT_MCMC' ) then
            i = i + 1 ; LINE_ARGS(i) = CHOPT_MCMC

         else if ( LINE_ARGS(i) .EQ. 'LMCMC' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) LMCMC

         else if ( LINE_ARGS(i) .EQ. 'LTUP_MCMC' ) then
            i = i + 1 ;  READ(LINE_ARGS(i),*) LTUP_MCMC 

         else if ( LINE_ARGS(i) .EQ. 'IMCMC_STORE' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) IMCMC_STORE

         else if ( LINE_ARGS(i) .EQ. 'NSIG_MCMC_START' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) NSIG_MCMC_START

         endif

c set logical flag for used LINE_ARGS
 
         IF ( i .GT. ilast ) THEN
           DO iuse = ilast, i
              USE_LINE_ARGS(iuse) = .TRUE.
           ENDDO
         ENDIF

         i = i + 1
         ilast = i

      ENDDO

      RETURN
      END   ! end of MCMCINP_OVERRIDE


C ========================================
+DECK,NNINP_OVERRIDE.
      SUBROUTINE NNINP_OVERRIDE()

c Created Apr 23, 2014 R.Kessler
c
c Check command-line args for user-option to override
c &NNINP namelist values.
c
c ----------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,NNCOM.

c local var
      INTEGER  i, LL, ilast, iuse

C -------------- BEGIN --------------

      i = 2
      ilast = 2

      DO WHILE ( i .LT. NLINE_ARGS )

         LL = INDEX ( LINE_ARGS(i), ' ' ) - 1

         if ( LINE_ARGS(i) .EQ. 'NEARNBR_TRAINFILE_PATH' ) then
            i = i + 1 ;  NEARNBR_TRAINFILE_PATH = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'NEARNBR_TRAINFILE_LIST' ) then
            i = i + 1 ; NEARNBR_TRAINFILE_LIST = LINE_ARGS(i)

         else if (LINE_ARGS(i).EQ.'NEARNBR_TRAINFILE_SCALE_NON1A') then
            i = i + 1 ; 
            READ(LINE_ARGS(i),*) NEARNBR_TRAINFILE_SCALE_NON1A

         else if ( LINE_ARGS(i) .EQ. 'NEARNBR_SEPMAX_VARDEF' ) then
            i = i + 1 ; NEARNBR_SEPMAX_VARDEF = LINE_ARGS(i)

         else if ( LINE_ARGS(i) .EQ. 'NEARNBR_TRUETYPE_VARNAME' ) then
            i = i + 1 
             NEARNBR_TRUETYPE_VARNAME = LINE_ARGS(i)(1:60)

         else if ( LINE_ARGS(i) .EQ. 'NEARNBR_TRAIN_ODDEVEN' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) NEARNBR_TRAIN_ODDEVEN

         else if ( LINE_ARGS(i) .EQ. 'NEARNBR_SEPMAX_IGNORE' ) then
            i = i + 1 
            NEARNBR_SEPMAX_IGNORE = LINE_ARGS(i)(1:40)

         else if ( LINE_ARGS(i) .EQ. 'NN_ITYPE_FIX' ) then
            i = i + 1 ; READ(LINE_ARGS(i),*) NN_ITYPE_FIX

         endif

c set logical flag for used LINE_ARGS
 
         IF ( i .GT. ilast ) THEN
           DO iuse = ilast, i
              USE_LINE_ARGS(iuse) = .TRUE.
           ENDDO
         ENDIF

         i = i + 1
         ilast = i

      ENDDO

      RETURN
      END


C ==================================
+DECK,PROCSNNML.
      SUBROUTINE PROCSNNML(IERR)
c
c Created May 17, 2008 by R.Kessler
c
c Translate namelist strings that depend on filters
c into cutwin_*filt(2,filt) variables.
c
c Must call after first event is read so that filters are defined.
c Note that RDKCOR is not called yet.
c
c
c Aug 31, 2010: 
c  - set new variables  NFILT_SNRMAX & IFILT_SNRMAX(i=1,NFILT_SNRMAX)
c  - CUTWIN_SNRMAX_FILT now depends on sparse ifilt_SNRMAX index
c
c Nov 15, 2011: new variables FUDGE_FLUXCAL_[OFFSET,ERROR]
c
c Mar 06, 2012: parse new variable SNCUT_HOST_SBFLUX
c Apr 02, 2014: parse SNRMAX_FILTERS, set LFILTDEF_SNRMAX
c Dec 16, 2018: parse SIMVAR_CUTWIN_STRING
c -----------------------------

      IMPLICIT NONE

      INTEGER IERR

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IAFILT(MXFILT_OBS)
      REAL    XAFILT(MXFILT_OBS)

      INTEGER ifiltdef, NF, i, ifilt, ifiltinv
      CHARACTER cfilt*2
      REAL TMP_ZP, TMP_PRIM
      LOGICAL LDMP, LTMP

c function
      INTEGER FILTINDX

C ---------------- BEGIN -------------

      IERR = 0
      CALL PARSE_FILTSTRING(1,SNCUT_SNRMAX, NF, iafilt, xafilt )
      NFILT_SNRMAX = NF
      if ( NFILT_SNRMAX .GT. MXFILT_SNRMAX ) then
         write(c1err,661) NFILT_SNRMAX, MXFILT_SNRMAX
661      format(I2,' SNRMAX cuts exceeds bound of MXFILT_SNRMAX=',I2)
         c2err = 'Check &SNLCINP variable SNCUT_SNRMAX'
         CALL  MADABORT("PROCSNNML", C1ERR, C2ERR)
      endif


      DO i = 1, NF
         ifiltdef = IAFILT(i)
         ifilt    = IFILTDEF_INVMAP_SURVEY(ifiltdef)
         cutwin_snrmax_filt(1,i) = xafilt(i) ! Aug 31, 2010
         ifilt_SNRMAX(i)         = ifiltdef  ! Aug 31, 2010
      ENDDO

c -------

      CALL PARSE_FILTSTRING(1,SNCUT_HOST_SBFLUX, NF, iafilt, xafilt )
      NFILT_HOST_SBFLUX = NF
      if ( NF .GT. MXFILT_SNRMAX/2 ) then
         write(c1err,662) NFILT_HOST_SBFLUX, MXFILT_SNRMAX/2
662      format(I2,' HOST_SBFLUX cuts exceeds bound of ',I2)
         c2err = 'Check &SNLCINP variable SNCUT_SNRMAX'
         CALL  MADABORT("PROCSNNML", C1ERR, C2ERR)
      endif

      DO i = 1, NF
         ifiltdef = IAFILT(i)
         ifilt    = IFILTDEF_INVMAP_SURVEY(ifiltdef)
         cutwin_sbflux_filt(1,i) = xafilt(i) ! Aug 31, 2010
         ifilt_HOST_SBFLUX(i)    = ifiltdef  ! Aug 31, 2010
      ENDDO

c ----------

      CALL PARSE_FILTSTRING(1,EPCUT_SNRMIN, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         ifilt    = IFILTDEF_INVMAP_SURVEY(ifiltdef)
         cutwin_snrmin_filt(1,ifilt) = xafilt(i)
      ENDDO

c ------
      CALL PARSE_FILTSTRING(0, MAGOBS_SHIFT_PRIMARY, NF,iafilt,xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         magobs_shift_primary_filt(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,MAGOBS_SHIFT_ZP, NF, iafilt, xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         magobs_shift_zp_filt(ifiltdef) = xafilt(i) 
         magobs_shift_zp_user(ifiltdef) = xafilt(i)
      ENDDO

c ---
      CALL PARSE_FILTSTRING(1,FUDGE_FLUXCAL_OFFSET, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_FLUXCAL_OFFSET_FILT(ifiltdef) = xafilt(i)
      ENDDO

c - - - -
      CALL PARSE_FILTSTRING(1,FUDGE_FLUXCAL_ERROR, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_FLUXCAL_ERROR_FILT(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,FUDGE_FLUXCAL_ERRPIX, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_FLUXCAL_ERRPIX_FILT(ifiltdef) = xafilt(i)
      ENDDO

c - - - 

      CALL PARSE_FILTSTRING(1,FUDGE_MAG_ERROR, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_MAG_ERROR_FILT(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,FUDGE_MAG_COVERR, NF, iafilt, xafilt )
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FUDGE_MAG_COVERR_FILT(ifiltdef) = xafilt(i)
      ENDDO

c --- REST FRAME
      CALL PARSE_FILTSTRING(0, MAGREST_SHIFT_PRIMARY, NF,iafilt,xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         magrest_shift_primary_filt(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,MAGREST_SHIFT_ZP, NF, iafilt, xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         magrest_shift_zp_filt(ifiltdef) = xafilt(i)
         magrest_shift_zp_user(ifiltdef) = xafilt(i)
      ENDDO

      CALL PARSE_FILTSTRING(1,FILTER_LAMSHIFT, NF, iafilt, xafilt)
      DO i = 1, NF
         ifiltdef = IAFILT(i)
         FILTER_LAMSHIFT_FILT(ifiltdef) = xafilt(i)
      ENDDO

c ------
      LDMP = .FALSE.

      do ifiltdef  = 1, MXFILT_ALL
         cfilt     = filtdef_string(ifiltdef:ifiltdef)
         tmp_zp    = MAGOBS_SHIFT_ZP_FILT(ifiltdef)
         tmp_prim  = MAGOBS_SHIFT_PRIMARY_FILT(ifiltdef)

         LTMP = ( tmp_zp .ne. 0.0 .or. tmp_prim .NE. 0.0 ) 
         if ( LDMP .and. LTMP ) then
           print*, 'DBUG: ', cfilt, ifiltdef
     &      , ' : MAGSHIFT_[ZP,PRIMARY] = ', tmp_zp, tmp_prim
         endif
      enddo

c -------
      NF = INDEX(SNRMAX_FILTERS,' ') - 1

      IF ( NF > 0 ) THEN
        
        do ifilt = 1, MXFILT_ALL
           LFILTDEF_SNRMAX(ifilt) = .FALSE.
        enddo
        do ifilt = 1, NF
           cfilt = SNRMAX_FILTERS(ifilt:ifilt)
           IFILTDEF = FILTINDX(cfilt)
           ifiltinv = IFILTDEF_INVMAP_SURVEY(ifiltdef)
           if ( ifiltinv < 1 ) then
              C1ERR = 'Invalid filter = ' // Cfilt
              C2err = 'Check &SNLCINP variable SNRMAX_FILTERS = ' 
     &                   // SNRMAX_FILTERS(1:NF)
              CALL  MADABORT("PROCSNNML", C1ERR, C2ERR)              
           endif
           LFILTDEF_SNRMAX(ifiltdef) = .TRUE.
        enddo

      ENDIF


c ------------------------------------------------------------
c Dec 2018: check for cuts on SIMVAR (e.g., SIM_c, SIM_ZCMB)

      CALL PARSE_SIMVAR_CUTS()

      RETURN
      END  ! end PROCSNNML


C ==================================
+DECK,RDSNIGNORE.
      SUBROUTINE RDSNIGNORE
c
c Nov 10, 2008
c Read file SNCID_IGNORE_FILE and load logical array LSNCID_IGNORE
c This is designed for the thousands of SDSS-II candidates,
c so that large numbers of candidates can be ignored from a 
c list file.
c
c Dec 4 2012: 
c  read char CCID intead of float CID, and increment nml array
c  SNCCID_IGNORE. WARNING: not tested.
c
c Sep 2 2019: allow up to MXIGNORE_LIST=500 (instead of 52)
c
c --------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER CCID*(MXCHAR_CCID), cFILE*(MXCHAR_FILENAME)
      INTEGER i, NIGNORE, LENFILE, LENCID, NWD

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
C ------------- BEGIN ---------

      IF ( SNCID_IGNORE_FILE .EQ. ' ' ) RETURN

      CALL ENVreplace(SNCID_IGNORE_FILE)
      LENFILE   = INDEX(SNCID_IGNORE_FILE,' ') - 1
      cFILE     = SNCID_IGNORE_FILE(1:LENFILE)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, cFILE, LENFILE) 

      LENCID = INDEX(CCID,' ')-1

      NIGNORE = 0

      DO i = 1, NWD

         CALL get_PARSE_WORD_fortran(i, CCID, LENCID)

         NCCID_IGNORE = NCCID_IGNORE + 1
cc xxx mark delete     SNCCID_IGNORE(NCCID_IGNORE) = CCID
         SNCCID_IGNORE_ALL(NCCID_IGNORE) = CCID

         NIGNORE = NIGNORE + 1

         IF ( NCCID_IGNORE > MXIGNORE_LIST ) then
           write(c1err,661 ) NCCID_IGNORE
           write(c2err,662 ) MXIGNORE_LIST
           CALL  MADABORT("RDSNIGNORE", C1ERR, C2ERR)
         endif
661        format('NCCID_IGNORE=',I4,' exceeds bound.')
662        format('Check limit MXIGNORE_LIST = ', I4 )
        
      ENDDO

      print*,' '
      print*,' ------------------------------------------------ '
      print*,' Loaded ', NIGNORE,' IGNORE-candidates from '
      print*, '  ', SNCID_IGNORE_FILE(1:LENFILE)
      print*,' '

      RETURN
      END

C ====================================
+DECK,PRBANNER.
      SUBROUTINE PRBANNER ( banner )
      IMPLICIT NONE

      character banner*(*)

      print*,' '
      print*,
     &   ' ######################################################## '
      print*,'   ', BANNER

      print*,
     &   ' ######################################################## '

      print*,' '
      CALL FLUSH(6)

      RETURN
      END

C ========================================
+DECK,PR_SNSTATS.
      SUBROUTINE PRINT_SNSTATS   
c
c Print SN stats : reaad and passing cuts.
c If no SN pass cuts, list cut(s) that always fail.
c
c Get <z> and RMS from hid 11
c
c Mar 15, 2010: Fix bug at 'write(6,66)' : add CUTBIT_CID
c
c Oct 21, 2010: if CID cut always fails, print only that message;
c               suppress spurious messages about other cut failures.
c
c Jul 20, 2012: print WARNING message if NACCEPT_TYPE = 0
c
c Jan 3, 2013: call PRINT_NPASSCUTS to see how many SN pass vs. cut.
c
c Aug 18, 2013: remove check on redshift cut.
c
c Apr 26, 2017: I6 -> I7 in format 48.

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

      integer icut, i,  JDIFF
      LOGICAL LTEST, LFAIL
     
      REAL Tsn, Ttot, f_dupl

C ------------ BEGIN --------------

      global_banner = 'Job Summary '
      CALL PRBANNER ( GLOBAL_BANNER )

c ----------------------------------------------
c Start with Npasscut vs. ICUT, and for each type.

      CALL PRINT_NPASSCUTS()

c ------------------------
      write(6,48) N_SNLC_CUTS, N_SNLC
48    format(/,T5,'Finished processing ',I7,
     &   ' SN after snana  cuts',
     &    3x,'(',I7,' before cuts)'  )
      CALL FLUSH(6)

c Oct 21, 2010: skip other "NEVER FOUND" message if CID cut always fails
      IF ( NACCEPT_CID .EQ. 0 ) GOTO 600

c check for valid SNTYPES (Jul 2012)
      LFAIL = NSNTYPE_LIST .GT. 0 .and. NACCEPT_TYPE .LE. 0
      IF ( LFAIL ) THEN
         print*,' '
         print*,' WARNING-SNTYPE: ',
     &       'NEVER FOUND A VALID SNTYPE ?!?!?! '
         print*,' WARNING-SNTYPE: Check nml variable SNTYPE_LIST = ', 
     &        SNTYPE_LIST(1), SNTYPE_LIST(2)
         print*,' '
      ENDIF


+SELF,IF=CCDLATER.
c Need to define NACCEPT_CCDNUM, and increment it.
c check for valid CCDNUM
      LFAIL = NCCDNUM_LIST .GT. 0 .and. NACCEPT_CCDNUM .LE. 0
      IF ( LFAIL ) THEN
         print*,' '
         print*,' WARNING-CCDNUM: ',
     &       'NEVER FOUND A VALID CCDNUM ?!?!?! '
         print*,' WARNING-CCDNUM: Check nml variable CCDNUM_LIST = ', 
     &        CCDNUM_LIST(1), CCDNUM_LIST(2)
         print*,' '
      ENDIF
+SELF.

c print fit-cut stats
      if ( N_SNLC_FIT .GT. 0 ) then
        write(6,49) N_SNLC_FITCUTS
49      format(T5,'Finished processing ',I6,
     &   ' SN after fitter cuts' )
      endif

c if no supernova pass cuts, look for cuts that always fail.

         print*,' '

600   CONTINUE

      IF ( NACCEPT_CID .EQ. 0 ) THEN
         write(6,66)  CUTBIT_CID, 'CID'
         print*,'     check CUTWIN_CID and SNCID_LIST in &SNLCINP'

      ELSE IF  ( N_SNLC_CUTS .EQ. 0 ) THEN
        DO icut = 1, CUTBIT_MJD_MARKER          
          LTEST = BTEST ( CUTMASK8_SN_ALL , icut-1 )
          if ( LTEST .and. NACCEPT_CUT(icut) .EQ. 0 ) then
             i = INDEX(cutvar_name(icut), ':' )
             write(6,66) icut, cutvar_name(icut)(1:i-1)
          endif
        ENDDO
      ENDIF
66    FORMAT(T5,'** WARNING ** EVERY SN FAILS CUTBIT ', I3,
     &       ' :  ', A )

c -----------------------------------


      write(6,170) NEPOCH_BADPHOT_SUM, NEPOCH_TOT
170   format(T5,'Bad PHOTOMETRY FLAG for ',I8,' of ', I8,' epochs')

         print*,' '
c -------------------------------------------------
c print out processing time, and process time per SN.

      JDIFF = JTIME_LOOPSTART - JTIME_START
      print*,'   TOTAL  INIT   TIME : ', JDIFF,' seconds '

      JDIFF = JTIME_LOOPEND - JTIME_LOOPSTART
      Ttot = float(JDIFF)/60. 
      if ( N_SNLC_CUTS .GT. 0 ) then
        Tsn   = float(JDIFF)/float(N_SNLC_CUTS)
      else
        Tsn = 0.0
      endif

      write(6,30) Ttot, Tsn
30    format(T5,'TOTAL PROCESS TIME : ',F7.2,' minutes ',4x,
     &      '(',F6.2,' sec per SN)' )

         print*,' '
      CALL FLUSH(6)

c --------------------------
c print DUPLICATE-CID WARNING

      IF ( N_DUPLICATE_CID > 0 ) THEN
         f_dupl = float(N_DUPLICATE_CID)/ float(N_SNLC)
         write(6,60)
         write(6,60)
         write(6,606) N_DUPLICATE_CID, 100.*f_dupl
         write(6,60)
         write(6,60)
 606     format(/, T5,'SEVERE WARNING: rejected ',I4,' Duplicate CIDs',
     &          3x,'(',F6.2,'%)', / )
      ENDIF

60      format(T2, 32('@-') )

c print DUPLICATE-MJD WARNING
      IF ( N_DUPLICATE_MJD > 0 ) THEN
         f_dupl = float(N_DUPLICATE_MJD)/ float(NEPOCH_TOT)
         write(6,60)
         write(6,60)
         write(6,616) N_DUPLICATE_MJD, 100.*f_dupl
         write(6,617) NSTORE_DUPLICATE_MJD
         write(6,60)
         write(6,60)
         call flush(6)
 616     format(/,T5,'SEVERE WARNING: FOUND ',I4,' Duplicate MJD+BAND',
     &          3x,'(',F6.3,'%)' )
 617     format(T20,I4,' Duplicate MJDs are unique', /)
      ENDIF
      
      RETURN
      END   ! end PRINT_SNSTATS


C =======================
+DECK,PRNCUTS.
      SUBROUTINE PRINT_NPASSCUTS()

c
c Jan 3, 2013
c
c Print Number of SN passing each incremental cut, and for each type.
c Table has up to 6 types, if more then make new table so that
c table does not exceed 80 columns.
c
c Feb 22, 2013: fix to work for TYPE=0
c
c For ITYPE=-1, write string 'ALL' to be more clear about meaning.
c
c Jun 19 2019: incluce ROWKEY = "CUTSTAT:" to make log file parsable.
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,CTRLCOM.
+CDE,SNLCINP.

      LOGICAL USETYPE(-1:MXTYPE), LPRIN

      INTEGER 
     &   ITYPE, NTYPE, ITYPE_LIST(MXTYPE)
     &  ,I1, I2, i, icut
     &  ,NTYPE_PER_TABLE
     &  ,N, NLAST, jcolon

      CHARACTER CUTNAME*28, ROWKEY*8

C ------------- BEGIN -------------

c first get list of used TYPES
      NTYPE = 0
      DO itype = -1, MXTYPE
        USETYPE(itype) = .FALSE.
        if (  NPASSCUT_INCREMENT(itype,1) .GT. 0 )  then
           USETYPE(itype) = .TRUE.
           NTYPE =  NTYPE + 1
           ITYPE_LIST(NTYPE) = ITYPE           
        endif
      ENDDO

c print table header

      ROWKEY = "CUTSTAT:"

      print*,'                         ', 
     &      'Number of SN passing incremental cut for'
 
      NTYPE_PER_TABLE = 6
      DO  777 I1 = 1, NTYPE, NTYPE_PER_TABLE

        write(6,20) ROWKEY, 'CUT-NAME      ITYPE='
20      format(A, 2x, A20, $)

        I2   = MIN(I1+NTYPE_PER_TABLE-1,NTYPE)
        DO i = I1, I2
           itype = ITYPE_LIST(i)

           if ( itype .EQ. -1 ) then	
              write(6,27) 'ALL'
           else
              write(6,28) ITYPE
           endif
 27        format(A8,$)
 28        format(I8,$)
        ENDDO 
        print*,' '
        write(6,80)
80      format(T2,  72('-') )
      

        DO 888 ICUT = 1, NCUTBIT_SNLC 

           if ( .NOT. LSIM_SNANA .and. icut.EQ.CUTBIT_SEARCH ) goto 888

c print line if any entry has a change in NPASSCUT
           LPRIN = .FALSE.
           IF ( ICUT .EQ. 1 ) THEN
              LPRIN = .TRUE.
           ELSE
              DO i = I1, I2
                itype = ITYPE_LIST(i)
                NLAST = NPASSCUT_INCREMENT(itype,icut-1)
                N     = NPASSCUT_INCREMENT(itype,icut)
                if ( N .LT. NLAST ) LPRIN = .TRUE.
              ENDDO
           ENDIF
           IF ( LPRIN ) THEN            
              jcolon    = INDEX(cutvar_name(icut), ':' )
              CUTNAME   = CUTVAR_NAME(icut)(1:jcolon-1) ! remove ':'
              write(6,20) ROWKEY, CUTNAME  
              DO i = I1, I2
                itype = ITYPE_LIST(i)
                write(6,28) NPASSCUT_INCREMENT(itype,icut)
              ENDDO
              print*,' '            
           ENDIF
888     CONTINUE

c for fit, write number passing fit cuts.

        IF ( NFIT_ITERATION > 0 ) THEN
            CUTNAME = 'FIT+CUTS'
            write(6,20) ROWKEY, CUTNAME            
            DO i = I1, I2
               itype = ITYPE_LIST(i)
               write(6,28) NPASSCUT_FIT(itype)
            ENDDO
        ENDIF
              print*,' '  
              print*,' '   
777   CONTINUE

      write(6,80)
      RETURN
      END

C ======================================
+DECK,SNANA_DRIVER.
      SUBROUTINE SNANA_DRIVER(ISN)

c Created May 18, 2012 by R.Kessler
c
c Analysis driver for SN with sparse index ISN.
c Move code from MAIN to here so that each SN is fit
c right after it is read.
c
c Dec 4 2012: call new function USRINI2()
c
c Dec 11, 2012: move MON_SNANA(1) call to end after USRANA call.
c               i.e, call monitor after everything has been analyzed.
c
c Jan 2 2013:
c    if LSNCUTS=F  or LSNFITOK=F, then call MON_SNANA(1) before RETURN.
c    Allows ntuple update for CUTFLAG=0 to allow examining
c    why SN fails cuts.
c
c Jan 4, 2013: replace local ISTAT_FITANAN with global ERRFLAG_FIT
c              so that it goes into the SNANA ntuple (7100).
c              Invert logic so that ERRFLAG_FIT=0 is success
c              rather than failure.
c
c Nov 29 2014: move USRINI2 function at end of IF-bloc, after
c              MON_SNANA.
c
c Nov 29 2016: 
c   + remove function call to PRIVATE_CHECK.
c   + add call to EXEC_HEADER_OVERRIDE.
c          
c Dec 9 2017: 
c   + call REJECT_PRESCALE() here so that we don't do Bazin/PEAKMJD fit
c     for every prescale-rejected event.
c
c Jun 21 2018:
c   if ERRFLAG_FIT > 0 on any iteraton, REJECT fit immediately
c   See REJECT_FIT logical.
c
c ----------------------

      IMPLICIT NONE

      INTEGER ISN  ! (I) SN sparse index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,SNCONTCM.
+CDE,NNCOM.

+SELF,IF=SNFIT.
      INTEGER NCALL_MNFIT, ITER
      LOGICAL LAST_ITER, REJECT_FIT
+SELF.

      INTEGER IERR
      REAL*8  PS8
      LOGICAL REJECT_PRESCALE, USE_MINOS_LOCAL
      CHARACTER FNAM*14

c ----------------- BEGIN -------------

      FNAM = 'SNANA_DRIVER' 

c make sure required header elements are there
      CALL HEADMASK_CHECK(SNLC_CCID)

      if ( LSIM_SNANA ) THEN
         PS8 = DBLE(SIM_PRESCALE)
         if ( REJECT_PRESCALE(N_SNLC,PS8) ) RETURN

c Apr 2019: special NNtrain option to pick only EVEN CID
         if ( NEARNBR_TRAIN_ODDEVEN ) then
            if ( MOD(SNLC_CID,2) .EQ. 1 ) RETURN
         endif
      endif

c check option to fetch vPec from file
      CALL RD_VPEC_FILE(0)

c check option to override header values (Nov 29 2016)
      CALL EXEC_HEADER_OVERRIDE()

c - - - - - - - - - - - 
      NCALL_SNANA_DRIVER  = NCALL_SNANA_DRIVER  + 1

c one-time init after first event is read.      

      IF ( NCALL_SNANA_DRIVER .EQ. 1 )  THEN

        CALL MON_SNANA(IFLAG_INI)     ! book 1d distributions    

+SELF,IF=SNFIT.
        CALL FITPAR_INI2(IERR)
+SELF.

+SELF,IF=PSNID.
        CALL PSNIDINI2(IERR)
+SELF.

        CALL USRINI2(IERR)        ! generic user function (Dec 2012)        

          if ( IERR .NE. 0 ) then
            c1err = 'Problem with 2nd init when NCALL_SNANA_DRIVER=1'
            c2err = 'CID = ' // SNLC_CCID
            CALL  MADABORT(FNAM, C1ERR, C2ERR ) 
          endif
      ENDIF


+SELF,IF=SNFIT.
c check for SN-dependent filter response
      CALL FILTER_UPDATE_DRIVER()
+SELF.


c compute quantities, apply AB offsets, set cut-mask
      CALL SNRECON()       ! compute variables, apply AB offsets
      CALL U3BAND()        ! special U-band test
      CALL USRCUTS(IERR)   ! user code to set PASS_USRCUTS=F (Aug 2015)
      CALL SET_CUTMASK()   ! set cutmask 


+SELF,IF=SNFIT.
c check option to include IDEAL fit, after SNRECON (Aug 29 2017)
      CALL SIMFIT_IDEAL_PREP(0)
+SELF.

c set default to use minimized fitpar unless user calls MARG_DRIVER
      USEPDF_MARG = .FALSE.

c check dump-option for SN that fail cuts.

      IF ( .not. LSNCUTS ) THEN
         if ( STDOUT_UPDATE ) write(6,41) SNLC_CCID
41       format(T20,'SNANA cuts REJECT CID = ',A8, 2x,'=> SKIP ')
         IF ( LDMP_SNFAIL ) CALL DMP_SNFAIL()
         CALL MON_SNANA(IFLAG_ANA)       ! update ntuples for rejected SN
         RETURN  ! skip this SN
      ENDIF
 
      IF ( STDOUT_UPDATE ) THEN
        write(6,42) isn
     &        , SNLC_CCID
     &        , ISNLC_NEWMJD_STORE
     &        , ISNLC_NEWMJD_CUTS
      ENDIF

       IF ( OPT_REFORMAT_TEXT  .GT. 0 ) CALL WRTEXT()
cc       IF ( OPT_REFORMAT_SALT2 .EQ. 1 ) CALL WRSALT2_1()
       IF ( OPT_REFORMAT_SALT2 .EQ. 2 ) CALL WRSALT2_2()
       IF ( OPT_REFORMAT_FITS  .GT. 0 ) CALL UPD_WRFITS()

+SELF,IF=SNFIT.

c do the fit

       NPLOT_CONT    = 0   ! rest number of contour plots
       ITER          = 0
       LREPEAT_ITER  = .FALSE.
       LREPEAT_MINOS = .FALSE.
       REJECT_FIT    = .FALSE.
       NCALL_MNFIT   = 0
       
       N_SNLC_FIT = N_SNLC_FIT + 1

       DO 410 WHILE( iter < NFIT_ITERATION .and. .NOT.REJECT_FIT)

          ITER = ITER + 1
          LAST_ITER = ( ITER .EQ. NFIT_ITERATION )

          IF ( ITER==1 ) THEN
              USE_MINOS_LOCAL = .FALSE.
          ELSE
              USE_MINOS_LOCAL = (USE_MINOS .or. LREPEAT_MINOS)
          ENDIF
      
          CALL FITPAR_PREP ( iter, IERR )  ! init fit params
          if ( IERR .NE. 0 ) then
            ERRFLAG_FIT = IERR
            write(6,40) ITER, SNLC_CCID
40          format(T5,'FITPAR_PREP PROBLEM => SKIP FIT-ITER=', 
     &              I2,'  for  CID=',A8 )
            GOTO 410          ! bad init => skip fit-iteration
          endif

          write(6,43)
          WRITE(6,44) ISN, SNLC_CCID(1:ISNLC_LENCCID), 
     &           NFITPAR_MN, ITER
44        format(T5,'CALL MNFIT_DRIVER for ISN=',I5,
     &         3x,'CID=',A, 3x, 'NFITPAR=',I3, 3x,'iter=',I1 )
          write(6,43)
43        FORMAT(/,T2, 60('#'), / )

c call main driver for fitter. 
c Note that all returned output from MNFIT_DRIVER goes to common blocks.

          CALL MNFIT_DRIVER ( 
     &       SNLC_CID, NFITPAR_MN                 ! (I)
     &      ,INIVAL, INISTP, INIBND               ! (I)
     &      ,PARNAME_STORE                        ! (I)
     &      ,USE_MINOS_LOCAL                      ! (I)
     &      ,MINUIT_PRINT_LEVEL                   ! (I)
     &      ,FITVAL(1,iter)                       ! (O)
     &      ,FITERR_PLUS(1,iter)                  ! (O)
     &      ,FITERR_MINUS(1,iter)                 ! (O)
     &      ,FITCHI2_MIN                          ! (O)
     &      ,NFIXPAR, ERRTYPE                     ! (O)
     &      ,MNSTAT_COV                           ! (O)
     &      ,IERR                                 ! (O)
     &            )   

c avoid infinite loop with MNFIT calls ...
         NCALL_MNFIT = NCALL_MNFIT + 1
         IF  ( NCALL_MNFIT .GT. 2*MXITER ) THEN
            write(c1err,641) 2*MXITER, SNLC_CCID
            write(c2err,642) NFIT_ITERATION
641         format('MNFIT_DRIVER called > ',I3,' times for CID=',A) 
642         format('even though NFIT_ITERATION = ', I2 )
            CALL  MADABORT(FNAM, C1ERR, C2ERR ) 
         ENDIF

c  store fit results

         CALL MNFIT_STOREPAR(iter,IERR) 

c analyze results: returns ERRFLAG_FIT
c  =  0 => OK; keep SN
c  >  0 => discard fit
c  = -1 => decrement ITER and try again (e.g., for photoZ spike) 

          CALL FITPAR_ANA ( isn, iter, ERRFLAG_FIT )

c check ERRFLAG_FIT
          CALL SNANA_ERRFLAG_FIT(iter,ERRFLAG_FIT)
          if ( ERRFLAG_FIT > 0 ) REJECT_FIT = .TRUE.
 
410     CONTINUE  ! end of iteration loop

        print*,'    Finished fitting CID = ', 
     &               SNLC_CCID(1:ISNLC_LENCCID)
        print*,' ' 
+SELF.

+SELF,IF=PSNID.
      CALL PSNIDANA(IERR)
+SELF.


42    format(T8,'Analyze ISN=',I8, 2x,
     &    'for ',A14,'  NMJD(stored,cuts)=', I4, ' ->', I3 )
      CALL FLUSH(6)
      CALL USRANA(IERR)     ! call user-analysis routine


+SELF,IF=SNANA.
c pack the meta data 
      IF ( OPT_TABLE(ITABLE_SNLCPAK) > 0  ) THEN
        CALL SNLCPLOT()       ! prepare light curves for plotting
      ENDIF
+SELF.

      IF ( OPT_TABLE(ITABLE_SPECPAK) > 0  ) THEN
        CALL SPECPLOT()       ! prepare spectra for plotting (Apr 2019)
      ENDIF


c Beware that SNANA table gets filled after FITRES table.
      CALL MON_SNANA(IFLAG_ANA)     ! monitor-driver

      CALL MAKE_SIMLIB_FILE(2)   ! update SIMLIB Feb 2016


+SELF,IF=TESTFUNS.
      CALL TEST_GET_SNFITSIO_INFO()
+SELF.

      RETURN
      END         ! end of SNANA_DRIVER

C ==============================
+DECK,SNANA_ERRFLAG,IF=SNFIT.
      SUBROUTINE SNANA_ERRFLAG_FIT(ITER,ERRFLAG)

c Created May 24 2018
c Minor refactor: move some code out of SNANA_DRIVER for cleanup.

      IMPLICIT NONE

      INTEGER ITER, ERRFLAG ! (I)

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,SNCONTCM.

      LOGICAL LAST_ITER, ALREADY_MINOS

C ------------ BEGIN ----------

      LAST_ITER = ( ITER .EQ. NFIT_ITERATION )

      if ( LAST_ITER ) then  
         if ( ERRFLAG == 0 ) then
            N_SNLC_FITCUTS = N_SNLC_FITCUTS + 1
            CUTFLAG_SNANA = IBSET(CUTFLAG_SNANA,1) ! for SNANA ntuple
            NPASSCUT_FIT(ISNLC_TYPE) = NPASSCUT_FIT(ISNLC_TYPE)+1
            NPASSCUT_FIT(-1)         = NPASSCUT_FIT(-1)+1 ! all types
         endif

c check option to redo entire fit with MINUIT's MINOS option;
c this is a better fit, particularly for errors, but it is 
c much slower. So use this only when a serious fit problem is found.
         ALREADY_MINOS = LREPEAT_MINOS .or. USE_MINOS
         if ( ERRFLAG .EQ. -2 .and. (.NOT. ALREADY_MINOS) ) then
            ITER = 0
            LREPEAT_MINOS = .TRUE.
         endif

      endif

c Aug 16, 2009 : check for 1st-iteration cuts, 
c such as from filter dropouts  in photoZ fit.

      if ( .NOT.LAST_ITER .and.  ERRFLAG .GT. 0) then  
         write(6,441) SNLC_CCID
 441     format(T4,'MNFIT_DRIVER: ', 
     &        'CUTS AFTER 1st FIT-ITER REJECT CID ', A8,' => SKIP')
         CALL MON_SNANA(IFLAG_ANA) ! update ntuples for failed fit
         RETURN
      endif

c check option to redo fit-iteration 
      if ( ERRFLAG .EQ. -1 ) then
         ITER = ITER - 1 
         LREPEAT_ITER = .TRUE.
      else
         LREPEAT_ITER = .FALSE.
      endif
      
      RETURN
      END   ! end SNANA_ERRFLAG_FIT
+SELF.

C ======================================
+DECK,SNEND.
      SUBROUTINE SNANA_END

c Created MAy 2012 by R.Kessler
c
c Shell to call functions after all SN have been processed.
c
c Nov 10 2018: move call to PRINT_SNSTATS() to end of SNANA_END
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,NNCOM.

      INTEGER IERR, LENF
c ----------------- BEGIN -------------

c      CALL PRINT_SNSTATS

c -----------------------------

+SELF,IF=SNFIT.
      CALL PRBANNER ( "CALL FITPAR_END" )
      CALL FITPAR_END(IERR)
+SELF.

+SELF,IF=PSNID.
      CALL PRBANNER ( "CALL PSNIDEND" )
      CALL PSNIDEND(IERR)
+SELF.

      CALL PRBANNER ( "CALL USREND" )
      CALL USREND ( IERR )

      IF ( OPT_REFORMAT_FITS > 0 )  THEN
         CALL END_WRFITS()
      ENDIF

c close hbook file using wrapper so that we don't need CERNLIB flag here.
      IF ( USE_TABLEFILE_HBOOK ) THEN
         LENF = index(HFILE_OUT,' ') - 1
         CALL TABLEFILE_CLOSE(HFILE_OUT(1:LENF)//char(0), LENF)
      ENDIF
      IF ( USE_TABLEFILE_ROOT ) THEN
         LENF = index(ROOTFILE_OUT,' ') - 1
         CALL TABLEFILE_CLOSE(ROOTFILE_OUT(1:LENF)//char(0), LENF)
      ENDIF

      IF ( USE_TABLEFILE_TEXT ) THEN  ! April 2019
         CALL TABLEFILE_CLOSE("NULL"//char(0),10)
      ENDIF

      IF ( FLAG_NEARNBR == NNFLAG_TRAIN ) THEN
         CALL SNANA_NEARNBR_TRAIN_END()
      ELSE IF ( FLAG_NEARNBR == NNFLAG_APPLY ) THEN
         CALL SNANA_NEARNBR_APPLY_END()
      ENDIF

      CALL MAKE_SIMLIB_FILE(3)  ! end optional SIMLIB FILE 

      CALL WARN_OLDINPUTS("list"//char(0), 0);

      CALL END_MAGCOR()  ! check for warnings

c - - - - - - 
      CALL PRINT_SNSTATS

      call flush(6)
      print*,' ' 
      print*,'   ENDING PROGRAM GRACEFULLY. '

      RETURN
      END    ! end of SNANA_END

C ======================================
+DECK,FORCLOSE.
      SUBROUTINE FORCLOSE(LUN)
c Apr 2014: 
c Wrapper to close a fortran logical unit from C code;
c needed by CLOSE_HFILE in sntools_output_hbook.c
      INTEGER LUN
      CLOSE(LUN)
      RETURN
      END

C ===========================================
+DECK,REJECTPS.
      LOGICAL FUNCTION  REJECT_PRESCALE(N,PRESCALE)

c Created Jan 2015
c Apply &SNLCINP SIM_PRESCALE (if >1) to randomly pre-scale
c the simulation. Use reproducible random numbers based
c on input integer N (incremental index) ,
c   RAN = mod(N,PI)/PI
c
c Apr 26 2017: pass PRESCALE as argument.

      IMPLICIT NONE

      INTEGER N           ! (I) use for pseudo-random pre-scale
      REAL*8  PRESCALE    ! (I) prescale
c local var

+CDE,SNPAR.
c +CDE,SNDATCOM.
c +CDE,SNLCINP.

      DOUBLE PRECISION XN, RAN, RANMAX

C ------------- BEGIN --------------

      REJECT_PRESCALE = .FALSE.

      IF ( PRESCALE < 1.000001 ) RETURN

      XN     = DBLE(N)
      RAN    = mod(XN,PI)/PI
      RANMAX = 1.0/PRESCALE
      IF ( RAN > RANMAX ) REJECT_PRESCALE = .TRUE.

      RETURN
      END
C ============================================
+DECK,INIWRFITS.
      SUBROUTINE INI_WRFITS

c Prepare for translating text file format into FITS format.
c Jun 2013: open IGNORE file and leave it open
c
c Aug 7, 2014: set IMPLICIT NONE !!!
c Dec 9, 2017: pass missing NMARK argument to WR_SNFITSIO_INIT

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      CHARACTER 
     &   cPATH*(MXCHAR_PATH)
     &  ,cVERSION*(MXCHAR_VERSION)
     &  ,cPREFIX*(MXCHAR_VERSION)
     &  ,cHEADFILE*(MXCHAR_FILENAME)
     &  ,LIST_FILE*(MXCHAR_FILENAME)
     &  ,IGNORE_FILE*(MXCHAR_FILENAME)

      INTEGER 
     &   SIMFLAG, LL, NMARK
     &  ,LEN_PATH
     &  ,LEN_SURVEY
     &  ,LEN_VERS
     &  ,LEN_HEAD
 
      REAL*8  DVAL
    
C ------------------ BEGIN ----------------

      LEN_SURVEY = INDEX(SURVEY_NAME,' ') - 1
      cPATH      = './' // char(0)
      LEN_PATH   = 2

      IF ( VERSION_REFORMAT_FITS(1:4) .EQ. 'NULL' ) THEN
         VERSION_REFORMAT_FITS  = 
     &        SURVEY_NAME(1:LEN_SURVEY) // '_translated' 
      ENDIF

      LEN_VERS = INDEX(VERSION_REFORMAT_FITS,' ') - 1
      cVERSION = VERSION_REFORMAT_FITS(1:LEN_VERS) // char(0)
      cPREFIX  = cVERSION
 

      IF ( LSIM_MAGOBS ) THEN
cc         SIMFLAG = 4   ! Aug 6 2014
         SIMFLAG = 8   ! Jan 23 2018
      ELSE IF ( LSIM_SNANA ) THEN 
cc         SIMFLAG = 3
         SIMFLAG = 4   ! Jan 23 2018
      ELSE
         SIMFLAG = 2
      ENDIF

c set global header info

      CALL SET_SNDATA_STRING("SURVEY",    SURVEY_NAME)
      CALL SET_SNDATA_STRING("FILTERS",   SURVEY_FILTERS)
      CALL SET_SNDATA_STRING("SNANA_DIR", SNANA_DIR)

      DVAL  = DBLE(SNLC_NXPIX)
      CALL SET_SNDATA_DBLE("NXPIX", DVAL )
      DVAL  = DBLE(SNLC_NYPIX)
      CALL SET_SNDATA_DBLE("NYPIX", DVAL )

      DVAL  = DBLE(ISNLC_CCDNUM(1) )
      CALL SET_SNDATA_DBLE("CCDNUM", DVAL ) ! Jun 2 2017

c set optional private variables to leave list in header.
      CALL SET_SNDATA_PRIVATE();

c -----------------------
      CALL WR_SNFITSIO_INIT(cPATH, cVERSION, cPREFIX, SIMFLAG
     &           , NMARK, cHEADFILE  ! output name
     &           , LEN_PATH, LEN_VERS, LEN_VERS, LEN_HEAD)     

c recompute LEN_VERS in case it gets corrupted by WR_SNFITSIO_INIT 
      LEN_VERS = INDEX(VERSION_REFORMAT_FITS,' ') - 1 

c --------------------------------------------------
c -------- open and fill LIST file -----------------

      LIST_FILE = VERSION_REFORMAT_FITS(1:LEN_VERS) // '.LIST'
      OPEN (LUNTMP, FILE = LIST_FILE, status='UNKNOWN' )
      LL = INDEX(cHEADFILE, char(0) ) - 1
      WRITE(LUNTMP,50) cHEADFILE(1:LL)
50    FORMAT(A)
      CLOSE(LUNTMP)

c --------------------------------------------------
c -------- open IGNORE file and leave it open (Jun 2013)


      IGNORE_FILE = VERSION_REFORMAT_FITS(1:LEN_VERS) // '.IGNORE'
      OPEN (LUNIGNORE, FILE = IGNORE_FILE, status='UNKNOWN' )
      write(LUNIGNORE,420)  ! write header
 420  format(T10,'CID      MJD     FILTER')
      NEPOCH_IGNORE_WRFITS = 0

      RETURN
      END  ! end  INI_WRFITS


C ==========================================
+DECK,UPDWRFITS.
      SUBROUTINE UPD_WRFITS()
c
c Created May 2012 by R.Kessler
c Translate data text files into fits format.
c Process real data or simulation, although simulation
c can be written in FITS format with  "FORMAT_MASK: 32".
c
c Output version is automatically defined as [SURVEY]_FITS
c
c For each call to set_SDNATA_STRING[DBLE], add code in
c set_SNDATA() inside sntools.c
c
c Nov 2012: tack on optional private variables
c May 2013: include HOSTGAL_OBJID
c Jun 2013: update IGNORE file (LUNIGNORE)
c Sep 2015: increase STRINGVAL from 2000 -> 20000 bytes to allow
c           for 3 DES seasons. See MXLEN_EPSTRING.
c
c Feb 19 2017: set SUBSURVEY
c ----------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PRIVCOM.
+CDE,FITSCOM.

c local var

      INTEGER 
     &   LEN_KEY, LEN_STR
     &  ,NEP, iep, i, LFLD, IFILT_OBS, ifilt, igal
     &  ,LEN1_CCID, LEN2_CCID, LENPRE, HOSTGAL_USEMASK

      CHARACTER 
     &    KEY*60
     &   ,STRINGVAL*(MXLEN_EPSTRING)
     &   ,CFILT*2
     &   ,CCID*(MXCHAR_CCID)
     &   ,PREFIX*20

      REAL*8  DVAL, DARRAY(MXEPOCH)

c --------------- BEGIN -------------------

      STRINGVAL = "NULL" // char(0)
      LEN_STR   = INDEX(STRINGVAL, ' ') - 1     

      CALL SET_SNDATA_STRING("SUBSURVEY", SUBSURVEY_NAME)
      CALL SET_SNDATA_STRING("SNID", SNLC_CCID )
      CALL SET_SNDATA_STRING("IAUC", SNLC_IAUC )

      DVAL      = SNLC8_RA
      CALL SET_SNDATA_DBLE("RA", DVAL )

      DVAL      = SNLC8_DEC
      CALL SET_SNDATA_DBLE("DECL", DVAL )

      DVAL      = SNLC_PIXSIZE
      CALL SET_SNDATA_DBLE("PIXSIZE", DVAL )

      DVAL      = SNLC_NXPIX
      CALL SET_SNDATA_DBLE("NXPIX", DVAL )

      DVAL      = DBLE(ISNLC_CCDNUM(1) )
      CALL SET_SNDATA_DBLE("CCDNUM", DVAL )   ! Jun 2 2017 

      DVAL      = DBLE(ISNLC_WRMASK_FLUXCOR_SNANA )
      CALL SET_SNDATA_DBLE("MASK_FLUXCOR_SNANA", DVAL )   ! Nov 2018

      DVAL      = SNLC_NYPIX
      CALL SET_SNDATA_DBLE("NYPIX", DVAL )

      DVAL      = DBLE( ISNLC_TYPE  )
      CALL SET_SNDATA_DBLE("SNTYPE", DVAL )

      IF ( SURVEY_NAME(1:4) .EQ. 'SDSS') THEN
        DVAL      = DBLE( ISNLC_TYPE  )
        CALL SET_SNDATA_DBLE("SEARCH_TYPE", DVAL )
      ENDIF

      DVAL      = SNLC_SEARCH_PEAKMJD 
      CALL SET_SNDATA_DBLE("PEAKMJD", DVAL )

      DVAL      = DBLE ( ISNLC_NEPOCH_STORE )
      CALL SET_SNDATA_DBLE("NEPOCH", DVAL )

c ---------- redshift info --------
      DVAL      = SNLC_ZCMB 
      CALL SET_SNDATA_DBLE("REDSHIFT_FINAL", DVAL )

      DVAL      = SNLC_ZCMB_ERR
      CALL SET_SNDATA_DBLE("REDSHIFT_FINAL_ERR", DVAL )

      DVAL      = SNLC_ZHELIO
      CALL SET_SNDATA_DBLE("REDSHIFT_HELIO", DVAL )

      DVAL      = SNLC_ZHELIO_ERR
      CALL SET_SNDATA_DBLE("REDSHIFT_HELIO_ERR", DVAL )

      DVAL      = SNLC_VPEC
      CALL SET_SNDATA_DBLE("VPEC", DVAL )

      DVAL      = SNLC_VPEC_ERR
      CALL SET_SNDATA_DBLE("VPEC_ERR", DVAL )

c ------- host galaxy info  ------------
      HOSTGAL_USEMASK = 0
      IF ( EXIST_SNHOST_MAGOBS ) HOSTGAL_USEMASK = HOSTGAL_USEMASK + 1
      IF ( EXIST_SNHOST_SB     ) HOSTGAL_USEMASK = HOSTGAL_USEMASK + 4

      DVAL      = SNHOST_NMATCH
      CALL SET_SNDATA_DBLE("HOSTGAL_NMATCH", DVAL )
      DVAL      = SNHOST_NMATCH2
      CALL SET_SNDATA_DBLE("HOSTGAL_NMATCH2", DVAL )
      DVAL      = SNHOST_CONFUSION
      CALL SET_SNDATA_DBLE("HOSTGAL_CONFUSION", DVAL )

      DO igal = 1, MXSNHOST
         CALL SET_HOSTGAL_PREFIX(igal,PREFIX,LENPRE)
      
         DVAL      = SNHOST_OBJID(igal) 
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_OBJID", DVAL )

         DVAL      = SNHOST_ZPHOT(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_PHOTOZ", DVAL )

         DVAL      = SNHOST_ZPHOT_ERR(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_PHOTOZ_ERR", DVAL )

         DVAL      = SNHOST_ZSPEC(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_SPECZ", DVAL )

         DVAL      = SNHOST_ZSPEC_ERR(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_SPECZ_ERR", DVAL )

         DVAL      = SNHOST8_RA(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_RA", DVAL )
         DVAL      = SNHOST8_DEC(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_DEC", DVAL )

         DVAL      = SNHOST_ANGSEP(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_SNSEP", DVAL )

         DVAL      = SNHOST_DDLR(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_DDLR", DVAL )

         DVAL      = SNHOST_LOGMASS(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_LOGMASS", DVAL )
         DVAL      = SNHOST_LOGMASS_ERR(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_LOGMASS_ERR", DVAL )

         DVAL      = SNHOST_sSFR(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_sSFR", DVAL )
         DVAL      = SNHOST_sSFR_ERR(igal)
         CALL SET_SNDATA_DBLE(PREFIX(1:LENPRE)//"_sSFR_ERR", DVAL )

         IF ( EXIST_SNHOST_MAGOBS ) THEN
            DO ifilt = 1, NFILTDEF_READ
               DARRAY(ifilt) = DBLE( SNHOST_MAGOBS(ifilt,igal) )
            ENDDO
            KEY       = PREFIX(1:LENPRE)//'_MAG' // char(0)
            LEN_KEY   = INDEX(KEY, ' ') - 1
            CALL set_sndata(KEY, NFILTDEF_READ, STRINGVAL, DARRAY, 
     &           LEN_KEY, LEN_STR) 
            
            DO ifilt = 1, NFILTDEF_READ
               DARRAY(ifilt) = DBLE( SNHOST_MAGOBS_ERR(ifilt,igal) )
            ENDDO
            KEY       = PREFIX(1:LENPRE)//'_MAGERR' // char(0)
            LEN_KEY   = INDEX(KEY, ' ') - 1
            CALL set_sndata(KEY, NFILTDEF_READ, STRINGVAL, DARRAY, 
     &           LEN_KEY, LEN_STR) 
         ENDIF

      ENDDO ! end IGAL loop

c add host-galaxy SB if defined

      IF ( EXIST_SNHOST_SB ) THEN  ! added Sep 3 2014
         DO ifilt = 1, NFILTDEF_READ
            DARRAY(ifilt) = SNHOST_SBFLUXCAL(ifilt)            
         ENDDO
         KEY       = 'HOSTGAL_SB_FLUXCAL' // char(0)
         LEN_KEY   = INDEX(KEY, ' ') - 1
         CALL set_sndata(KEY, NFILTDEF_READ, STRINGVAL, DARRAY, 
     &        LEN_KEY, LEN_STR) 
      ENDIF
 

c ------- MW Galactic extinction ----------

      DVAL      = SNLC_MWEBV
      CALL SET_SNDATA_DBLE("MWEBV", DVAL )

      DVAL      = SNLC_MWEBV_ERR
      CALL SET_SNDATA_DBLE("MWEBV_ERR", DVAL )


c ------- PRIVATE variables --------

      IF ( NVAR_PRIVATE > 0 ) THEN
        KEY      = 'PRIVATE_VALUE' // char(0)
        LEN_KEY  = INDEX(KEY, ' ') - 1
        CALL set_sndata(KEY,NVAR_PRIVATE, STRINGVAL, PRIVATE_VALUE, 
     &           LEN_KEY,LEN_STR ) 
      ENDIF

c -------------------------------------------
c -------- Load light curve -----------------
c -------------------------------------------

      NEP  = ISNLC_NEPOCH_STORE

c --- MJD ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC8_MJD(iep)
      ENDDO
      KEY  = 'MJD' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- FLUXCAL ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_FLUXCAL(iep)
      ENDDO
      KEY  = 'FLUXCAL' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- FLUXCAL_ERR ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_FLUXCAL_ERRTOT(iep)
      ENDDO
      KEY  = 'FLUXCAL_ERRTOT' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- MAG ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_MAG(iep)
      ENDDO
      KEY  = 'MAG' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 


c --- MAGERR ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_MAG_ERRPLUS(iep)
      ENDDO
      KEY  = 'MAGERR' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- PHOTFLAG ---
      DO iep = 1, NEP
         DARRAY(iep) = DBLE ( ISNLC_PHOTFLAG(iep) )
      ENDDO
      KEY  = 'PHOTFLAG' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- PHOTPROB ---
      DO iep = 1, NEP
         DARRAY(iep) = DBLE ( SNLC_PHOTPROB(iep) )
      ENDDO
      KEY  = 'PHOTPROB' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- PSF_SIG1 ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_PSF_SIG1(iep)
      ENDDO
      KEY  = 'PSF_SIG1' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- PSF_SIG2 ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_PSF_SIG2(iep)
      ENDDO
      KEY  = 'PSF_SIG2' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- PSF_RATIO ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_PSF_RATIO(iep)
      ENDDO
      KEY  = 'PSF_RATIO' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- SKY_SIG ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_SKYSIG(iep)
      ENDDO
      KEY      = 'SKY_SIG' // char(0)
      LEN_KEY  = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- SKY_SIG_T (template sky noise) ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_SKYSIG_T(iep)
      ENDDO
      KEY      = 'SKY_SIG_T' // char(0)
      LEN_KEY  = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- RDNOISE ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_RDNOISE(iep)
      ENDDO
      KEY  = 'RDNOISE' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- GAIN ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_GAIN(iep)
      ENDDO
      KEY  = 'GAIN' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- ZEROPT ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_ZEROPT(iep)
      ENDDO
      KEY  = 'ZEROPT' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- ZEROPT_ERR ---
      DO iep = 1, NEP
         DARRAY(iep) = SNLC_ZEROPT_ERR(iep)
      ENDDO
      KEY  = 'ZEROPT_ERR' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 

c --- Pixel location

      IF( SNLC_NXPIX > 0 ) THEN
         DO iep = 1, NEP
            DARRAY(iep) = SNLC_XPIX(iep)
         ENDDO
         KEY      = 'XPIX' // char(0)
         LEN_KEY  = INDEX(KEY, ' ') - 1
         CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 
         
         DO iep = 1, NEP
            DARRAY(iep) = SNLC_YPIX(iep)
         ENDDO
         KEY      = 'YPIX' // char(0)
         LEN_KEY  = INDEX(KEY, ' ') - 1
         CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 
      ENDIF

c -------------------
      DVAL = -9.0
c -------------------

c ---- FILTER ----
      KEY  = 'FLT' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      LEN_STR   = -1
      STRINGVAL = ' '
      DO iep = 1, NEP
         IFILT_OBS = ISNLC_IFILT_OBS(iep)
         CFILT     = FILTDEF_STRING(ifilt_obs:ifilt_obs)
         i = 2*iep-1
         STRINGVAL(i:i+1) = CFILT(1:1) // ' '
         LEN_STR   = LEN_STR + 2
      ENDDO
      STRINGVAL = STRINGVAL(1:LEN_STR) // char(0)
      CALL set_sndata(KEY,NEP, STRINGVAL, DVAL, LEN_KEY,LEN_STR) 

c ---- FIELD ----
      KEY       = 'FIELD' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      LEN_STR   = 0
      STRINGVAL = ' '
      DO iep = 1, NEP
         LFLD = INDEX( SNLC_FIELD(iep),' ' ) - 1
         STRINGVAL(LEN_STR+1:LEN_STR+LFLD+1) = 
     &        SNLC_FIELD(iep)(1:LFLD) // ' '
         LEN_STR  = LEN_STR + LFLD + 1
      ENDDO
      LEN_STR = LEN_STR - 1
      STRINGVAL = STRINGVAL(1:LEN_STR) // char(0)

      CALL set_sndata(KEY,NEP, STRINGVAL, DVAL, LEN_KEY, LEN_STR) 

c ---- TELESCOPE ----
      KEY       = 'TELESCOPE' // char(0)
      LEN_KEY   = INDEX(KEY, ' ') - 1
      LEN_STR   = 0
      STRINGVAL = ' '
      DO iep = 1, NEP
         LFLD = INDEX( SNTEL_LIST(1) // ' ' ,' ' ) - 1
         STRINGVAL(LEN_STR+1:LEN_STR+LFLD+1) = 
     &        SNTEL_LIST(1)(1:LFLD) // ' '
         LEN_STR  = LEN_STR + LFLD + 1
      ENDDO
      LEN_STR = LEN_STR - 1
      STRINGVAL = STRINGVAL(1:LEN_STR) // char(0)
      CALL set_sndata(KEY,NEP, STRINGVAL, DVAL, LEN_KEY, LEN_STR) 

c -------------------------------------------------
c Aug 6 2014: optional SIM_MAGOBS if it's there 
c   (e.g., for fakes overlaid onto real images)

      IF ( ITERSE_SIM_EPMAGOBS > 0 ) THEN
         DO iep = 1, NEP
            DARRAY(iep) = SIM_EPMAGOBS(iep)
         ENDDO
         KEY  = 'SIM_MAGOBS' // char(0)
         LEN_KEY   = INDEX(KEY, ' ') - 1
         CALL set_sndata(KEY,NEP,STRINGVAL, DARRAY, LEN_KEY,LEN_STR) 
         
      ENDIF

c =====================================
      CALL wr_snfitsio_update()
c =====================================

c update IGNORE file (Jun 2013)

      LEN1_CCID = INDEX(SNLC_CCID,' ') - 1
      DO 400 i = 1, NEPOCH_IGNORE
         CCID = EPOCH_IGNORE_CCID(i)   
         LEN2_CCID = INDEX(CCID,' ') - 1
         IF( LEN1_CCID .NE. LEN2_CCID ) GOTO 400
         IF ( CCID(1:LEN1_CCID) .EQ. SNLC_CCID(1:LEN1_CCID) ) THEN
            write(LUNIGNORE,410) 
     &      CCID(1:LEN1_CCID), EPOCH_IGNORE_MJD(i), EPOCH_IGNORE_FILT(i)
 410        format('IGNORE:  ', A, 3x, F9.3, 3x, A1)
            call flush(LUNIGNORE)
            NEPOCH_IGNORE_WRFITS = NEPOCH_IGNORE_WRFITS + 1
         ENDIF
 400  CONTINUE


      RETURN
      END  ! end of UPD_WRFITS

C ===============================
+DECK,ENDWRFITS.
      SUBROUTINE END_WRFITS

c
c Close FITS files and create README file.
c Nov 25, 2012: create blank IGNORE file if 2nd bit if 
c               OPT_REFORMAT_FITS is set
c
c Jun 21 2013: give big warning if IGNORE file is not created.
c
c Feb 26 2015: catenate each original README into final README.
c
c -------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER LEN_VERS, LEN_SURVEY, i, iver
      CHARACTER 
     &   README_FILE*(MXCHAR_FILENAME)
     &  ,TXT*80, CMD*(MXCHAR_FILENAME)

C ----------------- BEGIN ----------------

c call C function to close out the FITS files.
      CALL wr_snfitsio_end()

c make README file and write basic info.

      LEN_VERS = INDEX(VERSION_REFORMAT_FITS,' ') - 1
      README_FILE = VERSION_REFORMAT_FITS(1:LEN_VERS) // '.README'
      OPEN (LUNTMP, FILE = README_FILE, status='UNKNOWN' )

      LEN_SURVEY = INDEX(SURVEY_NAME,' ') - 1
      WRITE(TXT,20) SURVEY_NAME(1:LEN_SURVEY)
20    FORMAT('Convert ', A,' TEXT files into FITS format for ')
      WRITE(LUNTMP,500) txt

      DO i = 1, N_VERSION
        TXT = '     ' // VERSION_PHOTOMETRY(i)
        write(LUNTMP,500) txt
      ENDDO

      WRITE(LUNTMP,500) ' '

      WRITE(LUNTMP,30) 'Processed', N_SNLC
      WRITE(LUNTMP,30) 'Wrote    ', N_SNLC_CUTS
30    format(A, 2x, I7, 2x, ' light curves.' )
      call FLUSH(LUNTMP)

500   FORMAT(A)
      CLOSE(LUNTMP)  ! close README file


c --- catenate original README contents for each version --------

      DO iver = 1, N_VERSION

c first write formatted DUMP-statement.

         OPEN (LUNTMP, FILE = README_FILE, Access='append',Status='old')

         write(LUNTMP,600)
         write(LUNTMP,600)
         write(LUNTMP,700)
         write(LUNTMP,700)
         write(LUNTMP,701)  VERSION_PHOTOMETRY(iver)

600      format(' ')
700      format('# ', 74('=') )
701      format('# DUMP ORIGINAL README for ', A)

         CLOSE(LUNTMP)  ! close README file

c now just catenate the final readme with the original readme file.

         LEN_VERS  = INDEX(SNREADME_FILE(iver),' ' ) - 1
         CMD = 'cat ' // SNREADME_FILE(iver)(1:LEN_VERS) 
     &         // ' >> ' // README_FILE
         
         CALL SYSTEM(CMD)

      ENDDO

c ---- update IGNORE file with comment on total number of IGNORE epochs
      write(LUNIGNORE,430) NEPOCH_IGNORE_WRFITS
 430  format(/,'Total number of IGNORE epochs: ', I5)
      close(LUNIGNORE)

      RETURN
      END

C ===============================
+DECK,SETSNSTR.
      SUBROUTINE SET_SNDATA_STRING(KEY,STRINGVAL)

      IMPLICIT NONE
      CHARACTER KEY*(*)         ! (I) name of key to set SNDATA struct
      CHARACTER STRINGVAL*(*)   ! (I) string value

c local var
      CHARACTER cKEY*80, cSTRINGVAL*80
      INTEGER ONE, LEN_KEY, LEN_STR
      REAL*8  DVAL
C -------------- BEGIN -------------
      ONE = 1
c add blank space at end in case there isn't one already there
      LEN_KEY   = INDEX(KEY       // ' ', ' ') - 1
      LEN_STR   = INDEX(STRINGVAL // ' ', ' ') - 1     
      cKEY       = KEY(1:LEN_KEY) // char(0)
      cSTRINGVAL = STRINGVAL(1:LEN_STR) // char(0)
      DVAL      = -9.0
      CALL set_sndata(cKEY, ONE, cSTRINGVAL, DVAL, 
     &                LEN_KEY, LEN_STR ) 
      RETURN
      END  ! end of SET_SNDATA_STRING

C ==========================================
+DECK,SETSNPRIV.
      SUBROUTINE SET_SNDATA_PRIVATE()
c
c if  NVAR_PRIVATE > 0 then set SNDATA.PRIVATE_VAR_NAME in sndata.h

      IMPLICIT NONE
+CDE,SNPAR.
+CDE,PRIVCOM.

      INTEGER IVAR, LEN_KEY, LEN_NAME
      CHARACTER KEY*80, cKEY*80, NAME*80, cNAME*80
      REAL*8 DVAL
C --------------- BEGIN ---------------

      IF ( NVAR_PRIVATE .LE. 0 ) RETURN

      KEY       = 'PRIVATE_KEYWORD'
      LEN_KEY   = INDEX(KEY // ' ', ' ') - 1      
      cKEY      = KEY(1:LEN_KEY) // char(0)

      DO IVAR = 1, NVAR_PRIVATE
         NAME = PRIVATE_KEYWORD(IVAR)
         LEN_NAME = INDEX(NAME  // ' ', ' ') - 1  
         cNAME    = NAME(1:LEN_NAME) // char(0)
         DVAL     = -9.0

         CALL set_sndata(cKEY, ONE, cNAME, DVAL, 
     &                   LEN_KEY, LEN_NAME ) 
      ENDDO

      RETURN
      END

C =======================================
+DECK,SETSNDBL.
      SUBROUTINE SET_SNDATA_DBLE(KEY,DVAL)

      IMPLICIT NONE
      CHARACTER KEY*(*)         ! (I) name of key to set SNDATA struct
      REAL*8    DVAL            ! (I) double precision value to load

c local var
      CHARACTER cKEY*80, cSTRINGVAL*80
      INTEGER ONE, LEN_KEY, LEN_STR

C -------------- BEGIN -------------
      ONE = 1
c add blank space at end in case there isn't one already there
      LEN_KEY   = INDEX(KEY       // ' ', ' ') - 1
      cKEY       = KEY(1:LEN_KEY) // char(0)

      cSTRINGVAL = "NULL" // char(0)
      LEN_STR   = INDEX(cSTRINGVAL // ' ', ' ') - 1     

      CALL set_sndata(cKEY, ONE, cSTRINGVAL, DVAL, 
     &                LEN_KEY, LEN_STR ) 

      RETURN
      END


C =========================================
+DECK,WRTEXT.
      SUBROUTINE WRTEXT()
c
c Created Jun 24, 2010 by R.Kessler
c Write data to text file.
c Intended for
c  + updating obsolete formats
c  + writing data files with SNANA-generated fudges on flux and fluxerr
c
c
c Data files are created locally with the same name
c as the original; it is up to the user to move/copy
c files when done.
c
c Nov 12 2018: 
c   + rename WRTERSE -> WRTEXT
c   + major overhaul to update the output 
c
c ---------------------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PRIVCOM.

      INTEGER 
     &   LL, NOBS, NVAR, NF
     &  ,EPMIN, EPMAX, EP, NEWMJD, IDFIELD
     &  ,IFILT, IFILT_OBS, LFLD, i, IVAR, IGAL, LENP

      REAL*8 MJD
      CHARACTER cfilt1*1, MYFMT*28, TMPKEY*80, VARLIST*100, CLINE*200
      CHARACTER ENDLINE_MARK*1, PREFIX*20

C ------------- BEGIN ------------

      IF( OPT_REFORMAT_TEXT .EQ. 0 ) RETURN

c abort if sim
      IF ( LSIM_SNANA ) THEN
        C1ERR = 'REFORMAT_TERSE for data only. For sim,'
        C2err = 'just set GEN_SNDATA_SIM: 2 in sim-input file.'
        CALL  MADABORT("WRTEXT", C1ERR, C2ERR)
      ENDIF

      NF = NFILTDEF_SURVEY
      LL = INDEX(SNDATA_FILE_CURRENT,' ' ) - 1
      print*,'  Create TERSE file: ', SNDATA_FILE_CURRENT(1:LL)

      OPEN(   UNIT   = LUNDAT 
     &      , FILE   = SNDATA_FILE_CURRENT
     &      , STATUS = 'UNKNOWN'
     &           )


      WRITE(LUNDAT,10) 'SURVEY:     ', SURVEY_NAME
      WRITE(LUNDAT,10) 'SNID:       ', SNLC_CCID
      WRITE(LUNDAT,10) 'IAUC:       ', SNLC_IAUC
      WRITE(LUNDAT,10) 'FILTERS:    ', SURVEY_FILTERS(1:NF)
      WRITE(LUNDAT,100)'FAKE:       ', ISNLC_FAKE
      WRITE(LUNDAT,100)'TYPE:       ', ISNLC_TYPE
      WRITE(LUNDAT,100)'MASK_FLUXCOR_SNANA:  ', 
     &            ISNLC_WRMASK_FLUXCOR_SNANA
 
      WRITE(LUNDAT,12) 'RA:         ', SNLC8_RA
      WRITE(LUNDAT,12) 'DEC:        ', SNLC8_DEC
      WRITE(LUNDAT,13) 'MWEBV:      ', SNLC_MWEBV
      WRITE(LUNDAT,13) 'MWEBV_ERR:  ', SNLC_MWEBV_ERR

      WRITE(LUNDAT,31) 'PIXSIZE:    ', SNLC_PIXSIZE
      WRITE(LUNDAT,21) 'PEAKMJD:    ', SNLC_SEARCH_PEAKMJD

      WRITE(LUNDAT,20) 'REDSHIFT_FINAL:  ', 
     &   SNLC_ZCMB, SNLC_ZCMB_ERR, '(CMB)'

      if ( SNLC_ZHELIO .GT. 0.0 ) then
         WRITE(LUNDAT,20) 'REDSHIFT_HELIO:  ', 
     &   SNLC_ZHELIO, SNLC_ZHELIO_ERR, '(HELIO)'
      endif

10    FORMAT(A,A)
100   FORMAT(A,I3)
12    FORMAT(A,F12.6, T40,'# deg')
13    FORMAT(A,F8.4,  T40, '# MW E(B-V)' )
20    FORMAT(A,F7.4,' +- ', F7.4, T40, '# ',  A )
21    FORMAT(A,F10.3)
31    FORMAT(A,F7.4, T40, '# arcSec' )
36    FORMAT(A,F11.6,T40, '# deg' )

c host galaxy stuff

      DO 404 IGAL = 1, MXSNHOST 
         IF ( SNHOST_OBJID(igal) .ne. 0 ) THEN
            CALL SET_HOSTGAL_PREFIX(igal,PREFIX,LENP)
            write(LUNDAT,10)  ' ', ' ' ! blank line

            if ( IGAL==1 ) then
               write(LUNDAT,302) PREFIX(1:LENP)//'_NMATCH:    ', 
     &              SNHOST_NMATCH
               write(LUNDAT,302) PREFIX(1:LENP)//'_NMATCH2:    ', 
     &              SNHOST_NMATCH2
            endif
            write(LUNDAT,301) PREFIX(1:LENP)//'_OBJID:     ', 
     &         SNHOST_OBJID(igal)
            WRITE(LUNDAT,20)  PREFIX(1:LENP)//'_PHOTOZ:    ', 
     &           SNHOST_ZPHOT(igal), SNHOST_ZPHOT_ERR(igal),   '(HELIO)' 
            WRITE(LUNDAT,20)  PREFIX(1:LENP)//'_SPECZ:     ', 
     &           SNHOST_ZSPEC(igal), SNHOST_ZSPEC_ERR(igal),   '(HELIO)'     
            WRITE(LUNDAT,36)  PREFIX(1:LENP)//'_RA:     ', 
     &           SNHOST8_RA(igal)
            WRITE(LUNDAT,36)  PREFIX(1:LENP)//'_DEC:    ', 
     &           SNHOST8_DEC(igal)
            WRITE(LUNDAT,31)  PREFIX(1:LENP)//'_SNSEP:     ', 
     &           SNHOST_ANGSEP(igal)
            WRITE(LUNDAT,31)  PREFIX(1:LENP)//'_DDLR:      ', 
     &           SNHOST_DDLR(igal)

            if ( IGAL==1 ) then
               WRITE(LUNDAT,31)  'HOSTGAL_CONFUSION: ', SNHOST_CONFUSION
            endif

            WRITE(LUNDAT,20) PREFIX(1:LENP)//'_LOGMASS:    ', 
     &           SNHOST_LOGMASS, SNHOST_LOGMASS_ERR, 'log10(M/Msolar)'   

            WRITE(LUNDAT,20) PREFIX(1:LENP)//'_sSFR:    ', 
     &           SNHOST_sSFR, SNHOST_sSFR_ERR, '  ' 

            write(MYFMT,309) NF
            WRITE(LUNDAT, MYFMT) PREFIX(1:LENP)//'_MAG:        ',
     &           (SNHOST_MAGOBS(i,igal),i=1, NF), 
     &           '# '//SURVEY_FILTERS(1:NF)
            WRITE(LUNDAT, MYFMT) PREFIX(1:LENP)//'_MAGERR:     ',
     &           (SNHOST_MAGOBS_ERR(i,igal),i=1, NF), 
     &           '# '//SURVEY_FILTERS(1:NF)
            
            if ( IGAL==1 ) then
               WRITE(LUNDAT, MYFMT) 'HOSTGAL_SB_FLUXCAL: ',
     &              (SNHOST_SBFLUXCAL(i),i=1, NF), 
     &              '# '//SURVEY_FILTERS(1:NF)
            endif
         ENDIF  ! end OBJID>0 
 404  CONTINUE  ! end IGAL 

 301  format(A, I9)
 302  format(A, I2)
 309  format('(A,', I1,'(F9.2),4x, A,)' )

c private variables  
      IF ( NVAR_PRIVATE > 0 ) THEN
         write(LUNDAT,10) ' ', ' '
         write(LUNDAT,10) '# ', 'Private variables'
      ENDIF
      DO IVAR = 1, NVAR_PRIVATE
         LL   = INDEX(PRIVATE_KEYWORD(IVAR),' ') -1
         TMPKEY = PRIVATE_KEYWORD(IVAR)(1:LL)//':'
         write(LUNDAT,350) TMPKEY, PRIVATE_VALUE(IVAR)
 350     format(A35, F10.3 )
      ENDDO
c - - - - - - - - - 
c now start the observations

2     FORMAT(A)
c3     FORMAT(A,$)

      write(LUNDAT,2) ' '
      write(LUNDAT,2) '# ====================================== '
      write(LUNDAT,2) '# TERSE LIGHT CURVE OUTPUT '
      write(LUNDAT,2) '# '

c ------------
c evaluate NOBS in case there are NEWMJDs with no valid fluxes.

      NOBS = 0
      DO 150  NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 151 EP = EPMIN, EPMAX
          if ( SNLC_FLUXCAL_ERRTOT(EP) .GT. 0.0 ) then
            NOBS = NOBS + 1
          endif
151     CONTINUE
150   CONTINUE

      ENDLINE_MARK = '/'

      NVAR    = 11
      VARLIST = 
     &    'MJD BAND FIELD  FLUXCAL FLUXCALERR  ' //
     &    'ZPFLUX PSF SKYSIG GAIN PHOTFLAG PHOTPROB '// ENDLINE_MARK
      LL = INDEX(VARLIST,'/')-1
      if ( LSIM_SNANA) then
         NVAR = NVAR + 1
         VARLIST = VARLIST(1:LL) // ' SIM_MAGOBS /'
         LL = INDEX(VARLIST,ENDLINE_MARK)-1
      endif

      WRITE(LUNDAT,100) 'NOBS: ', NOBS
      WRITE(LUNDAT,100) 'NVAR: ', NVAR
      WRITE(LUNDAT,2)   'VARLIST: ' // VARLIST(1:LL)

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        MJD     = SNLC8_MJD(EPMIN)
        IDFIELD = ISNLC_IDFIELD(EPMIN)
        LFLD    = INDEX(SNLC_FIELD(EPMIN),' ') - 1
        DO 201 EP = EPMIN, EPMAX

          if ( SNLC_FLUXCAL_ERRTOT(EP) .LT. 0.0 ) goto 201

          IFILT_OBS = ISNLC_IFILT_OBS(ep)
          IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
          cfilt1    = FILTDEF_STRING(ifilt_obs:ifilt_obs)
          WRITE(CLINE,300) 
     &        MJD, cfilt1, SNLC_FIELD(EP)(1:LFLD)
     &      , SNLC_FLUXCAL(EP), SNLC_FLUXCAL_ERRTOT(EP)
     &      , SNLC_ZEROPT(EP), SNLC_PSF_SIG1(EP), SNLC_SKYSIG(EP)
     &      , SNLC_GAIN(EP), ISNLC_PHOTFLAG(EP), SNLC_PHOTPROB(EP)
     &      , ENDLINE_MARK
300       FORMAT(F9.3, 2x, A1,2x, A, 2x,     ! MJD, FILTER, FIELD
     &           2G12.5,                     ! FLUXCAL, FLUXCAL_ERR
     &           2F6.3, F7.2,                ! ZP, PSF, SKYSIG
     &           F6.3, I7, F6.3, 1x,         ! GAIN, PHOTFLAG, PHOTPROB
     &           A )
          LL = INDEX(CLINE,ENDLINE_MARK) - 1
          WRITE(LUNDAT,2) 'OBS: ' // CLINE(1:LL)

201     CONTINUE

200   CONTINUE

      write(LUNDAT,2) 'END: '

      CLOSE ( UNIT = LUNDAT )
      RETURN
      END     ! end WRTEXT



C ====================================
+DECK,INI_WRS2.
      SUBROUTINE INI_WRSALT2_2
c -----------------------------------------------
c Nov 2011 R.Kessler
c
c Initialization for translating SNANA formatted data
c into SALT2-formatted data. The input options are fed
c vis &SNLCINP namelist string  
c
c  &SNLCINP
c     ...
c   REFORMAT_KEYS = 
c   '@INSTRUMENT <instr> @MAGSYS <magsys> @PREFIX <prefix> @REPLACE <f1> <f2>
c     ...
c  &END 
c
c where @INSTRUMENT and @MAGSYS are required and the others are optional.
c Definition of above keys
c
c @INSTRUMENT = name of telescope or survey defined by SALT2
c @MAGSYS     = mag system defined by SALT2 (i.e, AB, VEGA ...)
c @PREFIX     = file-name prefix (default prefix is name of survey)
c @REPLACE    = replace filter list <f1> with <f2>. For example,
c               if f1 = UGRIZ and f2 = ugriz, then U -> u, G -> g,
c               etc in the output SALT2 files.
c
c
c ------------------------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,WRS2COM.

      INTEGER iwd, NWD, ifilt, NTMP, IFILT_OBS, IFILT_TMP(2) 
      INTEGER LL, LL0, LL1, LL2, MSKOPT
      character 
     &   cwd*(MXCHAR_FILEWORD)
     &  ,cwd1*(MXCHAR_FILEWORD)
     &  ,cwd2*(MXCHAR_FILEWORD)
     &  ,ctmp*(MXCHAR_FILEWORD)
     &  ,cfilt(2)*2, cfilt1*1
     &  ,cutvar_file*(MXCHAR_FILENAME)
     &  ,list_file*(MXCHAR_FILENAME)

c function
      INTEGER FILTINDX

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
C -------------------- BEGIN -------------------

      CALL PRBANNER("INI_WRSALT2: Translate SNANA -> SALT2 format")

      LL = INDEX(REFORMAT_KEYS,' ') -1
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD = STORE_PARSE_WORDS(MSKOPT, REFORMAT_KEYS(1:LL)//char(0),LL)

      NAMEof_SURVEY        = 'NULL'      
      NAMEof_INSTRUMENT    = 'NULL'
      NAMEof_MAGSYS        = 'NULL'
      NAMEof_PREFIX        =  SURVEY_NAME
      NAMEof_REPLACE(1)    = 'NULL'
      NAMEof_REPLACE(2)    = 'NULL'

      NREPLACE = 0
      NEWKEY = 0

      DO ifilt = 1, MXFILT_ALL
           IMAP_REPLACE(IFILT) = -9
      ENDDO

      DO iwd = 1, NWD

        CALL get_PARSE_WORD_fortran(iwd+0, cwd,  LL0 )
        CALL get_PARSE_WORD_fortran(iwd+1, cwd1, LL1 )

        if ( cwd(1:LL0) .EQ. '@SURVEY' ) then
          NAMEof_SURVEY = cwd1

        else if ( cwd(1:LL0) .EQ. '@INSTRUMENT' ) then
          NAMEof_INSTRUMENT = cwd1

        else if ( cwd(1:LL0) .EQ. '@MAGSYS' ) then
          NAMEof_MAGSYS = cwd1

        else if ( cwd(1:LL0) .EQ. '@PREFIX' ) then
          NAMEof_PREFIX = cwd1

        else if ( cwd(1:LL0) .EQ. '@REPLACE' ) then
           CALL get_PARSE_WORD_fortran(iwd+2, cwd2, LL2 )
          NAMEof_REPLACE(1) = cwd1
          NAMEof_REPLACE(2) = cwd2
          NREPLACE    = INDEX(NAMEof_REPLACE(1), ' ' ) - 1
        else if ( cwd(1:1) .EQ. '@' ) then
          NEWKEY = NEWKEY + 1
          NEWKEY_NAME(NEWKEY) = cwd(2:LL0)
          NEWKEY_ARG(NEWKEY)  = cwd1
        endif

      ENDDO

      LEN_SURVEY  = INDEX(NAMEof_SURVEY,    ' ' ) - 1
      LEN_INST    = INDEX(NAMEof_INSTRUMENT,' ' ) - 1
      LEN_MAGSYS  = INDEX(NAMEof_MAGSYS,    ' ' ) - 1
      LEN_PREFIX  = INDEX(NAMEof_PREFIX,    ' ' ) - 1

c make sure that required keys are specified.

      if ( NAMEof_INSTRUMENT .EQ. 'NULL' ) then
        c1err = 'MUST specify @INSTRUMENT <instrument> in '
        c2err = '&SNLCINP namelist string REFORMAT_KEYS'
        CALL  MADABORT("WRSALT2_2", C1ERR, C2ERR)
      endif
      if ( NAMEof_MAGSYS .EQ. 'NULL' ) then
        c1err = 'MUST specify @MAGSYS <magsys> in '
        c2err = '&SNLCINP namelist string REFORMAT_KEYS'
        CALL  MADABORT("WRSALT2_2", C1ERR, C2ERR)
      endif

c ----------
c Check for filter-name substitutions;
c i.e., UGRIZ -> ugriz for the SDSS
  
      IF ( NREPLACE .GT. 0  ) THEN

c abort if filter-strings have different length
        NTMP   = INDEX(NAMEof_REPLACE(2), ' ' ) - 1
        IF ( NREPLACE .NE. NTMP ) THEN
          c1err = 'Filter @REPALCE strings have different length'
          c2err = 'Cannot replace ' // 
     &              NAMEof_REPLACE(1)(1:NREPLACE) // ' with ' //
     &              NAMEof_REPLACE(2)(1:NTMP)
          CALL  MADABORT("WRSALT2_2", C1ERR, C2ERR)
        ENDIF

c create map between original filter and subst. filter

        DO 55 ifilt = 1, NREPLACE
           cfilt(1) = NAMEof_REPLACE(1)(ifilt:ifilt)
           cfilt(2) = NAMEof_REPLACE(2)(ifilt:ifilt)
           IFILT_TMP(1) = FILTINDX ( cfilt(1) )
           IFILT_TMP(2) = FILTINDX ( cfilt(2) )
           IMAP_REPLACE(IFILT_TMP(1)) = IFILT_TMP(2)
           
           write(6,56) cfilt, IFILT_TMP
56         format(t10,'Prepare @REPLACE map for ' , A2,' -> ', A2,
     &       '(', I2,' -> ', I2, ')' )

55      CONTINUE
      ENDIF

c ----------------------------
c  open list-file and leave it open.

      LIST_FILE = NAMEof_PREFIX(1:LEN_PREFIX) // '.LIST'
      print*,'   Open list-file: ', LIST_FILE(1:LEN_PREFIX+12)

      OPEN( UNIT   = LUNSALT2
     &    , FILE   = LIST_FILE
     &    , STATUS = 'UNKNOWN'
     &           )

c ----------------------------
c write cut-def file, then close it.

      CUTVAR_FILE = NAMEof_PREFIX(1:LEN_PREFIX) // '_CUTVAR.LOG'
      print*,'   Write cut-definitions to ' // 
     &    CUTVAR_FILE(1:LEN_PREFIX+12)

      OPEN( UNIT   = LUNTMP
     &    , FILE   = CUTVAR_FILE
     &    , STATUS = 'UNKNOWN'
     &           )

      write(LUNTMP,111) 'Z_HELIO   ', 
     &       'heliocentric redshift'
      write(LUNTMP,111) 'MWEBV     ', 
     &       'Galactic E(B-V)'
      write(LUNTMP,111) 'MWEBV_ERR     ', 
     &       'error on Galactic E(B-V)'

        write(ctmp,401) int(cutwin_trest(1)), int(cutwin_trest(2))
401     format(I3,'<Trest<' , I3,' days')
        write(LUNTMP,111) 'NOBS      ', 
     &       'Nobs total with any S/N and ' // ctmp(1:20)
        write(LUNTMP,111) 'TRESTMIN  ', 
     &       'min Trest(days) relative to peak (any S/N)' 
        write(LUNTMP,111) 'TRESTMAX  ', 
     &       'max Trest(days) relative to peak (any S/N)'

        write(LUNTMP,111) 'T0GAPMAX  ', 
     &       'max rest-frame gap (days) that overlaps peak epoch'

        write(LUNTMP,111) 'SNRMAX    ', 
     &       'max S/N among all observations'
        write(LUNTMP,111) 'SNRMAX2   ', 
     &       'max S/N excluding filter with SNRMAX'

        write(LUNTMP,111) 'SNRMAX3   ', 
     &       'max S/N excluding filters with SNRMAX & SNRMAX2'


        write(LUNTMP,600) ' '
        DO IFILT     = 1, NFILTDEF_SURVEY
           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
           cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
           ctmp      = 'SNRMAX_' // cfilt1
           LL        = INDEX(ctmp,' ') - 1
           write(LUNTMP,111) ctmp(1:10),
     &       'max S/N for indicated filter'
        ENDDO

      IF ( OPT_SETPKMJD > 0 ) THEN
        write(LUNTMP,600) ' '
        DO IFILT     = 1, NFILTDEF_SURVEY
           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
           cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
           ctmp      = 'ERRT0_' // cfilt1
           LL        = INDEX(ctmp,' ') - 1
           write(LUNTMP,111) ctmp(1:10),
     &       'fitted T0 error (days) for indicated filter'
        ENDDO

        write(LUNTMP,600) ' '
        DO IFILT     = 1, NFILTDEF_SURVEY
           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
           cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
           ctmp      = 'ERRF0_' // cfilt1
           LL        = INDEX(ctmp,' ') - 1
           write(LUNTMP,111) ctmp(1:10),
     &       'ERR(F0)/F0 for indicated filter'
        ENDDO

      ENDIF

111     format('@', A, ' : ', A)
600     format(A)
        CLOSE(UNIT=LUNTMP)

      print*,' -----------------------------------------------' 
      print*,' '
      RETURN
      END
C =========================================
+DECK,WRS2_2.
      SUBROUTINE WRSALT2_2()
c
c Created July 30, 2010 by R.Kessler
c Re-write SN data files into new SALT2 format with
c one file per SN.
c Output used by J. Guy's SALT2 'snfit' and 'pcafit' programs,
c version 2.3.0 and higher.
c Mainly used for SDSS data, and for simulations.
c
c
c See &SNLCINP namelist variables
c  OPT_REFORMAT_SALT2 = 2
c
c so that arbitray keys can be specified.
c
c
c Jan 25, 2013: use REAL*8 MJD8 instead of REAL*4 MJD to avoid
c               round-off error.
c
c May 20 2013: include RA and DEC in SALT2 files.
c
c Jul 8 2013: write name of ascii SNDATA file ONLY for FORMAT_TEXT=T
c
c Jul 17, 2013: write @FIELD  <list of fields>
c
c Feb 25, 2014: remove logic with ITERSE_FLUXZPT
c -----------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,WRS2COM.
+CDE,PKMJDCOM.

      INTEGER 
     &   EPMIN, EPMAX, EP, NEWMJD
     &  ,IFILT, IFILT_OBS, IFILT_REPLACE
     &  ,LENCID, LS, IERR, CID, ikey, L1, L2, LL, i
    
      REAL 
     &   PEAKMJD, FLUX, FLUXERR
     &  ,ZP, ZPOFF, arg, Fscale, TMP, ERR

  
      REAL*8  MJD8

      LOGICAL LWR_FILT(MXFILT_OBS)

      CHARACTER 
     &   cfilt1*1,  ccid*(MXCHAR_CCID)
     &  ,salt2_file*(MXCHAR_FILENAME)
     &  ,SURVEY_NAME_LOCAL*(MXCHAR_FILEWORD)
     &  ,SIMFILE*(MXCHAR_FILENAME)
     &  ,ctmp*60

c  functions
      LOGICAL CHECK_EPOCH_IGNORE

C ------------ BEGIN -------------

      CCID   = SNLC_CCID

c if CCID is an integer, write in I6.6 (or I8.8) format
      read( ccid, 25 , iostat = IERR ) CID
25    format(I9)
      
      IF ( IERR .EQ. 0  ) THEN
         CALL CIDSTRING(CID,CCID,LENCID)
      ENDIF

c  ----------------------

      LS  = INDEX(SURVEY_NAME,' ' ) - 1
      LENCID = INDEX(CCID,' ' ) - 1

      SALT2_FILE = NAMEof_PREFIX(1:LEN_PREFIX) // '_' // 
     &             CCID(1:LENCID) // '.DAT'

       LL = INDEX(SALT2_FILE,' ') - 1
       WRITE(LUNSALT2,700) SALT2_FILE(1:LL)
700    FORMAT(A)

      IF ( LSIM_SNANA ) THEN
          PEAKMJD = SIM_PEAKMJD
      ELSE
          PEAKMJD = SNLC_SEARCH_PEAKMJD
      ENDIF

      OPEN(   UNIT   = LUNDAT 
     &      , FILE   = SALT2_FILE
     &      , STATUS = 'UNKNOWN'
     &           )

      IF ( NAMEof_SURVEY(1:4) .EQ.  'NULL' ) then
        SURVEY_NAME_LOCAL = SURVEY_NAME  ! SNANA survey name
      ELSE
        SURVEY_NAME_LOCAL = NAMEof_SURVEY ! user-specified survey name
      ENDIF


      ctmp = 'Translated into SALT2 format by SNANA ' // SNANA_VERSION
      write(LUNDAT,120) ctmp
      write(LUNDAT,120) ' '

      write(LUNDAT,120) 'Required variables'
      write(LUNDAT,11) 'SURVEY',   SURVEY_NAME_LOCAL
      write(LUNDAT,11) 'SN',       CCID(1:LENCID)

      write(LUNDAT,126) 'RA',    SNLC8_RA
      write(LUNDAT,126) 'DEC',   SNLC8_DEC

c ---- write field(s) - include all overlapping fields for this SN -----
      write(LUNDAT,1220) 
      DO  i = 1, ISNLC_NFIELD_OVP
         LL = INDEX( SNLC_FIELD_OVPLIST(i), ' ') - 1
         write(LUNDAT,1230) SNLC_FIELD_OVPLIST(i)(1:LL)
      ENDDO
      write(LUNDAT,1240)

 1220 FORMAT('@FIELD  ', $)
 1230 FORMAT(A, '  ', $)
 1240 FORMAT(' ')

c ------------------------------------

      write(LUNDAT,12) 'Z_HELIO',  SNLC_ZHELIO
      write(LUNDAT,12) 'Z_CMB  ',  SNLC_ZCMB

      write(LUNDAT,12) 'MWEBV  ',  SNLC_MWEBV
      write(LUNDAT,12) 'MWEBV_ERR ',SNLC_MWEBV_ERR
      write(LUNDAT,13) 'DayMax  ', PEAKMJD

c --------------------------------------
c add new keys, if any are given (Dec 2010)

      DO 22 ikey = 1, NEWKEY
         L1 = INDEX(NEWKEY_NAME(ikey),' ') - 1
         L2 = INDEX(NEWKEY_ARG(ikey),' ') - 1
         write(LUNDAT,11) 
     &      NEWKEY_NAME(ikey)(1:L1), NEWKEY_ARG(ikey)(1:L2)
22    CONTINUE


c Set LWR_FILT logical array for filters to write out.
c Use SNRMAX_FILT to determine if a filter is used.

      DO IFILT     = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)        
         TMP       = SNLC_SNRMAX_FILT(ifilt) 
         if ( TMP .NE. -9.0 ) then          
            LWR_FILT(IFILT_OBS) = .TRUE.
         else
            LWR_FILT(IFILT_OBS) = .FALSE.
         endif
      ENDDO
      
c --------------------------------------
c add extra cut variables (Sep 29 2010)

      write(LUNDAT,120) ' '
      write(LUNDAT,120) 'Analysis variables'
      write(LUNDAT,30) 'SNTYPE   ',  ISNLC_TYPE
      write(LUNDAT,30) 'NOBS     ',  ISNLC_NEPOCH_USE
      write(LUNDAT,14) 'TRESTMIN ',  SNLC_TRESTMIN
      write(LUNDAT,14) 'TRESTMAX ',  SNLC_TRESTMAX
      write(LUNDAT,14) 'T0GAPMAX ',  SNLC_T0GAPMAX
      write(LUNDAT,14) 'SNRMAX   ',  SNLC_SNRMAX_SORT(1)
      write(LUNDAT,14) 'SNRMAX2  ',  SNLC_SNRMAX_SORT(2)
      write(LUNDAT,14) 'SNRMAX3  ',  SNLC_SNRMAX_SORT(3)

c write SNRMAX for each filter.
      DO IFILT     = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)        
         cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)         
         TMP       = SNLC_SNRMAX_FILT(ifilt) 
         if ( LWR_FILT(ifilt_obs) ) then          
            write(LUNDAT,114) 'SNRMAX_', cfilt1, TMP
         endif

      ENDDO

114   format('@', A, A, 2x, F8.3)

c to quanititative FoM, write error on flux and T0 for each band 
      IF ( OPT_SETPKMJD > 0 ) THEN

        write(LUNDAT,120) ' '
        write(LUNDAT,120) 'Fitted errors => exp(dT/T1)/[1+exp(dT/T2)]'
        write(LUNDAT,120) 'ERRT0 => error on peak MJD'
        write(LUNDAT,120) 'ERRF0 => ERROR(F0)/F0 where F0 = peak flux'


        DO IFILT    = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
          if ( LWR_FILT(ifilt_obs) ) then
            ERR       = PKMJD_ERR(ifilt_obs) 
            write(LUNDAT,114) 'ERRT0_', cfilt1, ERR
          endif
        ENDDO         
          write(LUNDAT,12) 'ERRT0_MIN', PKMJD_ERRMIN
          write(LUNDAT,12) 'ERRT0_WGT', PKMJD_ERRWGT

        DO IFILT    = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)          
          cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
          if ( LWR_FILT(ifilt_obs) ) then
            ERR       = PKFLUX_ERR(ifilt_obs)/PKFLUX_FIT(ifilt_obs)
            write(LUNDAT,114) 'ERRF0_', cfilt1, ERR
          endif
        ENDDO 
          write(LUNDAT,12) 'ERRF0_MIN', PKFLUX_ERRMIN
          write(LUNDAT,12) 'ERRF0_WGT', PKFLUX_ERRWGT

      ENDIF  ! end of OPT_SETPKMJD


      IF ( LSIM_SNANA ) THEN
        write(LUNDAT,120) ' '
        write(LUNDAT,120) 'SIMULATION Parameters'

c start with the exact name of the SNANA file that was translated
        IF ( FORMAT_TEXT ) THEN
          L1 = INDEX(VERSION_PHOTOMETRY(1),' ' ) - 1
          L2 = INDEX(SNDATA_FILE_CURRENT,' ' ) - 1
          SIMFILE = '$SNDATA_ROOT/SIM/' // 
     &        VERSION_PHOTOMETRY(1)(1:L1) // '/' //
     &        SNDATA_FILE_CURRENT(1:L2)
          LL = INDEX(SIMFILE,' ') - 1
          WRITE(LUNDAT,11) 'SIM_SNANAFILE' , SIMFILE(1:LL)
        ENDIF

        write(LUNDAT,30)  'SIM_SNTYPE   ', SIM_GENTYPE
        write(LUNDAT,30)  'SIM_TEMPLATE_INDEX  ', SIM_TEMPLATE_INDEX
        write(LUNDAT,93)  'SIM_PEAKMJD  ', SIM_PEAKMJD
        write(LUNDAT,12)  'SIM_MWEBV    ', SIM_MWEBV
        write(LUNDAT,12)  'SIM_REDSHIFT ', SIM_REDSHIFT_CMB
        write(LUNDAT,12)  'SIM_MU       ', SIM_DLMAG

        IF ( SIM_TEMPLATE_INDEX .EQ. 0 ) THEN
          write(LUNDAT,12)  'SIM_x0 ',    SIM_SALT2x0
          write(LUNDAT,12)  'SIM_mb ',    SIM_SALT2mb
          write(LUNDAT,12)  'SIM_x1 ',    SIM_SHAPEPAR
          write(LUNDAT,12)  'SIM_c  ',    SIM_COLORPAR
          write(LUNDAT,12)  'SIM_alpha ', SIM_SHAPELAW
          write(LUNDAT,12)  'SIM_beta  ', SIM_COLORLAW
        ENDIF

        DO IFILT    = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          cfilt1    = filtdef_string(ifilt_obs:ifilt_obs)
          TMP       = SIM_PEAKMAG(ifilt) 
          write(LUNDAT,114) 'SIM_PEAKMAG_', cfilt1, TMP
        ENDDO

      ENDIF  ! end of LSIM_SNANA 

      write(LUNDAT,120) ' '
      write(LUNDAT,120) '--------------------------------------'
      write(LUNDAT,120) ' '

c ---------------------------------------
c define data columns
      write(LUNDAT,20) 'Date'
      write(LUNDAT,20) 'Flux'
      write(LUNDAT,20) 'Fluxerr'
      write(LUNDAT,20) 'ZP'
      write(LUNDAT,20) 'Filter'
      write(LUNDAT,20) 'MagSys'
      write(LUNDAT,20) 'end'

11    format('@', A, 2x, A)
12    format('@', A, 2x, F8.5)
13    format('@', A, 2x, F9.3, 2x, '1')
14    format('@', A, 2x, F7.2)
20    format('#', A, ' : ' )
30    format('@', A, 2x, I5)
93    format('@', A, 2x, F9.3)
126   format('@', A, 2x, F12.6)

120   format('# ! ', A )

c write observations.

      DO 301 NEWMJD = 1, ISNLC_NEWMJD_STORE
          EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
          EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

          DO 302 EP = EPMIN, EPMAX

            IF ( CHECK_EPOCH_IGNORE(0,ep) ) GOTO 302

            IFILT_OBS     = ISNLC_IFILT_OBS(ep)
            IFILT_REPLACE = IMAP_REPLACE(IFILT_OBS)

c  skip obs that are cut in SNRECON (Jan 2, 2012)
            if ( .not. LWR_FILT(ifilt_obs) ) GOTO 302


            IF ( IFILT_REPLACE .GT. 0 ) THEN
               cfilt1 = filtdef_string(ifilt_replace:ifilt_replace)
            ELSE
               cfilt1 = filtdef_string(ifilt_obs:ifilt_obs)
            ENDIF

            ZPOFF   = MAGOBS_SHIFT_ZP_FILT(ifilt_obs)
            MJD8    = SNLC8_MJD(EP)

            ZP  = ZEROPOINT_FLUXCAL_DEFAULT + ZPOFF
            arg = 0.4*ZPOFF

            Fscale  = 10.0**ARG

c get fluxes in native system (i.e., undo AB offsets)
            Flux    = Fscale * SNLC_FLUXCAL(EP)
            Fluxerr = Fscale * SNLC_FLUXCAL_ERRTOT(EP)
            WRITE(LUNDAT,330) MJD8, FLUX, FLUXERR, ZP
     &          , NAMEof_INSTRUMENT(1:LEN_INST)
     &          , cfilt1
     &          , NAMEof_MAGSYS(1:LEN_MAGSYS)

302      CONTINUE  ! EP
301   CONTINUE  ! NEWMJD

330   FORMAT(F9.3, 2x, 2G14.6, 1x, F7.3, 3x,A,'::',A,1x,A )

      CLOSE ( LUNDAT )

      RETURN
      END  ! end of WRSALT2_2


C ============================
+DECK,MADABORT.
      SUBROUTINE MADABORT(funname,c1err,c2err)
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
      character funname*(*)          ! name of function calling MADABORT
      character c1err*(*), c2err*(*) ! two error messages
      INTEGER ISEV_FATAL, IPROMPT, LENF, LEN1, LEN2
      PARAMETER ( ISEV_FATAL = 4, IPROMPT=0 )
      LOGICAL LEGACY_ABORT

      EXTERNAL ERRMSG
      INTEGER  LENSTR
c ----------------- BEGIN --------------

      LEGACY_ABORT = .FALSE.

      IF ( LEGACY_ABORT ) then
         CALL MADABORT_LEGACY(funname,c1err,c2err)
      ELSE
         LENF = LENSTR(funname)
         LEN1 = LENSTR(c1err)
         LEN2 = LENSTR(c2err)
         call errmsg(ISEV_FATAL, IPROMPT, 
     &       funname(1:LENF)//char(0), 
     &       c1err(1:LEN1)//char(0),
     &       c2err(1:LEN2)//char(0),
     &          LENF, LEN1, LEN2 )
      ENDIF

      RETURN
      END

C =============================
+DECK,LENSTR.
      INTEGER FUNCTION LENSTR(string)
c Created Dec 17 2019
c STRING = 'Hi, what is this.' --> LENSTR = 17
c 
      IMPLICIT NONE
      CHARACTER STRING*(*)
      INTEGER LENTOT, LEN, i
C ---------- BEGIN -------------
      LENTOT = index(string,' ', back = .TRUE. ) - 1
      DO i = 1, LENTOT
        IF ( STRING(i:i) .NE. ' ' ) LEN=i
      ENDDO
      LENSTR = LEN
      RETURN
      END

C ===========================================
+DECK,MADABORT_LEGACY.
c
c Jan 2019: replace STOP with EXIT for well-defined return code.
c
      SUBROUTINE MADABORT_LEGACY(funname,c1err,c2err)
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
      character funname*(*)          ! name of function calling MADABORT
      character c1err*(*), c2err*(*) ! two error messages

C ------- BEGIN ------------

      print*,' '
      print*, ' '
      print*,' '
      print*,"   `|```````|`    "
      print*,"   <| o\\ /o |>   "
      print*,"    | ' ; ' |     "
      print*,"    |  ___  |     "
      print*,"    | |' '| |     "
      print*,"    | `---' |     "
      print*,"    \_______/    "
      print*,""

      print*,' FATAL ERROR in function : ', FUNNAME
      print*,' ',  c1err(1:76)
      print*,' ',  c2err(1:76)
      print*, ' '
      print*, ' ***** ABORT ***** '
      print*, ' '
      CALL FLUSH(6)
c      STOP
      CALL EXIT(EXIT_ERRCODE)

      RETURN
      END  ! end MADABORT_LEGACY


C ======================================
+DECK,CHCKLINE_ARGS.
      SUBROUTINE CHECK_LINE_ARGS
c
c Feb 7, 2007
c Check that all NLINE_ARG command-line args
c were used. If any were not used, then give
c error message and abort.
c 

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i, LL, NBAD

C ------------------ BEGIN --------------

      NBAD = 0

      DO i = 2, NLINE_ARGS

         LL = INDEX ( LINE_ARGS(i), ' ' ) - 1         
         if ( .NOT. USE_LINE_ARGS(i) ) then
            NBAD = NBAD + 1

            if ( NBAD .EQ. 1 ) then
              print*,' '
              print*,' CHECK_LINE_ARGS ERROR: '
            endif
            print*,' ERROR: Detected un-used command-line argument: ',
     &                 '"' , LINE_ARGS(i)(1:LL), '"'
         endif
      ENDDO

      IF ( NBAD .GT. 0 ) THEN
         print*,' ***** ABORT ***** '
         CALL EXIT(EXIT_ERRCODE)
      ENDIF

      RETURN
      END


C ================================================
+DECK,INIT_SNVAR.
      SUBROUTINE INIT_SNVAR(IERR)
c
c Init some SN variables.
c Called once at beginning of program.
c See INIT_SNDATA to initilaize each SN.
c
c Nov 6, 2006: define SNANA_DIR and read ZPOFF from default file.
c
c Dec 16, 2006: update 2006 ranges and add MJDRANGE
c
c Oct 6, 2009:  fix dumb bugs caught with fcheck-bounds
c    HIDKCOR -> HIDMAG
c    IFILTDEF_IGNORE_REST(i) -> IFILTDEF_IGNORE_REST(ifilt)
c
c Mar 29, 2010: init &SNLCINP namelist char-string ZPOFF_FILE
c
c Feb 19 2014: abort if SNDATA_ROOT is not defined.
c Jan 16 2019: init EXIT_ERRCODE
c ---------------------------------------------------
 
      IMPLICIT NONE
      INTEGER   IERR         ! (O) 0=> OK,  else error


c include everything except the memory hogging SNLCCOM

+CDE,SNPAR.
+CDE,SNFILECOM.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,KCORCOM,IF=R4KCOR,I2KCOR.
+CDE,SNHOSTCOM.
c +CDE,PARSECOM.
+CDE,SNSIMCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.
+CDE,PKMJDCOM.
+CDE,PRIVCOM.
+CDE,NNCOM.
+CDE,EARLYCOM.
+CDE,SPECCOM.

      INTEGER icut, i, ibit, itype, ipar, ifilt, LM,istat
      INTEGER LL, LL_SNANA, NWD
      CHARACTER ENVtemp*400, HOST*40, MACH*40, FNAM*12

c function
      INTEGER FILTINDX, EXEC_CIDMASK, STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS, SET_EXIT_ERRCODE

C ---------------- BEGIN ------------

      FNAM = 'INIT_SNVAR'

+SELF,IF=SNANA.
      EXIT_ERRCODE = EXIT_ERRCODE_SNANA
+SELF,IF=SNFIT.
      EXIT_ERRCODE = EXIT_ERRCODE_SNFIT
+SELF,IF=PSNID.
      EXIT_ERRCODE = EXIT_ERRCODE_PSNID
+SELF.
      CALL SET_EXIT_ERRCODE(EXIT_ERRCODE) ! for C function aborts


c get SNANA version from C function
      call GET_SNANA_VERSION(SNANA_VERSION,LL)
      LL_SNANA = index(SNANA_VERSION, char(0) ) - 1
      SNANA_VERSION(LL_SNANA+1:LL_SNANA+3) = '   '

      IERR = 0
      IDSURVEY = -9 ;  IDSUBSURVEY=-9
      NCALL_SNANA_DRIVER  = 0 
 
      CALL PRBANNER ( " INIT_SNVAR: Init variables." )

      FORMAT_TEXT    = .FALSE.
      FORMAT_TERSE   = .FALSE.
      FORMAT_VERBOSE = .FALSE.
      FORMAT_FITS    = .FALSE.

      ISJOB_SNANA = .FALSE.
      ISJOB_PSNID = .FALSE.

      NEPOCH_TOT = 0
      NEPOCH_CUT = 0
      NEPOCH_BADPHOT     = 0
      NEPOCH_BADPHOT_SUM = 0

      INTERP_OPT  = INTERP_LINEAR  ! used by simulation

c define filter indices for Legacy filters
      IFILT_SDSS_u = FILTINDX("u ")
      IFILT_SDSS_g = FILTINDX("g ")
      IFILT_SDSS_r = FILTINDX("r ")
      IFILT_SDSS_i = FILTINDX("i ")
      IFILT_SDSS_z = FILTINDX("z ")
      IFILT_BESS_U = FILTINDX("U ")
      IFILT_BESS_B = FILTINDX("B ")
      IFILT_BESS_V = FILTINDX("V ")
      IFILT_BESS_R = FILTINDX("R ")
      IFILT_BESS_I = FILTINDX("I ")
      IFILT_BESS_BX = FILTINDX("X ")
      IFILT_Y = FILTINDX("Y ")
      IFILT_J = FILTINDX("J ")
      IFILT_H = FILTINDX("H ")
      IFILT_K = FILTINDX("K ")

      SURVEY_NAME    = ''
      SUBSURVEY_NAME = ''
      SUBSURVEY_NAME_LIST=''

      SURVEY_FILTERS = ''
      FREEZE_SURVEY_FILTERS = .FALSE.
      EXIST_BXFILT_OBS      = .FALSE.
      EXIST_BXFILT_REST     = .FALSE.

      NFILTDEF_SURVEY = 0
      NFILTDEF_READ   = 0
      NFILTDEF_REST   = 0
      
      NFILTDEF_IGNORE_REST = 0

      DO ifilt = 1, MXFILT_OBS
          IFILTDEF_MAP_SURVEY(ifilt) = -9
          IFILTDEF_MAP_REST(ifilt)   = -9
          IFILTDEF_IGNORE_REST(ifilt) = -9
      ENDDO

      DO ifilt = 1, MXFILT_ALL

          IFILTDEF_INVMAP_SURVEY(ifilt)  = -9
          IFILTDEF_INVMAP_REST(ifilt)    = -9

          MAGOBS_SHIFT_PRIMARY_FILT(ifilt)  = 0.0
          MAGOBS_SHIFT_ZP_FILT(ifilt)       = 0.0
          MAGOBS_SHIFT_ZP_USER(ifilt)       = 0.0
          MAGREST_SHIFT_PRIMARY_FILT(ifilt) = 0.0
          MAGREST_SHIFT_ZP_FILT(ifilt)      = 0.0
          MAGREST_SHIFT_ZP_USER(ifilt)      = 0.0
          FILTOBS_ZPOFF_SNPHOT(ifilt)       = 0.0

          FILTOBS_TRANSMAX(ifilt)         =  0.0
          FILTOBS_LAMAVG(ifilt)           = -9.0
          FILTOBS_LAMRMS(ifilt)           = -9.0
          FILTOBS_LAMRANGE(1,ifilt)       = -9.0
          FILTOBS_LAMRANGE(2,ifilt)       = -9.0
          FILTOBS_LAMSHIFT(ifilt)         =  0.0
          NLAMBIN_FILTOBS(ifilt)          =  0

          FILTREST_TRANSMAX(ifilt)         =  0.0
          FILTREST_LAMAVG(ifilt)           = -9.0
          NLAMBIN_FILTREST(ifilt)          =  0
          FILTREST_LAMRANGE(1,ifilt)       = -9.0
          FILTREST_LAMRANGE(2,ifilt)       = -9.0

          FILTOBS_NAME(ifilt)       = ''
          LFILTDEF_OBS(ifilt)       = .FALSE.
          LFILTDEF_REST(ifilt)      = .FALSE.
          LFILTDEF_NONSURVEY(ifilt) = .FALSE.
          LFILTDEF_SNRMAX(ifilt)    = .TRUE.  ! use all filters by default

          FUDGE_FLUXCAL_ERROR_FILT(ifilt)   =  0.0 
          FUDGE_FLUXCAL_ERRPIX_FILT(ifilt)  =  0.0 
          FUDGE_FLUXCAL_OFFSET_FILT(ifilt)  =  0.0 
          FUDGE_MAG_ERROR_FILT(ifilt)       =  0.0 
          FUDGE_MAG_COVERR_FILT(ifilt)      =  0.0 

      END DO

c extract SNDATA_ROOT and SNANA_DIR  env variables
      
      CALL GETENV ( 'HOST',     ENVtemp )
      LL = INDEX ( ENVtemp , ' ' ) - 1
      HOST = ENVtemp(1:LL)

      CALL GETENV ( 'MACHTYPE', ENVtemp )     
      LM = INDEX ( ENVtemp , ' ' ) - 1
      MACH = ENVtemp(1:LM)

      print*,'  HOST MACHINE = ', HOST(1:LL), 
     &      '   (',MACH(1:LM),')'

      CALL GETENV ( 'SNDATA_ROOT', ENVtemp )
      LL = INDEX ( ENVtemp , ' ' ) - 1

      IF ( LL > MXCHAR_PATH ) then
         write(C1ERR,61) 'SNDATA_ROOT', LL
         write(C2ERR,62) MXCHAR_PATH
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF
61       FORMAT('LEN($', A, ') = ',I3,' is too long')
62       format('MXCHAR_PATH = ', I3)
      if ( LL .EQ. 0 ) then
         C1ERR = 'SNDATA_ROOT is not defined.'
         C2ERR = 'Check your snana setup.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      SNDATA_ROOT = ENVtemp(1:LL)
      print*,'  SNDATA_ROOT = ', SNDATA_ROOT(1:LL)

c - - - - - 
      CALL GETENV ( 'SNANA_DIR', ENVtemp )
      LL = INDEX ( ENVtemp , ' ' ) - 1
      IF ( LL > MXCHAR_PATH ) then
         write(C1ERR,61) 'SNANA_DIR', LL
         write(C2ERR,62) MXCHAR_PATH
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

      SNANA_DIR = ENVtemp(1:LL)
      print*,'  SNANA_DIR = ', SNANA_DIR(1:LL), 
     &   '    (', SNANA_VERSION(1:LL_SNANA),')'


      N_SNFILE      = 0
      N_SNFILE_LAST = 0

      N_SNLC          = 0
      N_SNLC_CUTS     = 0
      N_SNLC_FIT      = 0
      N_SNLC_FITCUTS  = 0
      N_SNLC_COVFIX   = 0
      N_SNLC_PLOT     = 0
      N_DUPLICATE_CID = 0
      N_DUPLICATE_MJD = 0
      NSTORE_DUPLICATE_MJD = 0

      DO itype = -1, MXTYPE
        NPASSCUT_FIT(itype) = 0
      DO ibit  = 1, NCUTBIT_SNLC+1
        NPASSCUT_INCREMENT(itype,ibit) = 0
      ENDDO
      ENDDO

      LSIM_SNANA   = .FALSE.  ! snana sim  
      LSIM_MAGOBS  = .FALSE.  
    

      NACCEPT_Z    = 0
      NACCEPT_ZERR = 0
      NACCEPT_CID  = 0
      NACCEPT_TYPE = 0
      DO icut = 1, NCUTBIT
        NACCEPT_CUT(icut) = 0
      ENDDO

c init HIDKCOR array to 0

+SELF,IF=R4KCOR,I2KCOR.

      NCALL_RDKCOR = 0
      RESTKCOR_FILTERS = ''
      USE_AVWARPTABLE = .FALSE.
      LRDZPOFF = .FALSE.

      LDMP_KCORFUN = .FALSE.
      LDMP_AVWARP  = .FALSE.


      NERR_AVWARP = 0
+SELF.

      ISTAT = EXEC_CIDMASK(0,MXCID_CHECK)  ! init CID bit-mask

      DO IPAR = 1, MXFITPAR
         ERRMAX_BAD(ipar) = 0.01  ! err < ERRMAX_BAD is labelled bad
      ENDDO
     
      SIMNAME_MODEL        = 'SIMNULL0'
      SIMNAME_SHAPEPAR     = 'SIM_SHAPE'  ! changed from SIMSHAPE (4/11/2017)
      SIMNAME_SHAPELAW     = 'SIMNULL1'  ! each SIMNULL has unique name
      SIMNAME_COLORPAR     = 'SIMNULL2'
      SIMNAME_COLORLAW     = 'SIMNULL3'
      SIMNAME_SNRMON       = 'NONE'

      SIMOPT_MWCOLORLAW = -9
      SIMOPT_MWEBV      = -9

      DO ifilt = 1, MXFILT_OBS
         SIM_EXPOSURE_TIME(ifilt)  = 1.0
      ENDDO
      
      SIMLIB_FILENAME = ""
      SIMLIB_MSKOPT   = 0

      DO ibit = 1, NCUTBIT
         CUTWIN_VAR(1,ibit) = -CUTVAL_OPEN
         CUTWIN_VAR(2,ibit) = +CUTVAL_OPEN
      ENDDO    
         CUTWIN_VAR(1,CUTBIT_NMJD_INCLUDE) = 0.99
              
      NEPOCH_IGNORE =  0
      EPOCH_IGNORE_LASTFILE = ''

cc      ZPOFF_FILE    = 'NULL'  ! NULL => use offsets in hid 292
      USERTAGS_FILE = ''
      VPEC_FILE            = ''
      HEADER_OVERRIDE_FILE = ''


      NPAR_SIMSED      = 0
      NPAR_BYOSED      = 0
      NPAR_LCLIB       = 0
 
      NPAR_SIM_HOSTLIB = 0

      C1ERR = ' '
      C2ERR = ' '
 
      DO_FLUXERRCALC = .FALSE.

      NFIT_PKMJD = 0
 
      NVAR_PRIVATE = 0
      IVAR_PRIVATE_REDSHIFT = 0
      DO i = 1, MXVAR_PRIVATE
        PRIVATE_KEYWORD(i)  = 'UNKNOWN'
        PRIVATE_VARNAME(i)  = 'UNKNOWN'
        PRIVATE_VALUE(i)    = PRIVATE_NULL
        PRIVATE_CUTWIN(1,i) = -CUTVAL_OPEN
        PRIVATE_CUTWIN(2,i) = +CUTVAL_OPEN
      ENDDO
    
      NCUT_PRIVATE = 0
      DO i = 1, MXCUT_PRIVATE
         PRIVATE_CUTWIN_STRING(i) = ''
         USE_PRIVATE_CUTWIN(i)    = 0
      ENDDO
      PRIVATE_REDSHIFT_CMB = ''

      SIMVAR_CUTWIN_STRING  = ''
      NSIMVAR_CUTWIN        = 0 

      EARLYLC_STRING        = ''
      REQUIRE_EPOCHS_STRING =  ''
      DUMP_STRING           = ''

c init HOST logicals
      EXIST_SNHOST_ZPHOT    = .FALSE.
      EXIST_SNHOST_LOGMASS  = .FALSE.
      EXIST_SNHOST_sSFR     = .FALSE.
      EXIST_SNHOST_MAGOBS   = .FALSE.
      EXIST_SNHOST_SB       = .FALSE.
      EXIST_SNHOST_ANGSEP   = .FALSE.
      EXIST_SNHOST_DDLR     = .FALSE.
      EXIST_SNHOST_CONFUSION= .FALSE.

c misc.
      NONSURVEY_FILTERS = ''
      FILTER_REPLACE    = ''
      FILTLIST_LAMSHIFT = ''

      NVAR_NEARNBR = 0
      FLAG_NEARNBR = NNFLAG_IGNORE 

      DO i = 1, MXFITSTORE
         PARNAME_STORE(i) = ''
         PAROPT_STORE(i)  = 0
      ENDDO

      CALL FLUSH(6)

      NWD = STORE_PARSE_WORDS(-1,""//char(0), 2 );

      RDFLAG_SPECTRUM = .FALSE.

      RETURN
      END   ! end of INIT_SNVAR


C =======================
+DECK,HDMSKCHK.
      SUBROUTINE HEADMASK_CHECK(CCID)

c Created Aug 28, 2012
c Check HEADMASK to make sure that all required header keys 
c have been read. Abort on any missing key.
c
c Feb 2016: check option to abort on missing header info.

      IMPLICIT NONE
      CHARACTER CCID*(*)  ! (I) name of SN

+CDE,SNPAR.
+CDE,SNFILECOM.
+CDE,SNCUTS.
+CDE,CTRLCOM.
+CDE,SNLCINP.

c local var

      INTEGER LKEY, LENTOT, ibit, OVP
      LOGICAL  LTMP

      CHARACTER 
     &   HEADBIT_STRING(0:NBIT_HEADMASK)*12
     &  ,CTMP*12
     &  ,KEY_LIST*100

C -------------- BEGIN ---------------

      OVP = IAND(HEADMASK,HEADMASK_REQUIRED)
      IF ( OVP .EQ. HEADMASK_REQUIRED ) RETURN

c Feb 2016: check option to abort on missing header info
      if ( .NOT. ABORT_ON_BADHEADER ) RETURN


c if we get here, print missing key(s) and abort.


c Start by filling string for each bit to simplify dump-logic

      HEADBIT_STRING(HEADBIT_SNID)    = 'SNID'
      HEADBIT_STRING(HEADBIT_IAUC)    = 'IAUC'
      HEADBIT_STRING(HEADBIT_CIDSEL)  = 'CIDSEL'
      HEADBIT_STRING(HEADBIT_SURVEY)  = 'SURVEY'
      HEADBIT_STRING(HEADBIT_FILTERS) = 'FILTERS'
      HEADBIT_STRING(HEADBIT_RA)      = 'RA'
      HEADBIT_STRING(HEADBIT_DEC)     = 'DEC'
      HEADBIT_STRING(HEADBIT_MWEBV)   = 'MWEBV'
      HEADBIT_STRING(HEADBIT_Z)       = 'REDSHIFT'

c get list of keys that are NOT set
      LENTOT   = 1
      KEY_LIST = ' '
      DO ibit = 0, NBIT_HEADMASK-1
         LTMP = BTEST(HEADMASK,ibit)
         if ( .not. LTMP ) then
            CTMP = HEADBIT_STRING(ibit)
            LKEY = INDEX(CTMP,' ') - 1
            KEY_LIST = KEY_LIST(1:LENTOT) // ' ' // CTMP(1:LKEY)
            LENTOT   = LENTOT + LKEY + 1
         endif
      ENDDO  

      write(C1ERR,61) HEADMASK, HEADMASK_REQUIRED, CCID
61    format('Bad HEADMASK=',I4,' (required=',I4,')', 3x,  
     &           'for SNID=', A )
      C2ERR = 'Missing key(s): ' // KEY_LIST(1:LENTOT)
      CALL MADABORT('HEADMASK_CHECK', C1ERR, C2ERR)

      RETURN
      END   ! HEADMASK_CHECK

C ======================
+DECK,NNRDINP.
      INTEGER FUNCTION SNANA_NEARNBR_RDINPUT()

c Created Apr 2013 by R.Kessler
c Check NEARNBR_XXX parameters from optioanl &NNINP namelist,
c and run initialization functions in sntools_nearnbr.c.
c This is a generic interface for any snana program so that
c the NN inputs can go into the same nml file as the other
c inputs.
c
c Returns NVAR 
c   = number of variables to analyze (flag that NN option is set)
c   = 0 -> NN option is NOT selected (flag to ignore NN option)
c
c Jun 12 2019:
c   pass TRUETYPE_SNIa to NEARNBR_SET_TRUETYPE().
c   Needed if SCALE_NON1A != 1.
c
c -----------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,NNCOM.  

      INTEGER   iocheck, LSTR,  LV, NVAR, NVAL, ISPLIT, N_IGNORE
      INTEGER   jskip, j, iwd, ign, NWD, MSKOPT, TRUETYPE_SNIa
      CHARACTER 
     &   STRING*(MXCHAR_FILENAME)
     &  ,VARLIST_IGNORE(NN_MXVAR)*(MXCHAR_FILEWORD)
     &  ,PATH*(MXCHAR_FILENAME)
     &  ,FNAM*24, VARNAME*(MXCHAR_FILEWORD)
     &  ,cwd*(MXCHAR_FILEWORD), c1, cMODE*8
     &  ,name_forC*(MXCHAR_FILENAME)

      LOGICAL   INPUT_ISVARNAME(4*NN_MXVAR)
      CHARACTER INPUT_VARNAME(4*NN_MXVAR)*(MXCHAR_FILEWORD)
      REAL*8    INPUT_VALUE(4*NN_MXVAR)
      REAL*8    SEPMAX(3), RATIO

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN -----------

      SNANA_NEARNBR_RDINPUT = 0
      FNAM = 'SNANA_NEARNBR_RDINPUT'

c init &NNINP values.      
      NEARNBR_TRAINFILE_PATH    = ' '
      NEARNBR_TRUETYPE_VARNAME  = ' '
      NEARNBR_SEPMAX_VARDEF     = ' '
      NEARNBR_SEPMAX_IGNORE     = ' '
      NEARNBR_TRAINFILE_LIST    = ' '
      NEARNBR_TRAIN_ODDEVEN     = .FALSE.
      NEARNBR_TRAINFILE_SCALE_NON1A = 1.0 

      NN_ITYPE_FIX    = -99
      NN_ITYPE_SNIa   = 1  

c init sums for each best-type
      NNSUM_UNKNOWN=0; NNSUM_IA=0;  NNSUM_NON1A=0

c re-open nml file
      OPEN (UNIT=LUNNML, file=nmlfile, status='OLD',ERR=900 )   
   
c try reading NNINP; if not there, just return quietly.    
      READ ( LUNNML, NML = NNINP, ERR = 900, IOSTAT = iocheck )         
      CLOSE ( UNIT = LUNNML )        
      if ( iocheck .NE. 0 ) return     

c make sure required output file (root or hbook) is specified
c to make NN-specific 1D and 2D histograms.
      if ( .NOT. USE_TABLEFILE ) then
         C1ERR = 'Must specify HFILE_OUT or ROOTFILE_OUT in &SNLCINP'
         C2ERR = 'to create required histograms for NN-training.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)  
      endif

c namelist &NNINP  exists ==> read it.
      CALL PRBANNER ( " FOUND and READ &NNINP NAMELIST. " )               
      WRITE ( 6 , NML = NNINP )   
      CALL FLUSH(6)

c check for command-line override
      CALL NNINP_OVERRIDE()
      
c make sure there is a training file to continue
      IF ( NEARNBR_TRAINFILE_LIST .EQ. ' ' ) THEN
         RETURN 
      ENDIF

c ----------------------------------------------
c call init functions in sntools_nearnbr.c

      CALL NEARNBR_INIT()  ! C function 
      
      IF ( NEARNBR_TRAINFILE_PATH .NE. ' ' ) THEN
        CALL SNANA_NEARNBR_RDPATH(PATH)  ! return PATH
        LSTR = INDEX(PATH,' ') - 1
        CALL NEARNBR_SET_TRAINPATH(PATH(1:LSTR)//char(0), LSTR)
      ENDIF

c -----------------------------
      IF ( NEARNBR_TRAIN_ODDEVEN ) THEN
         CALL NEARNBR_SET_ODDEVEN()  ! Apr 5 2019
         print*,'   ODDEVEN flag -> Select even CIDs'
         call flush(6)
      ENDIF

c init TRAINFILE

      STRING = NEARNBR_TRAINFILE_LIST
      LSTR = INDEX(STRING,' ') - 1
      CALL NEARNBR_SET_TRAINFILE(STRING(1:LSTR)//char(0), 
     &            NEARNBR_TRAINFILE_SCALE_NON1A, LSTR)

c ----------------
c set variable name with TRUETYPE

      STRING = NEARNBR_TRUETYPE_VARNAME
      LSTR = INDEX(STRING,' ') - 1
      TRUETYPE_SNIa = 1 ! beware this is hard-coded
      CALL NEARNBR_SET_TRUETYPE(STRING(1:LSTR)//char(0), 
     &                          TRUETYPE_SNIa, LSTR)

c get list of sepmax variables to IGNORE
      N_IGNORE = 0
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      IF ( NEARNBR_SEPMAX_IGNORE .NE. ' ' ) THEN
         LSTR      = INDEX(NEARNBR_SEPMAX_IGNORE,' ') -1 
         NAME_forC = NEARNBR_SEPMAX_IGNORE(1:LSTR)//char(0)
         N_IGNORE = STORE_PARSE_WORDS(MSKOPT,NAME_forC,LSTR)
         do jskip = 1, N_IGNORE
            CALL get_PARSE_WORD_fortran(jskip,
     &           VARLIST_IGNORE(jskip),LSTR)  ! returned
            write(6,678) VARLIST_IGNORE(jskip)
 678        format(T15,'Will IGNORE SEPMAX variable ' , A)
            call flush(6)
         enddo
      ENDIF

c -----------------------------
c break up each SEPMAX strings into VARNAME and SEPMAX(3) = MIN,MAX,BIN
c Example 1:  NEARNBR_SEPMAX_VARDEF = 'z .10' ->
c             VARNAME = 'z' and SEPMAX(3) = 0.10, 0, 0
c
c Example 1:  NEARNBR_SEPMAX_VARDEF = 'z .04 .20 .01' ->
c             VARNAME = 'z' and SEPMAX(3) = 0.04, 0.20, 0.01
c
c IGNORE any variable on the IGNORE list ... allows removing
c variables with FITOPT option in split_and_fit.

      LSTR = INDEX(NEARNBR_SEPMAX_VARDEF,' ', BACK=.TRUE.) - 1
      NAME_forC = NEARNBR_SEPMAX_VARDEF(1:LSTR)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT,NAME_forC,LSTR) 
c --------------------------------------------------------------
c check which words are variables names (i.e., strings) or values;
c check is based on first char of each word. Fill INPUT_XXX arrays.

      NVAR = 0 ;  NVAL = 0

      DO 100 iwd = 1, NWD
         INPUT_ISVARNAME(iwd) = .FALSE.
         INPUT_VALUE(iwd)     = 99999.
         INPUT_VARNAME(iwd)   = 'NULL'

         CALL get_PARSE_WORD_fortran(iwd,cwd,LSTR)

         c1   = cwd(1:1)
         j    = index('0123456789.', c1)
         if ( j <= 0 ) then
            INPUT_ISVARNAME(iwd) = .TRUE. 
            INPUT_VARNAME(iwd)   = cwd
            NVAR = NVAR + 1
         else
            READ(cwd,*) INPUT_VALUE(iwd)
            NVAL = NVAL + 1
         endif

        if ( NVAR > NN_MXVAR ) then
           c1err = 'Too many SEPMAX variables in NEARNBR_SEPMAX_VARDEF'
           c2err = 'See NN_MXVAR in snana.car'
           CALL  MADABORT(FNAM, C1ERR, C2ERR)
        endif

+SELF,IF=BLADEBUG.
         print*,' xxx ------------------------------ '
         write(6,40) iwd, cwd, c1, j
         write(6,41)
     &     INPUT_ISVARNAME(iwd), INPUT_VARNAME(iwd), INPUT_VALUE(iwd)         
 40      format(' xxx iwd=',I2, 2x, 'wd=',A6, 2x, 'c1=',A2, 2x,'j=',I4)
 41      format(' xxx ', 10x,'ISVAR=',L2, 3x,
     &       'NAME=',A6,3x, 'VAL=',F12.3)
          call flush(6)
+SELF.

 100  CONTINUE

c --------------------------------------------------------------
c if NVAL = NVAR, then we do analysis with fixed sepmax params.
c if NVAL = 3*NVAR then we do training.
c Abort on any other ratio.


      RATIO = 0.0
      IF ( NVAR > 0 ) RATIO = DBLE(NVAL)/DBLE(NVAR)
      IF ( RATIO == 1.0 ) THEN
         FLAG_NEARNBR = NNFLAG_APPLY ; jskip = 2
          cMODE = 'ANALYSIS'
      ELSE IF ( RATIO == 3.0 ) THEN
         FLAG_NEARNBR = NNFLAG_TRAIN ; jskip = 4
         cMODE = 'TRAINING'
      ELSE
         write(c1err,651) NVAL, NVAR, RATIO
 651     format('Invalid ratio [NVAL=',I3,'/NVAR=',I3,'] =',F5.2,2x,
     &       '(must be 1 or 3)'  )
         c2err = 'Check NEARNBR_SEPMAX_VARDEF in &NNINP.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)  
      ENDIF

c ----------------------------------------------
c Loop over VARDEF words again (with jskip = 2 or 4), and call 
c NEARNBR_SET_SEPMAX (in sntools_nearnbr.c) for each variable.

      NVAR = 0
      DO 300 iwd = 1, NWD, jskip

         VARNAME   = INPUT_VARNAME(iwd)

c Dec 6 2014: skip any on the ignore list
         do ign = 1, N_IGNORE
            if ( VARLIST_IGNORE(ign) .EQ. VARNAME ) goto 300
         enddo

         NVAR = NVAR + 1
         NEARNBR_SEPMAX_VARNAME(NVAR) = VARNAME(1:20) ! store globally 

         if ( FLAG_NEARNBR == NNFLAG_APPLY ) then
            SEPMAX(1) = INPUT_VALUE(iwd+1)
            SEPMAX(2) = 0.0
            SEPMAX(3) = 0.0
         elseif ( FLAG_NEARNBR == NNFLAG_TRAIN ) then
            SEPMAX(1) = INPUT_VALUE(iwd+1)
            SEPMAX(2) = INPUT_VALUE(iwd+2)
            SEPMAX(3) = INPUT_VALUE(iwd+3)
         else
            write(c1err,661) FLAG_NEARNBR
 661        format('Invalid FLAG_NEARNBR = ',I6,' . ' )
            c2err = 'Should be either 1(ANAL-mode) or 2(TRAIN mode).'
            CALL  MADABORT(FNAM, C1ERR, C2ERR)
         endif

         LV = INDEX(VARNAME,' ') - 1
         CALL NEARNBR_SET_SEPMAX(VARNAME(1:LV)//char(0), SEPMAX, LV)
 300  CONTINUE

      SNANA_NEARNBR_RDINPUT = NVAR  ! return arguement

c --------------------------------------
c 2nd init after passing all info

      CALL CDTOPDIR_OUTPUT()  ! climb out of MONINIT 
      
c set ISPLIT so that certain plots are made only on first split-job
      ISPLIT = MAX(JOBSPLIT(1),JOBSPLIT_EXTERNAL(1))

c init again after variable list is defined
      CALL NEARNBR_INIT2(ISPLIT)    ! C code in sntools_nearnbr.c

      RETURN
c -------------

900   CONTINUE   
      C1err = 'Could not read  &NNINP namelist '   
      C2err = 'Check ' // nmlfile(1:60)
      CALL  MADABORT(FNAM, C1ERR, C2ERR)   


      RETURN
      END    ! end of SNANA_NEARNBR_RDINPUT


C ==================================
+DECK,NNRDPATH.
      SUBROUTINE SNANA_NEARNBR_RDPATH(PATH) 

c Created Dec 2014
c
c Return PATH of trainfile for NN.
c If  NEARNBR_TRAINFILE_PATH has no dot, then assume
c it's a path and return PATH = NEARNBR_TRAINFILE_PATH.
c
c However, if NEARNBR_TRAINFILE_PATH has a dot then 
c assume it's a file containing a list of
c
c  VERSION:  [VERSION] [PATH]
c
c and read the file and return PATH associated with VERSION_PHOTOMETRY.
c Note that the subroutine inputs (VERSION_PHOTOMETRY and 
c NEARNBR_TRAINFILE_PATH) are passed via globals. This file
c option is intended to be used with a NN-pipeline script.
c
c Aug 28 2016:  call ENVreplace(NEARNBR_TRAINFILE_PATH)

      IMPLICIT NONE

      CHARACTER PATH*(*) ! output path

+CDE,SNPAR.
+CDE,NNCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
c +CDE,PARSECOM.

      INTEGER JDOT, JSLASH,  LREF, LTMP, NFOUND
      CHARACTER
     &    VER_TMP*(MXCHAR_VERSION)
     &   ,VER_REF*(MXCHAR_VERSION)
     &   ,PATH_TMP*200, KEY*20
     &   ,FNAM*22, C1ERR*80, C2ERR*80

C --------------- BEGIN -------------


      FNAM = 'SNANA_NEARNBR_RDPATH'

      call ENVreplace(NEARNBR_TRAINFILE_PATH) ! Aug 28 2016

      PATH   = 'UNKNOWN'
      JDOT   = INDEX(NEARNBR_TRAINFILE_PATH,'.', BACK=.TRUE.)
      JSLASH = INDEX(NEARNBR_TRAINFILE_PATH,'/', BACK=.TRUE.)      

c if last dot is before last slash, then it's a path already.
      IF ( JDOT < JSLASH ) THEN
         PATH = NEARNBR_TRAINFILE_PATH
         RETURN
      ENDIF

c if last dot is after last slash, it's a file to be parsed below.

c if we get here, read file to get path

      print*,'   Read NEARNBR_TRAINFILE_PATH from '
      print*,'   ', NEARNBR_TRAINFILE_PATH

      VER_REF = VERSION_PHOTOMETRY(1)
      LREF  = INDEX(VER_REF,' ' ) - 1
      NFOUND = 0

      OPEN ( UNIT=LUNTMP, FILE=NEARNBR_TRAINFILE_PATH, 
     &       STATUS='OLD', ERR=900 )

c - - - - - - - 
c Note that PATH_TMP must be in quotes to handle the slash symbol.

44    READ(LUNTMP,*, END=400) KEY, VER_TMP, PATH_TMP

      LTMP  = INDEX(VER_TMP,' ') - 1
      IF ( LTMP .NE. LREF ) GOTO 44
      IF ( VER_TMP(1:LTMP) .NE. VER_REF(1:LREF) ) GOTO 44

      NFOUND = NFOUND + 1
      PATH   = PATH_TMP

      GOTO 44
c - - - - - - - 

400   CLOSE(UNIT=LUNTMP)

c make sure we found the matching version<->path once and only once.

      IF ( NFOUND .NE. 1 ) THEN
        write(c1err,661) NFOUND
661     format('Found TRAINFILE_PATH ',I2,' times')
        c2err = 'for VERSION = ' // VER_REF(1:LREF)
        CALL MADABORT(FNAM, c1err, c2err)
      ENDIF

      RETURN

c -----------------------------
900   C1ERR = 'Could not open NEARNBR_TRAINFILE_PATH file:'
      C2ERR = NEARNBR_TRAINFILE_PATH(1:72)
      CALL MADABORT(FNAM, c1err, c2err)
      RETURN

      END  ! end of SNANA_NEARNBR_RDPATH


C ===========================================
+DECK,NNTRAIN_END.
      SUBROUTINE SNANA_NEARNBR_TRAIN_END()

c Created Apr 24 2014 by R.Kessler
c Print message on how to finish training.
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,NNCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.

      INTEGER LENF
      CHARACTER codeName*20

C ----------- BEGIN --------

      codeName = 'nearnbr_maxFoM.exe'

      CALL PRINT_NN_BANNER()

      print*,'   To optimize SEPMAX variables and finish NN training, '
      print*,'   run the following command: '

      if ( USE_TABLEFILE_HBOOK ) then
         LENF = index(HFILE_OUT,' ') - 1
         write(6,20) codeName, HFILE_OUT(1:LENF)
      endif

      if ( USE_TABLEFILE_ROOT ) then
         LENF = index(ROOTFILE_OUT,' ') - 1
         write(6,20) codeName, ROOTFILE_OUT(1:LENF)
      endif
 20   format(T7,A, 2x, A)

      CALL PRINT_NN_BANNER()

      RETURN
      END    ! SNANA_NEARNBR_TRAIN_END

C ==========================
+DECK,PRNN_BANNER.
      SUBROUTINE PRINT_NN_BANNER
      print*,' ' 
      print*,'# NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN'
      print*,'# NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN-NN'
      print*,' ' 
      call flush(6)
      RETURN
      END

C ===========================================
+DECK,NNAPPLY_END.
      SUBROUTINE SNANA_NEARNBR_APPLY_END()

c Created Apr 24 2014 by R.Kessler
c Print message on how to finish training.
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,NNCOM.
c+CDE,SNCUTS.
c+CDE,SNLCINP.

C -------------- BEGIN -------------

      CALL PRINT_NN_BANNER()

      print*,'  NN-APPLY Statistics Summary: '
      print*,'     NEVT(NN-unknown) = ', NNSUM_UNKNOWN
      print*,'     NEVT(NN-Ia)      = ', NNSUM_IA
      print*,'     NEVT(NN-NON1A)   = ', NNSUM_NON1A

      CALL PRINT_NN_BANNER()
      
      RETURN
      END     ! SNANA_NEARNBR_APPLY_END

C =======================================
+DECK,RDCIDLIST.
      SUBROUTINE RD_SNCIDLIST

c Created Nov 12, 2013
c Read optional list of CIDs from text file given by
c &SNLCINP namelist variable SNCID_LIST_FILE.
c
c Two format options are allowed.
c First is free-format with CIDs separated by 
c  * blank space
c  * <CR>
c  * comma 
c     
c Second option is the 'fitres' format with
c 'VARNAMES:'  and  'SN:' keys.
c Thus the fitres-output from a fitting program or from
c sntable_dump can be used as a CID-list input to any 
c snana program. The non-CID variables are ignored.
c
c May 1 2019: remove NVAR-dependence and only require VARNAMES
c             to FITRES file format. Also fix bug reading CID
c             from iwd+1 element, not iwd element.
c
c Aug 27 2019: CUTWIN_CID -> 0,0
c
c ---------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   IWD, NWD, LEN, LEN2, j, N_BADNAME, N_BADCHAR
      CHARACTER 
     &   CCID*(MXCHAR_CCID)
     &  ,CCID_TMP*(MXCHAR_CCID)
     &  ,CTMP*60
     &  ,BADCHARS*12, C1
     &  ,NAME_forC*200

      LOGICAL  ISBAD, ISFMT, FOUND_VARNAMES

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
C -------------------- BEGIN ----------------------
 
      IF ( SNCID_LIST_FILE .EQ. ' '    )  RETURN
      IF ( SNCID_LIST_FILE .EQ. 'NONE' )  RETURN
      IF ( SNCID_LIST_FILE .EQ. 'NULL' )  RETURN

      CALL ENVreplace(SNCID_LIST_FILE)  ! May 2018

      CALL PRBANNER("RD_SNCIDLIST:")

      CUTWIN_CID(1) = 0 
      CUTWIN_CID(2) = 0

      LEN = INDEX(SNCID_LIST_FILE,' ') - 1
      print*,'   Read list of CIDs from '
      print*,'   ', SNCID_LIST_FILE(1:LEN)
      CALL FLUSH(6)

c define list of forbidden characters in CID name.
      BADCHARS  = '%!#:$.  '
      N_BADCHAR = INDEX(BADCHARS,' ') - 1
      N_BADNAME = 0
 
c start loop over words in file.
      NAME_forC = SNCID_LIST_FILE(1:LEN) // char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,LEN) 

c ---------------------------------------------
c check if this is a fitres-formatted file with VARNAMES key

      FOUND_VARNAMES = .FALSE.

      DO 10 iwd = 1, NWD
         CALL get_PARSE_WORD_fortran(iwd,CTMP,LEN)
         if ( CTMP .EQ. 'VARNAMES:' ) FOUND_VARNAMES = .TRUE.
 10   CONTINUE
      ISFMT = ( FOUND_VARNAMES )
      if ( ISFMT ) THEN
         print*,'   Detected VARNAMES key --> KEY format'
      endif

c -----------------------------
      DO 100 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd,CTMP,LEN)

c check for formatted file
         if ( ISFMT ) THEN
            if ( CTMP .EQ. 'SN:' .or. CTMP .EQ. 'ROW:' ) THEN
               ! CID myst be string after SN/ROW key
               CALL get_PARSE_WORD_fortran(iwd+1,CCID,LEN2) 
               GOTO 99   ! load CID into array
            else
               GOTO 100  ! skip anything that is not a valid key
            endif
         endif
        
c below is for unformatted (or free-formatted) list of CIDs

         CCID_TMP = CTMP(1:MXCHAR_CCID)
         CCID     = CTMP(1:MXCHAR_CCID)
         LEN      = INDEX(CCID_TMP,' ') - 1

         if ( CCID_TMP .EQ. ',' .and. LEN .EQ. 1 ) GOTO 100  ! skip commas

c strip off comma before or after CCID
         if ( CCID_TMP(1:1) .EQ. ',' ) CCID = CCID_TMP(2:LEN)

c strip off comma before or after CCID
         if ( CCID_TMP(LEN:LEN) .EQ. ',' ) CCID = CCID_TMP(1:LEN-1)

c check for invalid characters in SN name
         ISBAD = .FALSE.
         DO 40 j = 1, N_BADCHAR
            C1 = BADCHARS(j:j)
            if ( C1 .EQ. ' ' ) GOTO 40
            IF ( INDEX(CCID,C1) > 0 )  ISBAD = .TRUE.
 40      CONTINUE
         IF ( ISBAD ) THEN
            N_BADNAME = N_BADNAME + 1
            write(6,44) CCID
 44         format(T8,'WARNING: Invalid CID name: ',A) ; call flush(6);
         ENDIF

c - - - - - - - - - - -  - - 
 99      CONTINUE

         NCCID_LIST = NCCID_LIST + 1
         CALL CHKARRBOUND(NCCID_LIST, ONE, MXCCID_LIST, "NCCID_LIST",
     &          "Check above CID-list file", "RD_SNCIDLIST")

         SNCCID_LIST_ALL(NCCID_LIST) = CCID

 100  CONTINUE  ! iwd

c -------------------
c abort if any CID names have invalid characters

      IF ( N_BADNAME > 0 ) THEN         
         write(c1err,661) N_BADNAME
 661     format(I4,' CIDs have invalid name.' )
         c2err = 'Check above WARNINGS and SNCID_LIST_FILE'
         CALL  MADABORT("RD_SNCIDLIST", C1ERR, C2ERR)
      ENDIF

c --------------------------
      write(6,30) NCCID_LIST
 30   format(T8,'Stored ',I5,' CIDs to process' )
      CALL FLUSH(6)

      RETURN
      END

C =======================================
+DECK,RDMJDLIST.
      SUBROUTINE RD_SNMJDLIST
c
c Created May 2008 by R.Kessler
c
c Read list of "SNID MJD" to process SNID list,
c so that fitter can interpolate flux at MJD.
c Initial use is for Ryan Foley's analysis with
c KECK spectra for SDSS-discovered SN.
c Second usage is comparing CSP-vs-SDSS photometry (J.Mosher)
c
c May 28, 2008: 
c   add screen-dump to see what's going on.
c 
c Jan 2012: 
c   check 'ALL' option to interpolate ALL SN at a MJD
c   After SN are read, a call to UPDSNMJDLIST checks the 
c   ALL option.
c
c May 18, 2012: complete re-write

c ---------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,INTERPCM.

      INTEGER   iwd, NWD, LEN, N, j, LL0, LL1
      CHARACTER CCID*(MXCHAR_CCID), NAME_forC*(MXCHAR_FILENAME)
      CHARACTER CTMP0*40, CTMP1*40
      REAL*8  MJD8
      LOGICAL LOK

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

c ---------- BEGIN ----------

      N_INTERP_MJDLIST    = 0

      
      IF ( SNMJD_LIST_FILE .EQ. ' ' ) RETURN

      N_INTERP_MJDLIST_DONE = 0
c init arrays
      N_INTERP_MJDLIST       = 0
      DO j = 1, MXINTERP
         INTERP8_MJDLIST(j)  = 0.0 
         INTERP_CCIDLIST(j)  = ''
         INTERP_MJDLIST_DONE(j) = .FALSE.
      ENDDO

      CALL PRBANNER("RD_SNMJDLIST:")

      LEN = INDEX(SNMJD_LIST_FILE,' ') - 1
      print*,' '
      print*,'  Read flux-interpolation instructions from '
      print*,'  ', SNMJD_LIST_FILE(1:LEN)

 
      NAME_ForC = SNMJD_LIST_FILE(1:LEN)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,LEN) 

      DO 100 iwd = 1, NWD-1, 2
 
         CALL get_PARSE_WORD_fortran(iwd+0, CTMP0, LL0 )
         CALL get_PARSE_WORD_fortran(iwd+1, CTMP1, LL1 )

         READ ( CTMP0, *) CCID
         READ ( CTMP1, *) MJD8

         N_INTERP_MJDLIST  = N_INTERP_MJDLIST + 1
         N = N_INTERP_MJDLIST

         INTERP_CCIDLIST(N) = CCID
         INTERP8_MJDLIST(N) = MJD8

         LEN = INDEX(CCID,' ') - 1
         write(6,70) CCID, MJD8
70       format(T6,'Will interpolate flux for SN ', A12,
     &        ' at MJD=', F10.3)

c --- error checking

         LOK = ( MJD8 .EQ. 0.0) .or.
     &         ( MJD8 .GT. 40000. .and. MJD8 .LT. 70000. ) 
         if ( .NOT. LOK ) then
            write(c1err,61) MJD8
61          format('Read Invalid MJD = ', F12.3,' from ' ) 
            c2err = SNMJD_LIST_FILE(1:80)
            CALL  MADABORT("RD_SNMJDLIST", C1ERR, C2ERR)
         endif

c abort if we exceed array bound
         IF ( N_INTERP_MJDLIST .GT. MXINTERP ) THEN
            CALL PRINT_PREABORT_BANNER("RD_SNMJDLIST"//char(0), 40)
            print*,'   SNMJD_LIST_FILE = ', SNMJD_LIST_FILE
            write(c1err,161) CCID, MJD8
161         format('N_INTERP_MJDLIST exceeds bound at CID=',A8, 2x,
     &          'MJD=',F9.3)
            write(c2err,162) MXINTERP
162         format('Check MXINTERP=',I5,' and SNMJD_LIST_FILE above.')

           CALL  MADABORT("RD_SNMJDLIST", C1ERR, C2ERR)
      ENDIF

100   CONTINUE  ! iwd

      RETURN
      END   ! end of RD_SNMJDLIST

C =============================
+DECK,GTINTLIST.
      SUBROUTINE GET_INTERP_MJDLIST(CCID, NMJD, MJDLIST, ADDFLAG)
c
c Return NMJD and MJDLIST to interpolate for this CID.
c ADDFLAG = T if this CCID is specifically listed;
c ADDFLAG = F if this CCID is added because of the ALL option.
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,INTERPCM.

c subroutine args
      CHARACTER CCID*(*)  ! (I) SN character id
      INTEGER NMJD        ! (O) number of MJDs to interpolate
      LOGICAL ADDFLAG     ! (O) T => add to process list
      REAL*8  
     &   MJDLIST(MXINTERP) ! (O) list of MJDs

c local var

      LOGICAL LMATCH, LALL
      INTEGER i, L0, L1
      character CCID_tmp*(MXCHAR_CCID)

c --------------- BEGIN --------------

      NMJD    = 0
      ADDFLAG = .FALSE.

      L0   = INDEX(CCID,' ') - 1

      DO 100 i = 1, N_INTERP_MJDLIST
         CCID_tmp = INTERP_CCIDLIST(i)
         L1 = INDEX(CCID_tmp,' ') - 1

         LMATCH = ( L0 .EQ. L1 ) .and. 
     &            ( CCID(1:L0) .EQ. CCID_tmp(1:L1) )
         LALL    = CCID_tmp(1:3) .EQ. 'ALL' 

         IF ( LMATCH ) ADDFLAG = .TRUE.  ! set return arg

c         print*,' xxx compare ', CCID,'  to ', CCID_tmp,
c     &     '  L0,L1=',L0,L1

         if ( LALL .or. LMATCH )then
           NMJD = NMJD + 1
           MJDLIST(NMJD) = INTERP8_MJDLIST(i)

c keep track of which ones are DONE to help know when to quit reading
           if ( .not. INTERP_MJDLIST_DONE(i) ) then
              N_INTERP_MJDLIST_DONE  = N_INTERP_MJDLIST_DONE + 1
              INTERP_MJDLIST_DONE(i) = .TRUE.
           endif

         endif
100   CONTINUE

      RETURN
      END

C =========================================
+DECK,ENVreplace.
      SUBROUTINE ENVreplace(STRING) 

c If input STRING starts with '$' then evaluate ENV
c with GETENV and return STRING with substitution.
c
c There is a C version of this function in sntools.c,
c but passing back the return string to fortran is not 
c so easy, so safer to write this one in fortran too.

      IMPLICIT NONE
      CHARACTER STRING*(*)  ! I/O

c local args
+CDE,SNPAR.

      INTEGER jslash, LTOT, LENV, LENS
      CHARACTER ENVname*200, ENV*400, SUFFIX*400
      CHARACTER C1ERR*72, C2ERR*72
      CHARACTER FNAM*12

C -------------- BEGIN -------------

      IF ( STRING(1:1) .NE. '$' ) RETURN

      FNAM = 'ENVreplace'

      LTOT    = INDEX(STRING,' ' ) - 1
      IF (LTOT <= 0 ) THEN
        CALL PRINT_PREABORT_BANNER(FNAM(1:10)//char(0), 40)
        print*,' STRING=', STRING
        write(c1err,31) LTOT
        c2err = 'STRING could be too long or zero length'
31      format( 'LEN(STRING)=', I3, ' ???' )
        CALL MADABORT(FNAM, C1ERR, C2ERR)        
      ENDIF

      JSLASH  = INDEX(STRING,'/') - 1
      IF ( JSLASH <= 0 ) JSLASH = LTOT
      SUFFIX  = STRING(JSLASH+1:LTOT)
      LENS    = INDEX(SUFFIX,' ') - 1

      ENVname = STRING(2:JSLASH)
      CALL GETENV(ENVname, ENV) ! return ENV
      LENV    = INDEX(ENV,' ')-1
 
      if ( LENV > MXCHAR_PATH ) then
         write(C1ERR,61) ENVname(1:JSLASH-1), LENV
61       format('LEN($', A, ') = ',I3,' is too long.')
         write(C2ERR,62) MXCHAR_PATH
62       format('MXCHAR_PATH = ', I3 )
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      if ( LENV+LENS > MXCHAR_FILENAME ) then
         write(C1ERR,161) STRING(1:LTOT), LENV+LENS
161       format('Decoded LEN($', A, ') = ',I3,' is too long.')
         write(C2ERR,162) MXCHAR_FILENAME
162       format('MXCHAR_FILENAME = ', I3 )
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      if ( LENV .EQ. 0 ) then
         C1ERR = 'ENV = $' // ENVname(1:JSLASH) // ' is not defined.'
         C2ERR = 'Check your input namelists.'
         CALL MADABORT(FNAM, C1ERR, C2ERR)
      endif

      STRING = ENV(1:LENV) // SUFFIX

      RETURN
      END     ! end of ENVreplace

C =======================================
+DECK,get_PARSE_WORD_fortran.
      SUBROUTINE get_PARSE_WORD_fortran(iwd,WORD,LEN) 
c
c Jan 2018
c Wrapper to call C-function get_PARSE_WORD to retrieve
c iwd word stored.
c
c Jan 2019: use MXCHAR_FILEWORD for char array abound.
c
      IMPLICIT NONE

+CDE,SNPAR.

c subroutine args
      INTEGER   IWD                       ! (I) word index to fetch
      CHARACTER WORD*(*)      ! (O) stored word
      INTEGER   LEN                       ! (O) length of word

c local args
      INTEGER  iwd_C
      CHARACTER WORD_C*(MXCHAR_FILEWORD)
      EXTERNAL GET_PARSE_WORD

C ------------- BEGIN -----------
      iwd_C = iwd-1
      CALL GET_PARSE_WORD(ONE, iwd_C,WORD_C,LEN)

      LEN  = INDEX(WORD_C, ' ' ) - 1
      WORD = WORD_C(1:LEN)

      RETURN
      END

C ======================
+DECK,UPCASE.
      SUBROUTINE UPCASE(strin, strupper)
      character strin*(*), strupper*(*)
      integer  j, LL

      strupper = ''
      LL = INDEX(strin,' ') - 1
      do j = 1, LL
       if(strin(j:j) >= "a" .and. strin(j:j) <= "z") then
         strupper(j:j) = achar(iachar(strin(j:j)) - 32)
       else
         strupper(j:j) = strin(j:j)
       end if
      end do
      END

C ======================
+DECK,LOCASE.
      SUBROUTINE LOCASE(strin, strlower)
c return strlower.
      character strin*(*), strlower*(*)
      integer  j, LL

      strlower = ''
      LL = INDEX(strin,' ') - 1
      do j = 1, LL
       if(strin(j:j) >= "A" .and. strin(j:j) <= "Z") then
         strlower(j:j) = achar(iachar(strin(j:j)) + 32)
       else
         strlower(j:j) = strin(j:j)
       end if
      end do
      END

C ===========================================
+DECK,RDNINT.
      SUBROUTINE RDNINT( cwords, NINT, IARRAY )
      IMPLICIT NONE
c ---------------------------------------------------
c Read NINT consecutive integers from cwords array
c Store results in IARRAY.
c --------------------------------------------------
      INTEGER   NINT
      character cwords(NINT)*60  ! (I) list of char words
      INTEGER   IARRAY(NINT)     ! (O) array of parsed integers
c local args
      INTEGER i
C ------------ BEGIN -----------
      DO i = 1, NINT
          read ( cwords(i), * ) IARRAY(i)
      ENDDO
      RETURN
      END

C ===========================================
+DECK,RDNFLOAT.
      SUBROUTINE RDNFLOAT ( CWORDS, NFLOAT, FARRAY )
      IMPLICIT NONE
c ---------------------------------------------------
c Read NFLOAT consecutive floats from CWORDS array
c Store results in FARRAY.
c
c Jul 2008: ABORT on 'nan'.
c Sep 2010: increase cwords bytes from 40 to 60
c
c --------------------------------------------------
      INTEGER NFLOAT
      character cwords(NFLOAT)*60  ! (I) list of char words
      REAL      FARRAY(NFLOAT)     ! (O) array of parsed floats
c local args
      INTEGER i
      character c1err*60, c2err*60
C ------------ BEGIN -----------
      DO i = 1, NFLOAT
          if ( cwords(i) .EQ. 'nan' ) then
             print*,' '
             c1err = "Found 'nan' instead of float. "
             c2err = "Use grep to find the nan in this version. "
             CALL MADABORT("RDNFLOAT", c1err, c2err )
          endif
          read ( cwords(i), * ) FARRAY(i)

      ENDDO
      RETURN
      END

C ===========================================
+DECK,RDNDBLE.
      SUBROUTINE RDNDBLE ( CWORDS, NDBLE, DARRAY )
      IMPLICIT NONE
c ---------------------------------------------------
c Created Jun 20, 2011
c Read NDBLE consecutive doubles from CWORDS array
c Store results in DARRAY.
c
c --------------------------------------------------
      INTEGER NDBLE
      character cwords(NDBLE)*60  ! (I) list of char words
      REAL*8    DARRAY(NDBLE)     ! (O) array of parsed floats
c local args
      INTEGER i
      character c1err*60, c2err*60
C ------------ BEGIN -----------
      DO i = 1, NDBLE
          if ( cwords(i) .EQ. 'nan' ) then
             print*,' '
             c1err = "Found 'nan' instead of dble. "
             c2err = "Use grep to find the nan in this version. "
             CALL MADABORT("RDNDBLE", c1err, c2err )
          endif
          read ( cwords(i), * ) DARRAY(i)
cc          read ( cwords(i), "(D20.10)" ) DARRAY(i)
      ENDDO
      RETURN
      END

C ==============================================
+DECK,RDSTRING.
      CHARACTER*80 FUNCTION RDSTRING( OPT, FILE )
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

c Read single-word STRING from FILE
c OPT=0 => read from file
c OPT=1 => read from $SNDATA_ROOT/file

      INTEGER OPT
      CHARACTER FILE*(*)
    
c local var

      INTEGER LL
      CHARACTER LOCFILE*(MXCHAR_FILENAME), string*80

C -----------

      IF ( OPT .EQ. 0 ) THEN
         LOCFILE = FILE
      ELSE
         LL = INDEX(SNDATA_ROOT,' ') - 1
         LOCFILE = SNDATA_ROOT(1:LL) // '/' // FILE
      ENDIF

      OPEN (UNIT=LUNTMP, FILE = LOCFILE, STATUS='OLD', ERR=666 )
      READ(LUNTMP,*) string
      CLOSE ( UNIT = LUNTMP )

      RDSTRING = STRING
      RETURN

c --------------------
666   CONTINUE
      LL = INDEX(FILE,' ') - 1
      C1ERR = 'Cannot open file: ' // file(1:LL)
      CALL MADABORT("RDSTRING", C1ERR, "")

      RETURN
      END

      
C ================================================
+DECK,RDSNLIST.
      SUBROUTINE RDSNLIST ( VERSION, IERR )
c
c Re-created June 2011.
c New routine GETINFO_PHOTOMETRY gets the path and 
c SNLIST_FILE, so here we can just read it without 
c worrying about if it exists.
c 
c
c Read list of SN files; increment N_SNFILE 
c After reading list file, REWIND it, but do not close it.
c 
c Nov 23 2013: major changes to read arbitrary number of ascii files.
c
c Jul 1 2014: print NLOC_SNFILE (for this version only) instead
c             of printing cumulative sum.
c
c ----------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER VERSION*(*)  ! (I) SN flux version to read
      INTEGER   IERR         ! (O) 0=> OK,  else error

c local args

      INTEGER  LEN_VERS, NLOC_SNFILE
      CHARACTER snfile*(MXCHAR_FILENAME)

C -------------- BEGIN -------------
      IERR = 0
      NLOC_SNFILE = 0

      LEN_VERS = INDEX ( VERSION , ' ' ) - 1      
      CALL PRBANNER("RDSNLIST")
      write(6,10) VERSION(1:LEN_VERS)
10    format(T5,'***** READ LIST for VERSION ', 
     &      A, ' *****', / )

      IF ( N_SNFILE > 0 ) CLOSE(LUNLIST)

      OPEN ( UNIT=LUNLIST, file=SNLIST_FILE, status='OLD' )

2     READ ( LUNLIST, 3, END = 50 ) snfile   
3     format(A)

      N_SNFILE    = N_SNFILE + 1    ! global counter, all versions
      NLOC_SNFILE = NLOC_SNFILE + 1 ! local counter, only this version

      if ( N_SNFILE > MXSNLC-1 ) THEN
         write(c1err,666) N_SNFILE
666      format('N_SNFILE=',I8,' exceeds array bound.' )
         c2err = 'Check MXSNLC.'
         CALL MADABORT("RDSNLIST", c1err, c2err )     
      endif        
     
      goto 2

50    CONTINUE

      REWIND(UNIT=LUNLIST)

      write(6,51) NLOC_SNFILE
51    format(T6,'Found ', I6,' SNLC data files to read.', / )

      ISNLC_IFILE = 0  ! reset file counter (for text-format only)

      IF ( N_SNFILE .LE. 0 ) THEN
         c1err = 'No SNDATA files found for'
         c2err = VERSION(1:LEN_VERS)
         CALL MADABORT("RDSNLIST", c1err, c2err )
      ENDIF

      RETURN
      END

C ================================================
+DECK,RDSRVTEXT.
      SUBROUTINE RDSURVEY_TEXT ( IERR ) 

C
C Jun 2011
C Read global information from header of 1st data file:
C Fill 
C   SURVEY_NAME 
C   SURVEY_FILTERS
C   NVAR_PRIVATE & PRIVATE_VARNAME  (optional)
C   NXPIX, NYPIX                    (optional)
c
C For simulation also fill SIMNAME_MODEL and FAKE.
c
c If sim-model is SIMSED, then read the parameter names too
c via PARSE_SIMSED(). This model is unique because the parameter
c are not known as in the other models.
c
c May 24, 2012:   Read filters if  .NOT. FREEZE_SURVEY_FILTERS 
c Nov 23, 2013:   remove IFILE arg; read LUNLIST
c Dec 20, 2013:   modify how LSIM is set
c Aug 07, 2014:   read NXPIX, NYPIX
c Oct 16, 2017:   call PARSE_TERSE_VARLIST to check ITERSE_CCDNUM
c Nov 14, 2018:   read MASK_FLUXCOR_SNANA
c
C -------------------------------------

      IMPLICIT NONE

c subroutine args

      INTEGER  IERR   ! (O) error flag, 0=OK

c local variables.

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER 
     &   LL, L1, L2, iwd, iwd2, i, NWD, NWD_LOAD, LWD0, ID
     &  ,IFAKE, IPAR_SIMSED, IPAR_BYOSED, IPAR_LCLIB
     &  ,IPAR_SIM_HOSTLIB

      character   
     &   cwdList(MXVAR_TERSE)*(MXCHAR_FILEWORD)
     &  ,cwd*(MXCHAR_FILEWORD)
     &  ,cwd1*(MXCHAR_FILEWORD)
     &  ,LOCALFILE*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)

      LOGICAL 
     &   LDONE_DATA, LOBS, LRDFILT
     &  ,L_SURVEY, L_FILTERS, L_GENMODEL
     &  ,ISKEY_VARLIST

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN ----------------

      IERR = 0

      global_banner = 'RDSURVEY_TEXT: Fetch global SURVEY info.'
      CALL prbanner( global_banner(1:60) )

c read name of first text file from [VERSION].LIST file
      READ(LUNLIST,3) SNDATA_FILE_CURRENT
 3    format(A)
      REWIND(LUNLIST)

      LL = INDEX(SNDATA_FILE_CURRENT,' ') - 1
      print*,'   Examine header from: ', SNDATA_FILE_CURRENT(1:LL)

      NPAR_SIMSED   = 0
      NPAR_BYOSED   = 0
      NPAR_LCLIB    = 0 

      IPAR_SIMSED   = 0
      IPAR_BYOSED   = 0
      IPAR_LCLIB    = 0

      NPAR_SIM_HOSTLIB = 0
      IPAR_SIM_HOSTLIB = 0

      L_SURVEY   = .FALSE.
      L_FILTERS  = .FALSE.
      L_GENMODEL = .FALSE.

      LL = INDEX ( SNDATA_PATH , ' ' ) - 1
      LOCALFILE = SNDATA_PATH(1:LL) // '/' // SNDATA_FILE_CURRENT

      LL        = INDEX(LOCALFILE,' ') - 1
      NAME_forC = LOCALFILE(1:LL)// char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,LL)

      IF ( FREEZE_SURVEY_FILTERS ) THEN
         LRDFILT   =  .FALSE.
         L_FILTERS =  .TRUE.
      ELSE
         LRDFILT =  .TRUE.
      ENDIF

c - - - - - - - - - 
      DO 10 iwd = 1, NWD

        call get_PARSE_WORD_fortran(iwd+0, cwdList(1),  LWD0 )
        call get_PARSE_WORD_fortran(iwd+1, cwdList(2),  LWD0 )
        cwd  = cwdList(1)
        cwd1 = cwdList(2)

        ISKEY_VARLIST  = ( cwd(1:7) .EQ. 'VARLIST' ) 
        NWD_LOAD = 2
        if ( ISKEY_VARLIST ) NWD_LOAD = NVAR_TERSE+1

        do i = 3, NWD_LOAD
            iwd2 = iwd + i - 1
            call get_PARSE_WORD_fortran(iwd2, cwdList(i),  LWD0 )
        enddo

c check required header keys

        if ( cwd .EQ. 'SURVEY:' ) then

          CALL PARSE_SURVEY_NAME(cwd1, SURVEY_NAME, SUBSURVEY_NAME,ID)
          L1          = INDEX ( SURVEY_NAME, ' ' ) - 1
          L_SURVEY    = .TRUE.
        endif

        if ( cwd .EQ. 'FILTERS:' .and. LRDFILT ) then
          SURVEY_FILTERS  = cwd1                 
          L2              = INDEX ( SURVEY_FILTERS, ' ' ) - 1
          NFILTDEF_SURVEY = L2
          NFILTDEF_READ   = L2
          L_FILTERS       = .TRUE.
        endif

        if ( cwd .EQ. 'MASK_FLUXCOR_SNANA:' ) then
           read(cwd1,*) ISNLC_RDMASK_FLUXCOR_SNANA  ! Nov 2018
        endif
     
c read optional NXPIX, NYPIX from header to know if 
c XPIX,YPIX are there for each epoch.
        if ( cwd .EQ. 'NXPIX:' ) THEN
           read(cwd1,*) SNLC_NXPIX
        endif

        if ( cwd .EQ. 'NYPIX:' ) THEN
           read(cwd1,*) SNLC_NYPIX
        endif

c check optional PRIVATE variables
        CALL PARSE_PRIVATE_TEXT ( cwdList(1) )

c check optoinal keys for data, but REQUIRED keys for simulation.

        if ( cwd .EQ. 'FAKE:' ) then
           read(cwd1,*) IFAKE
c IFAKE=1 for fake on real images; treat like data, but include SIM_MAGOBS
c IFAKE=2 for snana simulation -> set LSIM_SNANA=T
           if ( IFAKE .EQ. 1 ) LSIM_MAGOBS = .TRUE. ! 8.06.2014
           if ( IFAKE .EQ. 2 ) LSIM_SNANA  = .TRUE.
        endif

        if ( cwd .EQ. 'SIM_MODEL_NAME:' ) then
          SIMNAME_MODEL = cwd1(1:32)
          L_GENMODEL    = .TRUE.
        endif

c global parameters for Galactic extinction

        if ( cwd .EQ. 'SIMOPT_MWCOLORLAW:' ) then
          read(cwd1,*) SIMOPT_MWCOLORLAW
        endif
        if ( cwd .EQ. 'SIMOPT_MWEBV:' ) then
          read(cwd1,*) SIMOPT_MWEBV
        endif
        if ( cwd .EQ. 'SIM_MWRV:' ) then
          read(cwd1,*) SIM_MWRV
        endif

        if ( cwd .EQ. 'SIMLIB_MSKOPT:' ) then
          read(cwd1,*) SIMLIB_MSKOPT   ! Jan 2016
        endif

        CALL PARSE_MODELPAR_TEXT(cwdList, MODEL_SIMSED, IPAR_SIMSED)
        CALL PARSE_MODELPAR_TEXT(cwdList, MODEL_BYOSED, IPAR_BYOSED)
        CALL PARSE_MODELPAR_TEXT(cwdList, MODEL_LCLIB,  IPAR_LCLIB )

c check for SIM_HOSTLIB params (Feb 2014)
        CALL PARSE_SIM_HOSTLIB_TEXT(cwdList,IPAR_SIM_HOSTLIB)

c evaluate DONE flags

        LDONE_DATA = L_SURVEY  .and. L_FILTERS

c parse VARLIST (Oct 2017)
        CALL PARSE_TERSE_VARLIST(cwdList)

c for the data, we are DONE only when we reach the 1st epoch because 
c the FAKE key may not be there.

        LOBS = cwd .EQ. 'EPOCH:' .or. cwd .EQ. 'OBS:'
        IF ( LOBS ) GOTO 100         

10    CONTINUE  ! end iwd loop

c if we get here there are no epochs/observations => abort.
      c1err = 'Did not find any observations.'
      c2err = 'Check ' // SNDATA_FILE_CURRENT(1:72)
      CALL MADABORT("RDSURVEY_TEXT", c1err, c2err )

c -----------------------------------------------------
100   CONTINUE  ! come here after read entire header
c -----------------------------------------------------

c if we finish the header (i.e., LOBS=T) but have not found the
c required DATA keys, then abort.

      IF ( .not. LDONE_DATA ) then
        CALL PRINT_PREABORT_BANNER("RDSURVEY_TEXT"//char(0), 40)
        print*,' FOUND SURVEY:  key : ', L_SURVEY
        print*,' FOUND FILTERS: key : ', L_FILTERS
        c1err = 'Found 1st epoch before finding required header info.'
        c2err = 'Check ' // SNDATA_FILE_CURRENT(1:72)
        CALL MADABORT("RDSURVEY_TEXT", c1err, c2err )
      ENDIF

c if we read SIMSED parameters, make sure the number read
c matches NPAR_SIMSED

      IF ( NPAR_SIMSED .NE. IPAR_SIMSED ) THEN
         write(c1err,661) NPAR_SIMSED
         write(c2err,662) IPAR_SIMSED         
         CALL MADABORT("RDSURVEY_TEXT", c1err, c2err )
661      format('Expected to find NPAR_SIMSED=',I2,' params.')
662      format('but found ',I2 )
      ENDIF
      

      RETURN
      END   ! end of RDSURVEY_TEXT

C ================================================
+DECK,INITSURVEY.
      SUBROUTINE INIT_SURVEY ( IERR )
c
c Created Jun 2011
c [re-named from RDSURVEY, and read-part moved to RDSURVEY_TEXT]
c
c Process a few things from the global survey variables
c read from RDSURVEY_TEXT[FITS]
c 
c May 26, 2012: remove BX check; moved to LANDOLT_PREP.
c
c Jun 15, 2013: check FILTER_REPLACE option
c
c Aug 08, 2013: read and fill SURVEY_FIELD(i) for each survey field;
c               needed to sort overlapping fields so that
c               E2+E1 gets written as E1+E2
c
c Dec 16 2014: fix string logic checking SURVEY; see L1.
c
c -------------

      IMPLICIT NONE

c subroutine args

      INTEGER  IERR   ! (O) error flag, 0=OK

c local variables.

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER 
     &   iwd, NWD, IFILT_OBS, LL, L1, L2, LNAM, IDTEL, i, IDTMP
     &  ,IDFIELD, NFILT_NONSURVEY, NFILT_ADD, iadd, jtmp
     &  ,LWD0, LWD1, LWD2, LWD3

      character 
     &   cwd*60, cwd_next*60, cwd_next2*60, cwd_next3*60
     &  ,cfilt1*2, SURVEY_TMP*(MXCHAR_SURVEY)
     &  ,SURVEYFILE*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)
     &  ,upper*60, ctel*60, cfield*60
     &  ,SURVEY_FILTERS_ORIG*(MXFILT_ALL)

      LOGICAL LTMP, LKEY, LSRVY

c functions
      INTEGER FILTINDX
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS


C ------------------- BEGIN --------------

      IERR            = 0
      IDSURVEY        = 0
      NFIELD_SURVEY   = 0
      NSURVEY_LIST    = 0 

      LNAM  = INDEX ( SURVEY_NAME,    ' ' ) - 1
      L2    = 0

      IF ( FREEZE_SURVEY_FILTERS ) THEN
c        leave SURVEY_FILTERS and NFILTDEF_XXX alone
      ELSE
        L2  = INDEX ( SURVEY_FILTERS, ' ' ) - 1
        NFILTDEF_SURVEY = L2
        NFILTDEF_READ   = L2
      ENDIF

c ----------------------------------------
c Apr 2013: check user-option to add non-survey filters.
c           These extra filters must be defined in the kcor/calib file,
c           otherwise RDKCOR will abort.
c Jun 1 2013:
c  Only add NONSURVEY filter if it's NOT already defined. For example, 
c  consider SDSS ugrizUGRIZ, but the simulations are done only with UGRIZ.  
c  Thus we can define NONSURVEY_FITLERS ='UGRIZ' which are added to the 
c  simulation list to avoid a KCOR-abort, but for data these NONSURVEY_FILTERS
c  are ignored since they are already defined.

      NFILT_NONSURVEY = INDEX(NONSURVEY_FILTERS,' ') - 1
      SURVEY_FILTERS_ORIG = SURVEY_FILTERS
      NFILT_ADD = 0
      NONSURVEY_FILTERS_ADD = '' 

      DO 601 iadd = 1, NFILT_NONSURVEY
        cfilt1 = NONSURVEY_FILTERS(iadd:iadd)
        jtmp   = INDEX(SURVEY_FILTERS_ORIG,cfilt1(1:1))

        if ( jtmp .LE. 0 ) then
           NFILT_ADD = NFILT_ADD + 1
           NONSURVEY_FILTERS_ADD = 
     &     NONSURVEY_FILTERS_ADD(1:NFILT_ADD-1) // cfilt1(1:1)
        endif

601   CONTINUE

      IF ( NFILT_ADD > 0 ) THEN
           NONSURVEY_FILTERS_ADD = 
     &     NONSURVEY_FILTERS_ADD(1:NFILT_ADD) // '  '  ! add padding

         print*,'   Add NON-SURVEY FILTERS = ', 
     &              NONSURVEY_FILTERS_ADD(1:NFILT_ADD)
         call flush(6)
         SURVEY_FILTERS  = SURVEY_FILTERS(1:NFILTDEF_SURVEY) // 
     &                     NONSURVEY_FILTERS_ADD(1:NFILT_ADD)
         NFILTDEF_SURVEY = NFILTDEF_SURVEY + NFILT_ADD
         L2 = NFILTDEF_SURVEY
      ENDIF

c ----------------------------------------
c create IFILTDEF_MAP_SURVEY

       do i = 1, NFILTDEF_SURVEY
          cfilt1    = SURVEY_FILTERS(i:i)
          IFILT_OBS = FILTINDX(cfilt1) 

          IFILTDEF_MAP_SURVEY(i)    = IFILT_OBS
          IFILTDEF_INVMAP_SURVEY(ifilt_obs) = i

          if ( IFILT_OBS .LE. 0 ) then
            c1err = 'FILTER = ' // cfilt1 // 
     &         ' is invalid for SURVEY=' // SURVEY_NAME(1:LNAM)
            c2err = 'SURVEY_FILTERS = |' // SURVEY_FILTERS(1:L2) // '|'
            CALL MADABORT("INIT_SURVEY", c1err, c2err )
          endif

       enddo


c ------------
c Now open SURVEY.DEF file to get 
c  IDSURVEY
c  IDTEL
c  IDFIELD

      LL = INDEX ( SNDATA_ROOT , ' ' ) - 1
      SURVEYFILE = SNDATA_ROOT(1:LL) // '/SURVEY.DEF'

      LL        = INDEX(SURVEYFILE,' ')-1
      NAME_forC = SURVEYFILE(1:LL)//char(0)
      NWD  = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,LL)

      DO 110 iwd = 1, NWD-3

         CALL get_PARSE_WORD_fortran(iwd+0, cwd,       LWD0 )
         CALL get_PARSE_WORD_fortran(iwd+1, cwd_next,  LWD1 )
         CALL get_PARSE_WORD_fortran(iwd+2, cwd_next2, LWD2 )
         CALL get_PARSE_WORD_fortran(iwd+3, cwd_next3, LWD3 )
         if ( cwd .EQ. ' ' ) goto 110

         if ( cwd .EQ. 'SURVEY:' ) then
            L1 = index(cwd_next,' ') - 1
            SURVEY_TMP  = cwd_next(1:LL)
            read(cwd_next2,*) IDTMP

c    store all survey names in case there are subSurveys
c    such as LOWZ(CFA3)
            NSURVEY_LIST = NSURVEY_LIST + 1
            SURVEY_NAME_LIST(NSURVEY_LIST) = SURVEY_TMP
            IDSURVEY_LIST(NSURVEY_LIST)    = IDTMP

            if ( SURVEY_TMP(1:L1) .EQ. SURVEY_NAME(1:LNAM) ) then
c     IDSURVEY should never change, but IDSUBSURVEY can change
               IDSURVEY=IDTMP ; IDSUBSURVEY=IDTMP
            endif
         endif

c ------------
c check telescope

         LTMP = .NOT. DOALL_SNTEL 
         LKEY = cwd .EQ. 'TELESCOPE:' 

         if ( LKEY .AND. LTMP ) then
            call UPCASE(cwd_next, UPPER)       
            CTEL = UPPER        ! telescope in SURVEY.DEF file
          
            read(cwd_next2,*) IDTEL

c now compare with user request, and convert everything to upper case
c Allow data files to have extra characters such as "sdss-2.5m" or CTIO4m

            DO i = 1, NIDTEL_LIST
c     convert user name to uppercase
               CALL UPCASE(SNTEL_LIST(i), upper) 
               SNTEL_LIST(i) = upper(1:20) ! user-specified telescope
               LL = INDEX( CTEL, ' ' ) - 1

               if ( CTEL(1:LL) .EQ. SNTEL_LIST(i)(1:LL) ) then
                  SNTEL_LIST(i) = ctel(1:20) ! truncate extra characters
                  IDTEL_LIST(i) = IDTEL               
                  write(6,205) CTEL(1:LL), IDTEL
 205              format(T5,'Found requested TELESCOPE=',A,2x, 
     &                 'with IDTEL=', I3 )
               endif
            END DO  ! end loop of NIDTEL_LIST

         endif  ! end of TELSCOPE: if-block

c ------------
c check SN field
   
         LKEY   = cwd .EQ. 'FIELD:'
         LSRVY  = .FALSE.
         IF ( LKEY ) THEN
            read(cwd_next3,*) SURVEY_TMP      
            LSRVY  = SURVEY_TMP .EQ. SURVEY_NAME ! field for this survey 
         ENDIF

         if ( LKEY .and. LSRVY ) then

          call UPCASE(cwd_next, upper)       
          cfield = upper  ! FIELD in SURVEY.DEF file  

          read(cwd_next2,*) IDFIELD

          IF ( IDFIELD > 0 ) THEN
             NFIELD_SURVEY = NFIELD_SURVEY + 1
             SURVEY_FIELDNAME(NFIELD_SURVEY)=cfield(1:MXCHAR_FIELDNAME)
             SURVEY_IDFIELD(NFIELD_SURVEY)  = IDFIELD
          ENDIF
       
          IF ( NFIELD_SURVEY > MXIDFIELD ) THEN
             write(c1err,681) MXIDFIELD
 681         format('NSURVEY_FIELD exceeds bound of ', I4)
             c2err = 'Check MXIDFIELD and SURVEY.DEF file.'
             CALL MADABORT("INIT_SURVEY", c1err, c2err )
          ENDIF

c now compare with user request, and convert everything to upper case

           DO i = 1, NIDFIELD_LIST
c convert user name to uppercase
             CALL UPCASE(SNFIELD_LIST(i), upper) 
             SNFIELD_LIST(i) = upper   ! user-specified field
             LL = INDEX( cfield, ' ' ) - 1

             if ( cfield(1:LL) .EQ. SNFIELD_LIST(i)(1:LL) ) then
               SNFIELD_LIST(i) = cfield  ! truncate extra characters
               IDFIELD_LIST(i) = IDFIELD               
               write(6,206) CFIELD(1:LL), IDFIELD
206            format(T5,'Found requested FIELD=',A,2x, 
     &               'with IDFIELD=', I3 )
             endif
            END DO

         endif  ! end of FIELD: if-block
      
110   CONTINUE
     
c ------------------------
c print some info to stdout

      IF ( IDSURVEY .LE. 0 .and. SUBSURVEY_NAME .EQ. '' ) then
        c1err = 'Could not find IDSURVEY for SURVEY=' 
     &        // SURVEY_NAME(1:LNAM)
        c2err = 'Check ' // SURVEYFILE(1:72)
        CALL MADABORT("INIT_SURVEY", c1err, c2err )
      endif


      write(6,201) SURVEY_NAME(1:LNAM), IDSURVEY
201   format(T5,'Found SURVEY  = ',A, 3x, '(IDSURVEY=',I3,')' )

      write(6,202) SURVEY_FILTERS(1:L2), NFILTDEF_SURVEY
202   format(T5,'Found FILTERS = ',A, 3x, '(NFILTDEF=',I3,')' )


      if ( FORMAT_FITS ) then
        write(6,204) N_SNFILE
204     format(T5,'Found ',I7,' SN Candidates to Process.')
      endif

      print*,' '
      call flush(6)


c --------------------------------------------------------
c check that user telescopes & fields are defined in SURVEY.DEF ...
c but if 'ALL' option is set, don't bother checking.

      IF ( .NOT. DOALL_SNTEL ) THEN
        DO i    = 1, NIDTEL_LIST
          ctel  = SNTEL_LIST(i)
          idtel = IDTEL_LIST(i)
          if ( idtel .LT. 0 ) then
             LL = index( ctel, ' ' ) - 1
             c1err = 'Unknown TELESCOPE: ' // ctel(1:LL)
             c2err = 'Check namelist variable SNTEL_LIST '
             CALL MADABORT("INIT_SURVEY", c1err, c2err )
          endif
        ENDDO
      ENDIF

      IF ( .NOT. DOALL_SNFIELD ) THEN
        DO i    = 1, NIDFIELD_LIST
          cfield  = SNFIELD_LIST(i)
          idfield = IDFIELD_LIST(i)
          if ( idfield .LT. 0 ) then
             LL = index( cfield, ' ' ) - 1
             c1err = 'Unknown FIELD: ' // cfield(1:LL)
             c2err = 'Check namelist variable SNFIELD_LIST '
             CALL MADABORT("INIT_SURVEY", c1err, c2err )
          endif
        ENDDO
      ENDIF


c ---------------------------------
c check for FILTER_REPLACE option


      CALL INIT_FILTER_REPLACE()

      RETURN
      END      ! end of INIT_SURVEY

C ===================================
+DECK,INIFLTREPLACE.
      SUBROUTINE INIT_FILTER_REPLACE()

C Created Jun 2013 by R.K.
C Initialize IFILTOBS_REPLACE array based on user input 
c string FILTER_REPLACE read from &SNLCINP namelist.
C After this init, can use FILTINDX_REPLACE function.
c
c Example:  FILTER_REPLACE = 'UGRIZ -> ugriz' will 
c internally replace UGRIZ with ugriz so that we can
c analyze 'ugriz' (intead of ugrizUGRIZ) and get 
c all of the epochs. This is intended for cases in 
c which UGRIZ and ugriz bands are very similar.
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER 
     &  IFILTOBS, NF1, NF2, NFARROW, IFILT, NWD, LF
     & ,IFILTOBS_ORIG

      CHARACTER 
     &   ARROW*60
     &  ,FILTLIST1*(MXFILT_ALL)
     &  ,FILTLIST2*(MXFILT_ALL)
     &  ,NAME_forC*(MXFILT_ALL)
     &  ,FNAM*20
     &  ,CFILT_ORIG*2
     &  ,CFILT_REPLACE*2

c function
      INTEGER FILTINDX
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN ------------

      NFILT_REPLACE = 0
      DO IFILTOBS = 1, MXFILT_ALL
        IFILTOBS_REPLACE(IFILTOBS) = IFILTOBS  ! default is 1-to-1 map
      ENDDO

      FNAM = 'INIT_FILTER_REPLACE'

      IF ( FILTER_REPLACE .NE. ' ' ) THEN

        LF        = INDEX(FILTER_REPLACE,' ', BACK=.TRUE.) - 1
        NAME_forC = FILTER_REPLACE(1:LF) // char(0)
        NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_STRING,NAME_forC,LF)
        
        CALL get_PARSE_WORD_fortran(1, FILTLIST1, NF1)
        CALL get_PARSE_WORD_fortran(2, ARROW,     NFARROW)
        CALL get_PARSE_WORD_fortran(3, FILTLIST2, NF2)

c idiot checks

        if ( NF1 .NE. NF2 ) THEN
           c1err = 'Cannot use FILTER_REPLACE with ' // 
     &              'different size lists.'
           c2err = 'N(' // FILTLIST1(1:NF1) // ')' //
     &         ' != N(' // FILTLIST2(1:NF2) // ')'
           CALL MADABORT(FNAM, c1err, c2err )
        ENDIF
        IF ( ARROW(1:2) .NE. '->' ) THEN
           c1err = 'Second string of FILTER_REPLACE must by  ->'
           c2err = 'Check &SNLCINP namelist.'
           CALL MADABORT(FNAM, c1err, c2err )
        ENDIF

        NFILT_REPLACE = NF1
        DO IFILT = 1, NFILT_REPLACE
           CFILT_ORIG    = FILTLIST1(IFILT:IFILT)
           CFILT_REPLACE = FILTLIST2(IFILT:IFILT)

           IFILTOBS_ORIG                 = FILTINDX(CFILT_ORIG)
           IFILTOBS_REPLACE(IFILTOBS_ORIG) = FILTINDX(CFILT_REPLACE)

           write(6,20) CFILT_ORIG, CFILT_REPLACE, IFILTOBS_ORIG,
     &                    IFILTOBS_REPLACE(IFILTOBS_ORIG) 
 20        format(T10,'FILTER_REPLACE:  ', A, ' -> ', A, 3x,
     &        '(',I3,' -> ', I3, ')' )         
           CALL FLUSH(6)
        ENDDO
        print*,' '

c        print*,' xxx FILTLIST1 = ', FILTLIST1(1:12), NF1
c        print*,' xxx FILTLIST2 = ', FILTLIST2(1:12), NF2
c        print*,' xxx ARROW = ', ARROW
c        print*,' xxx REPLACE ', NFILT_REPLACE,'  filters '


      ENDIF

      RETURN
      END

C =============================
+DECK,SETSURVEY.
      SUBROUTINE SET_SURVEY(NAME, NFILTDEF, IFILTDEF, LAMSHIFT )
c
c May 18, 2008
c
c Set survey and IFILTDEF_[INV]MAP_SURVEY variables 
c by passing them (i.e., from simulation) rather than 
c by calling RDSURVEY. 
c 
c Jun 20 2017: pass LAMSHIFT as argument.
c
c ---------

      IMPLICIT NONE
c subroutine args

      CHARACTER NAME*(*)         ! (I) name of survey

      INTEGER
     &    NFILTDEF            ! (I) number of survey filters
     &   ,IFILTDEF(NFILTDEF)  ! (I) absolute filter indices

      REAL LAMSHIFT(NFILTDEF) ! (I) LAMSHIFT for each band
 
c local args

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,FILTCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.

      INTEGER ifilt, ifilt_obs

c ---------------- BEGIN ------------

      SURVEY_NAME     = NAME
      NFILTDEF_SURVEY = NFILTDEF


      DO ifilt    = 1, NFILTDEF
        ifilt_obs = IFILTDEF(ifilt)
        IFILTDEF_MAP_SURVEY(ifilt)        = ifilt_obs
        IFILTDEF_INVMAP_SURVEY(ifilt_obs) = ifilt
        FILTER_LAMSHIFT_FILT(ifilt_obs)   = LAMSHIFT(IFILT)
      ENDDO


c Apr 2013: make sure to abort on bad kcor redshift.
      ABORT_ON_BADZ = .TRUE.

      RETURN
      END

C ================================================
+DECK,ABTREST.
      SUBROUTINE ABORT_ON_CUTWIN_TREST()

C Feb 2014
C Utility called by photo-z fitting program to abort
C if any of the SNANA-Trest cuts are set ... because
c for photo-z fit we cannot make an a-priori cut that
c depends on redsfhit. Try CUTWIN_TOBSMIN, CUTWIN_TOBSMAX,
c and other cuts that do NOT depend on the fitted photo-z.
c
c  To override this abort, set
c  &SNLCINP
c    ABORT_ON_TRESTCUT = F
c -------------------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,SNLCINP.

    
      INTEGER NCUT, i, icut, ICUTLIST(20)
      INTEGER NCUT_USE, LEN
      LOGICAL LLO, LHI
      REAL    VLO, VHI

      CHARACTER c1err*76, C2err*76

C --------------- BEGIN --------------
      NCUT = 0

      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_TREST
      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_TRESTMIN
      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_TRESTMAX
      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_TGAPMAX
      NCUT = NCUT + 1 ;   ICUTLIST(NCUT) = CUTBIT_T0GAPMAX

      NCUT_USE = 0
      Do 100 i = 1, NCUT
         icut  = ICUTLIST(i)
         VLO   = CUTWIN_VAR(1,icut) 
         VHI   = CUTWIN_VAR(2,icut) 

         LLO   = ( VLO > -.99*CUTVAL_OPEN ) 
         LHI   = ( VHI < +.99*CUTVAL_OPEN  ) 
         if ( LLO .or. LHI ) THEN
            NCUT_USE = NCUT_USE + 1
            LEN = INDEX(CUTVAR_NAME(icut),' ') - 1
            write(6,60) CUTVAR_NAME(icut), VLO, VHI
 60         format(T5,'WARNING: should not use CUTWIN_', A15,
     &            2x, F10.3,' - ', F10.3 )
            call flush(6)
         endif
 100  CONTINUE

      IF ( NCUT_USE > 0 .and. ABORT_ON_TRESTCUT ) THEN
         write(c1err,160) NCUT_USE
 160     format(I3,' Trest &SNLCINP cuts above are forbidden.' )
         c2err = 'Can override abort with &SNLCINP ABORT_ON_TRESTCUT=F'
         CALL MADABORT('ABORT_ON_CUTWIN_TREST', c1err, c2err )
      ENDIF

      RETURN
      END

C ================================================
+DECK,RDEPIG.
      SUBROUTINE RDEPIGNORE ( IVERS, IERR )
c
c Created May 6, 2008 by R.Kessler
c Read list of epochs to ignore.
c 
c Use namelist variable EPOCH_IGNORE_FILE:
c if 'DEFAULT', then read [SNDATA_PREFIX].IGNORE.
c
c Fill variables in common EPXCOM
c
c File syntax is
c
c  IGNORE:  <CID1>  <MJD1>  <FILTER1>
c  IGNORE:  <CID2>  <MJD2>  <FILTER2>
c  etc ...
c
c  where <FILTER> is 'g' or 'r' or 'i' etc ...
c
c
c Jun 28, 2011: if IVERS>1 reads the same file then stop reading and return.
c ----------------------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   
     &    IVERS        ! (I) use this version index
     &   ,IERR         ! (O) 0=> OK,  else error

c local var

      INTEGER LL, LL1, LL2, LL3, LV, LF
      INTEGER iwd, NWD, N, LUN, NREAD_IGNORE
      REAL*8 MJD8
      CHARACTER 
     &   LOCAL_FILENAME*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)
     &  ,VERSION*(MXCHAR_VERSION)
     &  ,cwd*(MXCHAR_FILEWORD), cflt*4
     &  ,cwd_tmp*(MXCHAR_FILEWORD)
     &  ,ccid*(MXCHAR_CCID)
     &  ,ccid_last*(MXCHAR_CCID)

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN ----------
      IERR = 0
      LUN = LUNTMP

      VERSION  = VERSION_PHOTOMETRY(ivers) 
      LV       = index(VERSION,' ') - 1

      CALL PRBANNER ( "RDEPIGNORE:" )

      if ( EPOCH_IGNORE_FILE(1:4) .EQ. 'NONE' ) GOTO 8000
      if ( EPOCH_IGNORE_FILE(1:4) .EQ. 'NULL' ) GOTO 8000

c check if file is default, or if provided by user.

      IF ( EPOCH_IGNORE_FILE(1:7) .EQ. 'DEFAULT' ) THEN
        LL = INDEX( SNDATA_PREFIX, ' ' ) - 1
        LOCAL_FILENAME = SNDATA_PREFIX(1:LL) // '.IGNORE'
      ELSE
        LOCAL_FILENAME = EPOCH_IGNORE_FILE
      ENDIF

c for multiple versions, don't bother re-reading  the same
c IGNORE file
      IF ( IVERS .GT. 1 ) then
        LF  = INDEX(LOCAL_FILENAME,' ') - 1
        IF ( LOCAL_FILENAME(1:LF) .EQ. 
     &       EPOCH_IGNORE_LASTFILE(1:LF) ) THEN
             RETURN
        ENDIF
      ENDIF

c -----------
c Now start reading file

      LL = INDEX( LOCAL_FILENAME, ' ' ) - 1
      NAME_forC = LOCAL_FILENAME(1:LL)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,LL)


      write(6,50) LOCAL_FILENAME(1:LL)
50    format(T5,'Read epochs to ignore from: ', /, T5, A)

      NREAD_IGNORE = 0
      CCID_LAST    = EPOCH_IGNORE_CCID(1)

      DO 200 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd,cwd,LL)

         if ( cwd .EQ. 'IGNORE:' ) then
 
           NREAD_IGNORE = NREAD_IGNORE + 1
           CALL get_PARSE_WORD_fortran(iwd+1,CCID,LL1)
           if ( IVERS .GT. 1 .and. ccid .EQ. CCID_LAST ) then
             print*,'   IGNORE file already read -> SKIP re-reading. '
             return
           endif

           NEPOCH_IGNORE = NEPOCH_IGNORE + 1
           N = NEPOCH_IGNORE

           if ( N .GT. MXEPOCH_IGNORE ) then
              write(c1err,661) N
661           format('NEPOCH_IGNORE=',I4,' exceeds array bound.')
              c2err = 'Check file: ' // LOCAL_FILENAME(1:LL)
              CALL MADABORT("RDEPIGNORE", c1err, c2err )
           endif

           CALL get_PARSE_WORD_fortran(iwd+2,CWD_TMP,LL2)
           read(cwd_tmp,*) MJD8

           CALL get_PARSE_WORD_fortran(iwd+3,CWD_TMP,LL3)
           cflt =  CWD_TMP(1:4)
           EPOCH_IGNORE_CCID(N)  = CCID
           EPOCH_IGNORE_FILT(N)  = cflt
           EPOCH_IGNORE_MJD(N)   = MJD8

           LL = INDEX(CCID,' ' ) - 1
           IF ( LL .LE. 0 ) LL = MXCHAR_CCID

           write(6,55) N, CCID(1:LL), MJD8, cflt
55         format(T4,I3,': Add ignore-epoch to list for CID=',A, 
     &         3x,'MJD=',F9.3, 2x,'FILT=',A)
         endif

200   ENDDO

      EPOCH_IGNORE_LASTFILE = LOCAL_FILENAME
      call FLUSH(6)
      print*,' '
      RETURN

C -------------------------------------------
8000  CONTINUE
      print*,'  No epochs will be ignored => use all epochs. '
      CALL FLUSH(6)

      RETURN
      END  ! end of RDEPIGNORE

C ================================================
+DECK,CHKFMT.
      SUBROUTINE CHECK_FORMAT(IERR)

c Created Jun 15, 2011 by R.Kessler
c Check if format is FITS or TEXT; 
c set global logical FORMAT_FITS or FORMAT_TEXT
c
c Aug 8, 2011: pass PATH to RD_SNFITSIO_INIT so that it works
c              with PRIVATE_DATA_PATH option
c
      IMPLICIT NONE

      INTEGER IERR ! (O) 0 => OK

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITSCOM.

      INTEGER    IVERS, OPT, ISTAT, LEN_VERS, LEN_PATH
      CHARACTER  VERSION*(MXCHAR_VERSION), PATH*(MXCHAR_PATH)

C ------------ BEGIN -----------

      IERR = 0

c use first version on list since all versions must have same format
      IVERS    =  1  
      VERSION  = VERSION_PHOTOMETRY(ivers)
      LEN_VERS = INDEX(VERSION,' ') - 1
      VERSION  = VERSION(1:LEN_VERS) // char(0)

      LEN_PATH = INDEX(PRIVATE_DATA_PATH,' ') - 1
      PATH     = PRIVATE_DATA_PATH(1:LEN_PATH) // char(0)

      OPT      = 1  ! option to check format and return 
      ISTAT    = RD_SNFITSIO_INIT(OPT, PATH, VERSION, 
     &                              LEN_PATH, LEN_VERS)

      IF ( ISTAT .GT. 0 ) THEN
         FORMAT_FITS = .TRUE.
      ELSE
         FORMAT_TEXT = .TRUE.
      ENDIF

      RETURN
      END

C ================================================
+DECK,RDVERFITS.
      SUBROUTINE RDVERSION_FITS ( IVERS, IERR )

c --------------------------------------
c Created June 2011 
c Read all SNe for this "VERSION" in fits format.
c
c For split jobs (see JOBSPLIT input), strategy is to
c process every NJOBTOT'th SN to get a more random 
c distribution. Note that the TEXT-format strategy
c is to read consecutive ranges of ISN, but this
c old strategy can lead to highly non-uniform sample
c sizes among nodes because a given TYPE is not always
c randomly distributed among the SNIDs. The new strategy
c relies on a random distribution of SNIDs that end with
c 1-NJOBTOT.
c
c
c July 13 2017: check MXLC_FIT
c ----------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER   
     &    IVERS        ! (I) version index
     &   ,IERR         ! (O) 0=> OK,  else error

c local args

      INTEGER 
     &   OPT, LEN_VERS, LEN_PATH, JPAR, ISTAT
     &  ,IROW, NROW, NJOBTOT, IJOB

      CHARACTER VERSION*(MXCHAR_VERSION), PATH*(MXCHAR_PATH)

c functions
+CDE,FITSCOM.
      LOGICAL LDONE_CIDLIST

C ---------------- BEGIN -------------

      IERR = 0
      VERSION = VERSION_PHOTOMETRY(ivers)
      LEN_VERS = INDEX(VERSION,' ') - 1

      VERSION  = VERSION_PHOTOMETRY(ivers)(1:LEN_VERS) // char(0)

      LEN_PATH = INDEX(PRIVATE_DATA_PATH,' ') - 1
      PATH     = PRIVATE_DATA_PATH(1:LEN_PATH) // char(0)

c  N_SNFILE is the total number of candidates without
c  any selection on type, redshift, etc ...

      OPT = 0                          ! => full (default) init
      IF ( LFLAG_RDHEAD_ONLY ) OPT=2   ! Feb 7 2018

      NROW  = RD_SNFITSIO_INIT(OPT, PATH, VERSION,
     &                         LEN_PATH, LEN_VERS )

      IF ( NROW > MXSNLC-1 ) THEN
        write(C1err,161) NROW, MXSNLC
161     format('NROW=',I8,' exceeds bound MXSNLC=',I8 )
        C2err = 'Check MXSNLC parameter in snana.car'
        CALL MADABORT("RDVERSION_FITS", c1err, c2err )
      ENDIF

      N_SNFILE = NROW   ! N_SNFILE is global

c get global survey info

      IF ( LFLAG_RDHEAD_ONLY .or. IVERS .GT. 1 ) THEN
         CALL RDSURVEY_FITS(IERR)
         CALL INIT_SURVEY(IERR)
      ENDIF

c init lookup pointers for each new version
c to allow different table structure in each version.

       DO JPAR = 1, MXFITSPAR
           INDXFITS_HEAD(jpar)   = -9  
           INDXFITS_EPCUTS(jpar) = -9  
           INDXFITS_PHOT(jpar)   = -9  
       ENDDO

       IF ( LFLAG_RDHEAD_ONLY ) RETURN  

c strip off info for SPLITTING jobs among multiple CPUs.
      NJOBTOT = JOBSPLIT(2) ! total number of split jobs
      IJOB    = JOBSPLIT(1) ! do IJOB of NJOBTOT
      IF ( NJOBTOT .GT. 1 ) THEN
        write(6,20) JOBSPLIT
20      format(T5,'Process SPLIT-JOB ',I2,' of ', I2 )
      ENDIF
c -------------------------------------------
c read each SN and store.

      DO 100 irow = IJOB, NROW, NJOBTOT ! every NJOBTOT'th SN

        IF ( N_SNLC_FITCUTS > MXLC_FIT ) GOTO 100 ! July 13 2017

        CALL RDSNFITS ( IVERS, IROW, ISTAT )

        IF ( ISTAT .EQ. 0 ) THEN
          CALL SNANA_DRIVER(N_SNLC)
        ENDIF

c stop reading if/when all CIDs are processed
         IF ( LDONE_CIDLIST() ) GOTO 500  

100   CONTINUE  ! end IROW loop

500   CONTINUE

      CALL RD_SNFITSIO_CLOSE(VERSION,LEN_VERS)

      RETURN
      END   ! end of RDVERSION_FITS

C ===========================================
+DECK,RDSURVEY_FITS.
      SUBROUTINE RDSURVEY_FITS(IERR)

c Jun 2011
c 
c Analog of RDSURVEY_TEXT:
c Read global survey variables.
c
c Dec 27 2015: SIMLIB -> SIMLIB_FILE and read SIMLIB_MSKOPT
c Jun 16 2017: check for NSUBSAMPLE_MARK
c Mar 18 2018: read SIM__VARNAME_SNRMON
c Dec 26 2018: read CODE_IVERSION
c -----------------------------------

      IMPLICIT NONE
      INTEGER   IERR    ! (O) 0=> OK,  else error

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITSCOM.
+CDE,SPECCOM.

      INTEGER ISTAT, LRET, FLAG
      CHARACTER KEYNAME*80, KEYVAL*80, DATATYPE*20
      LOGICAL LRDFILT

c C functions
      INTEGER   RD_SNFITSIO_GLOBAL
      EXTERNAL  RD_SNFITSIO_GLOBAL

C ------------- BEGIN ------------

      IERR = 0

      global_banner =
     &   "RDSURVEY_FITS: FETCH GLOBAL SURVEY INFO from HEADER"
      CALL PRBANNER(global_banner(1:60) )

      KEYNAME   = "SURVEY" // char(0)
      ISTAT = RD_SNFITSIO_GLOBAL(KEYNAME, KEYVAL, 6, LRET )
      LRET  = INDEX(KEYVAL,char(0)) - 1
      SURVEY_NAME = KEYVAL(1:LRET)   

c check for sub-survey flag (Feb 17 2017)
      KEYNAME   = "SUBSURVEY_FLAG" // char(0)
      ISTAT = RD_SNFITSIO_GLOBAL(KEYNAME, KEYVAL, 14, LRET )
      LRET  = INDEX(KEYVAL,char(0)) - 1
      IF(LRET>0) THEN
         READ( KEYVAL(1:LRET), * ) FLAG
         IF ( FLAG > 0 ) SUBSURVEY_NAME = 'ENABLE' ! anything non-null
      ENDIF

c check for code version used to write fits file.
      KEYNAME   = "CODE_IVERSION" // char(0)
      ISTAT = RD_SNFITSIO_GLOBAL(KEYNAME, KEYVAL, 14, LRET )
      LRET  = INDEX(KEYVAL,char(0)) - 1
      IF(LRET>0) THEN
         READ( KEYVAL(1:LRET), * ) CODE_IVERSION
      ENDIF

c --------------------------------------------------------

      LRDFILT =  .NOT. FREEZE_SURVEY_FILTERS 
      IF ( LRDFILT ) THEN
        KEYNAME   = "FILTERS" // char(0)
        ISTAT = RD_SNFITSIO_GLOBAL(KEYNAME, KEYVAL, 7, LRET )
        LRET  = INDEX(KEYVAL,char(0)) -1
        SURVEY_FILTERS = KEYVAL(1:LRET)
      ENDIF

c -----------------------------------------
c check for optional SPECFILE (Apr 2019)
c We don't need the SPECFILE name yet; just need to set a logical flag.
c 
      KEYNAME   = "SPECFILE" // char(0) ;  KEYVAL=''
      ISTAT = RD_SNFITSIO_GLOBAL(KEYNAME, KEYVAL, 8, LRET )
      IF ( KEYVAL(1:4) .NE. 'NONE' ) THEN
         RDFLAG_SPECTRUM = .TRUE.
      ENDIF

c -----------------------------------------
      KEYNAME   = "DATATYPE" // char(0)
      ISTAT = RD_SNFITSIO_GLOBAL(KEYNAME, DATATYPE, 8, LRET)
      LSIM_SNANA = .FALSE. ; LSIM_MAGOBS = .FALSE.

      IF ( DATATYPE(1:4) .EQ. 'DATA' ) THEN
         ! do nothing
      ELSE IF ( DATATYPE(1:9)  .EQ. 'SIM_SNANA' ) THEN
         LSIM_SNANA = .TRUE.
      ELSE IF ( DATATYPE(1:10) .EQ. 'SIMULATION' ) THEN  ! legacy
         LSIM_SNANA = .TRUE.
      ELSE IF ( DATATYPE(1:10) .EQ. 'SIM_MAGOBS' ) THEN
         LSIM_MAGOBS = .TRUE.
      ELSE
        C1err = 'Unrecognized DATATYPE = ' // DATATYPE
        C2err = 'Check DATATYPE key in FITS header.'
        CALL MADABORT("RDSURVEY_FITS", c1err, c2err )
      ENDIF

c check optional private variables
      CALL RDPRIVATE_FITS()

      IF ( LSIM_SNANA ) THEN

c   SIMLIB_FILE & SIMLIB_MSKOPT are optional in order to 
c   be back-compatible with older snana versions (Dec 27 2015)

         KEYNAME   = "SIMLIB_FILE" // char(0)
         ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 11, LRET )
         LRET      = INDEX(KEYVAL,char(0)) - 1
         IF (LRET>0) READ( KEYVAL(1:LRET), * ) SIMLIB_FILENAME

         KEYNAME   = "SIMLIB_MSKOPT" // char(0)
         ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 13, LRET )
         LRET      = INDEX(KEYVAL,char(0)) - 1
         IF(LRET>0)  READ( KEYVAL(1:LRET), * ) SIMLIB_MSKOPT

         KEYNAME   = "SIMOPT_MWCOLORLAW" // char(0)
         ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 17, LRET )
         LRET      = INDEX(KEYVAL,char(0)) - 1
         READ( KEYVAL(1:LRET), * ) SIMOPT_MWCOLORLAW

         KEYNAME   = "SIM_MWRV" // char(0)
         ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 8, LRET )
         LRET      = INDEX(KEYVAL,char(0)) - 1
         READ( KEYVAL(1:LRET), * ) SIM_MWRV

         KEYNAME   = "SIMOPT_MWEBV" // char(0)
         ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 14, LRET )
         LRET      = INDEX(KEYVAL,char(0)) - 1
         READ( KEYVAL(1:LRET), * ) SIMOPT_MWEBV

         KEYNAME   = "SIM_NSUBSAMPLE_MARK" // char(0)
         ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 19, LRET )
         LRET      = INDEX(KEYVAL,char(0)) - 1
         READ( KEYVAL(1:LRET), * ) SIM_NSUBSAMPLE_MARK

         CALL RDFITSHEAD_SIMSED()  ! check for SIMSED model params
         CALL RDFITSHEAD_BYOSED()  ! check for BYOSED model params
         CALL RDFITSHEAD_LCLIB()   ! check for LCLIB model Feb 28 2018
         CALL RDFITSHEAD_SIM_HOSTLIB()

         KEYNAME   = "SIM_VARNAME_SNRMON" // char(0)
         ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 18, LRET )
         LRET      = INDEX(KEYVAL,char(0)) - 1
         if(LRET>5) SIMNAME_SNRMON = KEYVAL(1:LRET)

      ENDIF

      RETURN  
      END    ! end RDSURVEY_FITS

C ==========================================
+DECK,RDSNFITS.
      SUBROUTINE RDSNFITS ( IVERS, IROW, ISTAT )

c Created Jun 16, 2011 by R.Kessler
c
c Driver function to read data for a single SN.
c "IVERS" specifies the version.
c "IROW"  specifies the absolute row-location in the 
c         header fits file.
c
c -------------------------
      IMPLICIT NONE

c subroutine args

      INTEGER 
     &   IVERS  ! (I) version index
     &  ,IROW   ! (I) fits-file row or entry; analog of IFILE 
     &  ,ISTAT  ! (O) 0=> OK, otherwise reject

c local variables

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITSCOM.

      INTEGER  NRD, ISN, ep, IFILT, IFILT_OBS
      CHARACTER FNAM*10

C -------------- BEGIN --------------

      FNAM = 'RDSNFITS'

c turn off epoch selection-mask
      NRD = 0
      CALL SET_RDMASK_SNFITSIO(NRD, EPOCH_RDMASK_SNFITSIO)  

      ISN                  = N_SNLC + 1  ! prepare for next SN
      ABSO_INDEX(isn)      = IROW
      ISNLC_ABSO_INDEX     = IROW

      CALL INIT_SNDATA()

      IPARFITS_HEAD = 0    ! Oct 3, 2011

      CALL PARSE_HEAD(ISN, "", ISTAT)
      if ( ISTAT .LT. 0 ) RETURN

      IF ( LSIM_SNANA ) THEN
        CALL PARSE_SIM ( ISN, "SIM", ISTAT)
        if ( ISTAT .LT. 0 ) RETURN
      ENDIF

c read enough epoch info to make epoch-cuts and set read mask
      CALL RDSNFITS_EPCUTS ( IVERS, IROW )

c read all epoch info for this event from PHOT table
      CALL RDSNFITS_PHOT ( IVERS, IROW )

c read optional spectra (Apr 2019)
      CALL RDSNFITS_SPEC ( IVERS )

      N_SNLC = ISN 

      if ( N_SNLC > MXSNLC-1 ) THEN
        write(c1err,666) N_SNLC
666     format('N_SNLC=',I5,' exceeds MXSNLC array bound.')
        c2err = 'Try splitting job into multiple jobs with CID-ranges'
        CALL MADABORT(FNAM, c1err, c2err)
      endif

c ---------------------------------------------------------------
c set NEWMJD  variables. For FITS format, each new MJD corresponds
c to an observation, so NEPOCH = NOBS by definition. For verbose-text
c format we can have NEPOCH < NOBS if multiple obs in different
c filters are taken at the same epoch (i.e., SDSS).

      ISNLC_VERSION    = IVERS
      DO 200 ep = 1, ISNLC_NEWMJD_STORE
         ISNLC_EPOCH_RANGE_NEWMJD(1,ep) = ep
         ISNLC_EPOCH_RANGE_NEWMJD(2,ep) = ep

         IFILT_OBS = ISNLC_IFILT_OBS(ep)
         IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
         ISNLC_NEPOCH_FILT(ifilt) = 
     &   ISNLC_NEPOCH_FILT(ifilt) + 1
200   CONTINUE ! EP

c --------------------------------
      call PRINT_RDSN()  ! print one-line summary
c --------------------------------

      RETURN
      END   ! end of RDSNFITS

C ==========================================
+DECK,RDSNFITS_EPCUTS.
      SUBROUTINE RDSNFITS_EPCUTS ( IVERS, IROW )

c Created Jun 16, 2011 by R.Kessler
c
c Read enough epoch info to make epoch-selection and check
c for epochs to ignore.  Set the read-mask. 
c
c  IVERS  specifies the version.
c  IROW   specifies the absolute row-location in the fits file.
c
c Mar 20 2015: call CHECK_EPOCH_IGNORE here instead of SNRECON
c              so that ignored epochs are not even stored.
c
c -------------------------
      IMPLICIT NONE

c subroutine args

      INTEGER IVERS  ! (I) version index
      INTEGER IROW   ! (I) table row in FITS file

c local variables

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER 
     &   NRD, JPAR, LRET, ep
     &  ,IDTEL, IDFIELD, NEPCUT
  
      CHARACTER  KEYNAME*80

      REAL*4  Z, PKMJD, MJD
      LOGICAL LCUT, IGNORE

c  functions
+CDE,FITSCOM.
      LOGICAL LCUTEPOCH, CHECK_EPOCH_IGNORE

C -------------- BEGIN --------------

      JPAR   = 0

c Now read epoch info; start with required keys followed by
c CALL CHECK_FITSABORT, and with optional keys needed to select epochs.

      KEYNAME  = "MJD" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_DBL(IROW, KEYNAME, SNLC8_MJD(1), 
     &         INDXFITS_EPCUTS(JPAR), 3 )
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)

      KEYNAME  = "FIELD" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_STR(IROW, KEYNAME, STRFITS, 
     &         INDXFITS_EPCUTS(JPAR), 5, LRET )
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)
      LRET = INDEX( STRFITS, char(0) ) - 1
      CALL UNPACK_SNFITSIO_STR(NRD, KEYNAME, STRFITS(1:LRET) )

      KEYNAME  = "TELESCOPE" // char(0)  ! OPTIONAL
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_STR(IROW, KEYNAME, STRFITS,
     &     INDXFITS_EPCUTS(JPAR),9,LRET)
      IF ( NRD .GT. 0 ) THEN  ! TELESCOPE is optional key
        CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)
        LRET = INDEX( STRFITS, char(0) ) -1
        CALL UNPACK_SNFITSIO_STR(NRD, KEYNAME, STRFITS(1:LRET) )
      ENDIF

c Mar 2015 - parse more epoch variables for CHECK_EPOCH_IGNORE 

      KEYNAME  = "FLT" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_STR(IROW, KEYNAME, STRFITS, 
     &     INDXFITS_PHOT(JPAR), 3, LRET )
+SELF,IF=XXXBAND.
      IF ( NRD <= 0) THEN   
c         Mar 29 2017: try alternate BAND key
         KEYNAME  = "BAND" // char(0)
         NRD = RD_SNFITSIO_STR(IROW, KEYNAME, STRFITS, 
     &          INDXFITS_PHOT(JPAR), 3, LRET )
      ENDIF
+SELF.
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)
      LRET = INDEX( STRFITS, char(0) ) -1
      CALL UNPACK_SNFITSIO_STR(NRD, KEYNAME, STRFITS(1:LRET) )
      
      KEYNAME  = "FLUXCAL" // char(0) 
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_FLUXCAL,
     &     INDXFITS_EPCUTS(JPAR),7,LRET)
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)

      KEYNAME  = "FLUXCALERR" // char(0) 
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_FLUXCAL_ERRTOT,
     &     INDXFITS_EPCUTS(JPAR),10,LRET)
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)

c --- optional keys below have no call to CHECK_FITSABORT

      KEYNAME  = "PHOTFLAG" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_INT(IROW, KEYNAME, ISNLC_PHOTFLAG,
     &     INDXFITS_EPCUTS(JPAR),8,LRET)
cc      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)

      KEYNAME  = "PHOTPROB" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_PHOTPROB,
     &     INDXFITS_EPCUTS(JPAR),8,LRET)
cc      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)

c -----------------------------------------------------
c use above info to determine which epochs to keep/reject

      PKMJD  = SNLC_SEARCH_PEAKMJD
      Z      = SNLC_REDSHIFT
      NEPCUT = 0

      DO 99 ep = 1, NRD
        MJD     = SNGL( SNLC8_MJD(ep) )
        IDFIELD = ISNLC_IDFIELD(ep)
        IDTEL   = ISNLC_IDTEL(ep)

        IGNORE  = CHECK_EPOCH_IGNORE(1,ep) .and.
     &            (.not. REFORMAT_SAVE_BADEPOCHS)
        LCUT    = LCUTEPOCH(Z, PKMJD, MJD, IDTEL, IDFIELD ) 
     &            .and. (.not. IGNORE )

        IF ( LCUT ) then
          EPOCH_RDMASK_SNFITSIO(ep) = 1
          NEPCUT = NEPCUT + 1
        else
          EPOCH_RDMASK_SNFITSIO(ep) = 0
        endif
99    CONTINUE

c set epoch mask for fitsio reader
      CALL SET_RDMASK_SNFITSIO(NRD, EPOCH_RDMASK_SNFITSIO)

c set NEPCUT in global 
      ISNLC_NEWMJD_FOUND = NRD 
      ISNLC_NEWMJD_STORE = NEPCUT
      ISNLC_NEPOCH_STORE = NEPCUT

      RETURN
      END  ! end of RDSNFITS_EPCUTS


C ==========================================
+DECK,RDSNFITS_PHOT.
      SUBROUTINE RDSNFITS_PHOT ( IVERS, IROW )

c Created Jun 16, 2011 by R.Kessler
c
c Read EPOCH info from fits-PHOT file.
c
c  IVERS  specifies the version.
c  IROW   specifies the absolute row-location in the fits file.
c
c Feb 26, 2012: read ZEROPT, ZEROPT_ERR, GAIN and RDNOISE
c
c Aug 06, 2014: read SIM_MAGOBS instead of SIM_MAG, and check LSIM_MAGOBS
c
c Mar 03, 2018: read SIM_FLUXCAL_HOSTERR
c Mar 18, 2018: read SIM_SNRMAG[mag], but only if it is defined.
c
c Jun 24 2019: read SKY_AVG (used in FLUXCERRCALC)
c
c -------------------------
      IMPLICIT NONE

c subroutine args

      INTEGER IVERS  ! (I) version index
      INTEGER IROW   ! (I) fits-file row or entry; analog of IFILE 

c local variables

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER  NRD, JPAR, LRET, LENTMP
      CHARACTER  KEYNAME*80

c  functions
+CDE,FITSCOM.

C --------------- BEGIN --------------

      JPAR   = 0

      KEYNAME  = "MJD" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_DBL(IROW, KEYNAME, SNLC8_MJD(1), 
     &         INDXFITS_PHOT(JPAR), 3 )
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)


      KEYNAME  = "FIELD" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_STR(IROW, KEYNAME, STRFITS, 
     &         INDXFITS_PHOT(JPAR), 5, LRET )
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)
      LRET = INDEX( STRFITS, char(0) ) - 1
      CALL UNPACK_SNFITSIO_STR(NRD, KEYNAME, STRFITS(1:LRET) )


      KEYNAME  = "TELESCOPE" // char(0)  ! OPTIONAL
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_STR(IROW, KEYNAME, STRFITS,
     &         INDXFITS_PHOT(JPAR), 9, LRET)

      IF ( NRD > 0 ) THEN  ! optional key
        CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)
        LRET = INDEX( STRFITS, char(0) ) -1
        CALL UNPACK_SNFITSIO_STR(NRD, KEYNAME, STRFITS(1:LRET) )
      ENDIF


      KEYNAME  = "FLT" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_STR(IROW, KEYNAME, STRFITS, 
     &         INDXFITS_PHOT(JPAR), 3, LRET )
+SELF,IF=XXXBAND.
      IF ( NRD <= 0 ) THEN
         KEYNAME  = "BAND" // char(0)
         NRD = RD_SNFITSIO_STR(IROW, KEYNAME, STRFITS, 
     &             INDXFITS_PHOT(JPAR), 3, LRET )
      ENDIF
+SELF.
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)
      LRET = INDEX( STRFITS, char(0) ) -1
      CALL UNPACK_SNFITSIO_STR(NRD, KEYNAME, STRFITS(1:LRET) )

      KEYNAME  = "FLUXCAL" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_FLUXCAL(1), 
     &         INDXFITS_PHOT(JPAR), 7 )
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)

      KEYNAME  = "FLUXCALERR" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_FLUXCAL_ERRTOT(1), 
     &         INDXFITS_PHOT(JPAR), 10 )
      CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)

c optional quantities (no call to CHECK_FITSABORT)

      KEYNAME  = "PHOTFLAG" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_INT(IROW, KEYNAME, ISNLC_PHOTFLAG(1), 
     &         INDXFITS_PHOT(JPAR), 8 )

      KEYNAME  = "PHOTPROB" // char(0)  ! added Nov 24 2014
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_PHOTPROB(1), 
     &         INDXFITS_PHOT(JPAR), 8 )

      KEYNAME  = "PSF_SIG1" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_PSF_SIG1(1), 
     &         INDXFITS_PHOT(JPAR), 8 )

      KEYNAME  = "PSF_SIG2" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_PSF_SIG2(1), 
     &         INDXFITS_PHOT(JPAR), 8 )

      KEYNAME  = "PSF_RATIO" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_PSF_RATIO(1), 
     &         INDXFITS_PHOT(JPAR), 9 )

      KEYNAME  = "SKY_SIG" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_SKYSIG(1), 
     &         INDXFITS_PHOT(JPAR), 7 )

      KEYNAME  = "SKY_SIG_T" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_SKYSIG_T(1), 
     &         INDXFITS_PHOT(JPAR), 9 )

      KEYNAME  = "RDNOISE" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_RDNOISE(1), 
     &         INDXFITS_PHOT(JPAR), 7 )

      KEYNAME  = "ZEROPT" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_ZEROPT(1), 
     &         INDXFITS_PHOT(JPAR), 6 )

      KEYNAME  = "ZEROPT_ERR" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_ZEROPT_ERR(1), 
     &         INDXFITS_PHOT(JPAR), 10 )

      KEYNAME  = "GAIN" // char(0)
      JPAR = JPAR + 1
      NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_GAIN(1), 
     &         INDXFITS_PHOT(JPAR), 4 )

      IF( SNLC_NXPIX > 0 ) THEN
         KEYNAME  = "XPIX" // char(0)
         JPAR = JPAR + 1
         NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_XPIX(1), 
     &        INDXFITS_PHOT(JPAR), 4 )
         
         KEYNAME  = "YPIX" // char(0)
         JPAR = JPAR + 1
         NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SNLC_YPIX(1), 
     &        INDXFITS_PHOT(JPAR), 4 )
      ENDIF

c ---------------------------------
+SELF,IF=SIM_MAG.
c read legacy SIM_MAG key
      IF ( LSIM_SNANA .and. .NOT. LSIM_MAGOBS ) THEN
        KEYNAME  = 'SIM_MAG' // char(0)
        JPAR = JPAR + 1
        NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SIM_EPMAGOBS(1), 
     &         INDXFITS_PHOT(JPAR), 7 )
        CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)
        RETURN
      ENDIF
+SELF.

c ---------------------------------
c read sim quanitities

      IF ( LSIM_SNANA .or. LSIM_MAGOBS ) THEN
        KEYNAME  = "SIM_MAGOBS" // char(0)
        JPAR = JPAR + 1
        NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SIM_EPMAGOBS(1), 
     &         INDXFITS_PHOT(JPAR), 10 )
        CALL CHECK_FITSABORT(IVERS,NRD,KEYNAME)
      ENDIF

c Mar 3 2018: read optional true host noise
      IF ( LSIM_SNANA  ) THEN
        KEYNAME  = "SIM_FLUXCAL_HOSTERR" // char(0)
        JPAR = JPAR + 1
        NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SIM_EPFLUXCAL_HOSTERR(1), 
     &         INDXFITS_PHOT(JPAR), 20 )
      ENDIF

c Mar 18 2018: read optional SNRMON 
      LENTMP = INDEX(SIMNAME_SNRMON,' ') - 1
      IF ( LSIM_SNANA  .and. LENTMP > 10 ) THEN
        KEYNAME  = SIMNAME_SNRMON(1:LENTMP) // char(0)
        JPAR = JPAR + 1
        NRD = RD_SNFITSIO_FLT(IROW, KEYNAME, SIM_EPSNRMON(1), 
     &         INDXFITS_PHOT(JPAR), 20 )
      ENDIF


      RETURN
      END     ! end of RDSNFITS_PHOT 

C =============================================
+DECK,RDSNFITS_SPEC.
      SUBROUTINE RDSNFITS_SPEC(IVER)

c April 2019
c read spectra (1 or more) for current SNID. 
c Note that ROW numbers are read below, and thus not passed as argument.

      IMPLICIT NONE

      INTEGER IVER ! (I) iversion index (not used)

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SPECCOM.

      CHARACTER FNAM*14, CCID*(MXCHAR_CCID)
      INTEGER   LENCCID, ROWMIN, ROWMAX, irow, NRDSPEC
      REAL*8    METADATA(10), MJD

c external functions
      EXTERNAL RD_SNFITSIO_SPECROWS, RD_SNFITSIO_SPECDATA

C --------------- BEGIN ------------

      FNAM = 'RDSNFITS_SPEC'
      IF ( .not. RDFLAG_SPECTRUM ) RETURN

      LENCCID = ISNLC_LENCCID
      CCID = SNLC_CCID(1:LENCCID) // char(0)

c retrieve HEADER row-range of spectra 
      CALL RD_SNFITSIO_SPECROWS(CCID,ROWMIN,ROWMAX)
      NSPECTRUM = ROWMAX - ROWMIN + 1

c loop over header rows and extra spectrum for each row.
      NRDSPEC = 0 
      DO 200 irow = ROWMIN, ROWMAX
         NRDSPEC = NRDSPEC + 1
         if ( NRDSPEC > MXSPECTRUM ) goto 200
         call RD_SNFITSIO_SPECDATA(irow     ! (I) 
     &        ,METADATA                     ! (O) double array: MJD,TEXPOSE ...
     &        ,NLAMBIN_SPECTRUM(NRDSPEC)    ! (O) int scalar
     &        ,LAMMIN_SPECTRUM(1,NRDSPEC)   ! (O) double array vs. ilam
     &        ,LAMMAX_SPECTRUM(1,NRDSPEC)   ! (O) idem
     &        ,FLAM_SPECTRUM(1,NRDSPEC)     ! (O) idem
     &        ,FLAMERR_SPECTRUM(1,NRDSPEC) )! (O) idem

         MJD = METADATA(1)
         ID_SPECTRUM(NRDSPEC)      = NRDSPEC
         MJD_SPECTRUM(NRDSPEC)     = MJD
         TOBS_SPECTRUM(NRDSPEC)    = MJD - SNLC_SEARCH_PEAKMJD ! 5/2019
         TEXPOSE_SPECTRUM(NRDSPEC) = METADATA(2)
 200  CONTINUE

      RETURN
      END    ! end RDSNFITS_SPEC


C ======================================
+DECK,UNPSTR.
      SUBROUTINE UNPACK_SNFITSIO_STR(NVAL,KEYNAME,STRING)

c
c  Created Jun 2011
c  Following a call to RD_SNFITSIO_STR(IROW, KEYNAME, STRING ..)
c  this routine unpacks and decodes the retured STRING and fills 
c  the following arrays,
c
c  KEYNAME    filled array
c   FLT       ISNLC_IFILT_OBS
c   FIELD     ISNLC_IDFIELD & SNLC_FIELD
c   TEL       ISNLC_IDTEL
c
c -----------------------------

      IMPLICIT NONE

      INTEGER 
     &   NVAL    ! (I) expect number of values to extract from STRING

      CHARACTER 
     &   KEYNAME*(*)  ! (I) table par name read from fits file
     &  ,STRING*(*)   ! (I) string returned from RD_SNFITSIO_STR

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER iwd, LWD, NWD, LK, LENS, MSKOPT
      CHARACTER  CWD*80
      LOGICAL LVAR_FLT, LVAR_FIELD, LVAR_TEL

c functions
      INTEGER  FILTINDX_REPLACE, GET_IDFIELD, GET_IDTEL

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ----------------- BEGIN --------------

      IF ( NVAL .LT. 0 ) RETURN  ! all epochs fail cut (May 16, 2012)

c determine variable type from KEYNAME

      LVAR_FLT   = .FALSE.
      LVAR_FIELD = .FALSE.
      LVAR_TEL   = .FALSE.

      IF ( KEYNAME(1:3) .EQ. 'FLT' ) THEN
        LVAR_FLT = .TRUE.
      ELSE IF ( KEYNAME(1:5) .EQ. 'FIELD' ) THEN
        LVAR_FIELD = .TRUE.
      ELSE IF ( KEYNAME(1:3) .EQ. 'TEL' ) THEN
        LVAR_TEL = .TRUE.
      ELSE
        c1err = 'Unrecognized KEYNAME = ' // KEYNAME
        c2err = 'Check FITS table.'
        CALL MADABORT('UNPACK_SNFITSIO_STR', c1err,c2err)
      ENDIF

c break up STRING into substrings 
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      LENS   = INDEX(STRING,' ', BACK=.TRUE.)
      NWD    = STORE_PARSE_WORDS(MSKOPT, STRING(1:LENS)//char(0),LENS)

      IF  ( NWD .NE. NVAL ) THEN
        LK = INDEX(KEYNAME,' ') - 2
        CALL PRINT_PREABORT_BANNER("UNPACK_SNFITSIO_STR"//char(0),40)
        print*,'   NWD, NVAL = ', NWD, NVAL
        print*,'   SNLC_CCID = ', SNLC_CCID
        print*,'   KEYNAME   = ', KEYNAME(1:LK)
        print*,'   STRING    = ', STRING
        call flush(6)

        write(c1err,61) NWD, NVAL
     &                  
        write(c2err,62) 
     &       SNLC_CCID(1:ISNLC_LENCCID)
     &      ,KEYNAME(1:LK)

61      format('NWD=',I3,' substrings, but expected NVAL=',I3)
62      format('CID=',A, 2x, 'KEYNAME=',A )
        CALL MADABORT('UNPACK_SNFITSIO_STR', c1err,c2err)

      ENDIF

      DO 100 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd,CWD,LWD)

         if ( LVAR_FLT ) then
            ISNLC_IFILT_OBS(iwd) = FILTINDX_REPLACE(CWD)
         else if ( LVAR_FIELD ) then
            SNLC_FIELD(iwd)    = CWD(1:LWD)
            ISNLC_IDFIELD(iwd) = GET_IDFIELD(CWD)           
         else if ( LVAR_TEL ) then
            ISNLC_IDTEL(iwd) = GET_IDTEL(CWD)
         endif

+SELF,IF=DEBUG.
         if ( LVAR_FLT .and. isn .EQ. 1 .and. iwd .lt. 5 ) then
           print*,' xxx iwd=',iwd,'  IFILT_OBS=',ISNLC_IFILT_OBS(iwd)
         endif

         if ( LVAR_FIELD .and. isn .EQ. 1 .and. iwd .lt. 5 ) then
           print*,' xxx iwd=',iwd,
     &         '  FIELD=',SNLC_FIELD(iwd), ISNLC_IDFIELD(iwd)
         endi
+SELF.

100   CONTINUE

      RETURN
      END
C ========================================
+DECK,FITSABORT.
      SUBROUTINE CHECK_FITSABORT(IVERS,NRD,KEY)

c Created Jun 16, 2011
c ABORT if NRD = 0 or of NRD exceeds bound of MXEPOCH
c Call this routine after each fits-read for a REQIURED key.
c
c Note that NRD = -9 is OK because this means that
c all epochs failed the epoch-MASK  cuts.

      IMPLICIT NONE

      INTEGER 
     &  IVERS   ! (I) version index
     & ,NRD     ! (I) Number of elements returned for fits key

      CHARACTER KEY*(*)  ! (I) name of fits key

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER VERSION*100
      INTEGER LK, LV

C ---------- BEGIN ----------


      IF ( NRD .EQ. 0 .or. NRD .GT. MXEPOCH ) THEN

         print*,' ERROR: NRD = ', NRD

         LK = INDEX(KEY,' ') - 1
         c1err = 'Non-existent FITS parameter: ' // KEY(1:LK)
     &           // ' for CID='// SNLC_CCID(1:ISNLC_LENCCID)

         VERSION  = VERSION_PHOTOMETRY(ivers) 
         LV = INDEX(VERSION,' ') - 1
         c2err = 'Check fits files for version ' // VERSION(1:LV)

         CALL MADABORT("CHECK_FITSABORT",c1err, c2err)
      ENDIF

      RETURN
      END
C ==========================================
+DECK,GTINFOVER.
      SUBROUTINE GETINFO_PHOTOMETRY(ivers)

c Shell to use getInfo_PHOTOMETRY_VERION() function to 
c get path to data, full name of list file and
c full name of readme file. Also construct
c SNDATA_PREFIX

      IMPLICIT NONE

      INTEGER IVERS  ! (I) version index

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LEN_VERS, istat, L1, L2, L3
      CHARACTER*(2*MXCHAR_FILENAME)
     &   VERSION, PATH, LIST_FILE, README_FILE

      INTEGER   GETINFO_PHOTOMETRY_VERSION
      EXTERNAL  GETINFO_PHOTOMETRY_VERSION

C ----------------- BEGIN --------------


      VERSION  = VERSION_PHOTOMETRY(ivers) 
      LEN_VERS = INDEX(VERSION,' ') - 1
      VERSION  = VERSION(1:LEN_VERS)  // char(0)

      L1   =  INDEX(PRIVATE_DATA_PATH,' ') - 1
      PATH =  PRIVATE_DATA_PATH(1:L1) // char(0)    

      ISTAT = GETINFO_PHOTOMETRY_VERSION ( 
     &               VERSION,                        ! input
     &               PATH, LIST_FILE, README_FILE,   ! returned
     &               LEN_VERS, L1, L2, L3 )


      L1 = INDEX(PATH,char(0)) - 1
      IF ( L1 > MXCHAR_PATH ) then
         CALL PRINT_PREABORT_BANNER("GETINFO_PHOTOMETRY"//char(0),40)
         print*,' SNDATA_PATH = ', PATH(1:L1)
         write(c1err,61) 'SNDATA_PATH', L1, MXCHAR_PATH
         write(c2err,62)
         CALL MADABORT('GETINFO_PHOTOMETRY', C1err, C2err)
      ENDIF
      SNDATA_PATH = PATH(1:L1)           ! fill global

61    format('LEN(',A,')=',I3, 
     &      ' is too long (MXCHAR_PATH=',I3,')')
161   format('LEN(',A,')=',I3, 
     &      ' is too long (MXCHAR_FILENAME=',I3,')')
62    format('Check $SNDATA_ROOT');

      L2 = INDEX(LIST_FILE,char(0)) - 1
      IF ( L2 > MXCHAR_FILENAME ) then
         CALL PRINT_PREABORT_BANNER("GETINFO_PHOTOMETRY"//char(0),40)
         print*,' LIST_FILE = ', LIST_FILE(1:L2)

         write(c1err,161) 'LIST_FILE', L2, MXCHAR_FILENAME
         write(c2err,62)
         CALL MADABORT('GETINFO_PHOTOMETRY', C1err, C2err)
      ENDIF

      SNLIST_FILE = LIST_FILE(1:L2)      ! fill global

      L3 = INDEX(README_FILE,char(0)) - 1
      IF ( L3 > MXCHAR_FILENAME ) then
         CALL PRINT_PREABORT_BANNER("GETINFO_PHOTOMETRY"//char(0),40)
         print*,' README_FILE = ', README_FILE(1:L3)
         write(c1err,161) 'README_FILE', L3, MXCHAR_FILENAME
         write(c2err,62)
         CALL MADABORT('GETINFO_PHOTOMETRY', C1err, C2err)
      ENDIF
      SNREADME_FILE(IVERS) = README_FILE(1:L3)  ! fill global

c construct prefix = path/[version]
      SNDATA_PREFIX = SNDATA_PATH(1:L1) // 
     &       '/'  // VERSION(1:LEN_VERS) 

      RETURN
      END   ! end of GETINFO_PHOTOMETRY


C ======================================
+DECK,SNANAVERS.
      SUBROUTINE GETxx_SNANA_VERSIONS(VERSION_SNANA, VERSION_PHOTOM)
      IMPLICIT NONE
C ---------------------------------------------------------
C
C  !!! OBSOLETE !!!!
C
C Created Dec 2, 2012
C C-callable function to return snana version string and
C photometry version.
C Allows lower-level C functions (called by snana) to access version.
C ---------------------------------------------------------
      CHARACTER VERSION_SNANA*8            ! (O) snana version string
      CHARACTER VERSION_PHOTOM*200         ! (O) 
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LV
C --------------- BEGIN ------------
      LV = INDEX(SNANA_VERSION,' ') - 1
      VERSION_SNANA = SNANA_VERSION(1:LV) // char(0)

      LV = INDEX(VERSION_PHOTOMETRY(1),' ') - 1
      VERSION_PHOTOM = VERSION_PHOTOMETRY(1)(1:LV) // char(0)

      RETURN
      END

C ================================================
+DECK,RDVERTEXT.
      SUBROUTINE RDVERSION_TEXT ( IVERS, IERR )
c
c Read SN data for all SNe belonging to version "VERSION".
c Source is TEXT files.
c
c First read list of files from
c   $SNDATA_ROOT/lcmerge/VERSION.LIST   (data)
c      or
c   $SNDATA_ROOT/SIM/VERSION.LIST       (SIM)

c and then read each file and fill common block variables.
c
c
c      HISTORY
c
c Apr 21 2014: JOBSPLIT logic to be the same as for FITS format;
c              process every N'th file.
c
c Jul 1 2014: fix bug reading multiple ascii-format versions;
c             infile-loop, replace global N_SNFILE with local N_SNFILE_VER
c
c July 13 2017: check MXLC_FIT
c ------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER   
     &    IVERS        ! (I) version index
     &   ,IERR         ! (O) 0=> OK,  else error

c local args

      INTEGER 
     &   ifile, LEN_VERS, ifile_1st
     &  ,ISTAT, IJOB, NJOBTOT, N_SNFILE_VER

      CHARACTER*(MXCHAR_FILENAME) VERSION

c function
      LOGICAL LDONE_CIDLIST

C -------------- BEGIN -------------

      VERSION = VERSION_PHOTOMETRY(ivers)
      LEN_VERS = INDEX(VERSION,' ') - 1

      N_SNFILE_LAST = N_SNFILE
      ifile_1st = N_SNFILE_LAST+1  ! 1st file index in this version

c read list of SN data files for this version ;
c increments global N_SNFILE and sets SNDATA_PREFIX

      CALL RDSNLIST ( VERSION, IERR )     
        IF ( IERR .NE. 0 ) RETURN

c get number of files for this version (Jul 1 2014)
      N_SNFILE_VER = N_SNFILE - ifile_1st + 1

c read SURVEY_NAME and FILTERS from header in first file in list

      IF ( LFLAG_RDHEAD_ONLY .or. IVERS .GT. 1 ) THEN
        CALL RDSURVEY_TEXT(IERR)        
        CALL INIT_SURVEY(IERR)
      ENDIF

      IF ( LFLAG_RDHEAD_ONLY ) RETURN

c -----------------------
c loop over each SN file and parse it; fill SNLC_XXX arrays

      write(GLOBAL_BANNER,55) VERSION(1:LEN_VERS)
55    format('PARSE DATA files for VERSION ', A)
      CALL PRBANNER (GLOBAL_BANNER(1:72) )

c -----
c strip off info for SPLITTING jobs among multiple CPUs.
      NJOBTOT = JOBSPLIT(2) ! total number of split jobs
      IJOB    = JOBSPLIT(1) ! do IJOB of NJOBTOT
      IF ( NJOBTOT .GT. 1 ) THEN
        write(6,56) JOBSPLIT
 56     format(T5,'Process SPLIT-JOB ',I2,' of ', I2 )
      ENDIF
c ----

      DO 100 ifile = IJOB, N_SNFILE_VER, NJOBTOT        

         IF ( N_SNLC_FITCUTS > MXLC_FIT ) GOTO 100

c  open,read,parse this event
         CALL PARSE_SNDATA_TEXT ( ivers, ifile, ISTAT )   

         IF ( ISTAT .EQ. 0 ) THEN
           CALL SNANA_DRIVER(N_SNLC)
         ENDIF

c bail if all CIDs are processed
         IF ( LDONE_CIDLIST() ) GOTO 500  

100   CONTINUE

500   CONTINUE


      RETURN
      END     ! end of RDVERSION_TEXT

C ==============================================
+DECK,PARSE_SNDATA_TEXT.
      SUBROUTINE PARSE_SNDATA_TEXT ( ivers, ifile, ISTAT )
c
c parse this one SN file in TEXT/ASCII format
c (not for fits format).
c
c Load SNLC_XXX arrays if CID and REDSHIFT are valid.
c
c Jan 24 2018: initialize NWD_LOAD = NFILTDEF_SURVEY+1
c Apr 15 2019: call PARSE_SPECTRUM
c Jul 16 2019: fix dumb bug setting NVAR_SPECTRUM for data 
c Dec 05 2019: abort if 'OBS:' found but 'NOBS:' wasn't found.
c
c ------------------------------------------
 
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SPECCOM.

c declare subroutine args


      INTEGER 
     &    IVERS  ! (I) version index
     &   ,IFILE  ! (I) file index to read
     &   ,ISTAT  ! (O) 0=> OK, otherwise reject

c local var

      character 
     &   cwd(MXFILT_ALL)*60
     &  ,cwd_next*60
     &  ,CCID*(MXCHAR_CCID)
     &  ,LOCALFILE*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)
     &  ,FNAM*18

      LOGICAL 
     &   LNEWMJD_SAVE, LNEWMJD_NEW, LSIM_BADz
     &  ,END_MJD_VERBOSE, END_MJD_TERSE, END_PHOTOMETRY, ALLOW_SKIP
     &  ,ISKEY_SIM, ISKEY_VARLIST, ISKEY_EPOCH, ISKEY_OBS, ISKEY_MJD
     &  ,ISKEY_SPECBIN, ISKEY_SPECTRUM, ISKEY_SPEC, ZERO_REDSHIFT_OK

      INTEGER 
     &   iwd, iwd2, i, NWD, NEP, NEWMJD, NZ, isnlc, cid
     &  ,LL, LUN, INDX, IFILT, IFILT_OBS, LWD, NWD_LOAD
     &  ,EPMIN, EPMAX, EP

c function
      INTEGER IPLOT_JOBSPLIT
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

c ------------- BEGIN ------------

      FNAM = 'PARSE_SNDATA_TEXT'
      LUN = LUNDAT
10    CONTINUE

c break up file into list of words 
c   (NFILEWORD words in FILEWORD_LIST array)

      READ(LUNLIST,3) SNDATA_FILE_CURRENT
 3    FORMAT(A) 


c 4/21/2014: increment global IFILE index, and keep reading 
c until we get desired IFILE (for JOBSPLIT logic).
      ISNLC_IFILE = ISNLC_IFILE + 1
      if ( IFILE .NE. ISNLC_IFILE ) GOTO 10 

c ??? need to close LIST file when we get to the end. ???

      LL = INDEX ( SNDATA_PATH , ' ' ) - 1
      LOCALFILE = SNDATA_PATH(1:LL) // '/' // SNDATA_FILE_CURRENT
      LL = INDEX(LOCALFILE,' ') - 1
      NAME_forC = LOCALFILE(1:LL) // char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE, NAME_forC,LL)

      IF ( NWD .EQ. 0 ) THEN
          c1err = 'Zero-length file :'
          c2err = SNDATA_FILE_CURRENT(1:72)
          CALL MADABORT(FNAM, c1err, c2err)
      ENDIF

c allow SN to be skipped based on header info,
c unless the read-header-only flag is set
      ALLOW_SKIP = .NOT. LFLAG_RDHEAD_ONLY

c ---------------------------------------------------
c loop over words in the file and check for 
c  'KEYWORD VALUE'
c
c  ****** PARSELOOP *******


      NEWMJD = 0  ! init NEWMJDs
      Nep    = 0  ! init number of epochs
      NZ     = 0  ! init number of redshift measures

      isnlc  = N_SNLC + 1   ! prepare to fill next SN
      ISNLC_VERSION  = IVERS

      IF ( JOBSPLIT_EXTERNAL(2) > 1 ) THEN
        INDX = IPLOT_JOBSPLIT(IFILE)
      ELSE
        INDX = IFILE
      ENDIF
      ABSO_INDEX(isnlc) = IFILE
      ISNLC_ABSO_INDEX  = INDX

      CALL INIT_SNDATA()

      LNEWMJD_SAVE = .FALSE.
      LNEWMJD_NEW  = .FALSE.

      END_PHOTOMETRY = .FALSE.

c - - - - - - - - -
      DO 200 iwd = 1, NWD

        CALL get_PARSE_WORD_fortran(iwd, cwd(1), LWD )

        ISKEY_SIM     = cwd(1)(1:3) .EQ. 'SIM'
        ISKEY_VARLIST = cwd(1)(1:8) .EQ. 'VARLIST:'
        ISKEY_EPOCH   = cwd(1)(1:6) .EQ. 'EPOCH:' .and. FORMAT_VERBOSE
        ISKEY_OBS     = cwd(1)(1:4) .EQ. 'OBS:'   .and. FORMAT_TERSE 
        ISKEY_MJD     = ISKEY_EPOCH .or. ISKEY_OBS
        ISKEY_SPECTRUM  = cwd(1)(1:9) .EQ. 'SPECTRUM_' ! header stuff
        ISKEY_SPECBIN   = cwd(1)(1:5) .EQ. 'SPEC:'     ! wave bin
        ISKEY_SPEC      = ISKEY_SPECTRUM .or. ISKEY_SPECBIN

        NWD_LOAD = MAX(4,NFILTDEF_SURVEY+1)
        IF ( ISKEY_VARLIST  ) NWD_LOAD = NVAR_TERSE+1
        IF ( ISKEY_OBS      ) NWD_LOAD = NVAR_TERSE+1
        IF ( ISKEY_SPECTRUM ) NWD_LOAD = 2
        IF ( ISKEY_SPECBIN  ) THEN ; 
           NVAR_SPECTRUM  = 5                  ! for data
           if ( LSIM_SNANA ) NVAR_SPECTRUM = 7 ! for sim
           NWD_LOAD = NVAR_SPECTRUM
        ENDIF

        do i = 2, NWD_LOAD
          iwd2 = iwd + i - 1
          if ( iwd2 .LE. NWD ) then
            CALL get_PARSE_WORD_fortran(iwd2, cwd(i), LWD )
          endif          
        enddo
        do i = NWD_LOAD + 1, NWD_LOAD + 5
           cwd(i) = 'NULL'
        enddo

c  check that we are still reading the header        
        if ( ISNLC_NEWMJD_FOUND .EQ. 0 ) then

c read header params (CID, RA, DECL, etc ...)
            CALL PARSE_HEAD ( isnlc, cwd, istat )
            if ( istat .EQ. ISTAT_READAGAIN   ) goto 10
            if ( istat .LT. 0 .and. ALLOW_SKIP) return

            if ( FORMAT_TERSE ) then
               CALL PARSE_TERSE_VARLIST(cwd )
            endif

c read search parameters.
            CALL PARSE_SEARCH ( cwd, ISTAT )
            if ( istat .LT. 0 .and. ALLOW_SKIP ) return

c check that no new private variables are added
            CALL PARSE_PRIVATE_TEXT ( cwd(1) )

            if ( ISNLC_FAKE .EQ. 2 ) then
               CALL PARSE_SIM ( isnlc, cwd, istat )
               if ( istat .LT. 0 .and. ALLOW_SKIP ) return
            endif

         ENDIF  ! end of NEWMJD_FOUND=0 block

c ------------- parse NEWMJD & EPOCH info
    
c always check if we have an EPOCH: flag
c this is really a NEWMJD             

         if ( ISKEY_MJD ) then

             if ( ISNLC_NEWMJD_HEAD == 0 ) then
	       c1err = 'Found OBS: key, but no NOBS: key.'
	       c2err = 'Check NOBS: key for CID = ' // SNLC_CCID
               CALL MADABORT(FNAM,c1err, c2err)
	     endif

             if ( LFLAG_RDHEAD_ONLY ) RETURN

             if ( ISKEY_EPOCH ) then
               cwd_next = cwd(2)
               read(cwd_next,*) NEWMJD
               ISNLC_NEWMJD_FOUND  = NEWMJD
             else
               ISNLC_NEWMJD_FOUND = 
     &         ISNLC_NEWMJD_FOUND + 1
             endif

c reset counters for next possible stored NEWMJD
             NEWMJD = ISNLC_NEWMJD_STORE + 1

             ISNLC_NFILT_NEWMJD(NEWMJD) = 0
             ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD) = 0
             ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD) = 0

c make sure header info is valid before processing epochs
             if ( NEWMJD .EQ. 1 ) then
               CALL CHECK_HEADER()
             endif

             if ( LNEWMJD_NEW ) then
               write(c1err,60) ISNLC_NEWMJD_FOUND
60             format('Found NEWMJD=',I3,' before finishing last MJD')
               write(c2err,61) SNLC_CCID
61             format('Check END_OF_EPOCH: marker in ', A8)
               CALL MADABORT(FNAM,c1err, c2err)
             endif

             LNEWMJD_SAVE = .TRUE.
             LNEWMJD_NEW  = .TRUE.
         endif  ! end of OBS check


c if we found an epoch, then parse info.

         IF ( ISNLC_NEWMJD_FOUND .GT. 0) then
            CALL PARSE_PASSBAND ( cwd, istat )
            if ( istat .LT. 0 ) LNEWMJD_SAVE = .FALSE.

            CALL PARSE_EPOCH_TEXT ( cwd, istat )
            if ( istat .LT. 0 ) LNEWMJD_SAVE = .FALSE.
         ENDIF

c check for end of NEWMJD, and check if this NEWMJD should be saved.

         END_MJD_VERBOSE = FORMAT_VERBOSE .and.
     &    ( cwd(1) .EQ. 'END_OF_EPOCH:' .or.  
     &      cwd(1) .EQ. 'END_OF_MJD:' )
         END_MJD_TERSE = ISKEY_OBS

         IF ( END_MJD_VERBOSE .or. END_MJD_TERSE ) then
           LNEWMJD_NEW  = .FALSE.
           if ( LNEWMJD_SAVE ) then
              CALL ENDMJD_PROC(NEWMJD)
           endif
         ENDIF

c check for end of photometry and existence of SPECTRA
         if ( CWD(1) .EQ. 'END:' .or. 
     &        CWD(1) .EQ. 'END_PHOTOMETRY:' ) then
            END_PHOTOMETRY = .TRUE.
         endif

         IF ( END_PHOTOMETRY .and. ISKEY_SPEC ) THEN
            CALL PARSE_SPECTRUM ( cwd, istat )
         ENDIF

 200  CONTINUE  ! NWD loop


C ====================================================
 201  CONTINUE

c if we get here, then increment official SNLC counter

      N_SNLC = isnlc

      if ( N_SNLC > MXSNLC-1 ) THEN
        write(c1err,666) N_SNLC
666     format('N_SNLC=',I5,' exceeds MXSNLC array bound.')
        c2err = 'Try splitting job into multiple jobs with CID-ranges'
        CALL MADABORT(FNAM, c1err, c2err)
      endif

      CALL PRINT_RDSN()

      cid    = SNLC_CID
      ccid   = SNLC_CCID
      NEWMJD = ISNLC_NEWMJD_HEAD
      if ( ISNLC_NEWMJD_FOUND .NE. NEWMJD ) then
         write(c1err,65) ccid, NEWMJD, ISNLC_NEWMJD_FOUND
65       format('CID ',A, ' : Expected ',I3,' NEWMJDs, ',
     &          ' but found ',I3 )
         c2err = 'See EPOCH: in SNDATA file. ' 
         CALL MADABORT(FNAM, c1err, c2err)
      endif

c -------
c count epochs per filter and fill ISNLC_NEPOCH_FILT(ifilt) array

      DO 400 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD) 
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD) 

        DO EP = EPMIN, EPMAX
           IFILT_OBS = ISNLC_IFILT_OBS(ep)
           IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
           ISNLC_NEPOCH_FILT(ifilt) = 
     &     ISNLC_NEPOCH_FILT(ifilt) + 1
        ENDDO

400   CONTINUE


c add sanity check on simulated redshift (Jan 31, 2014
          
      ZERO_REDSHIFT_OK = 
     &   (SIM_MODEL_INDEX .EQ. MODEL_LCLIB) .or.
     &   (SIM_MODEL_INDEX .EQ. MODEL_FIXMAG )
      IF ( LSIM_SNANA .and. .NOT. ZERO_REDSHIFT_OK ) THEN
         LSIM_BADz = ( SIM_REDSHIFT_HELIO .LE. 0.0 ) 
         IF ( LSIM_BADz ) then 
           write(c1err,641) SIM_REDSHIFT_HELIO
641        format('Invalid SIM_REDSHIFT_HELIO=', F9.5)
           c2err = 'Check simulation'
           CALL  MADABORT(FNAM, c1err, c2err)
         ENDIF
      ENDIF


C ########################
         RETURN
C ########################

ccc      CALL EXIT(EXIT_ERRCODE)

      END  ! end of PARSE_SNDATA_TEXT

C ==================================
+DECK,PRINT_RDSN.
      SUBROUTINE PRINT_RDSN()

C print one-line summary of SN that has been read/parsed.
C Nov 7, 2012: of SNID is a char, print integer CID assignment here.
C Apr 26, 2017: set STDOUT_UDPATE logical to suppress std output
C               for BIG jobs.
C
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      REAL*8  PS_UPDATE
      LOGICAL REJECT_PRESCALE  ! function
C ------------- BEGIN -----------

c determine STDOUT_UPDATE logical to dump info

      IF ( N_SNLC < 2000 ) THEN
         PS_UPDATE = 1.0
      ELSE
         PS_UPDATE = 100.
      ENDIF
      STDOUT_UPDATE = (.NOT. REJECT_PRESCALE(N_SNLC,PS_UPDATE) )

      if ( .NOT. STDOUT_UPDATE ) RETURN

      print*,' *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-' //
     &       '*-*-*-*-*-*-*-*-*-*-*-*-*-*-'

      IF ( SNLC_CASTCID .EQ. 'CHAR' ) then
          write(6,30) SNLC_CID, SNLC_CCID(1:ISNLC_LENCCID)
30        format(T4,'Assign integer CID=',I6,' for ', A)
      endif

      write(6,200)
     &      SNLC_CCID
     &    , ISNLC_NEWMJD_FOUND
     &    , ISNLC_NEWMJD_STORE

200   format(T5,' Done Reading CID ', A16, 
     &       2x, 'NMJD(found,stored)=', I4,1x,I4 )

      CALL FLUSH(6)
      RETURN
      END

C ==============================================
+DECK,PARSE_HEAD.
      SUBROUTINE PARSE_HEAD ( isnlc, cwords, istat )
c
c parse header parameters.
c cword(1) is the keyword; cword(2) is the value.
c
c Returns istat = -1 if CID or REDSHIFT fails user cut.
c
c
c Mar 26, 2014: 
c   - fix dumb bug applying MWEVB_SCALE to SNLC_MWEBV_ERR ..in both places.
c
c Aug 7, 2014: read optional NXPIX, NYPIX
c
c Dec 2 2015: a little refactor to read both SNID and IAUC before
c             calling PARSE_CID ... allows selecting SNID or IAUC.
c             Also check WRTABLEFILE_IAUC flag.
c
c Jan 26 2017: call PARSE_SURVEY_NAME()
c Sep 24 2017: fix bug reading SUBSURVEY
c
c Jan 24 2018:
c   + For text format, allow XXX +- XXX_ERR or  
c     separate  XXX and XXX_ERR keys for
c        MWEBV[_ERR]
c        HOSTGAL_LOGMASS[_ERR]
c        HOSTGAL_PHOTOZ[_ERR]
c        HOSTGAL_SPECZ[_ERR]
c
c Feb 8 2019: call PARSE_HOSTGAL(igal) to parse multiple host-matches.
c --------------------------------------------------

      IMPLICIT NONE

c subroutine args.

      INTEGER   isnlc           ! (I) SN sparese index to load
      CHARACTER cwords(*)*60    ! (I) words to parse
      INTEGER   ISTAT           ! (O) 0=OK;   <0 => skip this ISNLC

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PRIVCOM.
    
c local var
      character 
     &   cwd*60, cwd_next*60, ccid*(MXCHAR_CCID)
     &  ,cfiltlist*60, KEY*80, RETSTR*80, FNAM*12
     &  ,SURVEY_NAME_LAST*(MXCHAR_SURVEY)

      REAL*8  RET8(MXFILT_OBS)

      integer 
     &   CID, IFAKE, NEWMJD, ivar, igal
     &  ,LL, L1, L2, ifilt, ifile, ITYPE

      LOGICAL USECID, LBAD, LTMP, LCHK
      LOGICAL L_SNID, L_IAUC, L_FILT, L_SEL

c functions
      INTEGER  SNTYPESTAT, CCDNUMSTAT, GET_IDSURVEY
      LOGICAL  READ_HEADKEY
cc      REAL     MWEBV_FUDGE

C ----------- BEGIN ---------

      istat    = 0
      FNAM     = 'PARSE_HEAD'
c --------------------

c start with optional SUBSURVEY string (FITS only)
      IF ( FORMAT_FITS ) THEN
        RETSTR = 'STRING'
        KEY    = 'SUBSURVEY'
        LTMP   = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
        IF ( LTMP .and. RETSTR(1:1) .NE. ' ' ) THEN
           SUBSURVEY_NAME = RETSTR(1:MXCHAR_SURVEY)
           IDSUBSURVEY    = GET_IDSURVEY(SUBSURVEY_NAME)           
        ENDIF
      ENDIF

c - - - - - 

      RETSTR = 'STRING'
      KEY    = 'SNID'
      LTMP   = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         HEADMASK = IBSET(HEADMASK, HEADBIT_SNID)
         LL   = INDEX(RETSTR,' ') - 1
         if ( LL .GT. MXCHAR_CCID ) then
           write(c1err,61) RETSTR(1:LL), LL
           write(c2err,62) MXCHAR_CCID
           CALL MADABORT(FNAM, c1err, c2err)
         endif
         SNLC_CCID = RETSTR(1:LL) 
         ISNLC_LENCCID  = LL
         call checkString_CCID(SNLC_CCID)  ! abort if illegal char in name
      ENDIF

      RETSTR = 'STRING'
      KEY    = 'IAUC'
      LTMP   = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         HEADMASK = IBSET(HEADMASK, HEADBIT_IAUC)
         LL   = INDEX(RETSTR,' ') - 1
         if ( LL .GT. MXCHAR_CCID ) then
           write(c1err,61) RETSTR(1:LL), LL
           write(c2err,62) MXCHAR_CCID
           CALL MADABORT(FNAM, c1err, c2err)
         endif
         SNLC_IAUC = RETSTR(1:LL) 
         ISNLC_LENIAUC = LL
         IF ( WRTABLEFILE_IAUC .and. LL > 0 ) THEN
            SNLC_CCID      = SNLC_IAUC
            ISNLC_LENCCID  = LL
            call checkString_CCID(SNLC_CCID)  ! abort if illegal char in name
         ENDIF
      ENDIF


61    format('stringLen(',A,') = ', I3 )
62    format('exceeds allocation of MXCHAR_CCID = ', I3)


c now the tricky part. Check CID after either optional IAUC is read
c or after required FILTERS is read. Since FILTERS is required,
c if we read the FITLERS key before IAUC, then the optional IAUC
c is not there.  

      L_SNID = BTEST(HEADMASK, HEADBIT_SNID)
      L_IAUC = BTEST(HEADMASK, HEADBIT_IAUC)
      L_FILT = BTEST(HEADMASK, HEADBIT_FILTERS)
      L_SEL  = BTEST(HEADMASK, HEADBIT_CIDSEL) ! ran PARSE_CID to select

      IF ( L_SNID.and.( L_IAUC.or.L_FILT).and.(.not.L_SEL) ) THEN

        HEADMASK = IBSET(HEADMASK, HEADBIT_CIDSEL)

c check if this CID is accepted, and convert to INTGER CID
        CALL PARSE_CID( SNLC_CCID, SNLC_IAUC,  ! inputs
     &                  CID, USECID)           ! returns args

c load integer globals
        SNLC_CID  = CID

c after loading globals, return if this CID is not used
        if ( .NOT. USECID ) THEN
           ISTAT = ISTAT_SKIP
           RETURN
        endif

        if ( FORMAT_TEXT )  RETURN
      ENDIF

      RETSTR = ''


c -------------------------------------------------------
c read redshift info here to apply CUT ASAP
      CALL PARSE_REDSHIFT ( isnlc, CWORDS(1), istat )
      if ( istat .LT. 0 )  RETURN
      
c -----------------------------------------------------


      KEY  = 'FAKE'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         IFAKE  = INT( RET8(1) )
         if ( IFAKE .EQ. 1 ) LSIM_MAGOBS = .TRUE. ! 8.06.2014
         if ( IFAKE .EQ. 2 ) LSIM_SNANA  = .TRUE.
         ISNLC_FAKE = IFAKE
      ENDIF

      KEY  = 'CCDNUM'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
          ISNLC_CCDNUM(1)  = INT( RET8(1) )
          istat = CCDNUMSTAT(ISNLC_CCDNUM(1))
          if ( istat .LT. 0 ) return
      ENDIF

      KEY  = 'MASK_FLUXCOR_SNANA'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
          ISNLC_RDMASK_FLUXCOR_SNANA = INT( RET8(1) )
      ENDIF

      KEY  = 'RA'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         SNLC8_RA = RET8(1)
         HEADMASK = IBSET(HEADMASK, HEADBIT_RA)
      ENDIF

c Feb 19 2019: read DEC or DECL
      KEY  = 'DEC'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SNLC8_DEC = RET8(1)
        HEADMASK = IBSET(HEADMASK, HEADBIT_DEC)
      ENDIF
      KEY  = 'DECL'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SNLC8_DEC = RET8(1)
        HEADMASK = IBSET(HEADMASK, HEADBIT_DEC)
      ENDIF


      KEY  = 'PIXSIZE'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SNLC_PIXSIZE = SNGL( RET8(1) )

      KEY  = 'NXPIX'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SNLC_NXPIX = SNGL( RET8(1) )

      KEY  = 'NYPIX'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SNLC_NYPIX = SNGL( RET8(1) )

c -----------------------------
c read/cut on SNTYPE (May 16, 2012)

      KEY  = 'SNTYPE'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         ITYPE = INT ( RET8(1) )
         ISNLC_TYPE = ITYPE

c cut on SNTYPE if it exists 
        LCHK = (ITYPE .GE. 0 )
        IF ( LCHK ) THEN
          istat = SNTYPESTAT(ITYPE)
          if ( istat .LT. 0 ) return
        ENDIF
      ENDIF
c -----------------------------

      KEY  = 'NOBS'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         NEWMJD = INT ( RET8(1) )

C abort if there are too many obs.
        if ( NEWMJD .GT. MXEPOCH ) then
           write(c1err,671) NEWMJD, MXEPOCH
671        format('NOBS=',I4, '  exceeds bound of MXEPOCH=',I4)
           c2err = 'Check SNID= ' // SNLC_CCID
           CALL MADABORT(FNAM, c1err, c2err)
        endif

         ISNLC_NEWMJD_HEAD = NEWMJD  ! store expected number of NEWMJD
         if ( FORMAT_TEXT ) then
           FORMAT_TERSE  = .TRUE.
           RETURN
         endif

c return if there are no observations         
         if ( NEWMJD .LE. 0 ) then
            ISTAT = ISTAT_SKIP
            RETURN
         endif

      ENDIF

      KEY  = 'NEPOCH'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         NEWMJD = INT ( RET8(1) )
         ISNLC_NEWMJD_HEAD = NEWMJD  ! store expected number of NEWMJD
         if ( FORMAT_TEXT ) then
           FORMAT_VERBOSE  = .TRUE.
           RETURN
         endif
      ENDIF

      KEY    = 'NEPOCH_PRESN' 
      RETSTR = 'FILTER'  ! flag to read NFILTDEF_READ filters
      LTMP   = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      RETSTR = ' '
      IF ( LTMP ) THEN
        DO ifilt = 1, NFILTDEF_READ
           ISNLC_NEPOCH_PRESN(ifilt) = INT ( RET8(ifilt) )
        ENDDO
      ENDIF

c - - - - - - - - - - - - - - - 

c Jan 24 2018: check optional TEXT format with MWEBV +- MWEBV_ERR

      RETSTR = '+ERR'
      KEY    = 'MWEBV'
      LTMP   = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )

      IF ( LTMP ) THEN
         HEADMASK = IBSET ( HEADMASK, HEADBIT_MWEBV )

         if ( RET8(1) .NE. IGNORE_HEADVAL) then
           SNLC_MWEBV     = SNGL ( RET8(1) )
           SNLC_MWEBV_ERR = SNLC_MWEBV * XTMW_FRACERR  ! default error
         endif
         if ( RET8(2) .NE. IGNORE_HEADVAL) then
           SNLC_MWEBV_ERR = SNGL ( RET8(2) )
         endif
      ENDIF

c ------------- HOST INFO ----------------------

      DO igal = 1, MXSNHOST
         call PARSE_HOSTGAL(igal, isnlc, cwords )
      ENDDO

c -----------------------------
c check the newer PEAKMJD key, as well as the older key

      KEY  = 'PEAKMJD'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SNLC_SEARCH_PEAKMJD = SNGL(RET8(1))

      KEY  = 'SEARCH_PEAKMJD'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SNLC_SEARCH_PEAKMJD = SNGL(RET8(1))


c read optional FLUXCAL_OFF to correct for SN light in template

      KEY  = 'FLUXCAL_OFF'
      RETSTR = 'FILTER'  ! flag to read NFILTDEF_READ filters
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      RETSTR = ' '
      IF ( LTMP ) THEN
        DO ifilt = 1, NFILTDEF_READ
           SNLC_FLUXCAL_OFF(ifilt) = SNGL ( RET8(ifilt) )
        ENDDO
      ENDIF

c read PRIVATE parameters 

      DO 400 IVAR = 1, NVAR_PRIVATE
         KEY  = PRIVATE_KEYWORD(IVAR)
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
         IF ( LTMP ) THEN
           PRIVATE_VALUE(IVAR) = RET8(1)
         ENDIF
400   CONTINUE  ! end IVAR

c ###########################################

      IF ( FORMAT_FITS ) THEN
c set these header-mask bits for each SN.
         HEADMASK = IBSET(HEADMASK, HEADBIT_SURVEY)
         HEADMASK = IBSET(HEADMASK, HEADBIT_FILTERS)
         RETURN
      ENDIF

c ###########################################


c ---------------------------------------
c For TEXT format, read SURVEY and FILTERS keys to check
c for internal consistency 
c (to avoid mixing files from different surveys)
c 
      cwd      = cwords(1)
      cwd_next = cwords(2)
      cid      = SNLC_CID
      ccid     = SNLC_CCID

      if ( cwd .EQ. 'SURVEY:' ) then
         HEADMASK = IBSET(HEADMASK, HEADBIT_SURVEY )
         SURVEY_NAME_LAST = SURVEY_NAME

c Jan 26 2017: always read SURVEY key in case sub-survey changes 
         CALL PARSE_SURVEY_NAME( cwd_next,
     &            SURVEY_NAME, SUBSURVEY_NAME, IDSUBSURVEY ) 

         L1   = INDEX(SURVEY_NAME,      ' ' ) - 1 
         L2   = INDEX(SURVEY_NAME_LAST, ' ') - 1
         FOUND_SURVEY = .TRUE.
         IFILE = ABSO_INDEX(isnlc)

         LBAD = (L1 .NE. L2) .or. 
     &          (SURVEY_NAME_LAST(1:L1) .NE. SURVEY_NAME(1:L1))

         if ( LBAD .and. ABORT_ON_BADSURVEY ) THEN
            c1err = 'Found SURVEY=' // SURVEY_NAME(1:L1)
            c2err = 'but expected SURVEY=' // SURVEY_NAME_LAST(1:L2) 
     &         // ' for ' // SNDATA_FILE_CURRENT(1:40)
            CALL MADABORT(FNAM, c1err, c2err)
         endif 

      endif


c check that filters are the SURVEY_FILTERS

      IF ( cwd .EQ. 'FILTERS:' ) THEN
          HEADMASK = IBSET(HEADMASK, HEADBIT_FILTERS )
          read(cwd_next,*) cfiltlist
          CALL CHECK_FILTERS_KEY(cfiltlist)      
      ENDIF  ! end of FILTERS block


      RETURN
      END   ! end of PARSE_HEAD

C ============================
+DECK,PARSE_HOSTGAL.
      SUBROUTINE PARSE_HOSTGAL(IGAL, ISNLC, CWORDS)

      IMPLICIT NONE

      INTEGER IGAL              ! index of HOST-match to parse
      INTEGER ISNLC             ! running SN index 
      CHARACTER cwords(*)*60    ! (I) words to parse

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
c+CDE,PRIVCOM.

      CHARACTER KEY*80, RETSTR*80, PREFIX*20
      INTEGER   LENPRE, ifilt
      INTEGER*8 I8TMP
      LOGICAL LTMP
      REAL*8  RET8(MXFILT_OBS)

c functions
      LOGICAL  READ_HEADKEY
C --------------- BEGIN ------------

      CALL SET_HOSTGAL_PREFIX(IGAL,PREFIX,LENPRE)

C Start with items that only appear once;
c i.e., do not depend on host-match.

      IF ( IGAL == 1 ) THEN
         KEY    = 'HOSTGAL_NMATCH' ; RETSTR = ''
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
         IF ( LTMP ) THEN
            SNHOST_NMATCH = DINT(RET8(1))
         ENDIF  

         KEY    = 'HOSTGAL_NMATCH2' ; RETSTR = ''
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
         IF ( LTMP ) THEN
            SNHOST_NMATCH2 = DINT(RET8(1))
         ENDIF  

         KEY  = 'HOSTGAL_CONFUSION' ; RETSTR = ''
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
         IF ( LTMP ) THEN
            SNHOST_CONFUSION = SNGL(RET8(1))
            EXIST_SNHOST_CONFUSION = .TRUE.
         ENDIF

         KEY  = 'HOSTGAL_SB_FLUXCAL'
         RETSTR = 'FILTER'      ! flag to read NFILTDEF_READ filters
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
         RETSTR = ' '
         IF ( LTMP ) THEN
            EXIST_SNHOST_SB = .TRUE.
            DO ifilt = 1, NFILTDEF_READ
               SNHOST_SBFLUXCAL(ifilt) = SNGL ( RET8(ifilt) )
            ENDDO
         ENDIF
      ENDIF  ! end IGAL=1

c - - - - - - - - 

      KEY    = PREFIX(1:LENPRE)//'_OBJID'
      RETSTR = ''
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         I8TMP = DINT(RET8(1))
         SNHOST_OBJID(igal) = I8TMP

c xxxxxxxxxxxxxxxxx
        IF ( OPT_DEBUG == 888 ) THEN
c            SNHOST_OBJID(igal) = I8TMP*1000000000 + I8TMP
            SNHOST_OBJID(igal) = I8TMP*I8TMP*I8TMP*I8TMP
        ENDIF
c xxxxxxxxxxxxxxxx

         DSNHOST_OBJID(igal) = DBLE( SNHOST_OBJID(igal) )
      ENDIF  

      KEY    = PREFIX(1:LENPRE)//'_PHOTOZ'
      RETSTR = '+ERR'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      RETSTR = ''
      IF ( LTMP ) THEN
          EXIST_SNHOST_ZPHOT = .TRUE.
          if ( RET8(1) .NE. IGNORE_HEADVAL ) then
             SNHOST_ZPHOT(igal)    = SNGL(RET8(1)) 
          endif
          if ( RET8(2) .NE. IGNORE_HEADVAL ) then
             SNHOST_ZPHOT_ERR(igal) = SNGL(RET8(2))
          endif
      ENDIF

      KEY    = PREFIX(1:LENPRE)//'_SPECZ' 
      RETSTR = '+ERR'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      RETSTR = ''
      IF ( LTMP ) THEN
          if ( RET8(1) .NE. IGNORE_HEADVAL ) then
            SNHOST_ZSPEC(igal)     = SNGL(RET8(1))
          endif
          if ( RET8(2) .NE. IGNORE_HEADVAL ) then
            SNHOST_ZSPEC_ERR(igal) = SNGL(RET8(2))
          endif
      ENDIF

      KEY  = PREFIX(1:LENPRE)//'_RA'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN ;  SNHOST8_RA(igal) = RET8(1) ;  ENDIF

      KEY  = PREFIX(1:LENPRE)//'_DEC'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN ;  SNHOST8_DEC(igal) = RET8(1) ;  ENDIF

      KEY  = PREFIX(1:LENPRE)//'_SNSEP'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SNHOST_ANGSEP(igal) = SNGL(RET8(1))
        EXIST_SNHOST_ANGSEP = .TRUE.
      ENDIF

      KEY  = PREFIX(1:LENPRE)//'_DDLR'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SNHOST_DDLR(igal) = SNGL(RET8(1))
        EXIST_SNHOST_DDLR = .TRUE.
      ENDIF

c - - - - - - - - - - - -  -

      KEY    = PREFIX(1:LENPRE)//'_LOGMASS' ;    
      RETSTR = '+ERR'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
          if ( RET8(1) .NE. IGNORE_HEADVAL ) then
            SNHOST_LOGMASS(igal)     = SNGL(RET8(1))
          endif
          if ( RET8(2) .NE. IGNORE_HEADVAL ) then
             SNHOST_LOGMASS_ERR(igal) = SNGL(RET8(2))
          endif
          EXIST_SNHOST_LOGMASS = .TRUE.
      ENDIF

      KEY    = PREFIX(1:LENPRE)//'_sSFR' ;    
      RETSTR = '+ERR'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
          if ( RET8(1) .NE. IGNORE_HEADVAL ) then
            SNHOST_sSFR(igal)     = SNGL(RET8(1))
          endif
          if ( RET8(2) .NE. IGNORE_HEADVAL ) then
             SNHOST_sSFR_ERR(igal) = SNGL(RET8(2))
          endif
          EXIST_SNHOST_sSFR = .TRUE.
      ENDIF

c - - - 

      KEY    = PREFIX(1:LENPRE)//'_MAG'
      RETSTR = 'FILTER'  ! flag to read NFILTDEF_READ filters
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      RETSTR = ' '
      IF ( LTMP ) THEN
        EXIST_SNHOST_MAGOBS = .TRUE.
        DO ifilt = 1, NFILTDEF_READ
           SNHOST_MAGOBS(ifilt,igal) = SNGL ( RET8(ifilt) )
        ENDDO
      ENDIF

      
      RETURN
      END

C =================================
+DECK,SET_HOSTGAL_PREFIX.
      SUBROUTINE SET_HOSTGAL_PREFIX(IGAL,PREFIX,LENPRE)

c Feb 2019
c For inoput IGAL, return PREFIX = 'HOSTGAL' or 'HOSTGAL2', etc ..,
c along with LENPRE = length of PREFIX string.
c The output is used for parsing and writing output.
      IMPLICIT NONE
      INTEGER IGAL         ! (I) 1,2 ... host-match index
      CHARACTER PREFIX*20  ! (O) key prefix
      INTEGER LENPRE       ! (O) length of prefix string

      IF ( IGAL == 1 ) THEN
         PREFIX = 'HOSTGAL'; LENPRE=7
      ELSE
         write(PREFIX,20) IGAL
 20      format('HOSTGAL',I1.1)
         LENPRE = 8
      ENDIF
      RETURN
      END

C =================================
+DECK,CHECKSTRING_CCID.
      SUBROUTINE CHECKSTRING_CCID(CCID)

c  Jun 2016: abort if illegal char in SNLC_CCID

      IMPLICIT NONE
      CHARACTER CCID*(*)
       
c local
      INTEGER NBADCHAR, ichar
      PARAMETER  (NBADCHAR = 14)
      CHARACTER  BADCHAR_LIST*(NBADCHAR)
      CHARACTER  c1err*44, c2err*44, c1*2
C ----------- BEGIN ---------------

      BADCHAR_LIST = ':;!@#$%^&*()=?'

      DO 100 ichar = 1, NBADCHAR
         C1 = BADCHAR_LIST(ichar:ichar)
         IF ( INDEX(CCID,C1) > 0 ) THEN
            c1err = 'Invalid CCID name = ' // CCID
            c2err = 'because it contains invalid char = ' // c1
            CALL MADABORT('CHECKSTRING_CCID', c1err, c2err)
         ENDIF
100   CONTINUE

      RETURN
      END

C ==============================
+DECK,CHKFLTKEY.
      SUBROUTINE CHECK_FILTERS_KEY(FILTERS)

C Apr 2013  [code moved from PARSE_HEAD]
C Called from PARSE_HEAD for text files to check that
C FILTERS argument is always the same. Abort if the
C FILTERS argument ever changes.
C
C -------------

      IMPLICIT NONE

      CHARACTER FILTERS*(*)  ! (I) argument of "FILTERS:" key

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER   NFILT, IFILT, itmp, IFILT_OBS
      CHARACTER cfilt1*2

c functions
      INTEGER FILTINDX

C ---------------- BEGIN ----------------

      NFILT     = INDEX ( FILTERS//' ', ' ' ) - 1

      DO itmp       = 1, NFILT
         cfilt1     = FILTERS(itmp:itmp)
         ifilt_obs  = FILTINDX(cfilt1)
         IFILT      = IFILTDEF_INVMAP_SURVEY(ifilt_obs)              
         
c check if sparse index is valid.
c Apr 2013: better error messaging.

         if ( ifilt .LE. 0 ) then                      
            CALL PRINT_PREABORT_BANNER("PARSE_HEAD"//char(0),40)
            print*,' FILTERS  defined in 1st data file:'
            print*,'      ', SURVEY_FILTERS(1:NFILTDEF_SURVEY)
            print*,' FILTERS  defined for ' 
     &           // SNLC_CCID(1:ISNLC_LENCCID), ' : '
            print*,'      ', FILTERS(1:NFILT)
            print*,'  --> FILTERS argument must be the same ',
     &                'in each data file. '
            
            c1err = 'Filter ' // cfilt1 // ' is unrecognized '
     &           // ' for CID=' // SNLC_CCID(1:ISNLC_LENCCID) // ' ; '
            
            c2err = 'see PRE-ABORT comments above.'
            CALL MADABORT("PARSE_HEAD", c1err, c2err)
         endif
         
      ENDDO                     ! end of ITMP loop

      RETURN
      END

C =======================================
+DECK,RDFITSHEAD_SIMSED.
      SUBROUTINE RDFITSHEAD_SIMSED

c Dec 2011
c Read/parse SIMSED keys from header if NPAR_SIMSED exists.
c
c Feb 2014: renamed from RDSIMSED_FITS
c Dec 2018: read SIMSED params based on CODE_IVERSION;
c           read 0 to NPAR-1; if legacy read 1 to NPAR.
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FITSCOM. 
      INTEGER   ISTAT, LRET, ipar, ipar_read, LENKEY
      CHARACTER KEYNAME*80, KEYVAL*80, c2*2, PARNAME*60

c C functions
      INTEGER   RD_SNFITSIO_GLOBAL
      EXTERNAL  RD_SNFITSIO_GLOBAL

C -------------- BEGIN ---------------

      KEYNAME   = "SIMSED_NPAR" // char(0)
      LENKEY    = INDEX(KEYNAME, char(0) ) - 1
      ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, LENKEY, LRET )      
      LRET      = INDEX(KEYVAL,char(0)) -1
      READ( KEYVAL(1:LRET), * ) NPAR_SIMSED
      IF ( NPAR_SIMSED .LE. 0 ) RETURN

c ----------------------------------------------
c SIMSED before Dec 2018 had SIMSED_PAR01  to SIMSED_PAR[NN].
c After refactor, it is SIMSED_PAR00 to N-1.
c For back compatibility, check for SIMSED_PAR00/

      DO 100 ipar = 1, NPAR_SIMSED
        ipar_read = ipar-1   ! default C-like index
        if ( CODE_IVERSION < 8 ) ipar_read = ipar  ! legacy 1-N indices
        write(c2,22) ipar_read
22      format(I2.2)
        KEYNAME = "SIMSED_PAR" // C2 // char(0)
        ISTAT   = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 20, LRET )
        LRET    = INDEX(KEYVAL,char(0)) -1
       
c xxxxxxxxxxxxx
c        print*,' xxx --------------------------------- '
c        print*,' xxx ipar,ipar_read, c2 = ', ipar,ipar_read, c2
c        print*,' xxx KEYNAME=', KEYNAME(1:40)
c        print*,' xxx KEVAL  =', KEYVAL(1:40),  LRET
c        print*,' xxx ISTAT  =', ISTAT
c        call flush(6) ! xxxxx
c xxxxxxxxxxxxx

        CALL PARSE_PARENTHESES(KEYVAL(1:LRET), PARNAME)
        SIMSED_KEYWORD(IPAR) = KEYVAL(1:LRET) ! key(varname)
        SIMSED_PARNAME(IPAR) = PARNAME(1:20)  ! extracted varname

100   CONTINUE

      CALL FLUSH(6)

      RETURN
      END  ! end of RDFITSHEAD_SIMSED

C =======================================
+DECK,RDFHEAD_BYOSED.
      SUBROUTINE RDFITSHEAD_BYOSED()

c Created Dec 10 2018
c Read/parse BYOSED keys from header if NPAR_BYOSED exists.
c

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   ISTAT, LRET, ipar, LENKEY
      CHARACTER KEYNAME*80, KEYVAL*80, c2*2, PARNAME*60

c C functions
      INTEGER   RD_SNFITSIO_GLOBAL
      EXTERNAL  RD_SNFITSIO_GLOBAL

C -------------- BEGIN ---------------

      KEYNAME   = "BYOSED_NPAR" // char(0)
      LENKEY    = INDEX(KEYNAME, char(0) ) - 1
      ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, LENKEY, LRET )
      LRET      = INDEX(KEYVAL,char(0)) - 1
      READ( KEYVAL(1:LRET), * ) NPAR_BYOSED
      IF ( NPAR_BYOSED .LE. 0 ) RETURN

c ----------------------------------------------

      DO 100 ipar = 1, NPAR_BYOSED
        write(c2,22) ipar-1
22      format(I2.2)
        KEYNAME = "BYOSED_PAR" // C2 // char(0)
        ISTAT   = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 12, LRET )
        LRET    = INDEX(KEYVAL,char(0)) -1

        CALL PARSE_PARENTHESES(KEYVAL(1:LRET), PARNAME)
        BYOSED_KEYWORD(IPAR) = KEYVAL(1:LRET) ! key(varname)
        BYOSED_PARNAME(IPAR) = PARNAME(1:20)  ! extracted varname

100   CONTINUE

      CALL FLUSH(6)

      RETURN
      END  ! end of RDFITSHEAD_BYOSED


C =======================================
+DECK,RDFHEAD_LCLIB.
      SUBROUTINE RDFITSHEAD_LCLIB

c Feb 2018
c Read/parse LCLIB keys from header if NPAR_LCLIB exists.
c

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   ISTAT, LRET, ipar, LENKEY
      CHARACTER KEYNAME*80, KEYVAL*80, c2*2, PARNAME*60

c C functions
      INTEGER   RD_SNFITSIO_GLOBAL
      EXTERNAL  RD_SNFITSIO_GLOBAL

C -------------- BEGIN ---------------

      KEYNAME   = "LCLIB_NPAR" // char(0)
      LENKEY    = INDEX(KEYNAME, char(0) ) - 1
      ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, LENKEY, LRET )
      LRET      = INDEX(KEYVAL,char(0)) -1
      READ( KEYVAL(1:LRET), * ) NPAR_LCLIB
      IF ( NPAR_LCLIB .LE. 0 ) RETURN

c ----------------------------------------------

      DO 100 ipar = 1, NPAR_LCLIB
        write(c2,22) ipar-1
22      format(I2.2)
        KEYNAME = "LCLIB_PAR" // C2 // char(0)
        ISTAT   = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 11, LRET )
        LRET    = INDEX(KEYVAL,char(0)) -1

        CALL PARSE_PARENTHESES(KEYVAL(1:LRET), PARNAME)
        LCLIB_KEYWORD(IPAR) = KEYVAL(1:LRET) ! key(varname)
        LCLIB_PARNAME(IPAR) = PARNAME(1:20)  ! extracted varname

100   CONTINUE

      CALL FLUSH(6)

      RETURN
      END  ! end of RDFITSHEAD_LCLIB


C =======================================
+DECK,RDFHEAD_SIM_HOSTLIB.
      SUBROUTINE RDFITSHEAD_SIM_HOSTLIB

c Feb 2014
c Read/parse SIM_HOSTLIB keys from header if NPAR_SIM_HOSTLIB exists.
c
c Mar 26 2019: ipar -> ipar-1 for each hostlib params


      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   ISTAT, LRET, ipar, LENKEY
      CHARACTER KEYNAME*80, KEYVAL*80, c2*2, PARNAME*60

c C functions
      INTEGER   RD_SNFITSIO_GLOBAL
      EXTERNAL  RD_SNFITSIO_GLOBAL

C -------------- BEGIN ---------------

      KEYNAME   = "SIM_HOSTLIB_NPAR" // char(0)
      LENKEY    = INDEX(KEYNAME, char(0) ) - 1
      ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, LENKEY, LRET )
      LRET      = INDEX(KEYVAL,char(0)) -1
      READ( KEYVAL(1:LRET), * ) NPAR_SIM_HOSTLIB
      IF ( NPAR_SIM_HOSTLIB .LE. 0 ) RETURN
c ----------------------------------------------

      DO 100 ipar = 1, NPAR_SIM_HOSTLIB
        write(c2,22) ipar-1  ! C like index
22      format(I2.2)
        KEYNAME = "SIM_HOSTLIB_PAR" // C2 // char(0)
        ISTAT   = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 12, LRET )
        LRET    = INDEX(KEYVAL,char(0)) -1

        CALL PARSE_PARENTHESES(KEYVAL(1:LRET), PARNAME)
        SIM_HOSTLIB_KEYWORD(IPAR) = KEYVAL(1:LRET) ! key(varname)
        SIM_HOSTLIB_PARNAME(IPAR) = PARNAME ! extracted varname

100   CONTINUE

      CALL FLUSH(6)

      RETURN
      END  ! end of RDFITSHEAD_SIM_HOSTLIB


C ==================================
+DECK,PRSSIMSED.
      SUBROUTINE PARSE_SIMSED_TEXT(CWORD, IPAR_SIMSED)
c
c Check for SIMSED parameters in the header (text format only).
c First read 'SIMSED_NPAR:' key and store value in NPAR_SIMSED.
c Next read and store each full SIMSED keyword in 
c SIMSED_KEYWORD(IPAR_SIMSED) and store the parameter name 
c in SIMSED_PARNAME(IPAR_SIMSED).
c
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c xxx Dec 10 2018 SUBROUTINE MARKED FOR DELETION xxxx
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

      IMPLICIT NONE

c subroutine args.

      CHARACTER CWORD(*)*60   ! (I) text string to parse
      INTEGER IPAR_SIMSED     ! (I) last/current parameter index

c local args
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   LK
      CHARACTER KEY*60, PARNAME*40

C ----------------- BEGIN --------------

      IF ( CWORD(1)(1:7) .NE. 'SIMSED_' ) RETURN

      IF ( CWORD(1) .EQ. 'SIMSED_NPAR:' ) THEN
        READ(CWORD(2),*) NPAR_SIMSED

        if ( NPAR_SIMSED .GT. MXPAR_SIMSED ) then
           write(c1err,661) NPAR_SIMSED
           write(c2err,662) MXPAR_SIMSED
           CALL MADABORT("PARSE_SIMSED_TEXT", c1err, c2err)

661        format('NPAR_SIMSED=',I4,' exceeds bound.')
662        format('Bound is MXPAR_SIMSED = ', I4 )

        endif
        RETURN
      ENDIF

      IF ( NPAR_SIMSED .LE. 0 ) RETURN

c Now we have a SIMSED keyword.

      LK  = INDEX(CWORD(1),':') - 1  ! length without exclude colon
      KEY = CWORD(1)(1:LK)           ! KEY = SIMSED_PARAM(PARNAME)

      CALL PARSE_PARENTHESES(KEY, PARNAME) ! return PARNAME

      IPAR_SIMSED = IPAR_SIMSED + 1
      SIMSED_KEYWORD(IPAR_SIMSED) = KEY
      SIMSED_PARNAME(IPAR_SIMSED) = PARNAME(1:20)

      RETURN
      END    ! end of PARSE_SIMSED_TEXT


C ==================================
+DECK,PARSE_MODELPAR_TEXT.
      SUBROUTINE PARSE_MODELPAR_TEXT(CWORD, MODEL_CLASS, IPAR_MODEL)
c
c Check for SIMSED parameters in the header (text format only).
c First read 'SIMSED_NPAR:' key and store value in NPAR_SIMSED.
c Next read and store each full SIMSED keyword in 
c SIMSED_KEYWORD(IPAR_SIMSED) and store the parameter name 
c in SIMSED_PARNAME(IPAR_SIMSED).
c
      IMPLICIT NONE

c subroutine args.

      CHARACTER CWORD(*)*60   ! (I) text string to parse
      INTEGER MODEL_CLASS     ! (I) integer model id: SIMSED,BYOSED,LCLIB
      INTEGER IPAR_MODEL      ! (I) last/current parameter index

c local args
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER   LK, LNAME, NPAR
      CHARACTER MODEL_NAME*12, KEY*60, PARNAME*40, FNAM*20

C ----------------- BEGIN --------------
      FNAM = 'PARSE_MODELPAR_TEXT'

      MODEL_NAME = ''
      IF ( MODEL_CLASS == MODEL_SIMSED ) MODEL_NAME = 'SIMSED'
      IF ( MODEL_CLASS == MODEL_BYOSED ) MODEL_NAME = 'BYOSED'
      IF ( MODEL_CLASS == MODEL_LCLIB  ) MODEL_NAME = 'LCLIB'

      IF ( MODEL_NAME .EQ. '' ) THEN
           write(c1err,551) MODEL_CLASS
551        format('Invalid MODEL_CLASS = ', I3)
           c2err = 'Should be either SIMSED, BYOSED, or LCLIB'
           CALL MADABORT(FNAM, c1err, c2err)
      ENDIF
   
      LNAME = INDEX(MODEL_NAME,' ')-1
      IF ( CWORD(1)(1:LNAME+1) .NE. MODEL_NAME(1:LNAME)//'_' ) RETURN

      IF ( CWORD(1) .EQ.  MODEL_NAME(1:LNAME)//'_NPAR:' ) THEN
        READ(CWORD(2),*) NPAR
        IF ( MODEL_CLASS == MODEL_SIMSED ) NPAR_SIMSED = NPAR
        IF ( MODEL_CLASS == MODEL_BYOSED ) NPAR_BYOSED = NPAR
        IF ( MODEL_CLASS == MODEL_LCLIB  ) NPAR_LCLIB  = NPAR

        if ( NPAR .GT. MXPAR_SIMSED ) then
           write(c1err,661) MODEL_NAME(1:LNAME), NPAR
           write(c2err,662) MXPAR_SIMSED
           CALL MADABORT(FNAM, c1err, c2err)

661        format('NPAR_',A, '=',I4,' exceeds bound.')
662        format('Bound is MXPAR_SIMSED = ', I4 )
        endif
        RETURN
      ENDIF

c figure out which NPAR
      IF ( MODEL_CLASS == MODEL_SIMSED ) NPAR = NPAR_SIMSED
      IF ( MODEL_CLASS == MODEL_BYOSED ) NPAR = NPAR_BYOSED 
      IF ( MODEL_CLASS == MODEL_LCLIB  ) NPAR = NPAR_LCLIB  

      IF ( NPAR .LE. 0 ) RETURN

c Now we have a SIMSED keyword.

      LK  = INDEX(CWORD(1),':') - 1  ! length without exclude colon
      KEY = CWORD(1)(1:LK)           ! KEY = SIMSED_PARAM(PARNAME)

      CALL PARSE_PARENTHESES(KEY, PARNAME) ! return PARNAME

      IPAR_MODEL = IPAR_MODEL + 1

      IF ( MODEL_CLASS == MODEL_SIMSED ) THEN
        SIMSED_KEYWORD(IPAR_MODEL) = KEY
        SIMSED_PARNAME(IPAR_MODEL) = PARNAME(1:20)
      ELSE IF ( MODEL_CLASS == MODEL_BYOSED ) THEN
        BYOSED_KEYWORD(IPAR_MODEL) = KEY
        BYOSED_PARNAME(IPAR_MODEL) = PARNAME(1:20)
      ELSE IF ( MODEL_CLASS == MODEL_LCLIB ) THEN
        LCLIB_KEYWORD(IPAR_MODEL) = KEY
        LCLIB_PARNAME(IPAR_MODEL) = PARNAME(1:20)
      ENDIF

+SELF,IF=XXXDBG.
	print*,' xxx IPAR_MODEL = ', IPAR_MODEL
	print*,' xxx CWORD(1)   = ', CWORD(1)(1:30)
	print*,' xxx load KEY,PARNAME = ', 
     &      KEY(1:28),' | ' , PARNAME(1:20)
+SELF.

      RETURN
      END    ! end of PARSE_MODELPAR_TEXT


C ==================================
+DECK,PRSSIMHOST.
      SUBROUTINE PARSE_SIM_HOSTLIB_TEXT(CWORD,IPAR)
c
c Feb 12 2014
c Check for  SIM_HOSTLIB  keys in the header, with the form
c      SIM_HOSTLIB(PARNAME): <value>.
c This routine is called for text format only.
c
c -------------

      IMPLICIT NONE

c subroutine args.

      CHARACTER CWORD(*)*60   ! (I) text string to parse
      INTEGER   IPAR          ! (I) last/current param index 

c local args
+CDE,SNDATCOM.
+CDE,SNLCINP.
      INTEGER   LK
      CHARACTER KEY*60, PARNAME*40

C ----------------- BEGIN --------------

      IF ( CWORD(1)(1:11) .NE. 'SIM_HOSTLIB' ) RETURN

      IF ( CWORD(1) .EQ. 'SIM_HOSTLIB_NPAR:' ) THEN
         READ(CWORD(2),*) NPAR_SIM_HOSTLIB
         RETURN
      ENDIF

      if ( NPAR_SIM_HOSTLIB .LE. 0 ) RETURN

c -------------
c Now we have a SIM_HOSTLIB keyword

      LK   = INDEX(CWORD(1),':') - 1  ! length without colon
      KEY  = CWORD(1)(1:LK)           ! KEY = SIM_HOSTLIB(PARNAME)

      CALL PARSE_PARENTHESES(KEY, PARNAME) ! return PARNAME

      IPAR = IPAR + 1 
      SIM_HOSTLIB_KEYWORD(IPAR)   = KEY
      SIM_HOSTLIB_PARNAME(IPAR)   = PARNAME

      RETURN
      END    ! end of PARSE_SIM_HOSTLIB_TEXT


C ===================================
+DECK,PRSPAREN.
      SUBROUTINE PARSE_PARENTHESES(INKEY,OUTSTR)

c Parse inKey to extract varName from ().
c Example:
c   Input : INKEY   = SIMSED_PARAM(COSANGLE)
c  -->
c   Ouptut: OUTSTR = COSANGLE
c
c ---------------------
      IMPLICIT NONE

c subroutine args
      CHARACTER INKEY*(*)   ! (I) input key with varname in ()
      CHARACTER OUTSTR*(*)  ! (O) string in ()


c local args
      INTEGER J1, J2, LK
      CHARACTER C1ERR*72, C2ERR*72
c -------------- BEGIN ---------------

      J1 = INDEX( INKEY , '(' ) 
      J2 = INDEX( INKEY , ')' ) 

      IF ( J1 .EQ. 0 .or. J2 .EQ. 0 ) THEN
         LK = INDEX( INKEY, ' ' ) - 1
         c1err = 'Invalid INKEY = ' // INKEY(1:LK)
         c2err = 'Expecting to find key-string  SIMSED_XXX(PARNAME)'
         CALL MADABORT("PARSE_PARENTHESES", c1err,c2err)
      ENDIF

      OUTSTR = INKEY(j1+1:j2-1)

      RETURN
      END    ! end of PARSE_PARENTHESES

C =================================
+DECK,RDPRIVFITS.
      SUBROUTINE RDPRIVATE_FITS

c Created Nov 2012
c Read/parse names of PRIVATE keys from header if NVAR_PRIVATE > 0
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      INTEGER 
     &   ISTAT
     &  ,LRET, LNAME, LNUM, ivar

      CHARACTER KEYNAME*80, KEYVAL*80, cnum*2, KEYWORD*60

c C functions
      INTEGER   RD_SNFITSIO_GLOBAL
      EXTERNAL  RD_SNFITSIO_GLOBAL

C -------------- BEGIN ---------------

      KEYNAME   = "NPRIVATE" // char(0)
      ISTAT     = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, 11, LRET )
      LRET      = INDEX(KEYVAL,char(0)) -1
      READ( KEYVAL(1:LRET), * ) NVAR_PRIVATE

      IF ( NVAR_PRIVATE .LE. 0 ) RETURN

      IF( NVAR_PRIVATE > MXVAR_PRIVATE ) THEN
         write(C1ERR,61) NVAR_PRIVATE, MXVAR_PRIVATE 
 61      format('NVAR_PRIATE=',I4,' exceeds MXVAR_PRIVATE=',I4 )
         C2ERR = 'Check XXX_HEAD.FITS file'
         CALL MADABORT("RDPRIVATE_FITS", C1ERR, C2ERR)
      ENDIF
c ----------------------------------------------

      DO 100 ivar = 1, NVAR_PRIVATE

        if ( ivar .LT. 10 ) then
           write(cnum,21) ivar
           LNUM = 1
        else
           write(cnum,22) ivar
           LNUM = 2
        endif
21        format(I1)
22        format(I2)

        KEYNAME = "PRIVATE" // CNUM(1:LNUM) // char(0)
        LNAME   = 7 + LNUM

        ISTAT   = RD_SNFITSIO_GLOBAL ( KEYNAME, KEYVAL, LNAME, LRET )
        LRET    = INDEX(KEYVAL,char(0)) -1
        KEYWORD = KEYVAL(1:LRET)  ! leave out the char(0)

        PRIVATE_KEYWORD(ivar) = KEYWORD ! load common block
        CALL PARSE_PRIVATE_KEYWORD(KEYWORD,ivar)

100   CONTINUE

      CALL FLUSH(6)

      RETURN
      END  ! end of RDPRIVATE_FITS

C ====================================
+DECK,PRS_TERSE.
      SUBROUTINE PARSE_TERSE_VARLIST(VARLIST)
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
      CHARACTER VARLIST(*)*60

c local var

      INTEGER IVAR
      CHARACTER CTMP*60, KEY*60

C --------------- BEGIN -----------

c first check NVAR key to store number of variables per epoch.

      KEY = VARLIST(1)
      if ( KEY .EQ. 'NVAR:' ) then
         read(VARLIST(2),*)  NVAR_TERSE
         if ( NVAR_TERSE .LT. 5 .or. NVAR_TERSE .GT. 20 ) then
            write(c1err,698) NVAR_TERSE
698         format('Invalid NVAR: ', I5 )
            c2err = 'Check NVAR key for CID = ' // SNLC_CCID
            CALL MADABORT("PARSE_TERSE_VARLIST", c1err, c2err)
         endif
         RETURN
      endif

c now check list of variable names
      if ( KEY .NE. 'VARLIST:' ) RETURN

      if ( NVAR_TERSE .LE. 0 ) then
         c1err = 'Found  terse VARLIST before NVAR'
         c2err = 'Check data file for CID = ' // SNLC_CCID
         CALL MADABORT("PARSE_TERSE_VARLIST", c1err, c2err)
      endif

      do ivar = 1, NVAR_TERSE
        CTMP  = VARLIST(ivar+1)
        VARLIST_TERSE(ivar) = CTMP(1:MXCHAR_CCID)

        if ( CTMP(1:3) .EQ. 'MJD' ) then
          ITERSE_MJD = IVAR

        else if ( CTMP(1:4) .EQ. 'FLT ' ) then
          ITERSE_FILTER = IVAR
        else if ( CTMP(1:4) .EQ. 'FILT' ) then  ! 9/13/2017
          ITERSE_FILTER = IVAR

        else if ( CTMP(1:4) .EQ. 'BAND' ) then   ! Mar 29 2017
          ITERSE_FILTER = IVAR   

        else if ( CTMP(1:5) .EQ. 'FIELD' ) then
          ITERSE_FIELD = IVAR

        else if ( CTMP(1:10) .EQ. 'FLUXCAL   ' ) then
          ITERSE_FLUXCAL = IVAR

        else if ( CTMP(1:10) .EQ. 'FLUXCALERR' ) then
          ITERSE_FLUXCALERR = IVAR

        else if ( CTMP(1:8) .EQ. 'PHOTFLAG' ) then
          ITERSE_PHOTFLAG = IVAR
        else if ( CTMP(1:8) .EQ. 'PHOTPROB' ) then
          ITERSE_PHOTPROB = IVAR

        else if ( CTMP(1:3) .EQ. 'ZPT' ) then
          ITERSE_ZPFLUX = IVAR
        else if ( CTMP(1:3) .EQ. 'Zpt' ) then
          ITERSE_ZPFLUX = IVAR
        else if ( CTMP(1:2) .EQ. 'ZP' ) then
          ITERSE_ZPFLUX = IVAR
        else if ( CTMP(1:6) .EQ. 'ZPFLUX' ) then
          ITERSE_ZPFLUX = IVAR
        else if ( CTMP(1:6) .EQ. 'FLUXZP' ) then
          ITERSE_ZPFLUX = IVAR

        else if ( CTMP(1:5) .EQ. 'ZPERR' ) then
          ITERSE_ZPERR = IVAR

        else if ( CTMP(1:3) .EQ. 'PSF' ) then
          ITERSE_PSFSIG = IVAR

        else if ( CTMP(1:8) .EQ. 'SKYSIG_T' ) then
          ITERSE_SKYSIG_T = IVAR
        else if ( CTMP(1:6) .EQ. 'SKYSIG' ) then
          ITERSE_SKYSIG = IVAR

        else if ( CTMP(1:4) .EQ. 'XPIX' ) then
          ITERSE_XPIX = IVAR
        else if ( CTMP(1:4) .EQ. 'YPIX' ) then
          ITERSE_YPIX = IVAR

        else if ( CTMP(1:4) .EQ. 'GAIN' ) then
          ITERSE_GAIN = IVAR

        else if ( CTMP(1:6) .EQ. 'CCDNUM' ) then
          ITERSE_CCDNUM = IVAR

        else if ( CTMP(1:4) .EQ. 'MAG ' ) then
          ITERSE_MAGOBS = IVAR

        else if ( CTMP(1:8) .EQ. 'FLT_REST' ) then
          ITERSE_SIM_EPFILTREST = IVAR

        else if ( CTMP(1:10) .EQ. 'SIM_MAGOBS' ) then
          ITERSE_SIM_EPMAGOBS = IVAR

        else if ( CTMP(1:11) .EQ. 'SIM_MAGREST' ) then
          ITERSE_SIM_EPMAGREST = IVAR

        endif

      enddo


c Aug 15 2015: check required fields
      CALL CHECKVAL_I('ITERSE_MJD'//char(0),        ONE, 
     &                 ITERSE_MJD,        ONE, NVAR_TERSE)
      CALL CHECKVAL_I('ITERSE_FIELD'//char(0),      ONE, 
     &                 ITERSE_FIELD,      ONE, NVAR_TERSE)
      CALL CHECKVAL_I('ITERSE_FILTER'//char(0),     ONE, 
     &                 ITERSE_FILTER,     ONE, NVAR_TERSE)
      CALL CHECKVAL_I('ITERSE_FLUXCAL'//char(0),    ONE, 
     &                 ITERSE_FLUXCAL,    ONE, NVAR_TERSE)
      CALL CHECKVAL_I('ITERSE_FLUXCALERR'//char(0), ONE, 
     &                 ITERSE_FLUXCALERR, ONE, NVAR_TERSE)

      RETURN
      END    ! end of PARSE_TERSE


C ====================================
+DECK,PARSE_CID.
      SUBROUTINE PARSE_CID ( ccid, iauc, cid, USECID )
c
c Convert character string CCID into integer CID.
c Returns logical USECID=T if this CID should be processed.
c
c
c Jul 28 2014; allow ABORT_ON_DUPLCID=F to count duplicates without aborting
c
c Jul 31 2015: move GET_INTERP_MJDLIST call before LCIDSELECT call
c
c Dec 2 2015: pass IAUC arg.
c
c ---------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,INTERPCM.

      CHARACTER  CCID*(*)  ! (I) character string for CID
      CHARACTER  IAUC*(*)  ! (I) char string for IAUC name
      INTEGER    CID       ! (O) integer CID
      LOGICAL    USECID    ! (O) T => process this CID

c local var

      INTEGER LCHAR, NMJD, ISTAT
      LOGICAL  USECID_LOCAL, ADDFLAG, LDUPL

      REAL*8  MJD8LIST(MXINTERP)

c function
      INTEGER CIDASSIGN, EXEC_CIDMASK
      LOGICAL LCIDSELECT

C --------------- BEGIN --------------

      CID = 0
      USECID = .FALSE.

c check if this CID should be processed.
       LCHAR = INDEX ( CCID, ' ' ) - 1
       LCHAR = MIN(MXCHAR_CCID,LCHAR)  ! check limit on Number of chars

c convert char-string to integer CID
      CID = CIDASSIGN(CCID)

      IF ( CID .LE. 0 ) THEN
        c1err = 'Cannot determine integer CID for: ' // CCID
        write(c2err,602)  LCHAR
602     format('LEN(CCID) = ', I5 )
        CALL MADABORT("PARSE_CID", c1err, c2err)
      ENDIF

      IF ( CID > MXCID ) THEN
        write(c1err,611) CID, MXCID
        C2err = '   '
611     format('CID=',I9,' exceeds MXCID=',I9 )
        CALL MADABORT("PARSE_CID", c1err, c2err)
      ENDIF


c check for CIDs to interpolate (May 18, 2012)
      CALL GET_INTERP_MJDLIST(CCID, NMJD, MJD8LIST, ADDFLAG)
      IF ( ADDFLAG ) THEN
          NCCID_LIST = NCCID_LIST + 1
          SNCCID_LIST(NCCID_LIST) = CCID  ! Dec 4 2012
          USECID_LOCAL = .TRUE.
          GOTO 800
      ENDIF

c ----------------------------------------------------
      IF ( .NOT. LCIDSELECT(cid,ccid,iauc) ) RETURN
      SNLC_CCID      = CCID    ! in case CCID -> IAUC (Dec 3, 2015)
      ISNLC_LENCCID  = INDEX(CCID,' ') - 1  ! Mar 20 2016
      USECID_LOCAL   = .TRUE.
      GOTO 800

c ---------------------------
800   CONTINUE

      IF ( CID < MXCID_CHECK ) THEN
        ISTAT = EXEC_CIDMASK(2,CID)  ! returns 1 if CID bit is set
        LDUPL = (ISTAT > 0 )
      ELSE
        LDUPL = .FALSE. ! cannot check duplicates for very large CID
      ENDIF

      IF ( USECID_LOCAL ) THEN

c if this CID has already been used (found), abort.

        if ( LDUPL  ) THEN 

          IF ( ABORT_ON_DUPLCID ) then
            write(c1err,801) CID, CCID(1:LCHAR)
801         format('CID= ',I9, ' (',A, ') appears more than once; ' )
            c2err = 'each CID can appear only once.'
            CALL MADABORT("PARSE_CID", c1err, c2err)
          ELSE
             print*,' *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-' //
     &            '*-*-*-*-*-*-*-*-*-*-*-*-*-*-'             
             write(6,866) CCID
 866         format(T10,'!!! DUPLICATE WARNING: reject CID=',A)
             call flush(6)
             N_DUPLICATE_CID = N_DUPLICATE_CID + 1
             return  ! return with USECID=F
          endif
        endif

        IF ( CID < MXCID_CHECK ) THEN
           ISTAT = EXEC_CIDMASK(1,CID)  ! set CID bit
        ENDIF

        NACCEPT_CID = NACCEPT_CID + 1
        USECID      = .TRUE.

      ELSE

        if ( LDMP_SNFAIL ) then
           print*,'  ** WARNING ** CID ',cid,' FAILS CID CUT '
           CALL FLUSH(6)
        endif

      ENDIF

      RETURN
      END  ! end of PARSE_CID

C ========================================
+DECK,PARSE_SURVEY_NAME.
      SUBROUTINE PARSE_SURVEY_NAME(INPUT_STRING,
     &     SURVEY, SUBSURVEY,ID)

c Created jan 26 2017
c Examples:
c
c   input              output         output 
c INPUT_STRING         SURVEY       SUBSURVEY
c - - - - - - - - - - - - - - - - - - - - - - - - 
c     SDSS             SDSS           SDSS
c     SNLS             SNLS           SNLS
c   LOWZ_ALL(CFA3)     LOWZ_ALL       CFA3
c - - - - - - - - - - - - - - - - - - - - - - - - 
c
c The purpose here is that for combined samples,
c integer ID is assigned to the SUBSURVEY.
c
c -----------------

+CDE,SNPAR.
+CDE,CTRLCOM.  

c subroutine args
      CHARACTER
     &   INPUT_STRING*(*)      ! (I)
     &  ,SURVEY*(*)            ! (O)
     &  ,SUBSURVEY*(*)         ! (O)

      INTEGER ID               ! (O) IDSURVEY

c local args
      INTEGER j1, j2, LENSTR
      CHARACTER  C1ERR*80, C2ERR*80

c function
      INTEGER GET_IDSURVEY 

c -------------- BEGIN -------------

      LENSTR = INDEX(INPUT_STRING, ' ' ) - 1
      j1 = INDEX(INPUT_STRING, '(' )
      j2 = INDEX(INPUT_STRING, ')' )
      
      if ( j1 .LE. 0 ) then
         SURVEY    = INPUT_STRING
         SUBSURVEY = INPUT_STRING
      else
         SURVEY    = INPUT_STRING(1:J1-1)    ! string before ()
         SUBSURVEY = INPUT_STRING(j1+1:J2-1) ! stuff inside ()
      endif
c ---------------------------------
c get integer ID of survey

      IF ( NSURVEY_LIST == 0 ) return  ! SURVEY LIST not read yet

      ID = GET_IDSURVEY(SUBSURVEY)

c -----------------------------------
c abort of IDSURVEY not found.
 
      IF ( ID < 0 ) THEN
         write(c1err,61) INPUT_STRING(1:LENSTR)
61       format('Could not find IDSURVEY for ', A )

         j1 = index(SURVEY,   ' ') - 1
         j2 = index(SUBSURVEY,' ') - 1
         write(c2err,62) SURVEY(1:j1), SUBSURVEY(1:j2)
62       format('SURVEY=',A, 4x, 'SUBSURVEY=', A)

         call MADABORT('PARSE_SURVEY_NAME', c1err, c2err)
      ENDIF

      RETURN
      END     ! end PARSE_SURVEY_NAME

C ============================================
+DECK,GET_IDSURVEY.
      INTEGER FUNCTION GET_IDSURVEY(SURVEY)

      CHARACTER SURVEY*(*)  ! (I) name of survey

c local var
+CDE,SNPAR.
+CDE,CTRLCOM.  

      INTEGER ID, j1, j2
      LOGICAL LMATCH
C ---------- BEGIN ------------

      ID = -9 ; GET_IDSURVEY=-9

      DO 101 i = 1, NSURVEY_LIST
         j1 = index(SURVEY,' ') - 1
         j2 = index(SURVEY_NAME_LIST(i),' ') - 1
         if ( j1 .NE. j2 ) goto 101
         LMATCH = ( SURVEY(1:j1) .EQ. SURVEY_NAME_LIST(i)(1:j2) )
         if ( LMATCH )  ID = IDSURVEY_LIST(i)
101   CONTINUE

      GET_IDSURVEY = ID

      RETURN
      END    ! end GET_IDSURVEY


C ================================================
+DECK,PARSE_SPECTRUM.
      SUBROUTINE PARSE_SPECTRUM ( cwords, istat ) 
c
c Apri 2019
c -----------------
      IMPLICIT NONE

c subroutine args
      CHARACTER cwords(*)*60    ! (I) words to parse
      INTEGER   ISTAT           ! (O) 0=OK;   <0 => skip this ISNLC

c local var
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SPECCOM.

      INTEGER ID,  NLAMBIN, ilam, iwd, NLAMBIN_EXPECT
      REAL*8  MJD, TEXPOSE, TOBS
      CHARACTER CWD*60, CWD_NEXT*60
      LOGICAL LDMP / .FALSE. /
c      LOGICAL LDMP / .TRUE. /

C ----------------- BEGIN ----------------
      ISTAT    = 0
      CWD      = cwords(1)
      CWD_NEXT = cwords(2)

      if ( LDMP .and. NLAMBIN_READ < 5 ) then
         write(6,65) NSPECTRUM, NLAMBIN_READ
 65      format(' xxx ---------- NSPECTRUM=',I2,
     &       '  NLAMBIN_READ=',I2, ' ---------------- ' )
         do iwd = 1, 8
            write(6,66) iwd, cwords(iwd)(1:20)
 66         format(' xxx cwords(',I2,') = ', A)
         enddo
         call flush(6)
      endif

c check header stuff
      IF ( CWD .EQ. 'SPECTRUM_ID:' ) THEN
         RDFLAG_SPECTRUM = .TRUE.
         READ(CWD_NEXT,*) ID
         NSPECTRUM    = NSPECTRUM + 1
         if ( NSPECTRUM > MXSPECTRUM ) then
           write(c1err,81) MXSPECTRUM 
81         format('NSPECTRUM exceeds bound of MXSPECTRUM=',I2 )
           c2err = 'Check MXSPECTRUM in snana.car'
           CALL MADABORT("PARSE_SPECTRUM", c1err, c2err )
         endif
         NLAMBIN_READ = 0 
         ID_SPECTRUM(NSPECTRUM) = ID
      ENDIF

      IF ( CWD .EQ. 'SPECTRUM_MJD:' ) THEN
         READ(CWD_NEXT,*) MJD
         TOBS = MJD - SNLC_SEARCH_PEAKMJD
         IF ( MJD < 0.0 ) TOBS = -9.0
         MJD_SPECTRUM(NSPECTRUM)  = MJD
         TOBS_SPECTRUM(NSPECTRUM) = TOBS
      ENDIF

      IF ( CWD .EQ. 'SPECTRUM_TEXPOSE:' ) THEN
         READ(CWD_NEXT,*) TEXPOSE
         TEXPOSE_SPECTRUM(NSPECTRUM) = TEXPOSE
      ENDIF

      IF ( CWD .EQ. 'SPECTRUM_NLAM:' ) THEN
         READ(CWD_NEXT,*) NLAMBIN
         NLAMBIN_SPECTRUM(NSPECTRUM) = NLAMBIN

         if ( NLAMBIN > MXLAM_SPECTRUM ) then
           write(c1err,91) NLAMBIN, MXLAM_SPECTRUM
91         format('NLAMBIN=',I5,' exceeds bound of ', 
     &            'MXLAM_SPECTRUM=',I5)
           c2err = 'Check MXLAM_SPECTRUM in snana.car'
           CALL MADABORT("PARSE_SPECTRUM", c1err, c2err )
         endif
      ENDIF

c check SPEC: line with wave and flux

      IF ( CWD .EQ. 'SPEC:' ) THEN
         NLAMBIN_READ = NLAMBIN_READ + 1
         ilam         = NLAMBIN_READ
         READ(cwords(2),*) LAMMIN_SPECTRUM(ilam,NSPECTRUM)
         READ(cwords(3),*) LAMMAX_SPECTRUM(ilam,NSPECTRUM)
         READ(cwords(4),*) FLAM_SPECTRUM(ilam,NSPECTRUM)
         READ(cwords(5),*) FLAMERR_SPECTRUM(ilam,NSPECTRUM)
      ENDIF

      IF ( CWD .EQ. 'SPECTRUM_END:' ) THEN
         NLAMBIN_EXPECT = NLAMBIN_SPECTRUM(NSPECTRUM)
         ID             = ID_SPECTRUM(NSPECTRUM)
         if ( NLAMBIN_READ .NE. NLAMBIN_EXPECT ) then
           write(c1err,661) NLAMBIN_READ, NLAMBIN_EXPECT
661        format('Read ',I4,' lam bins, but expected ',I4)
           write(c2err,662) SNLC_CCID(1:12), ID
662        format('CID=',A,' SPECTRUM_ID=',I2 )
           CALL MADABORT("PARSE_SPECTRUM", c1err, c2err )
         endif
         NLAMBIN_READ = 0
      ENDIF

      RETURN 
      END     ! end PARSE_SPECTRUM


C =============================================
+DECK,CIDASSIGN.
      INTEGER FUNCTION CIDASSIGN(CCID)
c
c Created May 28, 2008 by R.Kessler
c Assign integer CID to character string CCID
c If CCID is already an integer, then CID = CCID;
c otherwise set CID = IFILE.
c
c Note that if a string-named SN appears in 
c multiple PHOTOMETRY version, it can have
c a different CID in each case. For integer
c CIDs (like SDSS), the CID is always the same.
c
c
c ---------------------

      IMPLICIT NONE
      CHARACTER CCID*(*)  ! (I) 

c local var
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER IERR, CID, LCHAR 

c ----------- BEGIN -------------

      CID = -1 ; IERR=0
      read( ccid, 20 , iostat = IERR ) CID
20    format(I10)    ! was I8

      IF ( IERR .EQ. 0 ) THEN  ! CCID is an integer
           SNLC_CASTCID = 'INT'
           GOTO 555
      ELSE 

         LCHAR = INDEX ( CCID, ' ' ) - 1
         CID = ISNLC_ABSO_INDEX
         SNLC_CASTCID = 'CHAR' 
         GOTO 555

      ENDIF

555   CIDASSIGN = CID

      RETURN
      END


C ==============================================
+DECK,LDONE_CIDLIST.
      LOGICAL FUNCTION LDONE_CIDLIST()

c Jun 2011:
c Returns TRUE if all CID in the list have been processed;
c allows parsing function to stop early.
c
c May 18, 2012: return FALSE if interp-option is set
c Jun 25, 2019: check MXEVT_PROCESS
c
c -----------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,INTERPCM.

      LOGICAL LNCID

c ------------- BEGIN --------------

      LDONE_CIDLIST = .FALSE.  ! default

      if ( N_SNLC .GE. MXEVT_PROCESS ) then
         LDONE_CIDLIST = .TRUE.
         RETURN
      endif

c if CUTWIN_CID is set then return FALSE
      if ( cutwin_cid(1) .GT. 0 ) RETURN
      if ( cutwin_cid(2) .GT. 0 ) RETURN
     
      if ( SNCID_LIST_FILE .NE. ' ' ) RETURN ! Nov 2013

c return FALSE if interp-option is set but not finished
     
      if ( N_INTERP_MJDLIST .GT. 0 .and. 
     &     N_INTERP_MJDLIST_DONE .LT. N_INTERP_MJDLIST ) THEN
           LDONE_CIDLIST = .FALSE.
           RETURN
      endif

      LNCID = NACCEPT_CID .EQ. (NCID_LIST + NCCID_LIST)
      IF ( LNCID ) THEN
        LDONE_CIDLIST = .TRUE.
      ENDIF

      RETURN
      END       ! END OF LDONE_CIDLIST


C ==============================================
+DECK,PRS_REDSHIFT.
      SUBROUTINE PARSE_REDSHIFT ( isnlc, cwords, istat )
c
c parse redshift parameters.
c cword(1) is the keyword; cword(2) is the value,c
c or cword(2-6) are the five values for ugirz.
c Returns ISTAT=0 (OK) if redshift is within cut-window;
c other returns ISTAT = -1
c
c May 15, 2008: LZTMP includes cut on redshift error.
c
c Oct 31, 2008: add crazy-Z protection (see ZMAX)
c
c Mar 17, 2009: read ZHELIO and ZCMB
c
c Aug 7, 2009:   Z = Z  + REDSHIFT_FINAL_SHIFT
c                to fudge redshifts in photoZ fits
c
c Nov 21, 2009: protect NZ from exceeding MXZSPEC
c
c Jun 22, 2011: use READ_HEADKEY() function to read either TEXT or FITS
c
c Aug 28, 2012: set HEADMASK_Z bit if valid redshift key is found.
c               Used to make sure that required keys are found.
c
c Dec 18, 2012: simplify logic using new RETSTR='+ERR' feature to read
c               both the value and error with one call to READ_HEADKEY
c
c Aug 19, 2013: remove call to ZCUTSTAT; no more redshift cuts from 
c               header because it messess up the cut-bookkeeping.
c
c Jul 11 2015:  read optional SN-only redshift (REDSHIFT_SN[_ERR])
c
c May 1 2018: 
c   + use '+ERR' feature to read VPEC[ERR] as either 2 keys,
c     or as  VPEC: xxx +- yyy
c
c --------------

      IMPLICIT NONE

c subroutine args.

      INTEGER   isnlc           ! (I) SN sparese index to load
      CHARACTER cwords(*)*60    ! (I) words to parse
      INTEGER   ISTAT           ! (O) 0=OK;   <0 => skip this ISNLC

+CDE,SNDATCOM.
+CDE,SNLCINP.

c local var
      character CWD_ZERR*60, ZKEY*24, RETSTR*80
      REAL     Z, ZERR, ZMAX
      LOGICAL  LZTMP
      REAL*8   RET8(MXFILT_OBS)

c functions
      LOGICAL  READ_HEADKEY

C ----------- BEGIN ---------

      istat    = 0
      cwd_zerr = cwords(4)  ! skip over '+-' symbol

      RETSTR    = '+ERR'             ! also reads [ZKEY]_ERR
      ZKEY      = 'REDSHIFT_HELIO'  ! 
      LZTMP  = READ_HEADKEY(isnlc, cwords, ZKEY, RET8, RETSTR )
      IF ( LZTMP ) THEN
        HEADMASK = IBSET(HEADMASK, HEADBIT_Z)
        Z    = RET8(1)  + REDSHIFT_FINAL_SHIFT
        ZERR = RET8(2)

c store in global array
        SNLC_ZHELIO      = Z  
        SNLC_ZHELIO_ERR  = ZERR

c assign light-curve redshift to ZHELIO, even if it's
c already been assigned to SNLC_ZCMB below

        SNLC_REDSHIFT      = Z 
        SNLC_REDSHIFT_ERR  = ZERR

      ENDIF  ! LZTMP

c --------

      RETSTR  = '+ERR'
      ZKEY    = 'REDSHIFT_FINAL'
      LZTMP   = READ_HEADKEY(isnlc, cwords, ZKEY, RET8, RETSTR )

      IF ( LZTMP ) THEN
        HEADMASK = IBSET(HEADMASK, HEADBIT_Z)
        Z    = RET8(1)  + REDSHIFT_FINAL_SHIFT
        ZERR = RET8(2) 

        SNLC_ZCMB      = Z     ! used for Hubble diagram/fitres file
        SNLC_ZCMB_ERR  = ZERR

c protect against crazy Z for photoZ fits.
c Note that negative ZERR indicates photoZ 

          ZMAX = CUTWIN_REDSHIFT(2) 
          if ( ZERR < 0.0 .and. Z > ZMAX ) then
              Z = ZMAX
          endif

c assign light curve redshift if not already assigned by Z_HELIO
c i.e., light curve analysis should use Z_HELIO if it's defined;
c otherwise use Z_CMB

          IF ( SNLC_ZHELIO < 0.0 ) then
            SNLC_REDSHIFT      = Z   
            SNLC_REDSHIFT_ERR  = ZERR
          ENDIF

      ENDIF


c --------------------------------------------
c Jan 2018: read optional VPEC & its error

      RETSTR = '+ERR'
      ZKEY    = 'VPEC'
      LZTMP   = READ_HEADKEY(isnlc, cwords, ZKEY, RET8, RETSTR )
      IF ( LZTMP ) THEN
         if ( RET8(1) .NE. IGNORE_HEADVAL) then
           SNLC_VPEC     = SNGL ( RET8(1) )
         endif
         if ( RET8(2) .NE. IGNORE_HEADVAL) then
           SNLC_VPEC_ERR = SNGL ( RET8(2) )
         endif
      ENDIF

      IF (  abs(VPEC_ERR_OVERRIDE) > .001 ) THEN
         SNLC_VPEC_ERR = VPEC_ERR_OVERRIDE  ! Jan 11 2018
      ENDIF

      RETURN
      END   ! end PARSE_REDSHIFT 

C ===========================
+DECK,ZCUTSTAT.
      INTEGER FUNCTION ZCUTSTAT(Z,ZERR)
c
c
c Return  0 if both Z and ZERR pass cutwin;
c return -1 otherwise.
c For each cut that passes, increment global counter.
c
c ------------------

      IMPLICIT NONE

c function args
      REAL Z, ZERR  ! (I) redshift and error

c local variables
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER ibit
      LOGICAL LZTMP

c --------------- BEGIN ------------

c set mask to indicate that redshift [header] cut has been applied.
      ibit = CUTBIT_REDSHIFT
      APPLY_HEADER_CUTMASK = IBSET(APPLY_HEADER_CUTMASK,ibit-1)
      ibit = CUTBIT_REDSHIFT_ERR
      APPLY_HEADER_CUTMASK = IBSET(APPLY_HEADER_CUTMASK,ibit-1)

      ZCUTSTAT = 0

      LZTMP = Z  .GE. cutwin_redshift(1)  .and.
     &        Z  .LE. cutwin_redshift(2) 
      if ( LZTMP ) then 
        NACCEPT_Z = NACCEPT_Z + 1
      else
        zcutstat = -1
      endif

c ---
c make cut on error (mainly to remove those with ZERR < 0 )

      LZTMP = ZERR .GE. cutwin_redshift_err(1)  .and.
     &        ZERR .LE. cutwin_redshift_err(2) 

      if ( LZTMP ) then 
        NACCEPT_ZERR = NACCEPT_ZERR + 1
      else
        zcutstat = -1
      endif
c ---

      RETURN
      END


C ==============================================
+DECK,PARSE_EPOCH_TEXT.
      SUBROUTINE PARSE_EPOCH_TEXT ( cwords, istat )
c
c parse epoch parameters.
c cword(1) is the keyword; 
c
c Apply selection cuts to MJD/TREST, FIELD and TELESCOPE;
c return istat = -1 if any cut fails => reject this epoch
c
c
c         HISTORY
c 
c Nov 29 2014: REAL MJD --> REAL*8 MJD8 
c
c Mar 20 2015: call CHECK_EPOCH_IGNORE 
c
c -------------------------------

      IMPLICIT NONE

c subroutine args.

      CHARACTER cwords(*)*60    ! (I) words to parse
      INTEGER   ISTAT           ! (O) 0=OK;   <0 => skip this ISNLC

+CDE,SNDATCOM.
+CDE,SNLCINP.
     
c local var
      character 
     &   cwd*60, cwd_next*60, cfield*20, band_rest*2
     &  ,ctel*20, ccid*(MXCHAR_CCID)

      integer  
     &   Newmjd, ITMPN(MXFILT_OBS)
     &  ,IDTEL, IDFIELD, ITMP, EPMIN, EPMAX, ep, NFILT
     
      REAL Z, PKMJD
      LOGICAL LTMP, LTMP1, LTMP2, IGNORE

      REAL*8  MJD8 

c functions
      INTEGER GET_IDTEL, GET_IDFIELD, FILTINDX
      LOGICAL LCUTEPOCH, CHECK_EPOCH_IGNORE

C ----------- BEGIN ---------

      istat    = 0
      cwd      = cwords(1)
      cwd_next = cwords(2)
      ccid     = SNLC_CCID

      NEWMJD  = ISNLC_NEWMJD_STORE + 1
      EPMIN   = ISNLC_NEPOCH_STORE + 1

      ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD) = EPMIN

      if ( cwd .EQ. 'TELESCOPE:' ) then
          read(cwd_next,*) CTEL
          IDTEL = GET_IDTEL( CTEL )
          ISNLC_IDTEL(EPMIN) = IDTEL

          LTMP = DOALL_SNTEL .or. IDTEL .GT. 0
          if ( .NOT. LTMP ) then
             istat = ISTAT_SKIP
             return
          endif
          
      endif

c check field (allow legacy "STRIPE:" key for SDSS)

      LTMP = cwd .EQ. 'STRIPE:' .or. cwd .EQ. 'FIELD:' 
      if ( LTMP ) then
          read(cwd_next,*) cfield
          IDFIELD = GET_IDFIELD( CFIELD )
          ISNLC_IDFIELD(EPMIN) = IDFIELD
          SNLC_FIELD(EPMIN)    = cfield   ! July 16, 2013

c check if this field is OK
          LTMP = DOALL_SNFIELD .or. IDFIELD .GT. 0          
          if ( .NOT. LTMP ) then
             istat = ISTAT_SKIP
             return
          endif

      endif  ! end of FIELD

c for epoch, make Trest/MJD cut immediately to save memory storage

      LTMP1 = FORMAT_VERBOSE .and. cwd .EQ. 'MJD:'
      LTMP2 = FORMAT_TERSE   .and. cwd .EQ. 'OBS:'

      if ( LTMP1 .or. LTMP2 ) then

          read(cwd_next,*) MJD8

          Z        = SNLC_REDSHIFT
          PKMJD    = SNLC_SEARCH_PEAKMJD

c Use utility function to apply MJD/Trest cut,  but ignore 
c cut on IDTEL and IDFIELD; these last two cuts are applied 
c later if/when their values are read.
          LTMP    = LCUTEPOCH(Z, PKMJD, SNGL(MJD8), 999,999)

c always load MJD in case we need to flag an error somewhere
c in the parsing. If Trest fails cut, SNLC8_MJD will get over-written.

          SNLC8_MJD(EPMIN) = MJD8

          if ( .NOT. LTMP ) then
            istat = ISTAT_SKIP
            return
          endif 
      endif

c ------------- parse FILTER-BAND info
c               PASSBAND: filt-list must already be parsed.

      NFILT = ISNLC_NFILT_NEWMJD(NEWMJD)
      EPMAX = EPMIN + NFILT - 1

c check for TERSE format

      IF ( LTMP2 ) THEN 

c read mandatory args
        ITMP = 1 + ITERSE_FLUXCAL
        read(cwords(ITMP),*) SNLC_FLUXCAL(EPMIN)

        ITMP = 1 + ITERSE_FLUXCALERR
        read(cwords(ITMP),*) SNLC_FLUXCAL_ERRTOT(EPMIN)  

        ITMP = 1 + ITERSE_FIELD
        cfield = cwords(ITMP)(1:MXCHAR_FIELDNAME)
        ISNLC_IDFIELD(EPMIN) = GET_IDFIELD( CFIELD )
        SNLC_FIELD(EPMIN)    = CFIELD  ! Jul 16, 2013

c read optional PHOTFLAG if it's there 
        if ( ITERSE_PHOTFLAG > 0 ) then
           ITMP = 1 + ITERSE_PHOTFLAG
           read(cwords(ITMP),*) ISNLC_PHOTFLAG(EPMIN)  
        endif

c read optional PHOTPROB if it's there  (Nov 24 2014)
        if ( ITERSE_PHOTPROB > 0 ) then
           ITMP = 1 + ITERSE_PHOTPROB
           read(cwords(ITMP),*) SNLC_PHOTPROB(EPMIN)  
        endif

c read optional FLUX-ZPT if it's there (Nov 2, 2010).
        if ( ITERSE_ZPFLUX > 0 ) then
           ITMP = 1 + ITERSE_ZPFLUX
           read(cwords(ITMP),*) SNLC_ZEROPT(EPMIN) 
        endif

c read optional FLUX-ZPERR if it's there (Jan 2020)
        if ( ITERSE_ZPERR > 0 ) then
           ITMP = 1 + ITERSE_ZPERR
           read(cwords(ITMP),*) SNLC_ZEROPT_ERR(EPMIN) 
        endif
 
c read optional PSF if it's there (July 2013)
        if ( ITERSE_PSFSIG > 0 ) then
           ITMP = 1 + ITERSE_PSFSIG
           read(cwords(ITMP),*) SNLC_PSF_SIG1(EPMIN) 
        endif

c read optional SKYSIG if it's there (July 2013)
        if ( ITERSE_SKYSIG > 0 ) then
           ITMP = 1 + ITERSE_SKYSIG
           read(cwords(ITMP),*) SNLC_SKYSIG(EPMIN) 
        endif

c read optional SKYSIG_T if it's there (Aug 7 2014)
        if ( ITERSE_SKYSIG_T > 0 ) then
           ITMP = 1 + ITERSE_SKYSIG_T
           read(cwords(ITMP),*) SNLC_SKYSIG_T(EPMIN) 
        endif

c read optional XPIX & YPIX if it's there (Aug 2014)
        if ( ITERSE_XPIX > 0 ) then
           ITMP = 1 + ITERSE_XPIX
           read(cwords(ITMP),*) SNLC_XPIX(EPMIN) 
        endif
        if ( ITERSE_YPIX > 0 ) then
           ITMP = 1 + ITERSE_YPIX
           read(cwords(ITMP),*) SNLC_YPIX(EPMIN) 
        endif

c read optional GAIN if it's there (Oct 2015)
        if ( ITERSE_GAIN > 0 ) then
           ITMP = 1 + ITERSE_GAIN
           read(cwords(ITMP),*) SNLC_GAIN(EPMIN) 
        endif

c read optional CCDNUM if it's there (Oct 2017)
        if ( ITERSE_CCDNUM > 0 ) then
           ITMP = 1 + ITERSE_CCDNUM
           read(cwords(ITMP),*) ISNLC_CCDNUM(EPMIN) 
        endif

c read optional MAG if it's there (Sep 2011)        
        if ( ITERSE_MAGOBS > 0 ) then
           ITMP = 1 + ITERSE_MAGOBS
           read(cwords(ITMP),*) SNLC_MAG(EPMIN) 
        endif

c read optional SIM quantities if it's there (Jan 2014)
        if ( ITERSE_SIM_EPMAGOBS > 0 ) then
           ITMP = 1 + ITERSE_SIM_EPMAGOBS
           read(cwords(ITMP),*) SIM_EPMAGOBS(EPMIN) 
        endif

        if ( ITERSE_SIM_EPFILTREST > 0 ) then
           ITMP = 1 + ITERSE_SIM_EPFILTREST
           read(cwords(ITMP),*) BAND_REST
           SIM_EPFILTREST(EPMIN)  = FILTINDX(BAND_REST)
        endif

        if ( ITERSE_SIM_EPMAGREST > 0 ) then
           ITMP = 1 + ITERSE_SIM_EPMAGREST
           read(cwords(ITMP),*) SIM_EPMAGREST(EPMIN) 
        endif

c apply epoch cut.
        Z       = SNLC_REDSHIFT
        PKMJD   = SNLC_SEARCH_PEAKMJD
        IDTEL   = 999   ! no telescope defined for TERSE format
        IDFIELD = ISNLC_IDFIELD(EPMIN)  
        IGNORE  = CHECK_EPOCH_IGNORE(1,EPMIN) .and. 
     &            (.not. REFORMAT_SAVE_BADEPOCHS)
        LTMP    = LCUTEPOCH(Z, PKMJD, SNGL(MJD8), IDTEL, IDFIELD)
     &            .and. (.not. IGNORE )

        if ( .NOT. LTMP ) ISTAT = ISTAT_SKIP
        return
      ENDIF

      if ( cwd .EQ. 'PHOTOMETRYFLAG:' ) then
         CALL RDNINT ( cwords(2), NFILT, ITMPN )            
         do ep = EPMIN, EPMAX
            itmp  = ITMPN(ep-EPMIN+1)
            if ( Itmp .EQ. -9 ) ITMP = 0
            ISNLC_PHOTFLAG(ep) = ITMP
         enddo
      endif

        if ( cwd .EQ. 'GAIN:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_GAIN(EPMIN) )
        endif

        if ( cwd .EQ. 'RDNOISE:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_RDNOISE(EPMIN) )
        endif

        if ( cwd .EQ. 'XPIXEL:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_XPIX(EPMIN) )
        endif
        if ( cwd .EQ. 'YPIXEL:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_YPIX(EPMIN) )
        endif

c xxxxxxxxxx mark delete Jun 23 2019 xxxxxxxxxxxx
c        if ( cwd .EQ. 'SKY_AVG:' ) then
c          CALL RDNFLOAT(cwords(2),NFILT,SNLC_SKY_AVG(EPMIN) )
c        endif
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

        if ( cwd .EQ. 'SKY_SIG:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_SKYSIG(EPMIN) )
        endif
        if ( cwd .EQ. 'TRUN_SKY_SIG:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_SKYSIG_T(EPMIN) )
        endif

        if ( cwd .EQ. 'PSF_SIG1:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_PSF_SIG1(EPMIN) )
        endif
        if ( cwd .EQ. 'PSF_SIG2:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_PSF_SIG2(EPMIN) )
        endif
        if ( cwd .EQ. 'PSF_RATIO:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_PSF_RATIO(EPMIN) )
        endif

+SELF,IF=XXXREMOVE.
c xxxxxxxxx mark delete Jun 24 2019 xxxxxxxxxxxxxx
        if ( cwd .EQ. 'FLUX:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_FLUX(EPMIN))
        endif
        if ( cwd .EQ. 'FLUX_ERRTOT:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_FLUX_ERRTOT(EPMIN))
        endif
+SELF.

        if ( cwd .EQ. 'ZEROPT:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_ZEROPT(EPMIN))
        endif
        if ( cwd .EQ. 'ZEROPT_ERR:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_ZEROPT_ERR(EPMIN))
        endif

        if ( cwd .EQ. 'FLUXCAL:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_FLUXCAL(EPMIN))
        endif
        if ( cwd .EQ. 'FLUXCAL_ERRTOT:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,
     &             SNLC_FLUXCAL_ERRTOT(EPMIN))
        endif

c read magnitues and asymmetric errors

        if ( cwd .EQ. 'MAG:' ) then
           CALL RDNFLOAT(cwords(2),NFILT,SNLC_MAG(EPMIN))
        endif
        if ( cwd .EQ. 'MAG_ERRPLUS:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_MAG_ERRPLUS(EPMIN))
        endif
        if ( cwd .EQ. 'MAG_ERRMINUS:' ) then
          CALL RDNFLOAT(cwords(2),NFILT,SNLC_MAG_ERRMINUS(EPMIN))
        endif

c check for SIM stuff.

        if ( cwd .EQ. 'SIM_MAG:' ) then
          CALL RDNFLOAT(cwords(2), NFILT, SIM_EPMAGOBS(EPMIN) )
        endif

      RETURN
      END  ! end of PARSE_EPOCH_TEXT


C ==============================================
+DECK,PRS_BAND.
      SUBROUTINE PARSE_PASSBAND(cwords, istat )

c -------------------------
c Aug 22, 2007: 
c Check passband filters with keyword "BAND:" (old files)
c or "PASSBAND:" (new files).  There is no end-of-passband marker,
c so this logic is a bit fragile. A sequence might look like
c
c  PASSBAND:  g r i
c  FLUX:  22. 23. 24.
c
c  Let's assume that single-character words are filters
c  since no keyword is made of a single character.
c  We just have to hope for no signle-char comments at the end.
c  To be safe, ignore things like "#" and "%" and "!"
c
c Oct 24, 2009: modify to work for TERSE format. 
c               See FORMAT_TERSE logical
c
c July 27, 2010: replace  parameter IWDFILT_TERSE with 
c                variable ITERSE_FILTER
c
c -------------------

      IMPLICIT  NONE

c subroutine args.

      CHARACTER cwords(*)*60    ! (I) words to parse
      INTEGER   ISTAT           ! (O) 0=OK;   <0 => skip this ISNLC

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
      
c local var
      character 
     &   cwd*60
     &  ,cfilt*12
     &  ,ccid*(MXCHAR_CCID)

      INTEGER LL, iwd, ifilt, ifilt_obs, NEWMJD, ep, EPMIN

      LOGICAL LKEY

c function
      INTEGER FILTINDX_REPLACE

c ---------- BEGIN --------

      istat    = 0
      cwd      = cwords(1)

      IF ( FORMAT_VERBOSE ) THEN
        LKEY = CWD .EQ. 'BAND:' .OR. CWD .EQ. 'PASSBAND:' 
        IF ( .NOT. LKEY ) RETURN
        iwd   = 2  ! start location of filter relative to KEY
      ENDIF

      IF ( FORMAT_TERSE ) THEN
        LKEY = CWD .EQ. 'OBS:'
        IF ( .NOT. LKEY ) RETURN
        iwd   = 1 + ITERSE_FILTER  ! start location relative to OBS:
      ENDIF

      ccid    = SNLC_CCID
      NEWMJD  = ISNLC_NEWMJD_STORE + 1
      EPMIN   = ISNLC_NEPOCH_STORE + 1
      LL      = 1

      cfilt = cwords(iwd)(1:2)
      ep    = EPMIN - 1

      DO 100 WHILE ( LL .EQ. 1 )

c avoid common single-characters to denote comments
         if ( cfilt(1:1) .EQ. '#' ) LL = 999
         if ( cfilt(1:1) .EQ. '%' ) LL = 999
         if ( cfilt(1:1) .EQ. '!' ) LL = 999
         if ( cfilt(1:1) .EQ. '|' ) LL = 999 


         if ( FORMAT_TERSE .and. iwd .GT. ITERSE_FILTER+1 ) LL = 999

         if ( LL .EQ. 999 ) goto 100

c         ifilt_obs = FILTINDX(cfilt)
         ifilt_obs = FILTINDX_REPLACE(cfilt)
         ep = ep + 1

c         print*,' xxxx found ifilt_obs=',ifilt_obs,
c     &      '  for ',cfilt,' and ep=',ep,' iwd=',iwd, ' LL=',LL

c check epoch array bound.
         if ( ep .GT. MXEPOCH ) then
           write(c1err,660) ep, MXEPOCH
660        format('Epoch index EP=',I4,' exceeds MXEPOCH=',i4 )
           write(c2err,661) ccid, SNLC8_MJD(EPMIN) 
661        format('Check SN ', A8,' at MJD=',F9.3 )
           CALL MADABORT("PARSE_PASSBAND", c1err, c2err )
         endif

         ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD) = ep
         ISNLC_IFILT_OBS(ep) = ifilt_obs  ! store filt index
         ISNLC_NFILT_NEWMJD(NEWMJD) = 
     &   ISNLC_NFILT_NEWMJD(NEWMJD) + 1
         
c make sure that MJD & IDTEL are defined for each filter-epoch;
c not just the first filter.
         SNLC8_MJD(ep)     = SNLC8_MJD(EPMIN) 
         ISNLC_IDTEL(ep)   = ISNLC_IDTEL(EPMIN) 
         ISNLC_IDFIELD(ep) = ISNLC_IDFIELD(EPMIN) 
         SNLC_FIELD(ep)    = SNLC_FIELD(EPMIN)   ! July 16, 2013

         IFILT = IFILTDEF_INVMAP_SURVEY(ifilt_obs)
         if ( ifilt .LE. 0 .or. IFILT .GT. NFILTDEF_SURVEY ) THEN
            write(c1err,60) ifilt_obs, cfilt, ifilt

60          format('Undefined IFILT_OBS=',I3,' (',A4,'),  IFILT=',I2  )
            write(c2err,61) ccid, NEWMJD, SNLC8_MJD(EPMIN)
61          format('at CID=',A8,' , EPOCH=',I3,' , MJD=',F9.3 )
              CALL MADABORT("PARSE_PASSBAND", c1err, c2err)
         endif

         iwd = iwd + 1
         LL = INDEX( cwords(iwd), ' ' ) - 1
         cfilt = cwords(iwd)(1:2)

100   CONTINUE

      RETURN
      END

C ==============================================
+DECK,PARSE_SIM.
      SUBROUTINE PARSE_SIM ( isnlc, cwords, istat )
c
c parse SIM_xxx parameters if CWD starts with "SIM"
c cword(1) is the keyword; cword(2) is the value,c
c or cword(2-6) are the five values for ugirz.
c
c
c Apr 12 2017: check for SIM_LENSDMU
c
c Feb 28 2018: read LCLIB_PARVAL
c Dec 10 2018: read BYOSED_PARVAL, and allow more than 'SIM' key to continue
c Jun 18 2019: read SIM_SALT2gammaDM
c
c --------------

      IMPLICIT NONE

c subroutine args.

      INTEGER   isnlc           ! (I) SN sparese index to load
      CHARACTER cwords(*)*60    ! (I) words to parse
      INTEGER   ISTAT           ! (O) 0=OK;   <0 => skip this ISNLC

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      character   RETSTR*60, KEY*60

      REAL*8 RET8(MXFILT_OBS)
      INTEGER ifilt, IPAR, INDX, j
      LOGICAL LTMP, LPARSE, LMATCH

c functions
      LOGICAL READ_HEADKEY

C ----------- BEGIN ---------

      istat    = 0

      LPARSE = .FALSE.
      if ( CWORDS(1)(1:3) .EQ. 'SIM'    ) LPARSE = .TRUE.
      if ( CWORDS(1)(1:6) .EQ. 'BYOSED' ) LPARSE = .TRUE.
      if ( CWORDS(1)(1:6) .EQ. 'LCLIB'  ) LPARSE = .TRUE.

      if ( .not. LPARSE ) RETURN

c -----------------
      RETSTR = 'STRING'
      KEY  = 'SIM_MODEL_NAME'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         SIMNAME_MODEL = RETSTR(1:32)
      ENDIF

      RETSTR = 'STRING'
      KEY  = 'SIM_TYPE_NAME'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         SIMNAME_TYPE = RETSTR(1:12)
      ENDIF

      RETSTR = ''

      KEY  = 'SIM_MODEL_INDEX'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_MODEL_INDEX = INT(RET8(1))

      KEY  = 'SIM_TYPE_INDEX'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_GENTYPE = INT(RET8(1))

c - - - - - - - - - 
      KEY  = 'SIM_NON1a' ! legacy key name, 7.31 2018
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        INDX = INT(RET8(1))
        SIM_TEMPLATE_INDEX = INDX
        if ( .not.USESIM_SNIA .and. INDX .EQ. 0 ) ISTAT = -1
        if ( .not.USESIM_SNCC .and. INDX .GT. 0 ) ISTAT = -1
        if ( istat < 0 ) return
      ENDIF

      KEY  = 'SIM_TEMPLATE_INDEX'  ! new key name, 7.31.2018
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        INDX = INT(RET8(1))
        SIM_TEMPLATE_INDEX = INDX
        if ( .not.USESIM_SNIA .and. INDX .EQ. 0 ) ISTAT = -1
        if ( .not.USESIM_SNCC .and. INDX .GT. 0 ) ISTAT = -1

c check option to select specific SIM_TEMPLATE_INDEX (Dec 2018)
        if ( NSIM_TEMPLATE_INDEX_LIST > 0 ) then
           LMATCH = .FALSE.
           do j=1, NSIM_TEMPLATE_INDEX_LIST
              if(INDX == SIM_TEMPLATE_INDEX_LIST(j) ) LMATCH=.TRUE.
           enddo
           if ( .not. LMATCH ) ISTAT = -1
        endif

        if ( ISTAT < 0 ) return
      ENDIF
c - - - - - - - - - 

      KEY  = 'SIM_SEARCHEFF_MASK'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_SEARCHEFF_MASK = INT(RET8(1))

      KEY  = 'SIM_LIBID'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_LIBID = INT(RET8(1))

      KEY  = 'SIM_NGEN_LIBID'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_NGEN_LIBID = INT(RET8(1))

      KEY  = 'SIM_NOBS_UNDEFINED'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_NOBS_UNDEFINED = INT(RET8(1))

      KEY  = 'SIM_RA'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM8_RA = RET8(1)

      KEY  = 'SIM_DECL'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM8_DECL = RET8(1)

      KEY  = 'SIM_REDSHIFT'  ! allow legacy variable
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         SIM_REDSHIFT_CMB = SNGL(RET8(1))
      ENDIF

      KEY  = 'SIM_REDSHIFT_HELIO'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP )  SIM_REDSHIFT_HELIO = SNGL(RET8(1))

      KEY  = 'SIM_REDSHIFT_CMB'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP )  SIM_REDSHIFT_CMB = SNGL(RET8(1))

      KEY  = 'SIM_REDSHIFT_HOST'  ! Jan 2016
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP )  SIM_REDSHIFT_HOST = SNGL(RET8(1))

      KEY  = 'SIM_REDSHIFT_FLAG'  ! Apr 2019
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP )  SIM_REDSHIFT_FLAG = INT(RET8(1))

      KEY  = 'SIM_VPEC'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP )  SIM_VPEC = SNGL(RET8(1))

      KEY  = 'SIM_DLMU'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_DLMAG = SNGL(RET8(1))
      KEY  = 'SIM_DLMAG'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_DLMAG = SNGL(RET8(1))

      KEY  = 'SIM_LENSDMU'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_LENSDMU = SNGL(RET8(1))

      KEY  = 'SIM_MWEBV'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_MWEBV = SNGL(RET8(1)) 

      KEY  = 'SIM_PEAKMJD'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_PEAKMJD = SNGL(RET8(1))
      ENDIF

      KEY  = 'SIM_HOSTLIB_GALID'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_HOSTLIB_GALID = INT( RET8(1) )
      ENDIF

      KEY  = 'SIM_TEMPLATEMAG'
      RETSTR = 'FILTER'  ! flag to read NFILTDEF_READ filters
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      RETSTR = ' '
      IF ( LTMP ) THEN
        DO ifilt = 1, NFILTDEF_READ
           SIM_TEMPLATEMAG(ifilt) = SNGL ( RET8(ifilt) )
        ENDDO
      ENDIF

c ----------
c model parameters

      KEY  = 'SIM_SALT2x0'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_SALT2x0 = SNGL(RET8(1))

      KEY  = 'SIM_SALT2mB'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_SALT2mB = SNGL(RET8(1))

      KEY  = 'SIM_SALT2c'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_COLORPAR = SNGL(RET8(1))
        SIMNAME_COLORPAR = 'SIM_c'
cc xxx mark delete     SIMNAME_COLORPAR = 'SIM_SALT2c' ! Nov 2019
        SIMNAME_COLORLAW = 'SIM_beta'
      ENDIF

      KEY  = 'SIM_SALT2alpha'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
         SIM_SHAPELAW     = SNGL(RET8(1))
         SIMNAME_SHAPELAW = 'SIM_alpha'
      ENDIF

      KEY  = 'SIM_SALT2beta'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_COLORLAW = SNGL(RET8(1))

      KEY  = 'SIM_AV'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_AV           =  SNGL(RET8(1))

c store SIM_AV as the color param if NOT SALT2 model;
c otherwise leave SIM_AV as separate from SALT2c.
c Logic here may be a bit fragile.
        if ( SIM_MODEL_INDEX .NE. MODEL_SALT2 ) then
           SIM_COLORPAR     =  SIM_AV 
           SIMNAME_COLORPAR = 'SIM_AV'  ! Jul 2016: SIMAV->SIM_AV 
           SIMNAME_COLORLAW = 'SIM_RV'  ! Jul 2016: SIMRV->SIM_RV
        endif

      ENDIF

      KEY  = 'SIM_RV'  ! host RV
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_RV       = SNGL(RET8(1))
        if ( SIM_MODEL_INDEX .NE. MODEL_SALT2 ) then
          SIM_COLORLAW = SIM_RV
        endif
      ENDIF


      KEY  = 'SIM_MAGSMEAR_COH'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_MAGSMEAR_COH = SNGL(RET8(1))

      KEY  = 'SIM_SALT2gammaDM'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_SALT2gammaDM = SNGL(RET8(1))

      KEY  = 'SIM_STRETCH'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_SHAPEPAR     = SNGL(RET8(1))
        SIMNAME_SHAPEPAR = 'SIM_STRETCH'
      ENDIF

      KEY  = 'SIM_DELTA'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_SHAPEPAR     = SNGL(RET8(1))
        SIMNAME_SHAPEPAR = 'SIM_DELTA'
      ENDIF

      KEY  = 'SIM_DM15'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_SHAPEPAR     = SNGL(RET8(1))
        SIMNAME_SHAPEPAR = 'SIM_DM15'
      ENDIF

      KEY  = 'SIM_SALT2x1'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) THEN
        SIM_SHAPEPAR     = SNGL(RET8(1))
        SIMNAME_SHAPEPAR = 'SIM_x1'
cc xxx mark delete Dec 8 2019  SIMNAME_SHAPEPAR = 'SIM_SALT2x1'  ! Nov 2019
      ENDIF

c filter-dependent keys

      KEY  = 'SIM_PEAKMAG'
      RETSTR = 'FILTER'  ! flag to read NFILTDEF_READ filters
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      RETSTR = ' '
      IF ( LTMP ) THEN
        DO ifilt = 1, NFILTDEF_READ
           SIM_PEAKMAG(ifilt) = SNGL ( RET8(ifilt) )
        ENDDO
      ENDIF

c note that SIM_EXPOSURE_TIME is the same for
c each SN, so there is no ISNLC index.

      KEY  = 'SIM_EXPOSURE'
      RETSTR = 'FILTER'  ! flag to read NFILTDEF_READ filters
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      RETSTR = ' '
      IF ( LTMP ) THEN
        DO ifilt = 1, NFILTDEF_READ
           SIM_EXPOSURE_TIME(ifilt) = SNGL ( RET8(ifilt) )
        ENDDO
      ENDIF


c read SIMSED parameters 

      DO 401 IPAR = 1, NPAR_SIMSED
         KEY  = SIMSED_KEYWORD(IPAR)(1:60)
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
         IF ( LTMP ) THEN
           SIMSED_PARVAL(IPAR) = SNGL(RET8(1))
         ENDIF
401   CONTINUE  ! end IPAR

c read BYOSED parameters 

      DO 402 IPAR = 1, NPAR_BYOSED
         KEY  = BYOSED_KEYWORD(IPAR)(1:60)
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )     
         IF ( LTMP ) THEN
           BYOSED_PARVAL(IPAR) = SNGL(RET8(1))
         ENDIF
402   CONTINUE  ! end IPAR

c read LCLIB parameters 

      DO 410 IPAR = 1, NPAR_LCLIB
         KEY  = LCLIB_KEYWORD(IPAR)(1:60)
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
         IF ( LTMP ) THEN
           LCLIB_PARVAL(IPAR) = SNGL(RET8(1))
         ENDIF
410   CONTINUE  ! end IPAR


c read SIMSED parameters 

      DO 420 IPAR = 1, NPAR_SIM_HOSTLIB
         KEY  = SIM_HOSTLIB_KEYWORD(IPAR)
         LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
         IF ( LTMP ) THEN
           SIM_HOSTLIB_PARVAL(IPAR) = SNGL(RET8(1))
         ENDIF
 420  CONTINUE                  ! end IPAR

c - - - - 
      KEY  = 'SIM_SUBSAMPLE_INDEX'
      LTMP = READ_HEADKEY(isnlc, cwords, KEY, RET8, RETSTR )
      IF ( LTMP ) SIM_SUBSAMPLE_INDEX = INT(RET8(1))

      RETURN
      END     ! end of PARSE_SIM

C ==============================================
+DECK,PARSE_PRIVATE.
      SUBROUTINE PARSE_PRIVATE_TEXT(cword)

c  Nov 24, 2012
c  Check for private variable indicated by
c     PRIVATE(varName):  <value>
c
c  On reading header, store list of private variable names
c  in PRIVATE_KEYWORD and PRIVATE_VARANME. 
c
c input args.

      IMPLICIT NONE
      CHARACTER cword*(*)    ! (I) word to parse

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      integer LEN_NAME, IVAR_PRIVATE, NMATCH

c  function
      INTEGER NMATCH_PRIVATE

c ---------------- BEGIN ----------------

      IF ( CWORD(1:8) .NE. 'PRIVATE(' ) RETURN
      
      LEN_NAME = INDEX(CWORD, ':') - 1
      if ( LEN_NAME .LE. 0 ) RETURN  
c -----------------


      IF ( LFLAG_RDHEAD_ONLY ) THEN
        NVAR_PRIVATE = NVAR_PRIVATE + 1
        CALL PARSE_PRIVATE_KEYWORD( CWORD, NVAR_PRIVATE )
      ELSE

c here we check that no new private variables are added 
c after the first file. Make sure to exclude the colon (:) 
c from the keyname read from the text file.


        NMATCH = NMATCH_PRIVATE(CWORD(1:LEN_NAME),IVAR_PRIVATE)
        if ( NMATCH .EQ. 0 ) then
           c1err = 'Unknown PRIVATE var = ' // CWORD(1:LEN_NAME)
           c2err = 'for CID = ' // SNLC_CCID(1:ISNLC_LENCCID)
           CALL MADABORT("PARSE_PASSBAND", c1err, c2err)
        endif
      ENDIF

      RETURN
      END

C =======================
+DECK,PRSPRVKEY.
      SUBROUTINE PARSE_PRIVATE_KEYWORD(CWORD, IVAR_PRIVATE)

c For input CWORD = 'PRIVATE($VARNAME)', strip out the $VARNAME
c and load PRIVATE_VARNAME(IVAR_PRIVATE) = $VARNAME
c
c Jul 23 2015: check PRIVATE_REDSHIFT_CMB key

      IMPLICIT NONE

c input args
      CHARACTER CWORD*60     ! (I) text string to parse
      INTEGER IVAR_PRIVATE   ! (I) PRIVATE parameter index

c local args
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      INTEGER J1, J2, LK, IVAR, LEN_NAME, LENZ, NMATCH, icut
      INTEGER NWD, LWD1, LWD2, LWD3, MSKOPT
      CHARACTER VARNAME*60, STR*(MXCHAR_CUTNAME), CUTSTRING*30
      CHARACTER CWD1*60, CWD2*60, CWD3*60

      LOGICAL LCUTWIN
      REAL*8 CUTWIN(2)

c function
      INTEGER NMATCH_PRIVATE

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------------- BEGIN --------------

c store keyword WITHOUT the ':' on the end.
      LK = INDEX( CWORD , ':' ) - 1
      IF ( LK .LT. 0 ) LK = INDEX(CWORD,' ' ) - 1
      PRIVATE_KEYWORD(IVAR_PRIVATE) = CWORD(1:LK)

c now extract the parameter name from inside the ().
c For example, if KEYWORD = 'PRIVATE(BLA):'
c then the VARNAME is 'BLA'.

      J1 = INDEX( CWORD , '(' ) 
      J2 = INDEX( CWORD , ')' ) 

      IF ( J1 .EQ. 0 .or. J2 .EQ. 0 ) THEN
         c1err = 'Invalid PRIVATE_KEYWORD = ' // CWORD(1:LK)
         c2err = 'Expecting to find key-string  PRIVATE(PARNAME)'
         CALL MADABORT("PARSE_PRIVATE_KEYWORD", c1err,c2err)
      ENDIF


      VARNAME = CWORD(j1+1:j2-1)
      LEN_NAME = INDEX(VARNAME // ' ', ' ' ) - 1

c load parameter name into global variable

      PRIVATE_VARNAME(IVAR_PRIVATE) = VARNAME

c ----------------------------------------------------
c make sure that this NAME has not already been used

      NMATCH = NMATCH_PRIVATE(VARNAME,IVAR)

      IF ( NMATCH > 1 ) then
         c1err = 'found duplicate PRIVATE variable: ' 
     &                // VARNAME(1:LEN_NAME)
         c2err = 'Check PRIVATE(XXX) keys'
         CALL MADABORT("PARSE_PRIVATE_KEYWORD", c1err,c2err)
      ENDIF

c -------- check for cut on private var (Nov 4 2014) ---------
      LCUTWIN = .FALSE.
      CUTSTRING = ''
      DO 400 icut = 1, MXCUT_PRIVATE

         STR = PRIVATE_CUTWIN_STRING(icut)  ! 'VARNAME CUTMIN CUTMAX'
         if ( STR .EQ. '' ) GOTO 400
 
c        skip if already found
         CUTWIN(2) = PRIVATE_CUTWIN(2,IVAR_PRIVATE) 
         if ( CUTWIN(2) < .99*CUTVAL_OPEN ) GOTO 400

c break up string into pieces
         MSKOPT = MSKOPT_PARSE_WORDS_STRING
         NWD = STORE_PARSE_WORDS(MSKOPT,STR//' '//char(0), 60)
         call get_PARSE_WORD_fortran(1,CWD1,LWD1)

         if ( VARNAME .EQ. CWD1 ) then
            NCUT_PRIVATE = NCUT_PRIVATE + 1
            LCUTWIN = .TRUE.

            call get_PARSE_WORD_fortran(2,CWD2,LWD2)
            call get_PARSE_WORD_fortran(3,CWD3,LWD3)

            read(CWD2,*) CUTWIN(1)
            read(CWD3,*) CUTWIN(2)

            PRIVATE_CUTWIN(1,IVAR_PRIVATE) = CUTWIN(1)
            PRIVATE_CUTWIN(2,IVAR_PRIVATE) = CUTWIN(2)

            USE_PRIVATE_CUTWIN(icut) = 1 ! set logical flag

            write(CUTSTRING,444) CUTWIN
 444        format('CUT: ',G9.3,' to ', G9.3)
         endif
 400  CONTINUE


c -----------------------------------------
c check option to use private redshift
c e.g., from fakes overlaid on images

      LENZ = INDEX(PRIVATE_REDSHIFT_CMB,' ' ) - 1
      IF ( LENZ .EQ. LEN_NAME .and. 
     &     VARNAME(1:LENZ) .EQ. PRIVATE_REDSHIFT_CMB(1:LENZ) ) THEN
         IVAR_PRIVATE_REDSHIFT = IVAR_PRIVATE
         print*, ' '
         print*,
     &     '# ======================================================= '
         write(6,30) VARNAME(1:LENZ)
 30      format(' # NOTICE: Use PRIVATE variable ',A,
     &          ' for REDSHIFT_CMB')
         print*,
     &     '# ======================================================= '
         print*,' '
      ENDIF

c ----------------------------
c print one-line summary

      write(6,500) CWORD(1:LK), CUTSTRING
 500  format(T4,'Found ',A, T50,A)
      call flush(6)

      RETURN
      END

C ===============================
+DECK,NMAPRIV.
      INTEGER FUNCTION NMATCH_PRIVATE(NAME,IVAR_PRIVATE)

c
c Return number of NAME matches ; check both
c PRIVATE_VARNAME and PRIVATE_KEYWORD.
c Also returns IVAR_PRIVATE that is valid if NMATCH=1

      IMPLICIT  NONE
      CHARACTER NAME*(*)
      INTEGER   IVAR_PRIVATE
+CDE,SNPAR.
+CDE,PRIVCOM.

      INTEGER 
     &   IVAR 
     &  ,LEN_TMP, LEN_NAME
     &  ,NMATCH

      CHARACTER TMPNAME*60

C --------------- BEGIN --------------

      IVAR_PRIVATE   = -9
      NMATCH_PRIVATE =  0
      NMATCH         =  0
      LEN_NAME       = INDEX(NAME//' ' , ' ') - 1

      DO 30 IVAR = 1, NVAR_PRIVATE
        TMPNAME  = PRIVATE_VARNAME(IVAR)
        LEN_TMP  = INDEX(TMPNAME,' ') - 1
        IF ( LEN_TMP .NE. LEN_NAME ) goto 30

        if ( NAME(1:LEN_NAME) .EQ. TMPNAME(1:LEN_NAME) ) then
           IVAR_PRIVATE = IVAR
           NMATCH = NMATCH + 1
        endif
30    CONTINUE

c check the full name 'PRIVATE($VARNAME)'

      DO 32 IVAR = 1, NVAR_PRIVATE
        TMPNAME  = PRIVATE_KEYWORD(IVAR)
        LEN_TMP  = INDEX(TMPNAME,' ') - 1
        IF ( LEN_TMP .NE. LEN_NAME ) goto 32

        if ( NAME(1:LEN_NAME) .EQ. TMPNAME(1:LEN_NAME) ) then
           IVAR_PRIVATE = IVAR
           NMATCH = NMATCH + 1
        endif

32    CONTINUE


      NMATCH_PRIVATE = NMATCH

      RETURN
      END

C =========================================
+DECK,GETPRIV.
      DOUBLE PRECISION FUNCTION  GET_PRIVATE_VALUE(NAME,OPTERR)

c
c Nov 25, 2012
c Return value of PRIVATE variable whose name is NAME.
c
c If NAME is invalid:
c OPTERR =  0 -> on error return PRIVATE_NULL, but do NOT abort
c OPTERR = +1 -> abort on error
c   (note that OPTERR is an input instruction flag, not a return status)
c -----------------------

      IMPLICIT NONE

      CHARACTER NAME*(*)  ! (I) name of private variable
      INTEGER   OPTERR    ! (I) error instructions

c local var
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      INTEGER IVAR_PRIVATE, NMATCH

c function
      INTEGER NMATCH_PRIVATE

C --------------- BEGIN ------------

      GET_PRIVATE_VALUE = PRIVATE_NULL  ! init

      NMATCH = NMATCH_PRIVATE(NAME,IVAR_PRIVATE)

c -------------------------------------------------

      IF ( IVAR_PRIVATE < 0 ) THEN
        IF( OPTERR .EQ. 0 ) THEN
           RETURN   ! do nothing; let user deal with it
        ELSE
           C1ERR = 'Cannot find required PRIVATE_VARNAME = ' 
     &           // NAME(1:28)
           C2ERR = 'Check CID = ' // SNLC_CCID(1:ISNLC_LENCCID)
           CALL MADABORT("GET_PRIVATE_VALUE", c1err, c2err) 
        ENDIF
      ENDIF

c set return value
      GET_PRIVATE_VALUE = PRIVATE_VALUE(IVAR_PRIVATE)

      RETURN
      END

C ========================================
+DECK,DEFPRIV.
      SUBROUTINE DEFINE_PRIVATE_VAR(VARNAME_STRING)

c Created Dec 11, 2012 by R.Kessler
c Interface to define PRIVATE variables from private code
c instead of from data files.
c VARNAME_STRING = 'NEWVAR' -> add one variable to list
c VARNAME_STRING = 'NEWVAR1 NEWVAR2 NEWVAR3' 
c      -> add these three variable to list
c
c This routine can be called an arbitrary number of times
c from USRINI.
c
c Output:
c  - Increments NVAR_PRIVATE
c  - sets PRIVATE_VARNAME(NVAR_PRIVATE)
c  - sets PRIVATE_KEYWORD(NVAR_PRIVATE)

      IMPLICIT NONE
      CHARACTER VARNAME_STRING*(*) ! (I) string of var name(s)

+CDE,SNPAR.
+CDE,PRIVCOM.
c +CDE,PARSECOM.

      INTEGER iwd, NWD, N, LL, LEN_WD, LEN_KEY, MSKOPT
      CHARACTER cwd*60, c1err*72, c2err*72

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ---------------- BEGIN -----------------

      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD = STORE_PARSE_WORDS(MSKOPT,VARNAME_STRING//' '//char(0),80)

      DO 200 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd,cwd,LL)

         if ( cwd .EQ. ' ' ) goto 200
         LEN_WD = INDEX(CWD(1:LL)//' ',' ') - 1

         NVAR_PRIVATE = NVAR_PRIVATE + 1
   
         N = NVAR_PRIVATE

         IF ( N > MXVAR_PRIVATE ) GOTO 200

         PRIVATE_VARNAME(N) = cwd
         PRIVATE_KEYWORD(N) = 'PRIVATE(' // cwd(1:LEN_WD) // ')'

         LEN_KEY = INDEX(PRIVATE_KEYWORD(N)//' ',' ') - 1
         write(6,20) PRIVATE_KEYWORD(N)(1:LEN_KEY)
20       format(T5,'Store User-Defined ',A)

200   CONTINUE


c Check array bound.

      IF ( N .GT. MXVAR_PRIVATE ) THEN
        write(c1err,61) N, MXVAR_PRIVATE
        c2err = 'Define fewer PRIVATE vars of increase MXVAR_PRIVATE.'
61      format('NVAR_PRIVATE=',I3,
     &       ' exceeds bound of MXVAR_PRIVATE=',I3)

        CALL MADABORT('DEFINE_PRIVATE_VAR', C1ERR, C2ERR)
      ENDIF

      RETURN
      END   ! end of DEFINE_PRIVATE_VAR


C ==============================================
+DECK,PRS_SEARCH.
      SUBROUTINE PARSE_SEARCH ( cwords, istat )
c
c parse SEARCH_xxx parameters if CWD starts with "SIM"
c cword(1) is the keyword; cword(2) is the value,c
c or cword(2-6) are the five values for ugirz.
c
c Returns istat = -1 if TYPE is not valid
c
c
c Jun 02 2017: allow SNTYPE or TYPE keyword in ascii format.
c              
C -----------------

      IMPLICIT NONE

c input args.

      CHARACTER cwords(*)*60    ! (I) words to parse
      INTEGER   ISTAT           ! (O) 0=OK;   <0 => skip this ISNLC

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      character cwd*60, cwd_next*60
      LOGICAL LTMP, LTMP1, LTMP2, LTMP3, LSDSS 
      integer itype

c function
      INTEGER SNTYPESTAT

C ----------- BEGIN ---------

      istat    = 0
      cwd      = cwords(1)
      cwd_next = cwords(2)

      LTMP1 = CWD(1:6) .EQ. "SEARCH"
      LTMP2 = CWD(1:6) .EQ. "SNTYPE"   ! allow this keyword too
      LTMP3 = CWD(1:4) .EQ. "TYPE"     ! Jun 2, 2017
      if ( .not. ( LTMP1 .or. LTMP2 .or. LTMP3 )  )  then
c if there is TYPE-cut, set bit for 'applied TYPE-cut'
        if ( NSNTYPE_LIST .LE. 0 ) then
          istat = SNTYPESTAT(itype)  
        endif
        RETURN
      endif

c check search TYPE if NSNTYPE_LIST > 0 && one of the keywords exists;
c otherwise don't bother checking and accept everything.
c "SNTYPE:" is the newer keyword, and SEARCH_SNTYPE is the
c legacy keyword used only by SDSS

      LSDSS = SURVEY_NAME(1:4) .EQ. 'SDSS'       
      LTMP1 = (cwd .EQ. 'SEARCH_TYPE:') .and. LSDSS
      LTMP2 = (cwd .EQ. 'SNTYPE:' .or. cwd .EQ. 'TYPE:' )
     &        .and. (.NOT. LSDSS)
      LTMP  = LTMP1 .or. LTMP2 

      if ( LTMP ) then
          read(cwd_next,*) itype
          ISNLC_TYPE = itype

          istat = SNTYPESTAT(itype)
          if ( istat .LT. 0 ) return
      endif

      RETURN
      END  ! end of PARSE_SEARCH


C ==============================
+DECK,PARSE_FILTERSTRING.
      SUBROUTINE PARSE_FILTSTRING(OPT,string, NFILT, IFILTDEF, XFILTVAL)

c -------------------------------
c Created May 2008 by R.Kessler
c
c Translate input STRING into filter indices
c and values. Assume STRING is of the form
c
c  STRING = 'cfilt1 xval1  cfilt2  xval2 cfilt2 xval2 ...'
c
c where a float-value follows each single-char
c filter-string.
c
c Oct 26 2015: replace MXFILT_OBS arg with NFILT
c Dec 27 2015: fix bug initializing IFILTDEF and XFILTVAL
c              Loop 1-NFILT instead of 1-MXFILT_OBS
c
c May 20 2016: declare output arrays (MXFILT_OBS) instead of (NFILT)
c
c Feb 20 2017: update to allow multiple bands gluded together.
c              'gri .01'  is equivalent to  'g .01  r .01  i .01'
c
c --------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

c subroutine args
      CHARACTER string*(*)  ! (I) string to parse

      INTEGER  
     &   OPT                  ! (I) 1=> error check obs filter
     &  ,NFILT                ! (O) number of filters in string
     &  ,IFILTDEF(MXFILT_OBS) ! (O) absolute filter indices
     
      REAL  
     &   XFILTVAL(MXFILT_OBS)   ! (O) float values

c local var

      INTEGER iwd, NWD, ifilt_tmp, LEN, NFILT_TMP, NFILT_LAST, i
      INTEGER MSKOPT
      CHARACTER cwd*(MXCHAR_FILEWORD), band*2
      REAL VAL
      LOGICAL LERR

c function
      INTEGER FILTINDX
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
c --------------- BEGIN ------------

      NFILT = 0
      IFILT_TMP = 0
     
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD = STORE_PARSE_WORDS(MSKOPT,STRING//char(0), 80)

      DO i = 1, MXFILT_OBS
        IFILTDEF(i) = 0
        XFILTVAL(i) = 0.  ! init output to zero
      ENDDO

      NFILT_LAST = 0
      DO 200 iwd = 1, NWD

         CALL get_PARSE_WORD_fortran(iwd,cwd,NFILT_TMP)

         if ( IFILT_TMP == 0 ) then     
            NFILT_LAST = NFILT
            do i = 1, NFILT_TMP
              BAND            = cwd(i:i)
              NFILT           = NFILT + 1      
              IFILT_TMP       = FILTINDX(BAND)
              IFILTDEF(NFILT) = IFILT_TMP

c require valid observer-filter if OPT=1
              LERR = IFILTDEF_INVMAP_SURVEY(IFILT_TMP) .LE. 0
              if ( LERR .and. OPT==1 ) then
                LEN = index(cwd,' ') - 1
                c1err = 'Invalid obs-frame filter = '''
     &             // BAND // ''' from nml string'
                c2err = '= ''' // string(1:60) // '''  '
                CALL MADABORT("PARSE_FILTSTRING", c1err, c2err )
              endif
           enddo
         else
            read(cwd,*) VAL
            do i = NFILT_LAST+1, NFILT_LAST+NFILT_TMP
               XFILTVAL(i) = VAL
            enddo
            ifilt_tmp = 0
         endif
200   CONTINUE


      RETURN
      END   ! PARSE_FILTSTRING


C ====================================================
+DECK,PARSE_INTLIST.
      INTEGER FUNCTION PARSE_INTLIST(STRING_INLIST,OUTLIST)

c Created Jan 25 2018
c Translate comma-separated list of integers in STRING_LIST
c into array of integers (OUTLIST).
c Function returns number of integers in OUTLIST array.
c
      IMPLICIT NONE 

+CDE,SNPAR.
      INTEGER   MXINT
      PARAMETER (MXINT=10)

      CHARACTER STRING_INLIST*60    ! (I) comma-separated list of integers
      INTEGER   OUTLIST(MXINT)      ! (O) output array of integers
     
c local arg

      INTEGER iwd, NWD, LEN, MSKOPT
      CHARACTER CWD*60, C1ERR*72, C2ERR*72
C function
      INTEGER STORE_PARSE_WORDS

C ---------------- BEGIN ----------------
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      LEN    = INDEX(STRING_INLIST,' ') - 1
      NWD    = STORE_PARSE_WORDS(MSKOPT,STRING_INLIST//char(0),LEN)

      IF ( NWD > MXINT ) THEN
         write(c1err,61) NWD, MXINT
 61      format('NWD=',I2,' exceeds bound of MXINT=',I2)
         write(c2err,62) STRING_INLIST(1:LEN)
 62      format('STRING_INLIST=',A)
         CALL MADABORT("PARSE_INTLIST", c1err, c2err )
      ENDIF

      DO 200 iwd = 1, NWD
         CALL get_PARSE_WORD_fortran(iwd,cwd,LEN)
         READ(cwd,*) OUTLIST(iwd)
ccc         print*,' xxx ', iwd, OUTLIST(iwd)
 200  CONTINUE

      OUTLIST(NWD+1) = 0

      PARSE_INTLIST = NWD
      RETURN
      END

C ===========================================
+DECK,PARSE_SNCCID_LIST.
      SUBROUTINE PARSE_SNCCID_LIST(LINE) 

c Created May 30 2019
c Parse command LINE argument and load SNCCID_LIST array
c LINE = '2004hq,2006ab' -> SNCCID_LIST = '2004hq', '2006ab'
c 
c
      IMPLICIT NONE

      CHARACTER LINE*(*)

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER  MSKOPT, NWD, iwd, LL
      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------------- BEGIN ------------

      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      NWD    = STORE_PARSE_WORDS(MSKOPT,LINE//char(0),100)
       
      DO iwd = 1, NWD
         CALL get_PARSE_WORD_fortran(iwd,SNCCID_LIST(iwd),LL)
c        LL = INDEX(SNCCID_LIST(iwd),' ') - 1
c	 print*,' xxx SNCCID = |', SNCCID_LIST(iwd)(1:LL), '|'
      ENDDO
      
      RETURN
      END    ! PARSE_SNCCID_LIST

C ====================================================
+DECK,PARSE_NML_STRLIST.
      INTEGER FUNCTION PARSE_NML_STRINGLIST(STRLIST,NCHAR)

c Created Mar 12 2015 by R.Kessler
c Function returns number of non-null elements,
c and parses strings separated by blanks.
c
c The following inputs all produce the same output
c
c Input: 
c      STRLIST = 'E1', 'E2', 'S1', 'S2'
c          or
c      STRLIST = 'E1 E2 S1 S2'
c          or
c      STRLIST = 'E1 E2',  'S1 S2'

c all produce  Output:  
c    STRLIST = 'E1', 'E2', 'S1', 'S2'  
c    and FUN=4
c
c ------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
c +CDE,PARSECOM.

      INTEGER NCHAR   ! (I)
      CHARACTER STRLIST(MXLISTNML)*(NCHAR) ! (I,O)

c local var

      CHARACTER STRLIST_LOCAL(MXLISTNML)*(NCHAR)
      INTEGER i, j, NLIST, iwd, NWD, LL, MSKOPT

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
      
C ------------- BEGIN ------------

      NLIST = 0 
      MSKOPT = MSKOPT_PARSE_WORDS_STRING

c transfer input string to local string
      DO i = 1, MXLISTNML
         STRLIST_LOCAL(i) = STRLIST(i)
      ENDDO

      i = 1
      DO WHILE ( STRLIST_LOCAL(i) .NE. '' ) 

c remove optional '+' symbols between strings, and substitute blank.
         DO j = 1, NCHAR
           IF ( STRLIST_LOCAL(i)(j:j) .EQ. '+' ) then
              STRLIST_LOCAL(i)(j:j) = ' '
           endif
         ENDDO
         
         NWD = STORE_PARSE_WORDS(MSKOPT,STRLIST_LOCAL(i)//char(0),100)
       
         DO iwd = 1, NWD
            NLIST = NLIST + 1
            CALL get_PARSE_WORD_fortran(iwd,STRLIST(NLIST),LL)
         ENDDO

         i = i + 1

      END DO  ! end while

      PARSE_NML_STRINGLIST = NLIST

      RETURN
      END  ! end of PARSE_NML_STRINGLIST

C ====================================================
+DECK,CIDSTR.
      SUBROUTINE CIDSTRING(CID,CCID,LENCCID)
c
c Created Jan 15, 2011
c If integer CID < 1 million, return 6-char CCID and LENCCID=6;
c otherwise return 8-char CCID and LENCCID=8.
c   
      IMPLICIT NONE
+CDE,SNPAR.

      INTEGER   CID                ! (I) integer cand. id
      CHARACTER CCID*(MXCHAR_CCID)  ! (O) char-string for CCID
      INTEGER   LENCCID            ! (O) length of string

c local
      CHARACTER C1ERR*72, C2ERR*72

c ----------- BEGIN -----------

      IF ( CID .LT. 1000000 ) THEN    ! 1 million
         write(ccid,26) CID
26       format(I6.6)
         LENCCID = 6
      ELSE IF ( CID < 100000000 ) THEN  ! 100 million
         write(ccid,28) CID
28       format(I8.8)
         LENCCID = 8
      ELSE IF ( CID < MXCID ) THEN
         write(ccid,29) CID
29       format(I9.9)
         LENCCID = 9
      ELSE
         write(C1ERR,66) CID, MXCID
66       format('CID=',I9,' exceeds bound (MXCID=', I9,')' )
         C2err = '   '
         CALL MADABORT("CIDSTRING", c1err, c2err )
      ENDIF
      
      RETURN
      END

C ===============================================
+DECK,FILTREPLACE.
      INTEGER FUNCTION FILTINDX_REPLACE ( cfilt )

c Created Jun 2013 by RK.
c Same as FILTINDX, but apply FILTER_REPLACE (see INIT_FILTER_REPLACE)
c Examples:
c   FILTER_REPLACE = ''       : do exactly the same thing as FILTINDX.
c   FILTER_REPLACE = 'U -> u' : for U filter, return index for 'u'
c
c ------

      IMPLICIT NONE
      character cfilt*(*)  ! (I) filter name to parse

c local args
+CDE,SNPAR.
+CDE,FILTCOM.

      INTEGER   IFILTDEF_ORIG
c  function
      INTEGER FILTINDX

C ---------------- BEGIN ---------------
      IFILTDEF_ORIG    =  FILTINDX(CFILT)
      FILTINDX_REPLACE =  IFILTOBS_REPLACE(IFILTDEF_ORIG)

      RETURN
      END

C ===============================================
+DECK,FILTINDX.
      INTEGER FUNCTION FILTINDX ( cfilt )
c
c May 2008 R.Kessler
c Returns absolute integer filter-index 1:MXFLT_ALL by
c parsing character name "cfilt".
c Assumes that last character is the 1-char symbol;
c i.e, SDSS-g => g,  CTIO4m-R => R, etc ...

      IMPLICIT NONE
      character cfilt*(*)  ! (I) filter name to parse

+CDE,SNPAR.
+CDE,FILTCOM.


      integer LL, ifilt
      character cfilt1*1, ctest*1


c ----------- BEGIN -----------

      FILTINDX = 0

      LL  = index(CFILT//' ',' ' ) - 1     
      cfilt1 = CFILT(LL:LL)

      DO ifilt = 1, MXFILT_ALL
        ctest = filtdef_string(ifilt:ifilt)
        if ( ctest(1:1) .eq. cfilt1(1:1) ) then
           FILTINDX = ifilt
           return
        endif
      ENDDO

      RETURN
      END

C ==============================
+DECK,ISBXFILT.
      LOGICAL FUNCTION ISBXFILT(IFILT,NAME,FRAME)

c Created May 2012
c Set global locical EXIST_BXFILT_OBS[REST]=T if this
c X-filter contains 'BX'.
c

      IMPLICIT NONE

c function args

      INTEGER IFILT  ! absolute filter index
      CHARACTER
     &   NAME*(*)    ! full name of filter
     &  ,FRAME*(*)   ! 'OBS' or 'REST'

+CDE,SNPAR.
+CDE,FILTCOM.

      INTEGER JX
      CHARACTER C2*2

C ----------------- BEGIN ----------------

      ISBXFILT = .FALSE.
      IF ( IFILT .NE. IFILT_BESS_BX ) RETURN

      JX = INDEX(NAME,'X')

      IF ( JX .GT. 1 ) THEN
          C2 = NAME(JX-1:JX)
          IF( C2 .EQ. 'BX' ) then
             ISBXFILT = .TRUE.
          else
             return
          endif

c now that ISBXFILT=T  set global logical 
          IF ( FRAME .EQ. 'OBS'  ) EXIST_BXFILT_OBS  = .TRUE.
          IF ( FRAME .EQ. 'REST' ) EXIST_BXFILT_REST = .TRUE.

      ELSE

          IF ( FRAME .EQ. 'OBS'   ) ISBXFILT = EXIST_BXFILT_OBS 
          IF ( FRAME .EQ. 'REST'  ) ISBXFILT = EXIST_BXFILT_REST

      ENDIF

      RETURN
      END

C ==========================================
+DECK,MWEBVFUDGE.
      REAL FUNCTION MWEBV_FUDGE(MWEBV)
c
c NOV 29 2017: *** OBSOLETE FUNCTION *****
c
c Return MWEBV with user-requested fudges (if any are specified).
c Abort of MWEBV < 0.
c
c -------------------

      IMPLICIT NONE

      REAL  MWEBV  ! (I) Galactic E(B-V) read from data file

+CDE,SNDATCOM.
+CDE,SNLCINP.

C --------------- BEGIN ---------------

      if ( MWEBV .LT. 0.0 ) then
         write(c1err,662) MWEBV,  SNLC_CCID
662      format('MWEBV=',F8.2,' is negative for SN ', A8,'  ?!?!?!' )
         c2err = 'Check MWEBV: in data file header'
         CALL MADABORT("MWEBV_FUDGE", c1err, c2err )
      endif

      MWEBV_FUDGE = (MWEBV * MWEBV_SCALE)  +  MWEBV_SHIFT

      RETURN
      END
C ================================================      
+DECK,GET_IDTEL.
      INTEGER FUNCTION GET_IDTEL ( tel_name )
c
c May 2008
c Return integer ID for this telescope name
c IDTEL is from $SNDATA_ROOT/SURVEY.DEF
c
c Allow data files to have extra characters such as
c "sdss-2.5m" for sdss and 'CTIO4m" for CTIO
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.


      character tel_name*(*)  ! name of telescope

c local
      character tel_upper*60
      INTEGER LL, i

c --------------- BEGIN -----------------

      GET_IDTEL = -9

      CALL UPCASE(tel_name, tel_upper) ! returns tel_upper
      if ( tel_upper(1:3) .EQ. 'ALL' ) then
        GET_IDTEL = 0
        return
      endif

      DO i = 1, NIDTEL_LIST
        LL = INDEX(SNTEL_LIST(i),' ' ) - 1
        if ( tel_upper(1:LL) .EQ. SNTEL_LIST(i)(1:LL) ) then
          GET_IDTEL = IDTEL_LIST(i)
        endif
      END DO

      RETURN
      END


C ================================================      
+DECK,GET_IDFIELD.
      INTEGER FUNCTION GET_IDFIELD ( field_name )
c
c May 2009
c Return integer ID for this FIELD.
c IDFIELD is defined $SNDATA_ROOT/SURVEY.DEF
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      character field_name*(*)  ! name of telescope

c local
      character field_upper*60
      INTEGER LL, i
c --------------- BEGIN -----------------

      GET_IDFIELD = -9

      CALL UPCASE(field_name, field_upper) ! returns field_upper

      if ( field_upper(1:3) .EQ. 'ALL' ) then
        GET_IDFIELD = 0
        return
      endif

      DO i = 1, NIDFIELD_LIST  ! user-list of fields
        LL = INDEX(SNFIELD_LIST(i),' ' ) - 1 
        IF ( FIELD_UPPER(1:LL) .EQ. SNFIELD_LIST(i)(1:LL) ) THEN
          GET_IDFIELD = IDFIELD_LIST(i)
        ENDIF
      END DO

      RETURN
      END         ! end of GET_IDFIELD


C ==================================
+DECK,READ_HEADKEY.
      LOGICAL FUNCTION READ_HEADKEY(ISN, CWORDS, KEYNAME, RET8, RETSTR)
c
c
c READ header KEYNAME and return value either as
c - double precision TMP8 or 
c - string RETSTR if input RETSTR = 'STRING'
c
c Input RETSTR options:
c  = 'FILTER'   --> read NFILTDEF_READ consecutive values.
c  = '+ERR'     --> read VALUE +- ERROR, return RET8(1:2) = VALUE and ERROR
c
c
c For the FITS format with the FILTER option, each filter-key 
c is assumed to have the name KEYNAME_[filter]; i.e., KEYNAME
c is a prefix for the FILTER option.
c
c The CWORDS strings are used for text-format only.
c Return function value is TRUE if KEYNAME is read; 
c false if not read.
c
c Dec 17, 2012: new '+ERR' option to read both VALUE and VALUE_ERR
c
c Jan 24 2018: 
c  + update  ASCII check to allow both ways of specifying error:
c     KEY:  XXX +- XXX_ERR   ! one key with two values
c         or
c     KEY:     XXX        ! separate key for value ...
c     KEY_ERR: XXX_ERR    ! and for error
c Basic idea is to return IGNORE_HEADVAL for missing information
c so that calling routine knows what value(s) to use.
c
c Apr 30 2018:
c   + fix bug setting KEYERR_MATCH = DO_ERR and (old logic)
c
c --------------------

      IMPLICIT NONE

c function arguments
      INTEGER    ISN    ! (I) SN index (used for fits-format only)
      CHARACTER  
     &   CWORDS(*)*60   ! (I) string to check for text-format 
     &  ,KEYNAME*(*)    ! (I) header key to read
 
      REAL*8    RET8(*)    ! (O) return value if int, float or double
      CHARACTER RETSTR*60  ! (I/O) return value of string

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FITSCOM.

      INTEGER 
     &   LENKEY, LENKEY2
     &  ,NRD, IRD, IROW, LRET, NRET, IFILT_OBS

      LOGICAL 
     &   DO_RETSTR, DO_RET8, DO_FILT, DO_ERR, ISPM
     &  ,KEY_MATCH, KEYERR_MATCH
      CHARACTER
     &   KEY_SEARCH*60, KEYERR_SEARCH*60
     &  ,TMPSTR*80, CFILT*1, CPM*2

C ----------------- BEGIN -----------------

      RET8(1) = DBLE(-9.0)

      READ_HEADKEY = .FALSE.
      LENKEY  = INDEX(KEYNAME,' ') - 1

      DO_FILT     = ( RETSTR(1:4) .EQ. 'FILT'   ) 
      DO_ERR      = ( RETSTR(1:4) .EQ. '+ERR'    ) 
      DO_RETSTR   = ( RETSTR(1:6) .EQ. 'STRING' ) 
      DO_RET8     = (.NOT. DO_RETSTR)      

      IF ( DO_FILT ) THEN
         NRD = NFILTDEF_READ
      ELSE IF ( DO_ERR ) THEN
         NRD = 2     ! VALUE  &  ERROR
         CPM = '+-'  ! optional symbol between VAL and ERR
      ELSE
         NRD = 1
      ENDIF
      
c --------------------------

      IF ( FORMAT_FITS ) THEN

         IROW          = ABSO_INDEX(isn)

         DO 50 IRD = 1, NRD

           if ( DO_FILT ) then  ! IRD = IFILT
             ifilt_obs  = IFILTDEF_MAP_SURVEY(ird)
             cfilt      = FILTDEF_STRING(ifilt_obs:ifilt_obs)
             KEY_SEARCH = KEYNAME(1:LENKEY) // 
     &                      '_' // CFILT // char(0)
             LENKEY2 = LENKEY + 2

           else if ( DO_ERR ) then  ! read KEY and KEY_ERR
             if ( IRD .EQ. 1 ) then
                KEY_SEARCH = KEYNAME(1:LENKEY) // char(0)
             else
                KEY_SEARCH = KEYNAME(1:LENKEY) // '_ERR' // char(0)
             endif

           else    ! read single key
             KEY_SEARCH = KEYNAME(1:LENKEY) // char(0)
             LENKEY2 = LENKEY 
           endif

           IPARFITS_HEAD = IPARFITS_HEAD + 1

           IF ( DO_RETSTR ) THEN
             NRET = RD_SNFITSIO_STR(IROW, KEY_SEARCH, TMPSTR, 
     &              INDXFITS_HEAD(IPARFITS_HEAD), LENKEY2, LRET )
             LRET   = INDEX(TMPSTR,char(0)) -1  
             RETSTR = TMPSTR(1:LRET)
           ELSE
             NRET = RD_SNFITSIO_DBL(IROW, KEY_SEARCH, RET8(IRD), 
     &              INDXFITS_HEAD(IPARFITS_HEAD), LENKEY2, LRET )
           ENDIF
     
           IF ( NRET .GT. 0 ) READ_HEADKEY = .TRUE.

50       CONTINUE  ! end of IRD = 1, NRD loop

      ELSE

c ASCII
         KEY_SEARCH    = KEYNAME(1:LENKEY) // ':'
         KEYERR_SEARCH = KEYNAME(1:LENKEY) // '_ERR:'
         LENKEY2       = LENKEY + 1  ! include colon

         KEY_MATCH = 
     &      CWORDS(1)(1:LENKEY2) .EQ. KEY_SEARCH(1:LENKEY2)
         KEYERR_MATCH = DO_ERR .and. 
     &      (CWORDS(1)(1:LENKEY2+4) .EQ. KEYERR_SEARCH(1:LENKEY2+4))

         ISPM = CWORDS(3)(1:2) .EQ. CPM(1:2)

         IF ( KEY_MATCH .or. KEYERR_MATCH ) THEN 
           IF ( DO_RETSTR ) THEN
              RETSTR = CWORDS(2) 
           ELSE IF ( DO_ERR ) THEN

            RET8(1) = IGNORE_HEADVAL
            RET8(2) = IGNORE_HEADVAL
            if ( ISPM ) then
               read ( cwords(2), * ) RET8(1)  ! read val
               read ( cwords(4), * ) RET8(2)  ! read err; skip '+-' key
            else if ( KEYERR_MATCH ) then
               read ( cwords(2), * ) RET8(2)  ! read error   
            else if ( KEY_MATCH ) then
               read ( cwords(2), * ) RET8(1)  ! read val  
            endif
 
           ELSE IF ( DO_RET8 ) THEN
              CALL RDNDBLE( CWORDS(2), NRD, RET8 )
           ENDIF

           READ_HEADKEY = .TRUE.
         ENDIF

      ENDIF

      RETURN
      END

C ==================================
+DECK,ENDMJD_PROC.
      SUBROUTINE ENDMJD_PROC(NEWMJD)
c
c Aug 2007, R.Kessler
c
c Erase bad mesaurements.
c If all measurements (filters) are erased, then erase
c this MJD.
c
c Mar 28, 2008: store epochs for which the SNR-threshold
c               (user-namelist thresh_band) is less than 100
c
c May 9 2016: modify IGNORE logic
c
c ---------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

c input args
      INTEGER NEWMJD  ! index for SN and MJD

c local args

      INTEGER 
     &   EPMIN, EPMAX, ep, ep2
     &  ,ifilt_obs, ifilt_obs2, ifilt
     &  ,NEPSKIP, NFILT, EPMAX_OLD, NMOVED

      REAL FLUXCAL, FLUXCAL_ERR
      
      LOGICAL 
     &   LVALID(MXFILT_ALL)
     &  ,LMOVED(MXFILT_ALL)
     &  ,LTMP, IGNORE

      character cfilt1

C ------------- BEGIN -------------

      NFILT = ISNLC_NFILT_NEWMJD(NEWMJD) 

c for this NEWMJD, erase NULL measurements to save
c memory for old files with 5 filters per _line even
c when only 1 filter has data.
c Note that valid measurements are re-sorted
c and EPMAX is lowered.

      EPMIN  =  ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
      EPMAX  =  ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

      do ifilt_obs = 1, MXFILT_ALL
          LVALID(ifilt_obs) = .FALSE.
          LMOVED(ifilt_obs) = .FALSE.
      enddo

      NEPSKIP = 0

      DO 100 ep      = EPMIN, EPMAX
         ifilt_obs   = ISNLC_IFILT_OBS(ep)
         fluxcal     = SNLC_FLUXCAL(ep)
         fluxcal_err = SNLC_FLUXCAL_ERRTOT(ep)
cc         mag         = SNLC_MAG(ep)
         IGNORE      = (fluxcal_err < 0.0 ) .and. 
     &         (.not. REFORMAT_SAVE_BADEPOCHS )

c make sure filter is valid by checking that 
c the flux-error is non-negative.

         IFILT = IFILTDEF_INVMAP_SURVEY(IFILT_OBS)
         if ( IFILT .LT. 1 .or. IFILT .GT. NFILTDEF_SURVEY ) then
                         
            cfilt1 = FILTDEF_STRING(ifilt_obs:ifilt_obs)

            write(c1err,650) 
     &         ifilt_obs, cfilt1, SNLC8_MJD(EPMIN), SNLC_CCID
650         format('Invalid IFILT_OBS=',I3, '(',A,')' ,
     &          '  at MJD=',F9.3, 3x,'CID=',A)

            write(c2err,651) SURVEY_FILTERS(1:NFILTDEF_SURVEY)
651         format('Valid IFILT_OBS  are ', A )

            CALL MADABORT("ENDMJD_PROC", c1err, c2err )
         endif

         LMOVED(ifilt_obs) = .FALSE.
       
c check for valid measure.
c Set LSORT=T for any invalid measurement

         LTMP  =  (.not. IGNORE ) 
     &     .and.  (CUTWIN_SNRMIN_FILT(1,ifilt) < 100.0)

         if ( LTMP ) then
            LVALID(ifilt_obs) = .TRUE.
         else
           NEPSKIP =  NEPSKIP + 1
           LVALID(ifilt_obs) = .FALSE.
         endif
100   CONTINUE

c -------------------------------------------------------
c increment NEWMJD and NEPOCH if we have not erased
c all measurements

      if ( NEPSKIP .EQ. NFILT ) RETURN ! erase entire MJD

c ----------------

      ISNLC_NEWMJD_STORE = NEWMJD  ! increment new MJD

      ISNLC_NEPOCH_STORE = ISNLC_NEPOCH_STORE + 
     &   ISNLC_NFILT_NEWMJD(NEWMJD) 

      if ( NEPSKIP .EQ. 0 ) RETURN  ! all OK => bail
      
c if we get here, then there is at least one invalid
c measurement (epoch) for this NEWMJD; re-sort
c epochs to skip bad epochs.

      EPMAX_OLD = EPMAX
      EPMAX     = EPMAX_OLD - NEPSKIP 

      IF ( EPMAX .LT. EPMIN ) then

        write(c1err,660) EPMIN,EPMAX_OLD, EPMIN, EPMAX, 
     &       NFILT, NEPSKIP
660     format('EPMIN,MAX=',2I4, ' -> ', 2I4, 3x, 
     &       'NEPFILT=',I2, 2x,  'NEPSKIP=',I2  )
        write(c2err,661) SNLC8_MJD(EPMIN), SNLC_CCID
661     format('at MJD = ', F9.3, 4x, 'CID=', A )

        CALL MADABORT("ENDMJD_PROC", c1err, c2err )

      ENDIF


c loop over epochs and re-sort with NULL measurements removed.
c Logic is tricky.

      DO 200 ep = EPMIN, EPMAX_OLD

         ifilt_obs   = ISNLC_IFILT_OBS(ep)
         if ( LVALID(ifilt_obs) ) goto 200
   
c here we have invalid measure at epoch EP ...
c copy next valid epoch here.

         NMOVED = 0
         DO 202 ep2 = ep+1, EPMAX_OLD 
           ifilt_obs2   = ISNLC_IFILT_OBS(ep2)          
           LTMP = .NOT. LMOVED(ifilt_obs2) .and. NMOVED.EQ.0
           if ( LVALID(ifilt_obs2) .and. LTMP ) then
              CALL MOVE_SNLC_ARRAYS(ep,ep2)  ! move ep2 -> ep
              LMOVED(ifilt_obs2) = .TRUE.
              LVALID(ifilt_obs2) = .FALSE.
              NMOVED = NMOVED + 1
           endif

202      CONTINUE

200   CONTINUE  ! end of 'ep' loop

c ---------------------------------------
c adjust global variables that depend on NEPSKIP or EPMAX

       ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD) = EPMIN
       ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD) = EPMAX 

       ISNLC_NEPOCH_STORE = 
     & ISNLC_NEPOCH_STORE - NEPSKIP 

       ISNLC_NEPOCH_FOUND = 
     & ISNLC_NEPOCH_FOUND - NEPSKIP 

       ISNLC_NFILT_NEWMJD(NEWMJD) = 
     & ISNLC_NFILT_NEWMJD(NEWMJD) - NEPSKIP

      RETURN
      END

C ===================================
+DECK,MOVE_SNLC_ARRAYS.
      SUBROUTINE MOVE_SNLC_ARRAYS(ep1,ep2)
c
c
c Jun 25 2019: include SIM_XXX arrays
c Nov 12 2019: check LSIM_MAGOBS to set SIM_EPMAGOBS(ep)

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER ep1, ep2  ! (I)
 
C ------------- BEGIN ------------

      SNLC8_MJD(ep1)           = SNLC8_MJD(ep2)
      ISNLC_IDFIELD(ep1)       = ISNLC_IDFIELD(ep2)
      SNLC_FIELD(ep1)          = SNLC_FIELD(ep2) 
      ISNLC_IDTEL(ep1)         = ISNLC_IDTEL(ep2)
      ISNLC_IFILT_OBS(ep1)     = ISNLC_IFILT_OBS(ep2)
      SNLC_FLUXCAL(ep1)        = SNLC_FLUXCAL(ep2)
      SNLC_FLUXCAL_ERRTOT(ep1) = SNLC_FLUXCAL_ERRTOT(ep2)
      ISNLC_PHOTFLAG(ep1)      = ISNLC_PHOTFLAG(ep2)
      SNLC_PHOTPROB(ep1)       = SNLC_PHOTPROB(ep2)
      SNLC_PSF_SIG1(ep1)       = SNLC_PSF_SIG1(ep2)
      SNLC_PSF_SIG2(ep1)       = SNLC_PSF_SIG2(ep2)
      SNLC_PSF_RATIO(ep1)      = SNLC_PSF_RATIO(ep2)
      SNLC_SKYSIG(ep1)         = SNLC_SKYSIG(ep2)
      SNLC_SKYSIG_T(ep1)       = SNLC_SKYSIG_T(ep2)
      SNLC_RDNOISE(ep1)        = SNLC_RDNOISE(ep2)
      SNLC_ZEROPT(ep1)         = SNLC_ZEROPT(ep2)
      SNLC_ZEROPT_ERR(ep1)     = SNLC_ZEROPT_ERR(ep2)
      SNLC_GAIN(ep1)           = SNLC_GAIN(ep2)
      SNLC_XPIX(ep1)           = SNLC_XPIX(ep2)
      SNLC_YPIX(ep1)           = SNLC_YPIX(ep2)

c beware that CCDNUM is read from header, and also from 
c PHOT section of TEXT format ... but not read from PHOT-FITS file
      ISNLC_CCDNUM(EP1)        = ISNLC_CCDNUM(EP2)

      IF ( LSIM_SNANA .or. LSIM_MAGOBS ) THEN
        SIM_EPMAGOBS(EP1)          = SIM_EPMAGOBS(EP2)
        SIM_EPFLUXCAL(EP1)         = SIM_EPFLUXCAL(EP2)
      ENDIF

      IF ( LSIM_SNANA ) THEN
        SIM_EPFLUXCAL_HOSTERR(EP1) = SIM_EPFLUXCAL_HOSTERR(EP2)
        SIM_EPSNRMON(EP1)          = SIM_EPSNRMON(EP2)
      ENDIF

c - - - 
      SNLC_MAG(ep1)            = SNLC_MAG(ep2)
      SNLC_MAG_ERRPLUS(ep1)    = SNLC_MAG_ERRPLUS(ep2)
      SNLC_MAG_ERRMINUS(ep1)   = SNLC_MAG_ERRMINUS(ep2)

      RETURN
      END    ! end MOVE_SNLC_ARRAYS

C ===================================
+DECK,INIT_SNDATA.
      SUBROUTINE INIT_SNDATA()
c
c Init SNLC_XXX arrays for this SN
c Called for each SN.
c
c Nov 22 2017: use NEP_RESET to reduce CPU time for init

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.
+CDE,PRIVCOM.
+CDE,EARLYCOM.
+CDE,SPECCOM.

c local

      INTEGER iep, ifilt, ipar, i, NEP_RESET, igal

c ------------- BEGIN -------------

      HEADMASK = 0

      APPLY_HEADER_CUTMASK = 0
      FOUND_SURVEY = .FALSE.

      SNLC_CID    = -9
      SNLC_CCID   = ''
      SNLC_IAUC   = 'NULL'   ! Aug 31 2017 (can't write blank to FITS file)

      NSPECTRUM   = 0    ! for reading spectra for plot-table
      NLAMBIN_READ = 0 

      ISNLC_NEWMJD_HEAD   =  0
      ISNLC_NEWMJD_FOUND  =  0
      ISNLC_NEWMJD_STORE  =  0
      ISNLC_NEWMJD_CUTS   =  0
      ISNLC_NMJD_INCLUDE  =  0 ! Aug 2015
      ISNLC_NEPOCH_FOUND  =  0
      ISNLC_NEPOCH_STORE  =  0
      ISNLC_NEPOCH_PHOTPROB = 0  ! NEPOCH with PHOTPROB >= 0
      ISNLC_NFILT_SNRMAX  =  0
      ISNLC_NFILT_SNRMAX2 =  0
      ISNLC_NFIELD_OVP    =  0

      ISNLC_NFILT_TRESTMIN =  0
      ISNLC_NFILT_TRESTMAX =  0
      ISNLC_NFILT_TREST2   =  0  

      ISNLC_NEPOCH_DETECT =  0 
      SNLC_TLIVE_DETECT   = -9.0
      SNLC8_MJD_TRIGGER   = -99.0

      NEPOCH_BADPHOT      =   0
      ISNLC_FAKE          =  -9
      ISNLC_CCDNUM(1)     =  -9

      SNLC8_RA            =  -9.0
      SNLC8_DEC           =  -9.0
  
      SNLC_ZHELIO        =  -9.0
      SNLC_ZHELIO_ERR    =   0.0
      SNLC_ZCMB          =  -9.0
      SNLC_ZCMB_ERR      =   0.0
      SNLC_ZSN           =  -9.0 
      SNLC_ZSN_ERR       =   0.0

      SNLC_REDSHIFT      =  -9.0
      SNLC_REDSHIFT_ERR  =   0.0
      SNLC_VPEC          =   0.0
      SNLC_VPEC_ERR      =   0.0

      SNLC_PIXSIZE       =  -9.0
      SNLC_NXPIX         =  -9.0
      SNLC_NYPIX         =  -9.0

      SNLC_MWEBV         =   0.0
      SNLC_MWEBV_ERR     =   0.0
      SNLC_SEARCH_PEAKMJD    =  -9.0
      SNLC_SNANAFIT_PEAKMJD = -9.0
      ISNLC_TYPE         =  0

      SNLC_PHOTPROB_MIN = 1.0

c init a few SNHOST arrays

      SNHOST_NMATCH            =  0
      SNHOST_CONFUSION         = -9.0
      do igal = 1, MXSNHOST 
         SNHOST_OBJID(igal)       = -9
         SNHOST8_RA(igal)         = -999.0
         SNHOST8_DEC(igal)        = -999.0
         SNHOST_ANGSEP(igal)      = -9.0
         SNHOST_DDLR(igal)        = -9.0
         SNHOST_ZPHOT(igal)       = -9.0
         SNHOST_ZPHOT_ERR(igal)   = -9.0
         SNHOST_ZSPEC(igal)       = -9.0
         SNHOST_ZSPEC_ERR(igal)   = -9.0
         SNHOST_LOGMASS(igal)     = -9.0
         SNHOST_LOGMASS_ERR(igal) = -9.0
         SNHOST_sSFR(igal)        = -9.0
         SNHOST_sSFR_ERR(igal)    = -9.0
      enddo
c --------

         SNLC_SNRMAX_FILT(0) = -9.

      DO ifilt = 1, MXFILT_OBS
         ISNLC_NEPOCH_FILT(ifilt)    =   0
         ISNLC_NEPOCH_PRESN(ifilt)   =  -9
         EXIST_FILT(ifilt)          = .FALSE.
         SNLC_FLUXCALMAX(ifilt)     = -9.
         SNLC_MWXT_MAG(ifilt)       = 0.0
         SNLC_MWXT_MAGERR(ifilt)    = 0.0
         SNLC_MWXT_FLUXFRAC(ifilt)  = 0.0

         SNHOST_SBFLUXCAL(ifilt)      = -999.9
         SNHOST_SBFLUXCAL_ERR(ifilt)  = -999.9
         SNHOST_SBMAG(ifilt)          = -999.9
         do igal = 1, MXSNHOST
            SNHOST_MAGOBS(ifilt,igal)         = +99.0
            SNHOST_MAGOBS_ERR(ifilt,igal)     = +99.0
         enddo
         SNLC_SNRMAX_FILT(ifilt)     = -9.
         SNLC_SNRMAX_SORT(ifilt)     = -9.
         SNLC_FLUXCAL_OFF(ifilt)     = 0.0 

         SNLC_FIELDLIST = 'UNKNOWN'

         DO ipar = 1, NPAR_ANYLC
           SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar) = -99.0
           SNLC_SNANAFIT_PEAKMJD_FITERR(ifilt,ipar) = -99.0
         ENDDO
         
         SIM_TEMPLATEMAG(ifilt) = 99.0 
         SIM_LCWIDTH(ifilt)     = 0.0 
      ENDDO

      SIM_MODEL_INDEX = -9
      SIM_COLORPAR    = -9.
      SIM_COLORLAW    = -9.
      SIM_DLMAG       = -9.
      SIM_LENSDMU     = -9.
      SIM_SHAPEPAR    = -9.
      SIM_SHAPELAW    = -9.
      SIM_COLORPAR    = -9.
      SIM_COLORLAW    = -9.
      SIM_SALT2x0     = -9.
      SIM_SALT2mb     = -9.
      SIM_AV          = -9.    ! July 2016
      SIM_RV          = -9.    ! idem
      SIM_TEMPLATE_INDEX    = -9 
      SIM_SEARCHEFF_MASK = 0
      SIM_MAGSMEAR_COH   = 0.0 
      SIM_SALT2gammaDM   = 0.0

      SIM_NGEN_LIBID = 0
      SIM_NOBS_UNDEFINED  = 0 
      SIM_SUBSAMPLE_INDEX = -9

      IF ( NCALL_SNANA_DRIVER < 2 ) then
         NEP_RESET = MXEPOCH
      ELSE
         NEP_RESET = ISNLC_NEPOCH_STORE
      ENDIF
c      print*,' xxx NCALL,NEP_RESET=', NCALL_SNANA_DRIVER, NEP_RESET

      DO iep = 1, NEP_RESET

        SNLC_FIELD(iep)         = 'NULL'

        ISNLC_NFILT_NEWMJD(iep)          =  0
        ISNLC_EPOCH_RANGE_NEWMJD(1,iep)  =  -9
        ISNLC_EPOCH_RANGE_NEWMJD(2,iep)  =  -9
        ISNLC_IFILT_OBS(iep)      =  -9

        ISNLC_IDTEL(iep)          =  -9
        ISNLC_IDFIELD(iep)        =  -9

        SNLC8_MJD(iep)           =  -9.0

        ISNLC_PHOTFLAG(iep)  = 0 
        SNLC_PHOTPROB(iep)   = 0.0

        SNLC_SKYSIG(iep)     = 0.0
        SNLC_SKYSIG_T(iep)   = 0.0  ! Mar 2018
        SNLC_PSF_SIG1(iep)   = 0.0
        SNLC_PSF_SIG2(iep)   = 0.0
        SNLC_PSF_RATIO(iep)  = 0.0
        SNLC_AREA_NOISE(iep) = 0.0
        SNLC_GAIN(iep)       = 0.0
        SNLC_RDNOISE(iep)    = 0.0

        SNLC_FLUX_NSIG(iep)       =  0.0
        SNLC_FLUXCAL_ERRCALC(iep) =  0.0
        SNLC_FLUXCAL_ERRTEST(iep) = -9.0
        SNLC_FLUXCAL_HOSTERRCALC(iep) = 0.0 
        SNLC_FLUXCAL(iep)         =  0.0
        SNLC_FLUXCAL_ERRTOT(iep)  = -9.0  ! Oct 8 2014
        SNLC_MAG(iep)             =  0.0
        SNLC_MAG_ERRPLUS(iep)     =  0.0
        SNLC_MAG_ERRMINUS(iep)    =  0.0
        
        SNLC_ZEROPT(iep)          =  0.0
        SNLC_ZEROPT_ERR(iep)      =  0.0

        SNLC_XPIX(iep) = -9.0 
        SNLC_YPIX(iep) = -9.0 

        SNLC_DTOBS(iep)          = -9.0 
        SNLC_DTOBS_SAMEFILT(iep) = -9.0 

      END DO  ! end of epoch loop

c zero out the FITVAL_STORE array if fit-option is chosen

      IF ( DO_FIT ) THEN

         do i = 1, 4
           FITCHI2_STORE(i)      = 0.0
           FITPROBCHI2_STORE(i)  = 0.0
           LCCHI2_STORE(i)       = 0.0
           LCPROBCHI2_STORE(i)   = 0.0

           NDOF_STORE(i)  = 0
         enddo

         NDOF_PRIOR = 0

         do ipar = 1, MXFITSTORE
            FITVAL_STORE(ipar) = 0.0
            FITERR_STORE(ipar) = 0.0

            LCVAL_STORE(ipar) = 0.0
            LCERR_STORE(ipar) = 0.0
            LCFRACERRDIF_STORE(ipar) = 0.0
         enddo
      ENDIF

      NVAR_TERSE         =  0
      VARLIST_TERSE(1)   = ''
      ITERSE_MJD         = -9
      ITERSE_FILTER      = -9
      ITERSE_FIELD       = -9
      ITERSE_FLUXCAL     = -9
      ITERSE_FLUXCALERR  = -9
      ITERSE_PHOTFLAG    = -9
      ITERSE_PHOTPROB    = -9
      ITERSE_ZPFLUX      = -9
      ITERSE_PSFSIG      = -9
      ITERSE_SKYSIG      = -9
      ITERSE_SKYSIG_T    = -9
      ITERSE_MAGOBS      = -9
      ITERSE_XPIX        = -9
      ITERSE_YPIX        = -9
      ITERSE_GAIN        = -9
      ITERSE_CCDNUM      = -9

      ITERSE_SIM_EPMAGOBS      = -9 
      ITERSE_SIM_EPMAGREST     = -9 
      ITERSE_SIM_EPFILTREST    = -9 

      DO i   = 1, MXERRTYPE
         NERRTYPE(i) = 0
      ENDDO      

      DO i = 1, MXVAR_PRIVATE
        PRIVATE_VALUE(i)    = PRIVATE_NULL 
      ENDDO

      LSNCUTS       = .FALSE.
      PASS_USRCUTS  = .TRUE.
      PASS_PRIVCUTS = .TRUE.
      PASS_SIMCUTS  = .TRUE.
      CUTFLAG_SNANA =  0
      ERRFLAG_FIT   = -9  ! init to no fit

      MADE_LCPLOT = .FALSE.

      NSEASON_TOT      = 0
      NSEASON_ACTIVE    = 0


      ISNLC_CUTFLAG_REQEP    = 1
      ISNLC_CUTFLAG_PRIVATE  = 1
      ISNLC_CUTFLAG_USRCUTS  = 1
      ISNLC_CUTFLAG_SIMVAR   = 1
      ISNLC_WRMASK_FLUXCOR_SNANA = 0 
      ISNLC_RDMASK_FLUXCOR_SNANA = 0 

      NOBS_EARLYLC    = 0 
      NNIGHT_EARLYLC  = 0
      MJDLAST_EARLYLC = -999.
      MJDLAST_SELECT  = -999.
      NPHOTMASK_START_EARLYLC = 0 
      NSNR_START_EARLYLC      = 0 

      DO i = 1, NPAR_SIMSED
         SIMSED_PARVAL(i) = -999.0
      ENDDO
      DO i = 1, NPAR_LCLIB
         LCLIB_PARVAL(i) = -999.0
      ENDDO

      RETURN
      END   ! end of INIT_SNDATA


C =======================================
+DECK,INIT_CMASK.
      SUBROUTINE INIT_CUTMASK ( IERR )
c
c Creatd Jan 31, 2006 by R.Kessler
c Initialize CUTMASK_ALL and CUTWIN_XXX
c
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IERR ! (O)  0=> OK
      INTEGER ibit
      LOGICAL DOCUT

C -------------- BEGIN -------------------
 
      IERR = 0  ! init output arg
     
      if ( NCUTBIT .GE. 64 ) then
         print*,' INIT_CUTBIT FATAL ERROR: NCUTBIT=', NCUTBIT
         print*,' ***** ABORT ***** '
         CALL EXIT(EXIT_ERRCODE)
      endif

      CUTMASK8_SN_ALL    = 0  ! init common block var
      CUTMASK8_MJD_ALL   = 0  ! init common block var

      DO 100 ibit = 1, NCUTBIT
          DOCUT = .TRUE.

         if ( .NOT. LSIM_SNANA .and. ibit .EQ. CUTBIT_SEARCH ) goto 100

         if ( .NOT. DOCUT ) GOTO 100

         if ( ibit .LE. CUTBIT_MJD_MARKER ) then
           CUTMASK8_SN_ALL = IBSET ( CUTMASK8_SN_ALL, ibit-1 )
         else
           CUTMASK8_MJD_ALL = IBSET ( CUTMASK8_MJD_ALL, ibit-1 )
         endif
100   CONTINUE

      print*,' '
      print*,' INIT_CUTMASK: NCUTBIT          = ', NCUTBIT
      print*,' INIT_CUTMASK: CUTMASK8_SN_ALL  = ',CUTMASK8_SN_ALL
      print*,' INIT_CUTMASK: CUTMASK8_MJD_ALL = ',CUTMASK8_MJD_ALL

      RETURN
      END

C =======================================
+DECK,INIT_CNAMES.
      SUBROUTINE INIT_CUTNAMES ( IERR )
c
c Creatd Jan 31, 2007 by R.Kessler
c Initialize strings for cut names.
c
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IERR ! (O)  0=> OK
      INTEGER ibit, ifilt, ifilt_obs
      character cflt*1 

C -------------- BEGIN -------------------
 
      IERR = 0  ! init output arg

      do ibit = 1, NCUTBIT
        cutvar_name(ibit)  = 'UNDEFINED:'
      enddo

c hard-wire names of cut variables (maxchar = 28)

      cutvar_name(CUTBIT_CID)          = 'CID:'
      cutvar_name(CUTBIT_RA)           = 'RA:'
      cutvar_name(CUTBIT_DEC)          = 'DEC:'
      cutvar_name(CUTBIT_HOSTSEP)      = 'HOST-SN sep:'
      cutvar_name(CUTBIT_TRESTMIN)     = 'Trestmin:'
      cutvar_name(CUTBIT_TRESTMAX)     = 'Trestmax:'
      cutvar_name(CUTBIT_TRESTRANGE)   = 'TrestRange:'
      cutvar_name(CUTBIT_TGAPMAX)      = 'TGAPmax:'
      cutvar_name(CUTBIT_T0GAPMAX)     = 'T0GAPmax:'
      cutvar_name(CUTBIT_TobsMIN)      = 'TobsMin:'
      cutvar_name(CUTBIT_TobsMAX)      = 'TobsMax:'
      cutvar_name(CUTBIT_PEAKMJD)      = 'PeakMJD:'
      cutvar_name(CUTBIT_NMJD_INCLUDE) = 'NMJD_INCLUDE:'
      cutvar_name(CUTBIT_Nepoch)       = 'Nepoch:'
      cutvar_name(CUTBIT_REDSHIFT)     = 'Redshift:'
      cutvar_name(CUTBIT_REDSHIFT_ERR) = 'Redshift-ERROR:'
      cutvar_name(CUTBIT_PSF)          = 'PSF:'
      cutvar_name(CUTBIT_ZP)           = 'ZP:'
      cutvar_name(CUTBIT_PHOTPROB)     = 'PHOTPROB:'
cc xxx      cutvar_name(CUTBIT_NBAND_THRESH) = 'Nband thresh:'
      cutvar_name(CUTBIT_MWEBV)        = 'MWEBV:'
      cutvar_name(CUTBIT_NSEASON_ACTIVE) = 'NSEASON_ACTIVE:'
      cutvar_name(CUTBIT_REQEP)        = 'REQEP_CUTFLAG:'
      cutvar_name(CUTBIT_PRIVATE)      = 'PRIVATEVAR_CUTS:'
      cutvar_name(CUTBIT_SIMVAR)       = 'SIMVAR_CUTS:'
      cutvar_name(CUTBIT_USRCUTS)      = 'USRCUTS:'
      cutvar_name(CUTBIT_TREST)        = 'Trest:'
      cutvar_name(CUTBIT_TOBS)         = 'Tobs:'
      cutvar_name(CUTBIT_ERRTEST)      = 'ERR(CALC)/ERR(TRUE):'
cc xxx mark delete      cutvar_name(CUTBIT_IDTEL)        = 'Telescope:'
      cutvar_name(CUTBIT_SNRMAX)       = 'SNRmax:'
      cutvar_name(CUTBIT_SNRMAX2)      = 'SNRmax2:'
      cutvar_name(CUTBIT_NFILT_SNRMAX) = 'NFILT_SNRmax:'
      cutvar_name(CUTBIT_NFILT_SNRMAX2)= 'NFILT_SNRmax2:'
      cutvar_name(CUTBIT_NFILT_TRESTMIN) = 'NFILT_Trestmin:'
      cutvar_name(CUTBIT_NFILT_TRESTMAX) = 'NFILT_Trestmax:'
      cutvar_name(CUTBIT_NFILT_TREST2)   = 'NFILT_Trest2:'
      cutvar_name(CUTBIT_NFIELD)         = 'NFIELD:'
      cutvar_name(CUTBIT_SEARCH)         = 'SEARCHEFF_MASK:'

      DO ifilt      = 1, NFILT_SNRMAX
          ifilt_obs = IFILT_SNRMAX(ifilt)
          cflt      = FILTDEF_STRING(ifilt_obs:ifilt_obs)

          ibit = CUTBIT_OFFSET_SNRMAX + ifilt
          cutvar_name(ibit)  = 'SNRMAX-' // cflt // ':'

      ENDDO

      RETURN
      END

C ======================================
+DECK,MWEBV_FLUXCOR.
      SUBROUTINE MWEBV_FLUXCOR()
c
c Compute MW extinction in each defined passband,
c and correct SNLC_FLUXCAL[_ERRTOT]
c
c May 7, 2012: 
c   Apply  USE_MWCOR log here so that the following arrays
c   are always filled:
c     SNLC_MWXT_[MAG,MAGERR,FLUXFRAC]
c
c May 17, 2012: pass ISN as argument and remove local ISN loop.
c May 21, 2012: remove unused ISN arg.
c Sep 18, 2013: use OPT_MWCOLORLAW as last arg to GALextinct
c
c --------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.

c local var

      INTEGER IFILT, IFILT_OBS, NEWMJD, EPMIN, EPMAX, ep, OPT

      REAL*8  
     &   XTMW8,  XTMW8_PLUSERR
     &  ,AVMW8,  AVMW8_PLUSERR
     &  ,MWEBV8, MWEBV8_PLUSERR
     &  ,LAM8, GALextinct, RV8

      REAL    XTMW_cor, arg
      CHARACTER CFILT*2

      LOGICAL LDMP 

C ------------ BEGIN -------------

      LDMP = .FALSE.

      IF ( USESIM_TRUEFLUX .and. LSIM_SNANA ) THEN
         SNLC_MWEBV     = SIM_MWEBV
         SNLC_MWEBV_ERR = 0.0
      ENDIF

c determin MW extinction in each passband

       MWEBV8          = DBLE(SNLC_MWEBV )
       MWEBV8_PLUSERR  = DBLE(SNLC_MWEBV+SNLC_MWEBV_ERR)

       RV8             = DBLE(RV_MWCOLORLAW)
       AVMW8           = RV8 * MWEBV8
       AVMW8_PLUSERR   = RV8 * MWEBV8_PLUSERR

       OPT = OPT_MWCOLORLAW  ! RK : 9/18/2013

       if (  LDMP ) THEN
          write(6,122) SNLC_CCID(1:ISNLC_LENCCID), 
     &       SURVEY_FILTERS(1:NFILTDEF_SURVEY), MWEBV8, OPT
122       format(T5,'xxx --- XTMW(',A,'-', A,') for MWEBV=',F5.3,
     &         2x,'OPT=',I3 )
       endif


      DO ifilt = 1, NFILTDEF_SURVEY  
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          LAM8      = DBLE ( FILTOBS_LAMAVG(ifilt_obs) )

          XTMW8     = 
     &           GALextinct ( RV8, AVMW8, LAM8, OPT );
          XTMW8_PLUSERR  = 
     &           GALextinct ( RV8, AVMW8_PLUSERR, LAM8, OPT );

          SNLC_MWXT_MAG(ifilt)    = SNGL(XTMW8)
          SNLC_MWXT_MAGERR(ifilt) = SNGL(XTMW8_PLUSERR-XTMW8)

          if ( LDMP ) then
            CFILT = FILTDEF_STRING(ifilt_obs:ifilt_obs)
            write(6,123) CFILT, LAM8, XTMW8
123         format(T5,'xxx ', A,' : <LAM>=',F7.0, 2x, 'XTMW=',F6.4)
            call flush(6)
          endif

c store extinction in flux-fraction units.
c FLUXFRAC = Flux(Extincted)/flux(top-of-Galaxy)
          arg = -0.4 * XTMW8
          SNLC_MWXT_FLUXFRAC(ifilt) = 10.0**arg  ! <= 1.0
         
      END DO  ! end of ifilt loop


c correct data fluxes if USE_MWCOR=T
      IF ( .NOT.  USE_MWCOR )  RETURN

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE  
 
          EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
          EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
 
          DO EP = EPMIN, EPMAX

            IFILT_OBS = ISNLC_IFILT_OBS(ep)
            IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
            XTMW_cor  = 1.0 - SNLC_MWXT_FLUXFRAC(ifilt)

            SNLC_FLUXCAL(ep) = 
     &      SNLC_FLUXCAL(ep) / XTMW_cor

            SNLC_FLUXCAL_ERRTOT(ep) = 
     &      SNLC_FLUXCAL_ERRTOT(ep) / XTMW_cor

          ENDDO

200   CONTINUE  ! NEWMJD

      RETURN
      END   ! end MWEBV_FLUXCOR

C ===========================================
+DECK,RDUSRTAGS.
      SUBROUTINE RD_USERTAGS()
c
c Created Aug 2011 by R.Kessler
c If namelist USERTAGS_FILE is set, then read integer tag
c for each SN specified. These tags are then included in 
c analysis ntuples and fitres files. Motivation is to 
c easily tag subsets such as SN confirmed from a particular
c telescope.  For SN not listed in the USERTAGS_FILE,
c the tag is automatically set to zero.
c
c If an unknown CCID is found in the USERTAGS_FILE, 
c it is ignored (i.e., no abort)
c
c The format of the user-tag file is
c
c  SN:  <CID1>  <TAG-VALUE1>
c  SN:  <CID2>  <TAG-VALUE2>
c  SN:  <CID3>  <TAG-VALUE3>
c  etc ...
c
c --------------------

      IMPLICIT NONE


+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,USRTAGCM.

      INTEGER LEN, ITAG, iwd, NWD, N
      CHARACTER 
     &   CWD*60
     &  ,CKEY*(MXCHAR_CCID)
     &  ,CCID*(MXCHAR_CCID)
     &  ,NAME_ForC*(MXCHAR_FILENAME)

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ------------- BEGIN ----------------

      N_USERTAGS    = 0

      IF ( USERTAGS_FILE .EQ. ' ' ) RETURN

      LEN = INDEX(USERTAGS_FILE,' ') - 1

c init all tags to zero
      DO itag = 1, MXUSERTAG
        USERTAG_VALUELIST(itag) = 0
        USERTAG_CCIDLIST(itag)  = ''
        USERTAG_USED(itag)      = 0
      ENDDO

      CALL PRBANNER("RD_USERTAGS")
      print*,'  Read user tags to identify subsets. '

      NAME_ForC = USERTAGS_FILE(1:LEN)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE,NAME_forC,LEN) 

      DO 100 iwd = 1, NWD-1

         CALL get_PARSE_WORD_fortran(iwd+0,CWD,LEN)
         CKEY = CWD(1:MXCHAR_CCID)

         if ( CKEY .EQ. 'SN:' ) then

           N_USERTAGS = N_USERTAGS + 1
           N = N_USERTAGS

           if ( N .GT. MXUSERTAG ) then
             write(c1err,61) MXUSERTAG
61           format('Number of USER TAGS exceeds bound of ',I5)
             c2err = 'Check ' // USERTAGS_FILE(1:60)
             CALL MADABORT("RD_USERTAGS", c1err, c2err )
           endif

           CALL get_PARSE_WORD_fortran(iwd+1,CWD,LEN)
           READ ( CWD, *) CCID

           CALL get_PARSE_WORD_fortran(iwd+2,CWD,LEN)
           READ ( CWD, *) ITAG

           USERTAG_CCIDLIST(N)  = CCID
           USERTAG_VALUELIST(N) = ITAG

         endif

100   CONTINUE

      RETURN
      END


C =========================================
+DECK,GTUSERTAG.
      SUBROUTINE GET_USERTAG(CCID)

c
c Load global USERTAG value for this SN
c
      CHARACTER CCID*(*)

c local var
+CDE,SNPAR.
+CDE,USRTAGCM.


      INTEGER i, LCCID, LTMP
      CHARACTER CCID_TMP*(MXCHAR_CCID)

c -------------- BEGIN --------------

      USERTAG = -999
      IF ( N_USERTAGS .LE. 0 ) RETURN

      LCCID = INDEX(CCID,' ') - 1
      DO 100 i = 1, N_USERTAGS

         if ( USERTAG_USED(i) .NE. 0 ) GOTO 100

         CCID_TMP = USERTAG_CCIDLIST(i)
         LTMP     = INDEX(CCID_TMP,' ') - 1

         IF ( LTMP          .NE. LCCID             ) GOTO 100
         IF ( CCID(1:LCCID) .NE. CCID_TMP(1:LCCID) ) GOTO 100
         
         USERTAG = USERTAG_VALUELIST(i)
         USERTAG_USED(i) = 1
         RETURN
100   CONTINUE


      RETURN
      END  

C ==================================
+DECK,MULTISEASON.
      SUBROUTINE MULTISEASON(IFLAG)

c Created Oct 2014
c Driver for quick analysis to check for multi-season variability.
c 
c May 1 2019: convert GET_MULTISEASON args to double.

      IMPLICIT NONE

      INTEGER IFLAG ! (I) 

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER NEWMJD, EPMIN, EPMAX, EP, NOBS, iSeason
      INTEGER ITMP_REJECT(MXEPOCH)
      REAL*8  TMP8_MJD(MXEPOCH)
      REAL*8  TMP8_FLUX(MXEPOCH), TMP8_FLUXERR(MXEPOCH)
      REAL*8  OUT_CHI2RED(MXSEASON), OUT_AVGFLUX(MXSEASON)
      REAL*8  OUT_MJDMIN(MXSEASON),  OUT_MJDMAX(MXSEASON)
      REAL   PARLIST(8), CHI2RED, CUTVAL
      CHARACTER CCID_forC*(MXCHAR_CCID)
      LOGICAL USE_TGAP, USE_MASK

c -------------------- BEGIN --------------

      IF ( IFLAG == IFLAG_INI ) THEN

         USE_TGAP = MULTISEASON_TGAP < 1.0E8
         USE_MASK = MULTISEASON_OPTMASK > 0
         if ( .NOT. USE_TGAP ) THEN
            MULTISEASON_OPTMASK = 0
            RETURN
         endif
         if ( .NOT. USE_MASK ) MULTISEASON_OPTMASK = 1

c copy user-analysis parameters to list 
         PARLIST(1) = MULTISEASON_OPTMASK
         PARLIST(2) = MULTISEASON_TGAP
         PARLIST(3) = MULTISEASON_NREJECT_OUTLIER

c call to C function in multiseason.c
         CALL INIT_MULTISEASON(PARLIST)  

         RETURN
      ENDIF

      if ( MULTISEASON_OPTMASK == 0 ) return 

c ------ if we get here then analyze this CID -------

c create local array of MJD, FLUX, FLUXERR that were selected by SNRECON
      NOBS = 0

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 201 EP = EPMIN, EPMAX
           if ( ISNLC_SNRECON_USE(ep) == 0 ) GOTO 201
           NOBS = NOBS + 1
           TMP8_MJD(NOBS)     = SNLC8_MJD(ep)
           TMP8_FLUX(NOBS)    = DBLE( SNLC_FLUXCAL(ep) ) 
           TMP8_FLUXERR(NOBS) = DBLE( SNLC_FLUXCAL_ERRTOT(ep) )
 201    CONTINUE
 200  CONTINUE


c --------------
      CCID_forC = SNLC_CCID(1:ISNLC_LENCCID) // char(0)
      NOBS      = ISNLC_NEWMJD_STORE

      CALL GET_MULTISEASON( 
     &      CCID_forC
     &     ,NOBS, TMP8_MJD, TMP8_FLUX, TMP8_FLUXERR ! (I)
     &     ,ITMP_REJECT         ! (O) mask of reject epochs
     &     ,NSEASON_TOT         ! (O) number of seasons found
     &     ,OUT_CHI2RED         ! (O) reduced chi2 per season
     &     ,OUT_MJDMIN          ! (O) min-MJD for each season
     &     ,OUT_MJDMAX          ! (O) max-MJD for each season
     &     ,OUT_AVGFLUX         ! (O) avg flux for each season
     &     )

c transfer to float globals
      DO iSeason = 1, NSEASON_TOT
         MULTISEASON_CHI2RED(iSeason) = OUT_CHI2RED(iSeason)
         MULTISEASON_MJDMIN(iSeason)  = OUT_MJDMIN(iSeason)
         MULTISEASON_MJDMAX(iSeason)  = OUT_MJDMAX(iSeason)
         MULTISEASON_AVGFLUX(iSeason) = OUT_AVGFLUX(iSeason)
      ENDDO

      CUTVAL = MULTISEASON_CHI2RED_ACTIVE
      DO iSeason = 1, NSEASON_TOT
        CHI2RED = MULTISEASON_CHI2RED(iSeason)
        IF ( CHI2RED > CUTVAL ) THEN
           NSEASON_ACTIVE = NSEASON_ACTIVE + 1
        ENDIF
      ENDDO

c ------------------------------------------
c transfer ITMP_REJECT flag to ISNLC_RECON_USE 
c so that plots show rejected epochs

      NOBS = 0

      DO 2000 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 2001 EP = EPMIN, EPMAX
           if ( ISNLC_SNRECON_USE(ep) == 0 ) GOTO 2001
           NOBS = NOBS + 1
           if ( ITMP_REJECT(NOBS) == 1 ) then
              ISNLC_SNRECON_USE(ep) = 0
           endif
 2001   CONTINUE
 2000 CONTINUE

      RETURN
      END  ! end of MULTISEASON


C ============================================
+DECK,SELECT_EARLYLC.
      LOGICAL FUNCTION SELECT_EARLYLC(EP)
c
c Created March 2015 by R.Kessler
c Return TRUE if EARLYLC-requirements are satsified.
c Logical AND is applied to each selection defined in
c subroutine PARSE_EARLYLC_STRING().
c
c Note that all epochs BEFORE EARLYLC requirements are accepted;
c epochs are rejected after all of the EARLYLC obs or nights
c are found.
c
c 9/15/2017: implement SNR_START and PHOTMASK_START (see manual)
c
c -------------------

      IMPLICIT NONE

      INTEGER EP    ! (I) epoch to analyze

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,EARLYCOM.
+CDE,FILTCOM.

      REAL SNR, PROB, MJD
      INTEGER IFILT_OBS, MASK, OVPMASK, OVPMASK_START, NMJD_DIF
      LOGICAL LCUTS, LSNR, LPHOTPROB, LPHOTMASK, LFILT
      LOGICAL LDMP, SAMENIGHT, LNOSEL
      CHARACTER CFILT*2

C --------------- BEGIN --------------
 
      SELECT_EARLYLC = .TRUE.
      IF ( EARLYLC_STRING .EQ. '' ) RETURN

c strip off info for this epoch.
      IFILT_OBS = ISNLC_IFILT_OBS(ep)
      CFILT     = FILTDEF_STRING(ifilt_obs:ifilt_obs)
      PROB      = SNLC_PHOTPROB(ep)
      MASK      = ISNLC_PHOTFLAG(ep)
      MJD       = SNGL( SNLC8_MJD(ep) )

      if ( SNLC_FLUXCAL_ERRTOT(ep) > 0 ) then
         SNR  = SNLC_FLUXCAL(ep) / SNLC_FLUXCAL_ERRTOT(ep)
         if ( SNR > SNR_START_EARLYLC ) then
            NSNR_START_EARLYLC = NSNR_START_EARLYLC + 1
         endif
      else 
         SNR = 0.0
      endif       

      IF ( PHOTMASK_EARLYLC .NE. 0 ) THEN
        OVPMASK = IAND(PHOTMASK_EARLYLC,MASK)
      ELSE
        OVPMASK = 999  ! any number > 0
      ENDIF

c check PHOTMASK_START required to start counting epochs (9/15/2017)
c --> ignore epochs before PHOTMASK_START is satisfied.
      IF ( PHOTMASK_START_EARLYLC > 0 ) THEN
        OVPMASK_START = IAND(PHOTMASK_START_EARLYLC,MASK)
      ELSE
        OVPMASK_START = 999  ! any number > 0
      ENDIF 

      IF ( OVPMASK_START > 0 ) THEN
         NPHOTMASK_START_EARLYLC = NPHOTMASK_START_EARLYLC + 1 
      ENDIF

c set cut-logicals.
      LFILT      = (INDEX(FILTERS_EARLYLC,CFILT(1:1)) > 0)

      LSNR       = (SNR .GE. SNRMIN_EARLYLC) .AND.
     &             (NSNR_START_EARLYLC>0)

      LPHOTPROB  = PROB .GE. PHOTPROBMIN_EARLYLC

      LPHOTMASK  = ( OVPMASK > 0) .AND.
     &             ( NPHOTMASK_START_EARLYLC > 0)

      SAMENIGHT  = ( (MJD-MJDLAST_EARLYLC) < DT_SAMENIGHT )

      LCUTS = (LFILT .and. LSNR .and. LPHOTPROB .and. LPHOTMASK )


c apply all cuts to increment number of early obs.
      IF ( LCUTS ) THEN
         NOBS_EARLYLC = NOBS_EARLYLC + 1
         if ( .NOT. SAMENIGHT ) then
            NNIGHT_EARLYLC = NNIGHT_EARLYLC + 1
            MJDLAST_EARLYLC = MJD 
         endif
      ENDIF

c ---------------------------------------------------
c check if we reached max number of OBS or NIGHTS

      IF( NOBS_EARLYLC > MAXOBS_EARLYLC ) THEN
         SELECT_EARLYLC = .FALSE.
      ENDIF

      IF ( NNIGHT_EARLYLC > MAXNIGHT_EARLYLC ) THEN
         SELECT_EARLYLC = .FALSE.
      ENDIF

      IF ( SELECT_EARLYLC ) MJDLAST_SELECT = MJD


c check NDAYADD option to add number of days instead of
c number of obs or nights.

      LNOSEL = (.NOT. SELECT_EARLYLC) .and. (NDAYADD_EARLYLC>0)
      NMJD_DIF = -9
      if ( LNOSEL .and. MJDLAST_SELECT > 10000 ) then
         NMJD_DIF = int(MJD - MJDLAST_SELECT+0.5)
         SELECT_EARLYLC = (NMJD_DIF < NDAYADD_EARLYLC)
      endif
    
c xxxxxxxxxxxxxxx
c      print*,' xxx LNOSEL=',LNOSEL,
c     &   '  MJD,MJDLAST_SELECT=', MJD,MJDLAST_SELECT
c      print*,' xxx --> NMJD_DIF=', NMJD_DIF, 
c     &     '   SELECT=', SELECT_EARLYLC
c xxxxxxxxxxxxxxx

      LDMP = .false.  ! (PROB < 1.0E9)
      if ( LDMP ) THEN
         print*,' xxx ------------------------------------- '
         write(6,666) EP, CFILT, LFILT,
     &           MJD-56000, PROB, NOBS_EARLYLC, NNIGHT_EARLYLC
666      format(' xxx EP=',I3'-',A1, '(',L1,')', 2x, 
     &         'MJD=',F7.2, 2x, 'PROB=',F5.2, 2x,
     &         'N[OBS,NITE]=',2I3 )

         print*,' xxx NPHOTMASK_START_EARLYLC = ', 
     &       NPHOTMASK_START_EARLYLC

         write(6,667) LFILT, LSNR, LPHOTPROB, LPHOTMASK
667      format(' xxx LCUT(FILT,SNR,PHOTPROB,PHOTMASK) = ',4L3)
         print*,' xxx LCUTS, SELECT = ', LCUTS, SELECT_EARLYLC
      endif

      RETURN
      END     ! SELECT_EARLYLC

C ========================================
+DECK,PARSE_EARLYLC.
      SUBROUTINE PARSE_EARLYLC_STRING()

C Mar 2015 - 
c  parse &SNLCINP input EARLYLC_STRING and set global 
c  variables in common EARLYCOM. 
c  Also print summary to stdout.
c 
c Valid keys contained in the EARLYLC_STRING are
c (with example values):
c   MAXOBS:            4        ! default = 999
c   MAXNIGHT:          4        ! default = 999
c   FILTERS:         riz      ! default = all bands
c   SNRMIN:          5.0      ! default = -999
c   PHOTPROBMIN:     0.5      ! default = -999 
c   PHOTMASK        4096      ! default =  0
c   NDAYADD           10      ! default =  0
c   PHOTMASK_START  4096      ! default =  0    (disabled)
c   SNR_START          5      ! default =  999  (disabled)
c
c 9/15/2017: check for PHOTMASK_START
c

c -------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,EARLYCOM.

      INTEGER iwd, NWD, NOTUSED, L0, L1, MSKOPT
      CHARACTER 
     &   cwd0*(MXCHAR_FILEWORD),
     &   cwd1*(MXCHAR_FILEWORD), FNAM*22
      LOGICAL USEWD(200)

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C -------------- BEGIN -----------------

      FNAM = 'PARSE_EARLYLC_STRING'
      MSKOPT = MSKOPT_PARSE_WORDS_STRING

c set defaults
 
      NDAYADD_EARLYLC        =  0
      MAXOBS_EARLYLC         =  999
      MAXNIGHT_EARLYLC       =  999
      SNRMIN_EARLYLC         = -999.
      PHOTPROBMIN_EARLYLC    = -999.
      PHOTMASK_EARLYLC       =  0
      PHOTMASK_START_EARLYLC =  0 
      NPHOTMASK_START_EARLYLC=  0
      SNR_START_EARLYLC      =  -9999.
      NSNR_START_EARLYLC     =  0
      FILTERS_EARLYLC        = SURVEY_FILTERS
      
      IF ( EARLYLC_STRING .EQ. '' ) RETURN

      NWD = STORE_PARSE_WORDS(MSKOPT, EARLYLC_STRING//char(0), 100)

      DO iwd = 1, NWD
         USEWD(iwd) = .FALSE.
      ENDDO

      DO 10 iwd = 1, NWD

          CALL get_PARSE_WORD_fortran(iwd+0, cwd0, L0)
          CALL get_PARSE_WORD_fortran(iwd+1, cwd1, L1)

          if ( cwd0(1:6) .EQ. 'MAXOBS' ) then
             read(cwd1,* ) MAXOBS_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:7) .EQ. 'NDAYADD' ) then
             read(cwd1,* ) NDAYADD_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:8) .EQ. 'MAXNIGHT' ) then
             read(cwd1,* ) MAXNIGHT_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:7) .EQ. 'FILTERS' ) then
             FILTERS_EARLYLC = cwd1
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:6) .EQ. 'SNRMIN' ) then
             read(cwd1,* ) SNRMIN_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:11) .EQ. 'PHOTPROBMIN' ) then
             read(cwd1,* ) PHOTPROBMIN_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

c   be careful with two keys that have same 'PHOTMASK' in string
          if ( cwd0(1:14) .EQ. 'PHOTMASK_START' ) then
             read(cwd1,* ) PHOTMASK_START_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          else if ( cwd0(1:8) .EQ. 'PHOTMASK' ) then
             read(cwd1,* ) PHOTMASK_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

          if ( cwd0(1:9) .EQ. 'SNR_START' ) then
             read(cwd1,* ) SNR_START_EARLYLC
             USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
          endif

10    CONTINUE

      GLOBAL_BANNER = 'Init Selection of Early Part of Light Curve'
      CALL PRBANNER (GLOBAL_BANNER(1:60) )

      write(6,50) MAXOBS_EARLYLC, MAXNIGHT_EARLYLC
50    format(T5,'Select first ',I2,' obs or ',I2,' nights satisfying:')
      print*,'        FILTER  in   ', FILTERS_EARLYLC(1:40)
      print*,'   and  PHOTPROB > ', PHOTPROBMIN_EARLYLC
      print*,'   and  SNR      > ', SNRMIN_EARLYLC
      print*,'   and  NDAYADD  = ', NDAYADD_EARLYLC
   
      if ( PHOTMASK_EARLYLC > 0 ) then
         print*,'   and  PHOTFLAG contains ', PHOTMASK_EARLYLC
      endif

      if ( PHOTMASK_START_EARLYLC > 0 ) then
         print*,'   After epoch where PHOTFLAG contains ', 
     &         PHOTMASK_START_EARLYLC
      endif

      if ( SNR_START_EARLYLC > -900. ) then
         print*,'   After epoch where SNR > ', SNR_START_EARLYLC
      endif

      print*,' '
      call flush(6)

c ------------------------------------
c if any words are not used --> ABORT !!!

      NOTUSED =  0
      DO 66 iwd = 1, NWD
        if ( .NOT. USEWD(iwd) ) then
            NOTUSED = NOTUSED + 1
            CALL get_PARSE_WORD_fortran(iwd, cwd0, L0)
            write(6,666) cwd0 
666         format('ERROR: EARLYLC_STRING contains invalid ', A20)
        endif
66    CONTINUE

      IF ( NOTUSED > 0 ) THEN
        write(c1err,61) NOTUSED
        write(c2err,62) EARLYLC_STRING
61      format('Found ',I2,' undefined words in')
62      format('EARLYLC_STRING="', A48, '"' )
        CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF
      
      RETURN
      END  ! end of PARSE_EARLYLC_STRING

C ========================================================
+DECK,ISTAT_REQUIRE_EPOCHS.
      INTEGER FUNCTION ISTAT_REQUIRE_EPOCHS()

c Created Sep 2017
c Return 1 (TRUE) if epochs satify user input REQUIRE_EPOCHS_STRING.
c

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,REQEPCOM.

      INTEGER 
     &    NEWMJD, EPMIN, EPMAX, EP, i, NOBS(3)

      REAL*8 
     &   MJD_FIRST, MJD_LAST, MJD, MJD_DIF
     &  ,MJD_WIN_BEFORE(2), MJD_WIN_AFTER(2)
     &  ,SNR, FLUX, FLUXERR, z1

      CHARACTER FNAM*24
      LOGICAL  LPASS, LTRANGE(3), LDMP

C ------------------- BEGIN ----------------

      FNAM       = 'ISTAT_REQUIRE_EPOCHS'

      ISTAT_REQUIRE_EPOCHS     = 1
      NDAYS_ABOVE_SNRMIN_REQEP = 0.0
      IF ( NFILT_REQEP .EQ. 0 ) RETURN

      MJD_FIRST  = -9.0
      MJD_LAST   = -9.0 

      do i = 1, 3
        LTRANGE(i) = .FALSE.
        NOBS(i)    = 0
      ENDDO

      IF ( ISFRAME_OBS_REQEP ) then
         z1   = 1.0 
      else
         z1  = 1.0 + SNLC_REDSHIFT
         if ( SNLC_REDSHIFT < 0.0 ) then
            c1err = 'Negative redshift !'
            c2err = 'Cannot compute TREST'
            CALL MADABORT(FNAM, c1err, c2err )
         endif
      endif

C - - - - - - -  - -

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

      DO 201 EP = EPMIN, EPMAX

           MJD      = SNLC8_MJD(EP)
           FLUX     = DBLE( SNLC_FLUXCAL(EP) )
           FLUXERR  = DBLE( SNLC_FLUXCAL_ERRTOT(EP) )
           SNR      = 0.0
           IF ( FLUXERR > 0.00001 ) THEN
              SNR = FLUX / FLUXERR
           ENDIF

           IF ( SNR > SNRMIN_REQEP ) THEN
              if ( MJD_FIRST < 0.0 ) MJD_FIRST = MJD
              MJD_LAST = MJD
              NOBS(2) = NOBS(2) + 1
           ENDIF
201   CONTINUE
200   CONTINUE


c -----------------------------------
c check range of epochs above SNR
      MJD_DIF = MJD_LAST - MJD_FIRST
      NDAYS_ABOVE_SNRMIN_REQEP = MJD_DIF/z1
      if ( NDAYS_ABOVE_SNRMIN_REQEP > TRANGE_REQEP(2) 
     &        .OR. NOBS(2)==0 ) THEN
         ISTAT_REQUIRE_EPOCHS = 0
         GOTO 888
      endif

c We have a short-enough transient.
c Check that there there is at least 1 obs before and after
c the live range, so that a longer-duration event could
c have been observed.

      MJD_WIN_BEFORE(1) = MJD_FIRST - TRANGE_REQEP(1)*z1
      MJD_WIN_BEFORE(2) = MJD_FIRST - 0.001

      MJD_WIN_AFTER(1) = MJD_LAST + 0.001
      MJD_WIN_AFTER(2) = MJD_LAST + TRANGE_REQEP(3)*z1

      DO 400 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
      DO 401 EP = EPMIN, EPMAX

           MJD      = SNLC8_MJD(EP)
           
           if ( MJD > MJD_WIN_BEFORE(1) .and. 
     &          MJD < MJD_WIN_BEFORE(2) ) then
             NOBS(1) = NOBS(1) + 1
           endif

           if ( MJD > MJD_WIN_AFTER(1) .and. 
     &          MJD < MJD_WIN_AFTER(2) ) then
             NOBS(3) = NOBS(3) + 1
           endif

401   CONTINUE
400   CONTINUE

c ------------------------------------------------------

      DO i = 1, 3
        if ( NOBS(i)>0 .OR. TRANGE_REQEP(i) < 1.0E-9 ) THEN
           LTRANGE(i) = .TRUE.
        endif 
      ENDDO

      LPASS = ( LTRANGE(1) .and. LTRANGE(2) .and. LTRANGE(3) )
      IF ( LPASS ) THEN
         ISTAT_REQUIRE_EPOCHS = 1
      ELSE
         ISTAT_REQUIRE_EPOCHS = 0
      ENDIF

c - - - - - - - - - - - 
888   CONTINUE
 
      LDMP = ( SNLC_CID < -5 )
      IF ( LDMP ) THEN
        print*,' ' 
        print*,' xxx ---------- DUMP ISTAT_REQUIRE_EPOCHS ------ '
        print*,' xxx CID = ', SNLC_CID
        print*,' xxx TRANGE  = ', TRANGE_REQEP
        print*,' xxx LTRANGE = ', LTRANGE
        print*,' xxx NOBS    = ', NOBS
        print*,' xxx MJD_FIRST/LAST = ', 
     &      sngl(MJD_FIRST), '/', sngl(MJD_LAST)
        print*,' xxx ISTAT_REQUIRE_EPOCHS=', ISTAT_REQUIRE_EPOCHS
        print*,' ' 
      ENDIF

      RETURN
      END   ! end ISTAT_REQUIRE_EPOCHS


C ========================================================
+DECK,PARSE_REQUIRE_EPOCHS.
      SUBROUTINE PARSE_REQUIRE_EPOCHS_STRING()

c Created Sep 2017
c Parse &SNLCINP input REQUIRE_EPOCHS_STRING.
c Main goal is to select fast transients and reject the 
c larger source of Supernova.
c
c Example: 
c   REQUIRE_EPOCHS_STRING = 'FILTERS riz  TOBS_RANGES  14 20 25 SNRMIN 5'
c   REQUIRE_EPOCHS_STRING = 'FILTERS riz  TREST_RANGES 14 20 25 SNRMIN 5'
c
c Legacy Example:  
c    REQUIRE_EPOCHS_STRING = 'gri 14 20 21'
c --> For the gri passbands:
c  + Require (MJD_max - MJD_min)_DETECT < 20 days = [TRANGE(2)]
c  + require NOBS>=1 within 14 days before MJD_min  [TRANGE(1)]
c  + require NOBS>=1 within 21 days after  MJD_max  [TRANGE(3)]
c
c  For TRANGE(2), a "detection" is defined by SNR > CUTWIN_SNRMAX(1).
c  The NOBS>=1 requirements ensure observations before and after
c  the detect-range to avoid edge effects such as a falling
c  light curve at the start of a season where we can't see the
c  entire LC. Such edge cases can be rejected.
c
c  Setting TRANGE(1)=0 or TRANGE(3)=0 will disable the 
c  corresponding requirement.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,REQEPCOM.

      INTEGER ifilt, IFILT_OBS, iwd, NWD, i, L0, L1, MSKOPT
      character FNAM*28, CFILT*2, cwd0*80, cwd1*80
      LOGICAL LEGACY, USEWD(40)

      INTEGER FILTINDX

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------------- BEGIN ----------------

      FNAM = 'PARSE_REQUIRE_EPOCHS_STRING'
      MSKOPT = MSKOPT_PARSE_WORDS_STRING

c set defaults
      ISFRAME_REST_REQEP = .FALSE. 
      ISFRAME_OBS_REQEP  = .FALSE.
      DO i = 1, 3
        TRANGE_REQEP(i)  = 0.0 
      ENDDO
      NFILT_REQEP     = 0
      FILTLIST_REQEP  = ''
      SNRMIN_REQEP    = 0.0   ! defines detection

      IF ( REQUIRE_EPOCHS_STRING .EQ. '' ) RETURN

      NWD = STORE_PARSE_WORDS(MSKOPT,REQUIRE_EPOCHS_STRING//char(0),100)

      LEGACY = ( NWD .EQ. 4 ) 

      IF ( LEGACY ) THEN
        ISFRAME_OBS_REQEP = .TRUE.
        call get_PARSE_WORD_fortran(1, cwd0, L0)
        read( CWD0,* ) FILTLIST_REQEP

        call get_PARSE_WORD_fortran(2, cwd0, L0)
        read( CWD0,* ) TRANGE_REQEP(1)

        call get_PARSE_WORD_fortran(3, cwd0, L0)
        read( CWD0,* ) TRANGE_REQEP(2)

        call get_PARSE_WORD_fortran(4, cwd0, L0)
        read( CWD0,* ) TRANGE_REQEP(3)

        SNRMIN_REQEP = CUTWIN_SNRMAX(1)
      ELSE
         DO iwd = 1, NWD
            USEWD(iwd) = .FALSE.
         ENDDO
 
         DO 44 iwd = 1, NWD-1

           call get_PARSE_WORD_fortran(iwd+0, cwd0, L0)
           call get_PARSE_WORD_fortran(iwd+1, cwd1, L1)
          
           if ( cwd0(1:7) .EQ. 'FILTERS' ) then
              read(cwd1,* ) FILTLIST_REQEP
              USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
           else if ( cwd0(1:6) .EQ. 'SNRMIN' ) then
              read(cwd1,* ) SNRMIN_REQEP
              USEWD(iwd) = .TRUE.;  USEWD(iwd+1) = .TRUE.
           else if ( cwd0(1:11) .EQ. 'TOBS_RANGES' ) then
              USEWD(iwd) = .TRUE.;  
              ISFRAME_OBS_REQEP = .TRUE.
              do i = 1, 3
                call get_PARSE_WORD_fortran(iwd+i, cwd1, L1)
                read(cwd1,* ) TRANGE_REQEP(i); USEWD(iwd+i)=.TRUE.
              enddo
           else if ( cwd0(1:12) .EQ. 'TREST_RANGES' ) then
              USEWD(iwd) = .TRUE.;  
              ISFRAME_REST_REQEP = .TRUE.
              do i = 1, 3
                call get_PARSE_WORD_fortran(iwd+i, cwd1, L1)
                read(cwd1,* ) TRANGE_REQEP(i); USEWD(iwd+i)=.TRUE.
              enddo
           endif

44       CONTINUE
      ENDIF

c ------------------------------------------
c store absolute filter indices in sparse list
      NFILT_REQEP = INDEX(FILTLIST_REQEP,' ') - 1
      DO 10 ifilt=1, NFILT_REQEP
        CFILT = FILTLIST_REQEP(ifilt:ifilt)
        IFILT_OBS = FILTINDX(cfilt // ' ')
        IFILTLIST_REQEP(IFILT) = IFILT_OBS
10    CONTINUE

      CALL PRBANNER(FNAM)      
      print*,'   Require Epochs for filters : ', 
     &       FILTLIST_REQEP(1:NFILT_REQEP)
      
      write(6,41) 'Detection Requires SNR  > ', SNRMIN_REQEP        
      write(6,42) '(Tlast - Tfirst)_Detect < ', TRANGE_REQEP(2)
      write(6,42) 'Pre-detect  veto range  = ', TRANGE_REQEP(1)
      write(6,42) 'Post-detect veto range  = ', TRANGE_REQEP(3)
      print*,' ISFRAME[OBS,REST] = ', 
     &     ISFRAME_OBS_REQEP, ISFRAME_REST_REQEP
41    format(T8,A, F6.1 )
42    format(T8,A, F6.1, ' days' )

      RETURN
      END         ! end PARSE_REQUIRE_EPOCHS_STRING

C ========================================================
+DECK,INIT_HEADER_OVERRIDE.
      SUBROUTINE INIT_HEADER_OVERRIDE()

c Created Nov 29 2016 by R.Kessler
c Read optional list of header variables from file,
c to override values in data files. Useful for systematics,
c and for development of things like host Masses and
c peculiar velocities that may take several iterations
c before deciding final values for the data files.
c Also note that the CID in the HEADER_OVERRIDE file
c can be either the SNID or IAUC name.
c

      IMPLICIT NONE
    
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,OVRIDECOM.

      INTEGER iwd, NWD, LEN1, LEN2, LEN3, LENV, LEN_ALL, NROW
      INTEGER OPTMASK_STORE,  EXIST_VAR, NVAR_ALL, NVAR
      CHARACTER cFILE*(MXCHAR_FILENAME), cTABLE*20, cVARLIST*400 
      CHARACTER VARNAME*60, cVARNAME*60, FNAM*24

c functions
      INTEGER  SNTABLE_AUTOSTORE_INIT, EXIST_VARNAME_AUTOSTORE
      EXTERNAL SNTABLE_AUTOSTORE_INIT, EXIST_VARNAME_AUTOSTORE

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
C ------------ BEGIN -------------

      NVAR_HEADER_OVERRIDE = 0
      IF ( HEADER_OVERRIDE_FILE .EQ. ' '    ) RETURN
      IF ( HEADER_OVERRIDE_FILE .EQ. 'NULL' ) RETURN
      IF ( HEADER_OVERRIDE_FILE .EQ. 'NONE' ) RETURN

      FNAM = 'INIT_HEADER_OVERRIDE'

      LEN_ALL = INDEX(VARLIST_ALL_HEADER_OVERRIDE,' ') - 1
      cVARLIST = VARLIST_ALL_HEADER_OVERRIDE(1:LEN_ALL) // char(0)

c -------------------
c check option to list HEADER variable names that can be overwritten
      IF ( HEADER_OVERRIDE_FILE .EQ. 'LIST' ) THEN
        NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_STRING,cVARLIST,400)
        print*,' '
        print*,' Dump List of available HEADER-Override variables: '
        DO 11 iwd     = 1, NWD
          CALL get_PARSE_WORD_fortran(iwd,VARNAME,LENV)
          print*,'    ', VARNAME
11      CONTINUE
        print*,'  Done with list --> STOP. '
        CALL FLUSH(6)
        CALL EXIT(EXIT_ERRCODE)
      ENDIF
c -------------------

      CALL PRBANNER('INIT_HEADER_OVERRIDE')

      CALL ENVreplace(HEADER_OVERRIDE_FILE) 
      LEN1   = INDEX(HEADER_OVERRIDE_FILE,' ') - 1
      cFILE  = HEADER_OVERRIDE_FILE(1:LEN1) // char(0)

      cTABLE = 'OVERRIDE' // char(0) 
      LEN2   = INDEX(cTABLE,' ') - 1

      OPTMASK_STORE = 4  ! 0->4 on May 11 2017
      NROW = SNTABLE_AUTOSTORE_INIT(cFILE, cTABLE, cVARLIST, 
     &        OPTMASK_STORE,  LEN1, LEN2, LEN3 )

      write(6,20) NROW
 20   format(/, T4,'Stored ', I8,
     &    ' rows of header-override data ')

      IF ( NROW == 0 ) THEN
        C1ERR = 'NROW = 0 in HEADER_OVERRIDE_FILE'
        C2ERR = 'Check ' // HEADER_OVERRIDE_FILE(1:70)
        CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF 

c check which header variables exist in the user file

      NVAR_ALL=STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_STRING,cVARLIST,400)      
      NVAR     = 0 

      DO 10 iwd     = 1, NVAR_ALL

          call get_PARSE_WORD_fortran(iwd, VARNAME, LENV)
          cVARNAME  = VARNAME(1:LENV) // char(0)
          EXIST_VAR = EXIST_VARNAME_AUTOSTORE(cVARNAME,LENV)
          if ( EXIST_VAR > 0 ) then
            write(6,110) VARNAME(1:LENV)
110         format(T10,'--> Override header variable: ', A)
            NVAR = NVAR + 1
            if ( NVAR .LE. MXVAR_HEADER_OVERRIDE ) then
              VARLIST_HEADER_OVERRIDE(NVAR) = VARNAME(1:40)
            endif
          endif
 10   CONTINUE
      NVAR_HEADER_OVERRIDE = NVAR

      IF ( NVAR == 0 ) THEN
         c1err = 'Found no valid variables in HEADER_OVERRIDE_FILE.' 
         c2err = 'Check VARLIST_ALL_HEADER_OVERRIDE in snana.car'
         CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF

c check array bound
      IF ( NVAR > MXVAR_HEADER_OVERRIDE ) THEN
        write(c1err,61) NVAR
61      format(I3,' override variables exceeds bound.' )
        write(c2err,62) MXVAR_HEADER_OVERRIDE
62      format('Bound is MXVAR_HEADER_OVERRIDE = ', I3 )
        CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF

      print*,' ' 
      CALL FLUSH(6)

      RETURN
      END  ! INIT_HEADER_OVERRIDE

C ========================================================
+DECK,EXEC_HEADER_OVERRIDE.
      SUBROUTINE EXEC_HEADER_OVERRIDE()

c Created Nov 29 2016 by R.Kessler
c Execute header override.
c
c Aug 7 2019: fix bug setting SNLC_ZCMB_ERR to zerr instead of z.
c Nov 22 2019: check for HOSTGAL_OBJID, SIM_SALT2x1[c]
 
      IMPLICIT NONE
    
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,OVRIDECOM.

      INTEGER ivar, L, LENV, ISTAT
      REAL*8  DVAL
      REAL*4  z, zerr
      CHARACTER cVARNAME*40, VARNAME*40, cDUM*20
      CHARACTER CCID_SNID*(MXCHAR_CCID), CCID_IAUC*(MXCHAR_CCID)
      CHARACTER FNAM*24

c functions
      EXTERNAL SNTABLE_AUTOSTORE_READ
C ------------ BEGIN ------------

      IF ( NVAR_HEADER_OVERRIDE <= 0 ) RETURN

      FNAM = 'EXEC_HEADER_OVERRIDE'

      L = INDEX(SNLC_CCID,' ') - 1
      CCID_SNID = SNLC_CCID(1:L) // char(0)

      L = INDEX(SNLC_IAUC,' ') - 1
      CCID_IAUC = SNLC_IAUC(1:L) // char(0)

      DO 100 ivar = 1, NVAR_HEADER_OVERRIDE
        VARNAME   = VARLIST_HEADER_OVERRIDE(ivar)
        LENV      = INDEX(VARNAME,' ' ) - 1
        cVARNAME  = VARNAME(1:LENV) // char(0)
        CALL SNTABLE_AUTOSTORE_READ(CCID_SNID,cVARNAME,ISTAT,
     &          DVAL,cDUM,    MXCHAR_CCID, LENV, 20)

        IF ( ISTAT .NE. 0 ) THEN  ! try IAUC name
          CALL SNTABLE_AUTOSTORE_READ(CCID_IAUC,cVARNAME,ISTAT,
     &               DVAL,cDUM,     MXCHAR_CCID, LENV, 20)
        ENDIF
        
        IF ( ISTAT .NE. 0 ) GOTO 100

c brute-force check each possible header variable 

        IF ( VARNAME(1:LENV) .EQ. 'VPEC' ) THEN
          SNLC_VPEC = sngl(DVAL)
        ELSE IF ( VARNAME(1:LENV) .EQ. 'VPEC_ERR' ) THEN
          SNLC_VPEC_ERR = sngl(DVAL)

        ELSE IF ( VARNAME(1:LENV) .EQ. 'REDSHIFT_FINAL' ) THEN
          z         = sngl(DVAL)
          SNLC_ZCMB = z; SNLC_ZHELIO = z;  
          SNLC_REDSHIFT = z
        ELSE IF ( VARNAME(1:LENV) .EQ. 'REDSHIFT_FINAL_ERR' ) THEN
          zerr = sngl(DVAL)
          SNLC_ZCMB_ERR     = zerr    ! bugfix z 
          SNLC_ZHELIO_ERR   = zerr
          SNLC_REDSHIFT_ERR = zerr

        ELSE IF ( VARNAME(1:LENV) .EQ. 'REDSHIFT_HELIO' ) THEN
          SNLC_ZHELIO = sngl(DVAL)
        ELSE IF ( VARNAME(1:LENV) .EQ. 'REDSHIFT_HELIO_ERR' ) THEN
          SNLC_ZHELIO_ERR = sngl(DVAL)

        ELSE IF ( VARNAME(1:LENV) .EQ. 'HOSTGAL_OBJID' ) THEN
          SNHOST_OBJID(1) = sngl(DVAL)   ! Nov 22 2019
        ELSE IF ( VARNAME(1:LENV) .EQ. 'HOSTGAL_LOGMASS' ) THEN
          SNHOST_LOGMASS(1) = sngl(DVAL)
        ELSE IF ( VARNAME(1:LENV) .EQ. 'HOSTGAL_LOGMASS_ERR' ) THEN
          SNHOST_LOGMASS_ERR(1) = sngl(DVAL)

        ELSE IF ( VARNAME(1:LENV) .EQ. 'HOSTGAL_DDLR' ) THEN
          SNHOST_DDLR(1) = sngl(DVAL)   ! Dec 10, 2019

        ELSE IF ( VARNAME(1:LENV) .EQ. 'HOSTGAL_sSFR' ) THEN
          SNHOST_sSFR(1) = sngl(DVAL)
        ELSE IF ( VARNAME(1:LENV) .EQ. 'HOSTGAL_sSFR_ERR' ) THEN
          SNHOST_sSFR_ERR(1) = sngl(DVAL)

        ELSE IF ( VARNAME(1:LENV) .EQ. 'HOSTGAL_PHOTOZ' ) THEN
          SNHOST_ZPHOT(1)     = sngl(DVAL)
        ELSE IF ( VARNAME(1:LENV) .EQ. 'HOSTGAL_PHOTOZ_ERR' ) THEN
          SNHOST_ZPHOT_ERR(1) = sngl(DVAL)

        ELSE IF ( VARNAME(1:LENV) .EQ. 'MWEBV' ) THEN
          SNLC_MWEBV = sngl(DVAL)
        ELSE IF ( VARNAME(1:LENV) .EQ. 'MWEBV_ERR' ) THEN
          SNLC_MWEBV_ERR = sngl(DVAL)

        ELSE IF ( VARNAME(1:LENV) .EQ. 'SIM_SALT2x1' ) THEN ! Nov 24 2019
          SIM_SHAPEPAR = sngl(DVAL) 
        ELSE IF ( VARNAME(1:LENV) .EQ. 'SIM_x1' ) THEN
          SIM_SHAPEPAR = sngl(DVAL) 

        ELSE IF ( VARNAME(1:LENV) .EQ. 'SIM_SALT2c' ) THEN ! Nov 24 2019
          SIM_COLORPAR = sngl(DVAL) 
        ELSE IF ( VARNAME(1:LENV) .EQ. 'SIM_c' ) THEN ! Nov 24 2019
          SIM_COLORPAR = sngl(DVAL) 

        ELSE IF ( VARNAME(1:LENV) .EQ. 'PEAKMJD' ) THEN ! Nov 24 2019
          SNLC_SEARCH_PEAKMJD = sngl(DVAL) 
        ELSE IF ( VARNAME(1:LENV) .EQ. 'PKMJDINI' ) THEN
          SNLC_SEARCH_PEAKMJD = sngl(DVAL)
        ELSE IF ( VARNAME(1:LENV) .EQ. 'PEAKMJDINI' ) THEN  ! same
          SNLC_SEARCH_PEAKMJD = sngl(DVAL)

        ELSE
           C1ERR = 'Unknown VARNAME = '// VARNAME(1:LENV)
           C2ERR = 'Check VARLIST_ALL_HEADER_OVERRIDE in snana.car' 
           CALL MADABORT(FNAM, c1err, c2err )
        ENDIF

100   CONTINUE

      RETURN
      END      ! end EXEC_HEADER_OVERRIDE


C ========================================================
+DECK,INIT_MAGCOR.
      SUBROUTINE INIT_MAGCOR(MAGCOR_INFILE)

c Created Dec 7 2016 by R.Kessler
c Read optional list of mag-correction vs. epoch from ASCII file.
c The file syntax is
c
c If there is a minus sign in front of the file name,
c     MAGCOR_INFILE = '-/BLA/BLA/MAGCOR.DAT'
c then subtract MAGCOR instead of adding.
c
c  NVAR: 2
c  VARNAMES:  ROW  MAGCOR
c  ROW:  [CID]-[MJD]-[BAND]  [MAGCOR]
c  ROW:  [CID]-[MJD]-[BAND]  [MAGCOR]
c   etc ...
c
c Additional columns are allowed, but will be ignored.
c
c Nov 13 2018: pass MAGCOR_INFILE as input argument.
c
c ----------------------

      IMPLICIT NONE
    
+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER MAGCOR_INFILE*(MXCHAR_FILENAME)  ! (I)

      INTEGER LEN1, LEN2, LEN3, OPTMASK_STORE, ISTAT
      CHARACTER 
     &     cFILE*(MXCHAR_FILENAME)
     &    ,cTABLE*20, cVARLIST*20, FNAM*12

c functions
      INTEGER  SNTABLE_AUTOSTORE_INIT, EXIST_VARNAME_AUTOSTORE
      EXTERNAL SNTABLE_AUTOSTORE_INIT, EXIST_VARNAME_AUTOSTORE
      INTEGER ISTAT_MAGCOR_ADD

C ------------ BEGIN -------------

      NSTORE_MAGCOR = 0
      NUSE_MAGCOR   = 0
      IF ( MAGCOR_INFILE .EQ. ' '    ) RETURN
      IF ( MAGCOR_INFILE .EQ. 'NULL' ) RETURN
      IF ( MAGCOR_INFILE .EQ. 'NONE' ) RETURN

      SIGN_MAGCOR = +1  ! default is to add
      IF ( MAGCOR_INFILE(1:1) .EQ. '-' ) THEN
         SIGN_MAGCOR = -1  ! subtract instead
         MAGCOR_INFILE = MAGCOR_INFILE(2:)
      ENDIF

      FNAM = 'INIT_MAGCOR'
      CALL PRBANNER('INIT_MAGCOR: read mag-correction vs. epoch')

      CALL ENVreplace(MAGCOR_INFILE) 
      LEN1   = INDEX(MAGCOR_INFILE,' ') - 1
      cFILE  = MAGCOR_INFILE(1:LEN1) // char(0)

c check header to see if if MAGCOR has been added in version
c ISTAT=1 if MAGCOR alread added ; ISTAT=0 if not already added.
      ISTAT = ISTAT_MAGCOR_ADD(MAGCOR_INFILE,VERSION_PHOTOMETRY(1))

c avoid double-counting MAGCOR
      IF ( ISTAT==0 .and. SIGN_MAGCOR < 0 ) THEN
         C1ERR = 'MAGCOR not in data fluxes --> '
         C2ERR = 'Will not subtract MAGCOR'
         CALL MADABORT(FNAM,C1ERR,C2ERR)          
      ENDIF
      IF ( ISTAT==1 .and. SIGN_MAGCOR > 0 ) THEN
         C1ERR = 'MAGCOR already in data fluxes --> '
         C2ERR = 'Will not double-count MAGCOR.'
         CALL MADABORT(FNAM,C1ERR,C2ERR)          
      ENDIF

      cTABLE = 'MAGCOR' // char(0)  ! any table name will work for ASCII
      LEN2   = INDEX(cTABLE,' ') - 1

      cVARLIST = 'MAGCOR' // char(0)
      LEN3     = INDEX(cVARLIST,' ') - 1

      OPTMASK_STORE = 5  ! 1->5 on May 11 2017
      NSTORE_MAGCOR = 
     &       SNTABLE_AUTOSTORE_INIT(cFILE, cTABLE, cVARLIST, 
     &               OPTMASK_STORE,  LEN1, LEN2, LEN3 )

      write(6,20) NSTORE_MAGCOR
 20   format(/, T4,'Stored ', I6, ' epochs of MAG corrections. ')
      print*,'    Sign of MAGCOR : ', SIGN_MAGCOR
      print*,' '  ;  CALL FLUSH(6)

      RETURN
      END  ! end INIT_MAGCOR


C ========================================      
+DECK,ISTAT_MAGCOR_ADD.
      INTEGER FUNCTION ISTAT_MAGCOR_ADD(MAGCOR_FILE,VERSION)

c Check header of MAGCOR_FILE to see if VERSION has MAGCOR
c already added.  CHeck MAGCOR_FILE for
c
c   VERSION_ADD:  <VERSION>
c
c If MAGCOR already added in data files, return 1.
c If MAGCOR not added, return 0
c
c This function is used to help avoid double-counting MAGCOR,
c but the MAGCOR-add process (outside SNANA) must add  the 
c VERSION_ADD key at the top of the file.
c
c May 22 2018: skip lines with comment field

      IMPLICIT NONE
+CDE,SNPAR.

c inputs
      CHARACTER MAGCOR_FILE*(*), VERSION*(*)

c local
      INTEGER FOUND_ROW, LUN, NWD, LEN, LENVER, NLINE, MSKOPT
      LOGICAL SAME_LEN, SAME_VER, KEYMATCH
      CHARACTER LINE*200, cwd*80, VERSION_ADD*80, FNAM*22
      CHARACTER C1ERR*72, C2ERR*72

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
C --------------- BEGIN ---------------

      ISTAT_MAGCOR_ADD = 0 ! init function value
      FNAM   = 'ISTAT_MAGCOR_ADD'
      MSKOPT = MSKOPT_PARSE_WORDS_STRING
      LENVER = INDEX(VERSION,' ' ) - 1
 
      NLINE=0; FOUND_ROW=0 ; LUN = 24
      OPEN(   UNIT   = LUN
     &      , FILE   = MAGCOR_FILE
     &      , STATUS = 'OLD'
     &           )    


c keep reading until first ROW key is found
     
      DO 200 WHILE ( FOUND_ROW == 0 ) 
         READ(LUN,100) LINE
 100     format(A160)

         IF ( LINE(1:1) .EQ. '#' ) GOTO 200

         NLINE = NLINE + 1

         if ( NLINE > 50 ) then
            C1ERR = 'Could not find ROW key after 50 lines.'
            C2ERR = 'Check ' // MAGCOR_FILE
            CALL MADABORT(FNAM,C1ERR,C2ERR)          
         endif

         NWD = STORE_PARSE_WORDS(MSKOPT, LINE//char(0), 200)

         if ( NWD < 2 ) goto 200

         CALL get_PARSE_WORD_fortran(1,cwd,LEN)

         IF ( cwd(1:4) .EQ. 'ROW:' ) goto 500
         
         KEYMATCH = cwd(1:16) .EQ. 'VERSION_ADD:' 
         IF ( KEYMATCH ) THEN
            CALL get_PARSE_WORD_fortran(2,VERSION_ADD,LEN) 
            SAME_LEN = ( LEN .EQ. LENVER )
            SAME_VER = ( VERSION(1:LEN) .EQ. VERSION_ADD(1:LEN) ) 
            IF ( SAME_LEN .and. SAME_VER ) THEN               
              ISTAT_MAGCOR_ADD = 1 
              GOTO 500
            ENDIF
         ENDIF
200   CONTINUE
      
500   CONTINUE
      CLOSE(UNIT = LUN)

      RETURN
      END

C ========================================================
+DECK,EXEC_MAGCOR.
      SUBROUTINE EXEC_MAGCOR(ep)

c Dec 2016
c Apply MAGCOR read in INIT_MAGCOR. The corrections are
c applied to the FLUXCAL.
c Modify SNLC_FLUXCAL(ep) and SNLC_MAG(ep)
c
c May 1 2017: abort on crazy MAGCOR
c ---------------------------------

      IMPLICIT NONE
    
      INTEGER ep ! epoch index

c local variables
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
      
      INTEGER IFILT_OBS, ISTAT, L, L2
      REAL*8 MJD, DVAL
      REAL*4 MAGCOR, FCOR
      CHARACTER cVARNAME*20, BAND*2, cDUM*20
      CHARACTER STR_EPID1*60, STR_EPID2*60

      REAL MAGCOR_CRAZY
      PARAMETER ( MAGCOR_CRAZY = 0.2 ) 

c function
      EXTERNAL SNTABLE_AUTOSTORE_READ
c --------------- BEGIN -----------------

      IF ( NSTORE_MAGCOR <= 0 ) RETURN

      IFILT_OBS = ISNLC_IFILT_OBS(ep)
      BAND      = FILTDEF_STRING(ifilt_obs:ifilt_obs)       
      MJD       = SNLC8_MJD(ep)

c construct unique epoch-identifier by gluing SNID+MJD+BAND
c into a single string.

      L  = INDEX(SNLC_CCID,' ') - 1
      WRITE(STR_EPID1,40) SNLC_CCID(1:L), MJD, BAND, char(0)
40    FORMAT(A,'-',F9.3,'-', A1, A )

      cVARNAME = 'MAGCOR' // char(0)

      CALL SNTABLE_AUTOSTORE_READ(STR_EPID1, cVARNAME, ISTAT,
     &                 DVAL,cDUM, 60,10,10 )

c if no MAGCOR, then try again with IAUC name
      IF ( ISTAT .NE. 0 ) THEN
        L2  = INDEX(SNLC_IAUC,' ') - 1
        WRITE(STR_EPID2,40) SNLC_IAUC(1:L2), MJD, BAND, char(0)
        CALL SNTABLE_AUTOSTORE_READ(STR_EPID2, cVARNAME, ISTAT, 
     &                 DVAL,cDUM, 60,10,10 )
      ENDIF

      IF ( ISTAT .EQ. 0 ) then
        NUSE_MAGCOR  = NUSE_MAGCOR + 1
        MAGCOR = sngl(DVAL) * SIGN_MAGCOR

c trap crazy MAGCOR
        if ( abs(MAGCOR) > MAGCOR_CRAZY ) then
           write(C1ERR,61) MAGCOR
61         format('Crazy MAGCOR = ', G12.4 )
           C2ERR = 'Check ' // STR_EPID1(1:L+12)
           CALL MADABORT("EXEC_MAGCOR",C1ERR,C2ERR)
        endif

        FCOR   = 10**(-0.4*MAGCOR)

        SNLC_FLUXCAL(ep) = SNLC_FLUXCAL(ep) * FCOR
        SNLC_MAG(ep)     = SNLC_MAG(ep) + MAGCOR

c        write(6,66) DVAL, STR_EPID1, ISTAT
c66      format(' xxx MAGCOR=',F6.3,' for ', A20,'  ISTAT=',I3)
c        call flush(6)
      ENDIF

      CALL SETMASK_FLUXCOR_SNANA(MASK_FLUXCOR_SNANA)

      RETURN
      END  ! end EXEC_MAGCOR

C ========================================================
+DECK,END_MAGCOR.
      SUBROUTINE END_MAGCOR()
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.   
C --------------- BEGIN --------------

      IF ( NSTORE_MAGCOR == 0 ) RETURN

      print*,' '
      print*,' MAGCOR SUMMARY:'
      write(6,20) NUSE_MAGCOR, NSTORE_MAGCOR
20    format(T8,'Used ',I6,' MAGCOR epochs from ', 
     &          I6,' read from file.' )

      RETURN
      END


C ========================================================
+DECK,RD_VPEC_FILE.
      SUBROUTINE RD_VPEC_FILE(IFLAG)

c Read list of peculiar velocity corrections (and errors)
c from file VPEC_FILE.
c Units are km/s, and are converted into a z_CMB correction for
c the output Hubble diagram.
c
c !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
c !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
c
c WARNING(Nov 2016): 
c   this function may become obsolete since the same capability
c   is in HEADER_OVERRIDE_FILE, which can include additional
c   header variables.  
c   Should really switch to using HEADER_OVERRIDE_FILE.
c
c !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
c !~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~
c
c VPEC_FILE format must be 
c
c NVAR: <N>
c VARNAMES:  CID  VPEC VPEC_ERR  <bla1> <bla2> etc ...
c
c and note that VPEC and VPEC_ERR can be anywhere on the list
c
c Oct 27, 2014: use refactored AUTOSTORE functions 
c               (works on any format instead of ascii only)
c
c Nov 30 2016: 
c   + pass IFLAG=-1 for init, IFLAG=0 to execute.
c   + refactor to init and execute in same function
c
c Jun 8 2017:
c  + for LSIM_SNAN, VPEC_FILE -> '' so that VPEC_FILE applies ONLY to data
c  + allow ENV in VPEC_FILE; see ENVreplace call.
c
c ----------------------------

      IMPLICIT NONE

      INTEGER    IFLAG  ! (I) 

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER  L1, L2, L3, LENV, ISTAT
      INTEGER  OPTMASK_STORE, NSTORE_VPEC
      CHARACTER  
     &   VARLIST*80
     &  ,cFILE*(MXCHAR_FILENAME)
     &  ,cTABLE*20
     &  ,cVARLIST*80
     &  ,cVARNAME*40, CCID*(MXCHAR_CCID), cDUM*20

      REAL*8 DVAL 

c functions
      INTEGER  SNTABLE_AUTOSTORE_INIT
      EXTERNAL SNTABLE_AUTOSTORE_INIT, SNTABLE_AUTOSTORE_READ

C ------------- BEGIN ------------


      IF ( VPEC_FILE .EQ. '' ) RETURN

      IF ( LSIM_SNANA ) THEN
        print*,' '
        print*,'  ############################################### '
        print*,'  !!!! IGNORE VPEC_FILE for SNANA SIMULATION !!!! '
        print*,'  ############################################### '
        print*,' '
        CALL FLUSH(6)

        VPEC_FILE = ''  ! Jun 2017: no VPEC in simulation
        RETURN
      ENDIF

      IF ( IFLAG < 0 ) THEN  ! one-time init
  
        CALL ENVreplace(VPEC_FILE)

        GLOBAL_BANNER = 
     &      'Read User Peculiar-Velocity Corrections (km/sec)'
        CALL PRBANNER (GLOBAL_BANNER(1:60) )

c init variables to read

        OPTMASK_STORE = 7  ! 3->7 on May 11 2017
        VARLIST = 'VPEC,VPEC_ERR '  ! hard-wird names

        L1      = INDEX(VPEC_FILE,' ') - 1
        L2      = 4
        L3      = INDEX(VARLIST,  ' ') - 1

        cFILE     = VPEC_FILE(1:L1) // char(0)
        cTABLE    = 'VPEC'          // char(0) ! anything will work for ascii
        cVARLIST  = VARLIST(1:L3)   // char(0)

        NSTORE_VPEC = SNTABLE_AUTOSTORE_INIT(cFILE, cTABLE, cVARLIST, 
     &                   OPTMASK_STORE,  L1, L2, L3 )

        IF ( NSTORE_VPEC == 0 ) THEN
           C1ERR = 'NSTORE_VPEC = 0 in VPEC_FILE'
           C2ERR = 'Check ' // VPEC_FILE(1:70)
           CALL MADABORT("RD_VPEC_FILE",C1ERR,C2ERR)
        ENDIF 

      ELSE  ! EXECUTE
  
         CCID  = SNLC_CCID(1:ISNLC_LENCCID) // char(0)

         cVARNAME = 'VPEC' // char(0)  ; LENV  = 4
         CALL SNTABLE_AUTOSTORE_READ(CCID,cVarname,ISTAT,
     &         DVAL,cDUM,  ISNLC_LENCCID, LENV, 20)
         IF ( ISTAT == 0 ) SNLC_VPEC = sngl(DVAL)

         cVARNAME = 'VPEC_ERR' // char(0)  ; LENV  = 8
         CALL  SNTABLE_AUTOSTORE_READ(CCID,cVarname,ISTAT,
     &         DVAL,cDUM,  ISNLC_LENCCID, LENV, 20)
         IF ( ISTAT == 0 ) SNLC_VPEC_ERR = sngl(DVAL)

      ENDIF

      RETURN
      END  ! end of RD_VPEC_FILE


C ================================
+DECK,ZHD.
      SUBROUTINE REDSHIFT_HD()

c Created Oct 2013 by R.Kessler.
c Compute redshift 'ZHD' for  Hubble diagram, which is
c ZCMB + vPec correction.
c
c Nov 30 2016: 
c  + re-factor to use externally-computed SNLC_VPEC.
c    i.e., move the read-vpec-file stuff into RD_VPEC_FILE.
c
c
c Jan 26 2018: set SNLC_ZPEC[_ERR]
c
c ----------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      LOGICAL  DOCOR_VPEC
      REAL     ZERR1, ZERR2, ZPEC, ZPECERR

C ------------ BEGIN ---------

c init default with ZHD = CMB redshift
      SNLC_ZHD        = SNLC_ZCMB
      SNLC_ZHD_ERR    = SNLC_ZCMB_ERR

      DOCOR_VPEC = .FALSE.
      IF ( SNLC_VPEC     .NE. 0.0 ) DOCOR_VPEC = .TRUE.
      IF ( SNLC_VPEC_ERR .NE. 0.0 ) DOCOR_VPEC = .TRUE.

      SNLC_ZPEC     = SNLC_VPEC     / CLIGHT
      SNLC_ZPEC_ERR = SNLC_VPEC_ERR / CLIGHT

c ------------------------------------------
c re-compute ZHD and its error if SNLC_VPEC has non-null value
c Jan 3 2018: use VPEC (sigma_z) correction from Eq. 1 (A1) in
c             Davis 2012 [https://arxiv.org/pdf/1012.2912.pdf]

      IF ( DOCOR_VPEC ) THEN

         ZPEC     = ( SNLC_VPEC     / CLIGHT )
         ZPECERR  = ( SNLC_VPEC_ERR / CLIGHT )

         SNLC_ZHD = (1.0+SNLC_ZCMB) * (1.0+ZPEC) - 1.0 

         ZERR1 = SNLC_ZCMB_ERR
         ZERR2 = ZPECERR * (1.0 + SNLC_ZCMB) ! Eq A1, Davis 2012
         SNLC_ZHD_ERR = sqrt(ZERR1*ZERR1 + ZERR2*ZERR2)
      ENDIF

      RETURN 
      END   ! REDSHIFT_HD

C ============================================
+DECK,SNRECON.
      SUBROUTINE SNRECON()
c
c Created Feb 10, 2006 by R.Kessler
c
c Miscellaneous reconstruction/computation of 
c useful variables for analysis.
c
c Includes:
c
c  * ISNLC_NFILT_TRESTMIN[MAX]
c  * ISNLC_NFILT_TREST2  
c  * SNLC_TREST(epoch)        = MJD - MJDatPEAK(search) 
c  * SNLC_TOBS(epoch)
c  *
c  * SNLC_FLUXCAL_ERRCALC(ifilt,epoch,isn)  ! calc flux error 
c  * SNHOST_ZPHOT[_ERR]
c  * SNLC_SNRMAX_FILT(ifilt)
c  * SNLC_SNRMAX_SORT(rank)
c  * SNLC_SNRMAX_IFILTDEF(ifilt)
c  * SNLC_FLUXCALMAX(ifilt)
c
c  * correct SNLC_MAG and FLUXCAL for AB mag-offsets
c
c  * erase filter-epochs with bad photometry flag
c
c
c
c Nov 3 2014: evaluate ISNLC_CUTFLAG_PRIVATE 
c
c Mar 2015: after call to CHECK_EPOCH_IGNORE(EP), skip to 201 to 
c           make sure bad epochs are not used for anything.
c
c Aug 11 2015: increment ISNLC_NMJD_INCLUDE 
c
c Feb 18, 2017: add epoch cut for CUTWIN_LAMOBS
c
c Jul 03, 2017: call COUNTFIELDS before epoch loop instead of after,
c               so that duplicate-check marks correct FIELDLIST.
c
c Aug 29 2017: check logical USESIM_TRUEFLUX
c
c Nov 29 2017: apply MWEBV_SCALE and MWEBV_SHIFT here.
c
c Feb 12 2018: for USE_SNHOST_ZPHOT=T, convert host zphot to host zcmb
c Feb 16 2018: compute SNHOST_SBMAG(ifilt)
c Mar 18 2017: fill SNLC_DTOBS[_SAMEFILT] = time since last obs
c Sep 16 2018: compute NOBS_DETECT and TLIVE_DETECT
c
c Nov 12 2018: check APPLY_FLUXCOR_BUG to apply bug of computing
c              SNRMAX variables before EXEC_FUDGE_FLUXCAL()
c
c -------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PRIVCOM.

c local var

      INTEGER 
     &   newmjd, ifilt, ifilt_obs, LENLIST, INDEX_OVP
     &  ,NBAND_SNRMAX, NBAND_SNRMAX2
     &  ,EPMIN, EPMAX, ep, isort, PHOTFLAG
     &  ,ORDER, INDEX_SORT(MXFILT_OBS)  ! SORT args

      REAL
     &   Fluxcal, Fluxcal_err, TRUEFLUX
     &  ,Xnsig, MAG, SIM_MAG, magoff, ZP, PHOTPROB
     &  ,Tobs, z1, z, Trest, scale, arg
     &  ,Zhost, Zhosterr, LAMOBS, LAMZ1,  SNRMAX

      REAL*8  MJD8, EBV8, EBVERR8
      REAL*8  MJD8_FIRSTDETECT, MJD8_LASTALL, MJD8_LASTFILT(MXFILT_ALL)

      LOGICAL 
     &   LSIG, LLAM, LZ, LTEST, LXMJD, LINCMJD
     &  ,LSNRMAX(MXFILT_ALL)
     &  ,LSNRMAX2(MXFILT_ALL)
     &  ,LFLUX, LERR, LTMP, USE4SNRMAX

c function
      REAL*8   DLMAG8_REF
      EXTERNAL SORTFLOAT, modify_MWEBV_SFD
      INTEGER  ISTAT_REQUIRE_EPOCHS

C ------------------ BEGIN -----------------

c check to increment SUBSURVEY_LIST
 
      IF ( IDSURVEY .ne. IDSUBSURVEY ) THEN
        INDEX_OVP = INDEX(SUBSURVEY_NAME_LIST,SUBSURVEY_NAME) 
        IF ( INDEX_OVP<=0 ) THEN
          LENLIST = INDEX(SUBSURVEY_NAME_LIST,' ') - 1
          if ( LENLIST == 0 ) then  
             SUBSURVEY_NAME_LIST = SUBSURVEY_NAME
          else
            SUBSURVEY_NAME_LIST = SUBSURVEY_NAME_LIST(1:LENLIST)
     &          // ',' // SUBSURVEY_NAME
          endif
        ENDIF
      ENDIF

c - - - - - -
c Check option to use host photo-z as redshift.
      IF ( USE_SNHOST_ZPHOT ) CALL SET_SNHOST_ZPHOT()

c if ZHELIO < 0, convert zCMB -> zHELIO
      CALL SET_ZHELIO()

c - - - - -
      Z    = SNLC_REDSHIFT

      if ( Z > 0.0 ) then
         Z1 = 1.0  + z
      else
         Z1 = 1.0  ! in case Z = -9 is undefined; Trest -> Tobs
      endif

      ISNLC_NEPOCH_USE = 0


c ------ compute MJDMIN/MJDMAX here before calling SET_PKMJD ------

      SNLC8_MJDMIN  = 1.0E8
      SNLC8_MJDMAX  = 0.0
      DO NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO EP = EPMIN, EPMAX
          SNLC8_FLUXCAL(EP)        = DBLE(SNLC_FLUXCAL(ep))
          SNLC8_FLUXCAL_ERRTOT(EP) = DBLE(SNLC_FLUXCAL_ERRTOT(ep))
          MJD8  = SNLC8_MJD(EPMIN)
          IF( MJD8 .GT. SNLC8_MJDMAX ) SNLC8_MJDMAX = MJD8
          IF( MJD8 .LT. SNLC8_MJDMIN ) SNLC8_MJDMIN = MJD8
       ENDDO
      ENDDO

c Sep 21 2013: check option to modify MWEBV_SFD;
c Note that MWEBV and MWEBV_ERR are modified if OPT_MWEBV > 0
      EBV8 = DBLE(SNLC_MWEBV) ; EBVERR8 = DBLE(SNLC_MWEBV_ERR)

      CALL modify_MWEBV_SFD(OPT_MWEBV,SNLC8_RA, SNLC8_DEC,
     &                      EBV8, EBVERR8)  ! I -> O

      SNLC_MWEBV     = SNGL(EBV8)     * MWEBV_SCALE + MWEBV_SHIFT
      SNLC_MWEBV_ERR = SNGL(EBVERR8)  * MWEBV_SCALE      

c compute Galactic extinction in each band
c (Oct 11 2013: code moved from MAIN to here)
      CALL MWEBV_FLUXCOR()

c determine redshift for Hubble diagram (Oct 2013)
      CALL REDSHIFT_HD()

+SELF,IF=SNANA,SNFIT.
c get approx peakMJD    
      if ( OPT_SETPKMJD > 0 ) THEN
         CALL SET_PEAKMJD()
         CALL SELECT_EPOCHS_CUTWIN_TREST()
      endif
+SELF.

c -----------------------------------------------
c pick host photoZ

      Zhost    = -9.0
      Zhosterr = -9.0

      if ( SNHOST_ZPHOT(1) .GT. 0.0 ) then
         zhost    = SNHOST_ZPHOT(1)
         zhosterr = SNHOST_ZPHOT_ERR(1)
      else
        SNHOST_ZPHOT(1)     = Zhost
        SNHOST_ZPHOT_ERR(1) = Zhosterr
      endif


c compute lumi-distance using "standard" cosmology
c Useful as initial value for fits.

      IF ( Z .GT. 1.0E-5 ) THEN
         SNLC_DLMAG  = DLMAG8_REF( dble(Z) )
      ELSE
         SNLC_DLMAG  = -9.0  ! undefined
      ENDIF

      do ifilt = 1, NFILTDEF_SURVEY   
         LSNRMAX(ifilt)       = .FALSE.
         LSNRMAX2(ifilt)      = .FALSE.
         MJD8_LASTFILT(ifilt) = -9.0
         CALL SET_SBMAG(ifilt)  ! Feb 17 2018: compute SBMAG from SBFLUX
      enddo
  
      NBAND_SNRMAX  = 0
      NBAND_SNRMAX2 = 0
      MJD8_LASTALL  = -9.0
      NEP_SIM_MAGOBS =  0

c fill ISNLC_NFIELD with number of fields; 
      CALL COUNTFIELDS()

c = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
c = = = = = = = = START LOOP OVER EPOCHS = = = = = = = = 
c = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 
      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        MJD8  = SNLC8_MJD(EPMIN)
        Tobs  = MJD8 - SNLC_SEARCH_PEAKMJD
        Trest = Tobs / z1

        SNLC_TOBS(EPMIN)  = Tobs
        SNLC_TREST(EPMIN) = Trest

        DO 201 EP = EPMIN, EPMAX

           ISNLC_SNRECON_USE(ep) = 0

           SNLC_TREST(EP) = Trest
           SNLC_TOBS(EP)  = Tobs
           IFILT_OBS = ISNLC_IFILT_OBS(ep)
           IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
           
           CALL CHECK_DUPLICATE_MJDBAND(ep) ! Jun 13 2017

           if ( APPLY_FLUXCOR_BUG == 0 ) then
             CALL EXEC_FUDGE_FLUXCAL(ep)  ! flux and fluxerr fudges
           endif

           CALL SET_MAG(ep)  ! Jan 23 2018

           USE4SNRMAX = LFILTDEF_SNRMAX(ifilt_obs) ! Apr 2014

c test filter mean only if KCOR file is read.
           LLAM = .TRUE.
+SELF,IF=R4KCOR,I2KCOR.
          LZ = ( Z > 0 .and. Z < 998 )
          IF ( NCALL_RDKCOR > 0  .and. LZ ) THEN
            LAMOBS = FILTOBS_LAMAVG(ifilt_obs) 
            LAMZ1  = LAMOBS / Z1
            LLAM   = 
     &           LAMZ1  .GE. CUTWIN_LAMREST(1) .and.
     &           LAMZ1  .LE. CUTWIN_LAMREST(2) .and.
     &           LAMOBS .GE. CUTWIN_LAMOBS(1)  .and.  ! added Feb 18 2017
     &           LAMOBS .LE. CUTWIN_LAMOBS(2)
          ENDIF
+SELF.

c strip off local variables.
          Fluxcal      = SNLC_FLUXCAL(ep)
          Fluxcal_err  = SNLC_FLUXCAL_ERRTOT(ep)
          mag          = SNLC_MAG(ep)

c Jan 3 2018: skip saturated mags
          if ( FLUXCAL_ERR .GE. 0.9E8 .AND. LSIM_SNANA ) GOTO 201

          if ( APPLY_FLUXCOR_BUG > 0 ) then
            CALL EXEC_FUDGE_FLUXCAL(ep)  ! flux and fluxerr fudges
          endif

c convert sim-mag to SIM_FLUXCA
          IF ( LSIM_SNANA .or. LSIM_MAGOBS ) THEN
             ZP        = ZEROPOINT_FLUXCAL_DEFAULT
	     SIM_MAG   = SIM_EPMAGOBS(ep)
	     if ( SIM_MAG < 90.0 ) then
	       NEP_SIM_MAGOBS = NEP_SIM_MAGOBS + 1 ! Nov 25 2019
               ARG            = 0.4*(ZP - SIM_MAG)
               TRUEFLUX       = 10.0**(ARG)
             else               
	       TRUEFLUX = 0.0
             endif	 
             SIM_EPFLUXCAL(ep) = TRUEFLUX	
             IF ( USESIM_TRUEFLUX ) SNLC_FLUXCAL(ep)=TRUEFLUX
          ELSE
             SIM_EPFLUXCAL(ep) = -9.0
          ENDIF
 
+SELF,IF=SNANA,SNFIT.
          CALL FLUXERRCALC( ep, Fluxcal, Fluxcal_err )
c compute relative area of rectangle containing pixel location
          CALL CCD_AREAFRAC(ep)   ! 8.07.2014
+SELF.

c compute significance.
c Feb 2, 2007: 
c   use FLUXCAL instead of FLUX to determine signal/noise.
c
          Xnsig  = -999.0
          LERR   = (Fluxcal_err > 0.0 )
          LFLUX  = (abs(Fluxcal+9.0) > 1.0E-5 )  !  FLUXCAL != -9
          if ( LERR .and. LFLUX ) then
             Xnsig  = Fluxcal / Fluxcal_err
          endif

c ----------------
c Correct MAG and FLUXCAL  for  MAGOFF_AB.
c This correction is done AFTER Xsig = S/N is calculated

           magoff = MAGOBS_SHIFT_ZP_FILT(ifilt_OBS)
           SNLC_MAG(ep) = SNLC_MAG(ep) + magoff
           FLUXSCALE_ZP_FILT(IFILT_OBS) = 10.0**(-0.4 * magoff)

           if ( magoff .ne. 0.0 ) then
             scale = FLUXSCALE_ZP_FILT(IFILT_OBS) 
             SNLC_FLUXCAL(ep) =
     &       SNLC_FLUXCAL(ep) * Scale
             SNLC_FLUXCAL_ERRTOT(ep) =
     &       SNLC_FLUXCAL_ERRTOT(ep) * Scale
           endif

c Feb 2018: compute ZP quantity for cut
           SNLC_ZEROPT_forCUT(ep) = SNLC_ZEROPT(ep) ! default is ADU
           if ( cutwin_zpNPE(1) > 0. ) then
             SNLC_ZEROPT_forCUT(ep) = SNLC_ZEROPT(ep)
     &                              +  2.5*log10(SNLC_GAIN(ep))
           endif

c Mar 2018: store time since last obs: all bands, and same band
          IF ( MJD8_LASTALL > 0.0 ) THEN
             SNLC_DTOBS(ep) = SNGL(MJD8 - MJD8_LASTALL)
          ENDIF
          IF ( MJD8_LASTFILT(ifilt) > 0.0 ) THEN
             SNLC_DTOBS_SAMEFILT(ep) = SNGL(MJD8 - MJD8_LASTFILT(ifilt))
          ENDIF
          MJD8_LASTALL         = MJD8
          MJD8_LASTFILT(ifilt) = MJD8

c ----------------
c signal is accepted if it passes S/noise cut,
c or it is within the Trest window.

          SNLC_FLUX_NSIG(ep) = Xnsig

c check how many obs are in the INCLUDE_MJD window (Aug 2015)
          LINCMJD = MJD8 .GE. CUTWIN_MJD_INCLUDE(1) .and. 
     &              MJD8 .LE. CUTWIN_MJD_INCLUDE(2)
          IF ( LINCMJD ) ISNLC_NMJD_INCLUDE = ISNLC_NMJD_INCLUDE + 1

c check MJD-exclude window to reject epochs (but keep LC)
          LXMJD = MJD8 .GE. CUTWIN_MJD_EXCLUDE(1) .and. 
     &            MJD8 .LE. CUTWIN_MJD_EXCLUDE(2)
                    
          LSIG = Xnsig .GE. cutwin_snrmin_filt(1,ifilt)
     &     .and. Tobs  .GE. cutwin_Tobs(1)  
     &     .and. Tobs  .LE. cutwin_Tobs(2)  
     &     .and. Trest .GE. cutwin_Trest(1)  
     &     .and. Trest .LE. cutwin_Trest(2)  
     &     .and. MJD8  .GE. cutwin_MJD(1)
     &     .and. MJD8  .LE. cutwin_MJD(2)
     &     .and. .not. LXMJD     ! Feb 2012
     &     .and. LLAM            ! rest-frame lambda OK (7/08/08)
     &     .and. fluxcal_err >  0.0    ! flux err is > 0  

          IF ( .NOT. LSIG ) GOTO 201 ! Nov 30, 2011

c set use-flag for this epoch
          ISNLC_SNRECON_USE(ep) = 1

          if ( USE4SNRMAX ) then
             SNLC_SNRMAX_FILT(0)     = 
     &            MAX ( SNLC_SNRMAX_FILT(0), Xnsig )
             SNLC_SNRMAX_FILT(ifilt) = 
     &            MAX ( SNLC_SNRMAX_FILT(ifilt), Xnsig )
          endif

          SNLC_FLUXCALMAX(ifilt) =
     &         MAX ( SNLC_FLUXCALMAX(ifilt), Fluxcal )

          EXIST_FILT(ifilt) = .TRUE.
          ISNLC_NEPOCH_USE  = ISNLC_NEPOCH_USE + 1

c track number of filters that pass SNRMAX cut
          LTEST = XNSIG .GE. CUTWIN_SNRMAX(1)
          LTMP  = USE4SNRMAX .and. (.not. LSNRMAX(ifilt))

          IF ( LTEST .and. LTMP ) THEN
             NBAND_SNRMAX = NBAND_SNRMAX + 1
             LSNRMAX(ifilt) = .TRUE.
          ENDIF

c repeat for 2nd SNRMAX2 cut 
          LTEST = XNSIG .GE. CUTWIN_SNRMAX2(1)
          LTMP  = USE4SNRMAX .and. (.not. LSNRMAX2(ifilt))
          IF ( LTEST .and. LTMP ) THEN
             NBAND_SNRMAX2 = NBAND_SNRMAX2 + 1
             LSNRMAX2(ifilt) = .TRUE.
          ENDIF

c check PHOTPROB (Mar 2018)
          PHOTPROB = SNLC_PHOTPROB(ep)
          if ( PHOTPROB > -0.0001 ) then
             SNLC_PHOTPROB_MIN = MIN(SNLC_PHOTPROB_MIN,PHOTPROB)
             ISNLC_NEPOCH_PHOTPROB = ISNLC_NEPOCH_PHOTPROB + 1
          endif

c check for detection bit in PHOTFLAG (set by survey)
          PHOTFLAG = ISNLC_PHOTFLAG(ep)
          if ( IAND(PHOTFLAG,PHOTFLAG_DETECT) > 0 ) then
             ISNLC_NEPOCH_DETECT = ISNLC_NEPOCH_DETECT + 1
             if ( ISNLC_NEPOCH_DETECT == 1 ) MJD8_FIRSTDETECT=MJD8
             SNLC_TLIVE_DETECT = SNGL(MJD8 - MJD8_FIRSTDETECT)
          endif

c check for trigger bit set by survey (5.2019)          
          if ( IAND(PHOTFLAG,PHOTFLAG_TRIGGER) > 0 ) then
             SNLC8_MJD_TRIGGER = MJD8
          endif

201     CONTINUE     ! come here of LSIG fails

          
200   CONTINUE  ! NEWMJD

      ISNLC_NFILT_SNRMAX    = NBAND_SNRMAX
      ISNLC_NFILT_SNRMAX2   = NBAND_SNRMAX2

      ORDER = -1
      CALL SORTFLOAT( NFILTDEF_SURVEY, SNLC_SNRMAX_FILT(1), 
     &                 ORDER, INDEX_SORT(1) )

      DO isort  = 1, NFILTDEF_SURVEY
         ifilt  = INDEX_SORT(isort)
         SNRMAX = SNLC_SNRMAX_FILT(ifilt)
         SNLC_SNRMAX_SORT(isort) = SNRMAX
      ENDDO

c -----------------------------------------
      CALL GET_USERTAG(SNLC_CCID )

c ----------------------------------------
c Oct 2014: check for multi-season activity
 
      CALL MULTISEASON(IFLAG_ANA)

c check epochs above/below threshold
      ISNLC_CUTFLAG_REQEP = ISTAT_REQUIRE_EPOCHS()

c evalute cuts on PRIVATE & SIMVAR variables
      CALL EVAL_PRIVATEVAR_CUTS()
      CALL EVAL_SIMVAR_CUTS()

c check option to estimate LC width
      CALL GET_SIM_LCWIDTH(1)

c May 2017: load ADDCOL arrays
      CALL TABLE_ADDCOL_LOAD()

      RETURN
      END   ! end of SNRECON

C =============================
+DECK,SET_ZHELIO.
      SUBROUTINE SET_ZHELIO

C Creatd Feb 25 2018
c If SNLC_ZHELIO < 0, transform from zCMB.
c Otherwise, do nothing.

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER OPT
      CHARACTER EQ*4
      REAL*8    ZHEL8, ZCMB8

      REAL*8 zhelio_zcmb_translator ! function

C ------------- BEGIN ------------

      IF ( SNLC_ZHELIO > 0 ) RETURN
      IF ( SNLC_ZCMB   < 0 ) RETURN

c now we have undefined zHELIO and valid zCMB
      SNLC_ZHELIO_ERR = SNLC_ZCMB_ERR

      OPT    = 1     ! --> convert ZHEL to ZCMB
      EQ     = 'eq' // char(0)
      ZCMB8  = DBLE ( SNLC_ZCMB )
      ZHEL8  = 
     &    zhelio_zcmb_translator(ZCMB8,SNLC8_RA,SNLC8_DEC,EQ,OPT, 4)

      SNLC_ZHELIO = SNGL(ZHEL8)

      SNLC_REDSHIFT     = SNLC_ZHELIO
      SNLC_REDSHIFT_ERR = SNLC_ZHELIO_ERR

      RETURN
      END

C =============================================
+DECK,SET_SNHOST_ZPHOT.
      SUBROUTINE SET_SNHOST_ZPHOT
  
c Called if USE_SNHOST_ZPHOT=T.
c Sets redshift variables to host zphot.

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER OPT
      CHARACTER EQ*4
      REAL*8  ZCMB8, ZHEL8

      REAL*8 zhelio_zcmb_translator ! function
C -------------- BEGIN ----------------

      if ( .not. EXIST_SNHOST_ZPHOT ) then
          C1ERR = 'Cannot USE_SNHOST_ZPHOT for CID='//SNLC_CCID
          C2ERR = 'Check data files, or set USE_SNHOST_ZPHOT=F'
          CALL MADABORT("SNRECON", c1err, c2err )
      endif        

      OPT    = 1     ! --> convert ZHEL to ZCMB
      EQ     = 'eq' // char(0)
      ZHEL8  = DBLE( SNHOST_ZPHOT(1) )
      ZCMB8  =
     &    zhelio_zcmb_translator(ZHEL8,SNLC8_RA,SNLC8_DEC,EQ,OPT,4)

      SNLC_ZCMB         = SNGL(ZCMB8)
      SNLC_ZHELIO       = SNGL(ZHEL8)        
      SNLC_REDSHIFT     = SNGL(ZHEL8)

      SNLC_ZHELIO_ERR     = SNHOST_ZPHOT_ERR(1)
      SNLC_ZCMB_ERR       = SNHOST_ZPHOT_ERR(1)             
      SNLC_REDSHIFT_ERR   = SNHOST_ZPHOT_ERR(1)

      RETURN
      END

C ===============================
+DECK,SET_MAG.
      SUBROUTINE SET_MAG(ep)

C Created Jan 23 2018
C Compute observer mag SNLC_MAG(ep) to reduce
C data volume in files. Note that SNLC_MAGERR
c is not set because it is not used.
C 
      IMPLICIT NONE

      INTEGER ep  ! (I) epoch index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.

      REAL FLUXCAL, FLUXCAL_ERR, MAG

C --------- BEGIN ------------

      Fluxcal      = SNLC_FLUXCAL(ep)
      Fluxcal_err  = SNLC_FLUXCAL_ERRTOT(ep)      

      IF ( FLUXCAL_ERR > 0.99E8 ) THEN
        MAG = MAG_SATURATE
      ELSE IF ( FLUXCAL < 1.0E-9 ) THEN
        MAG = 128.0  ! negative flux
      ELSE 
        MAG = ZEROPOINT_FLUXCAL_DEFAULT - 2.5*LOG10(FLUXCAL)
      ENDIF

      SNLC_MAG(ep) = MAG

      RETURN
      END


C ===============================
+DECK,SET_SBMAG.
      SUBROUTINE SET_SBMAG(ifilt)

C Created Feb 17 2018
C Compute surface-brightness mag SNLC_SBMAG(ep) from SB flux.
C 
      IMPLICIT NONE
      INTEGER ifilt  ! (I) sparse filter index
+CDE,SNDATCOM.
      REAL SBFLUX, SBMAG, SBFLUXMIN      
C --------- BEGIN ------------
      SBFLUX = SNHOST_SBFLUXCAL(ifilt)
      SBFLUXMIN = 0.1

      IF ( SBFLUX > SBFLUXMIN ) THEN
         SBMAG = ZEROPOINT_FLUXCAL_DEFAULT - 2.5*LOG10(SBFLUX)
      ELSE
         SBMAG = ZEROPOINT_FLUXCAL_DEFAULT - 2.5*LOG10(SBFLUXMIN) 
      ENDIF
      SNHOST_SBMAG(ifilt) = SBMAG
      RETURN
      END

C ========================
+DECK,PARSE_SIMVAR_CUTS.
      SUBROUTINE PARSE_SIMVAR_CUTS()
      IMPLICIT NONE

c Dec 2018
c Parse &SNLCINP input SIMVAR_CUTWIN_STRING

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER NTMP, i, NWD, LWD
      CHARACTER ctmp1*60, ctmp2*60, ctmp3*60, FNAM*20

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------- BEGIN ---------
      IF ( .NOT. (LSIM_SNANA .or. LSIM_MAGOBS) )  RETURN
      IF ( SIMVAR_CUTWIN_STRING .EQ. '' ) RETURN

      FNAM = 'PARSE_SIMVAR_CUTS'
      NTMP = 0 
      LWD = MXCHAR_CUTNAME-2
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_STRING,
     &     SIMVAR_CUTWIN_STRING(1:LWD)//char(0), LWD) 

      DO i = 1, NWD, 3
         NTMP = NTMP + 1
         CALL get_PARSE_WORD_fortran(i+0, ctmp1, LWD)
         CALL get_PARSE_WORD_fortran(i+1, ctmp2, LWD)
         CALL get_PARSE_WORD_fortran(i+2, ctmp3, LWD)
         SIMVAR_CUTWIN_LIST(NTMP) = CTMP1
         READ(CTMP2,*)  SIMVAR_CUTWIN(1,NTMP)
         READ(CTMP3,*)  SIMVAR_CUTWIN(2,NTMP)
      ENDDO 
      NSIMVAR_CUTWIN = NTMP

      if ( NTMP > MXCUT_PRIVATE ) then
         write(c1err,61) NTMP, MXCUT_PRIVATE
 61      format('NSIMVAR_CUTWIN=',I2,' exceeds bound of ', I2)
         c2err = 'Check &SNLCINP input SIMCAR_CUTWIN_STRING'
         CALL MADABORT(FNAM, c1err, c2err )
      endif
      
      DO i = 1, NTMP
         LWD = INDEX(SIMVAR_CUTWIN_LIST(i),' ') - 1
         write(6,77) SIMVAR_CUTWIN_LIST(i)(1:LWD),
     &        SIMVAR_CUTWIN(1,i), SIMVAR_CUTWIN(2,i)
 77      format(T5,'SIMVAR_CUT on ', A20,' : ', F10.4,' to ', F10.4);
      ENDDO

      RETURN
      END   ! end PARSE_SIMVAR_CUTS


C ================================
+DECK,EVAL_SIMVAR_CUTS.
      SUBROUTINE EVAL_SIMVAR_CUTS()

c Created Dec 2018
c Evaluate PASS_SIMCUTS based on user-input SIMVAR_CUTWIN_STRING
c Check hard-coded SIM_xxx names, and also check SIMSED_xxx names.
c
c Nov 25 2019: check NEP_SIM_MAGOBS = number os SIM_MAGOBS < 99

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i, ipar, LENTMP
      REAL*8  VMIN, VMAX
      CHARACTER VARNAME*40, CTMP*60, VARNAME_TMP*60

C --------------- BEGIN ------------

      IF ( NSIMVAR_CUTWIN == 0 ) RETURN

      DO 100 i = 1, NSIMVAR_CUTWIN
         VMIN    = DBLE( SIMVAR_CUTWIN(1,i) )
         VMAX    = DBLE( SIMVAR_CUTWIN(2,i) )
         VARNAME = SIMVAR_CUTWIN_LIST(i) 
         if ( VARNAME .EQ. 'SIM_ZCMB' ) then
            if ( SIM_REDSHIFT_CMB < VMIN ) PASS_SIMCUTS = .FALSE.
            if ( SIM_REDSHIFT_CMB > VMAX ) PASS_SIMCUTS = .FALSE.

         else if ( VARNAME .EQ. 'SIM_PEAKMJD' ) then
            if ( SIM_PEAKMJD < VMIN ) PASS_SIMCUTS = .FALSE.
            if ( SIM_PEAKMJD > VMAX ) PASS_SIMCUTS = .FALSE.

         else if ( VARNAME .EQ. 'SIM_SALT2c' ) then
            if ( SIM_COLORPAR < VMIN ) PASS_SIMCUTS = .FALSE.
            if ( SIM_COLORPAR > VMAX ) PASS_SIMCUTS = .FALSE.

         else if ( VARNAME .EQ. 'SIM_SALT2x1' ) then
            if ( SIM_SHAPEPAR < VMIN ) PASS_SIMCUTS = .FALSE.
            if ( SIM_SHAPEPAR > VMAX ) PASS_SIMCUTS = .FALSE.     

         else if ( VARNAME .EQ. 'NEP_SIM_MAGOBS' ) then
            if ( NEP_SIM_MAGOBS < int(VMIN) ) PASS_SIMCUTS = .FALSE.
            if ( NEP_SIM_MAGOBS > int(VMAX) ) PASS_SIMCUTS = .FALSE.     
         endif
     
c check SIMSED variables
         DO IPAR    = 1, NPAR_SIMSED
            CTMP    = SIMSED_PARNAME(ipar)
            LENTMP  = INDEX(CTMP,' ') - 1
            VARNAME_TMP = 'SIMSED_' // CTMP(1:LENTMP)
            if ( VARNAME .EQ. VARNAME_TMP ) then
               if ( SIMSED_PARVAL(ipar) < VMIN ) PASS_SIMCUTS = .FALSE.
               if ( SIMSED_PARVAL(ipar) > VMAX ) PASS_SIMCUTS = .FALSE.
            endif
         ENDDO

 100  CONTINUE


      RETURN
      END

C ======================================
+DECK,PRIVATECUTS.
      SUBROUTINE EVAL_PRIVATEVAR_CUTS()

c
c Created Nov 3 2014
c Evaluate optional cuts on private variables.
c PASS_PRIVCUTS has been initialized to TRUE; set this 
c flag to FALSE if any private variable cut-window fails.
c The private cuts are defined by &SNLCINP variable 
c PRIVATE_CUTWIN_STRING = 'VARNAME  CUTMIN  CUTMAX'
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,PRIVCOM.

      INTEGER ivar
      REAL*8 VAL
C -------------- BEGIN ------------

      IF ( NCUT_PRIVATE .EQ. 0 ) RETURN

      DO ivar = 1, NVAR_PRIVATE
         VAL = PRIVATE_VALUE(ivar)
      
         IF ( VAL < PRIVATE_CUTWIN(1,IVAR) ) THEN
             PASS_PRIVCUTS = .FALSE.
             RETURN
         ENDIF

         IF ( VAL > PRIVATE_CUTWIN(2,IVAR) ) THEN
             PASS_PRIVCUTS = .FALSE.
             RETURN
         ENDIF

      END DO 

      RETURN
      END    ! end of EVAL_PRIVATEVAR_CUTS()

C ===============================================
+DECK,INIFUDGEFLUX.
      SUBROUTINE INIT_FUDGE_FLUXCAL(IERR)

c
c Init fudges on FLUXCAL[ERR]
c Apr 2017: call INIT_NONLIN().
c Dec 2017: use IGNOREFILE function on FUDGE_HOSTNOISE_FILE
c              to allow NONE
c Feb 15 2018: call INIT_FLUXERRMODEL
c Apr 15 2018: mass OPTMASK argument to INIT_FLUXERRMODEL

      IMPLICIT NONE

      INTEGER IERR  ! (I) return 0 if all ok

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LL, OPTMASK, MSKTMP, RDMASK
      CHARACTER cFILE*(MXCHAR_FILENAME), cNONE*6, FNAM*20
      LOGICAL FORCE_FLUXERRCOR, FORCE_FLUXCOR, VALID_FILE
      LOGICAL ALLOW_FLUXERRCOR, ALLOW_FLUXCOR, ISDATA

c function in sntools.c
      INTEGER IGNOREFILE

C --------------- BEGIN ----------------

      IERR = 0 
      FNAM = 'INIT_FUDGE_FLUXCAL'

      DOFUDGE_HOSTNOISE    = .FALSE. 
      DOFUDGE_NONLIN       = .FALSE.
      DOFUDGE_FLUXERRMODEL = .FALSE.
      FORCEMASK_FLUXCOR    = 0 
      ISDATA = (.NOT. LSIM_SNANA)

c --------------------------------------------------------
c check FORCE option in case flux fudges already applied

      RDMASK = ISNLC_RDMASK_FLUXCOR_SNANA

      MSKTMP = MASK_FLUXERRCOR_SNANA
      CALL SETFORCE_FLUXCOR_SNANA(MSKTMP,FLUXERRMODEL_FILE)
      CALL SETFORCE_FLUXCOR_SNANA(MSKTMP,FUDGE_HOSTNOISE_FILE)
      FORCE_FLUXERRCOR = ( IAND(MSKTMP,FORCEMASK_FLUXCOR) > 0 ) 
      ALLOW_FLUXERRCOR = 
     &  FORCE_FLUXERRCOR .or. (IAND(RDMASK,MSKTMP)==0 )

      MSKTMP = MASK_FLUXCOR_SNANA
      CALL SETFORCE_FLUXCOR_SNANA(MSKTMP,MAGCOR_FILE)
      CALL SETFORCE_FLUXCOR_SNANA(MSKTMP,NONLINEARITY_FILE)
      FORCE_FLUXCOR  = ( IAND(MSKTMP,FORCEMASK_FLUXCOR) > 0 )
      ALLOW_FLUXCOR = 
     &  FORCE_FLUXCOR .or. (IAND(RDMASK,MSKTMP)==0 )

c ------------------------------------------------
      CALL ENVreplace(FUDGE_HOSTNOISE_FILE) 
      LL    = INDEX(FUDGE_HOSTNOISE_FILE,' ')-1
      cFILE = FUDGE_HOSTNOISE_FILE(1:LL) // char(0)
      IF ( IGNOREFILE(cFILE,LL) == 0 ) THEN
         DOFUDGE_HOSTNOISE = .TRUE.
         CALL INIT_NOISEMODEL_HOST_LEGACY( cFILE, LL );
      ENDIF       

c Apr 2017: check nonlinearity from user-supplied map      
      CALL ENVreplace(NONLINEARITY_FILE);
      LL    = INDEX(NONLINEARITY_FILE,' ')-1
      cFILE = NONLINEARITY_FILE(1:LL) // char(0)
      if ( IGNOREFILE(cFILE,LL) == 0 ) then
         DOFUDGE_NONLIN       = .TRUE.
         CALL INIT_NONLIN(cFile,LL)
      endif

c ------------------------------
c Feb 2018: check FLUXERRMAPs for DATA
      OPTMASK = FLUXERRMODEL_OPTMASK
      CALL ENVreplace(FLUXERRMODEL_FILE);
      LL    = INDEX(FLUXERRMODEL_FILE,' ')-1
      cFILE = FLUXERRMODEL_FILE(1:LL) // char(0)
      VALID_FILE = (IGNOREFILE(cFILE,LL) == 0)
      if ( VALID_FILE ) then
        CALL PRINTMSG_FLUXCOR(MASK_FLUXERRCOR_SNANA,"FLUXERRMODEL_FILE")
      endif
      IF ( VALID_FILE .and. ALLOW_FLUXERRCOR .and. ISDATA ) THEN
         cNONE = 'NONE' // char(0)
         DOFUDGE_FLUXERRMODEL = .TRUE.
         CALL INIT_FLUXERRMODEL(OPTMASK,cFile,cNONE,cNONE,LL,4,4)
      ENDIF
      
c March 2018: check FLUXERRMAPs for SIM
      CALL ENVreplace(SIM_FLUXERRMODEL_FILE);
      LL    = INDEX(SIM_FLUXERRMODEL_FILE,' ')-1
      cFILE = SIM_FLUXERRMODEL_FILE(1:LL) // char(0)
      IF ( IGNOREFILE(cFILE,LL) == 0  .and. LSIM_SNANA ) THEN
         cNONE = 'NONE' // char(0)
         DOFUDGE_FLUXERRMODEL = .TRUE.
         CALL INIT_FLUXERRMODEL(OPTMASK,cFile,cNONE,cNONE,LL,4,4)
      ENDIF

c ------------------------------------------------
c check MAGCOR (e.g. chromatic corrections) for data
c CALL INIT_MAGCOR()

      CALL ENVreplace(MAGCOR_FILE);
      LL    = INDEX(MAGCOR_FILE,' ')-1
      cFILE = MAGCOR_FILE(1:LL) // char(0)
      VALID_FILE = (IGNOREFILE(cFILE,LL) == 0) 
      if ( VALID_FILE ) then
        CALL PRINTMSG_FLUXCOR(MASK_FLUXCOR_SNANA,"MAGCOR_FILE")
      endif

      IF ( VALID_FILE .and. ALLOW_FLUXCOR .and. ISDATA ) THEN
         CALL INIT_MAGCOR(MAGCOR_FILE);
      ENDIF

c check SIM_MAGCOR_FILE
      CALL ENVreplace(SIM_MAGCOR_FILE);
      LL    = INDEX(SIM_MAGCOR_FILE,' ')-1
      cFILE = SIM_MAGCOR_FILE(1:LL) // char(0)
      IF ( IGNOREFILE(cFILE,LL) == 0  .and. LSIM_SNANA ) THEN
         CALL INIT_MAGCOR(SIM_MAGCOR_FILE);
      ENDIF

c - - - - - - - - - - - - - 
c error checking
      if ( DOFUDGE_HOSTNOISE .and. DOFUDGE_FLUXERRMODEL ) then
         c1err = 'Cannot specify FUDGE_HOSTNOISE_FILE ' // 
     &           'and FLUXERRMODEL_FILE'
         c2err = 'Use one file or the other.'
         CALL MADABORT(FNAM, c1err, c2err )
      endif

      RETURN
      END       ! end of INIT_FUDGE_FLUXCAL


C ==============================
+DECK,PRINTMSG_FLUXCOR.
      SUBROUTINE PRINTMSG_FLUXCOR(INMASK,CORFILE)

c Created Nov 14 2018
c Print appropriate message for FLUXCOR or FLUXERR correction.
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER  INMASK   ! (I) 1=fluxcor, 2=fluxerrcor

      INTEGER  RDMASK, LEN
      LOGICAL  ALLOW, FORCE, ISDATA
      CHARACTER*(*) CORFILE

C ------------------- BEGIN ------------------

      ISDATA = (.NOT. LSIM_SNANA)
      RDMASK = ISNLC_RDMASK_FLUXCOR_SNANA
      LEN    = INDEX(CORFILE,' ') - 1

      FORCE = ( IAND(INMASK,FORCEMASK_FLUXCOR)  > 0   ) 
      ALLOW = ( FORCE .or. ( IAND(INMASK,RDMASK)==0 ) )

c start with default behavior of ignoring already-applied correction
      IF ( (.NOT. ALLOW) .and. ISDATA ) THEN
         print*,' '
         print*,' !!! '//CORFILE// ' CORRECTION ALREADY APPLIED '
         print*,' !!!  ==> IGNORE '// CORFILE
         print*,' '
      ENDIF

c check option to FORCE correction, even if already applied
      IF ( ALLOW .and. FORCE .and. ISDATA ) THEN
         print*,' '
         print*,' !!! '//CORFILE// ' CORRECTION ALREADY APPLIED '
         print*,' !!! ==> FORCE '//CORFILE//' ANYWAY   '
         print*,' '
      ENDIF

c for sims, give reminder that corrections are not applied to sims.
      IF ( LSIM_SNANA ) THEN
        print*,' '
        print*,'  !!! IGNORE '//CORFILE//' for SIMULATION'
        print*,'  !!!   (or switch to SIM_'//CORFILE//' option)  '
        print*,' '
      ENDIF

      call flush(6)

      RETURN
      END  ! end PRINTMSG_FLUXCOR


C ===============================
+DECK,FUDGEFCAL.
      SUBROUTINE EXEC_FUDGE_FLUXCAL(EP)

c Created Nov 15, 2011 by R.Kessler and J.Marriner
c Fudge FLUXCAL and ERROR based on user namelist option
c FUDGE_FLUXCAL_OFFSET/ERROR
c
c The following arrays are modified
c   - SNLC_FLUXCAL
c   - SNLC_FLUXCAL_ERRTOT
c
c Note that the SNLC_MAG array is not modified !!!
c
c Dec 14, 2011: abort on negative SQERR
c Sep 03, 2013: add FLUXCAL_OFF(ifilt)
c Oct 23, 2013: add use FUDGE_MAG_ERROR
c Aug 27, 2014: add FUDGE_FLUXCAL_ERRPIX (error per pixel x AREA)
c               See ERR2b and DAREA calc.
c
c Mar 06, 2015: check GEN_HOSTNOISE
c Sep 14, 2015: fix dumb bug setting ZP outside if-block
c Apr 17, 2017: call GET_NONLIN(...)
c Feb 16, 2018: 
c  + call get_FLUXERRMODEL, float -> double, little refactor
c
c Nov 12, 2018: call EXEC_MAGCOR(ep)
c ------------

      IMPLICIT NONE

      INTEGER EP  ! (I) epoch index and SN index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.

c local var

      REAL*8
     &   ERR1, ERR2a, ERR2b, ERR3, ERR_SIM, ERR_DATA
     &  ,SQERR, SQERR1, SQERR2a, SQERR2b, SQERR3, SQERRHOST, SQERRMAP
     &  ,RDNOISE_pe, FLUXCAL, FLUXADU, SNR, SNR_PROTECT, LOGSNR
     &  ,AREA, PSFSIG1, PSFSIG2, PSFRATIO  
     &  ,GALMAG, SBMAG, SBFLUX, SNSEP, NOISEPAR(2)
     &  ,MJD, GAIN, SKYSIG, ZP, ZPDIF, PARLIST(20)
     &  ,SQTMP, Fscale, Fpe_source, Fpe_sky, GENMAG

      INTEGER IFILT_OBS, IFILT, GALID, OPT, NPAR, LL
      CHARACTER cfilt*2, FNAM*20, cFIELD*32, cBAND*2
      LOGICAL DOFUDGE

c function
      EXTERNAL NoiseEquivAperture, GET_NONLIN, get_FLUXERRMODEL
      REAL*8   NoiseEquivAperture, GET_NONLIN

c ------------ BEGIN ----------------

      FNAM = 'EXEC_FUDGE_FLUXCAL'
      IFILT_OBS = ISNLC_IFILT_OBS(ep)
      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
      cfilt     = FILTDEF_STRING(ifilt_obs:ifilt_obs)

      SNLC_FLUXCAL(ep) = SNLC_FLUXCAL(ep) 
     &     + SNLC_FLUXCAL_OFF(ifilt)               ! offset in data file
     &     + FUDGE_FLUXCAL_OFFSET_FILT(IFILT_OBS)  ! user-nml offset


      ERR1  = DBLE(SNLC_FLUXCAL_ERRTOT(ep))              ! from data file
      ERR2a = DBLE(FUDGE_FLUXCAL_ERROR_FILT(IFILT_OBS))  ! fudge FLUXCAL error
      ERR2b = DBLE(FUDGE_FLUXCAL_ERRPIX_FILT(IFILT_OBS)) ! fudge FLUXCAL err/pix
      ERR3  = DBLE(FUDGE_MAG_ERROR_FILT(IFILT_OBS))* FLUXCAL ! fudge mag err

      SQERR1     = ERR1  * ERR1
      SQERR2a    = ERR2a * ERR2a
      IF ( ERR2a .LT. 0.0 ) SQERR2a = -SQERR2a
      SQERR2b    = ERR2b * ERR2b   ! * AREA  ! sum in quad over pixels
      SQERR3     = ERR3  * ERR3
      SQERRHOST  = 0.0 
      SQERRMAP   = 0.0 

c get C function arguments
      cBAND        = cfilt(1:1) // char(0)
      LL           = INDEX(SNLC_FIELD(ep), ' ') - 1
      cFIELD       = SNLC_FIELD(ep)(1:LL) // char(0)
      GALID        = SNHOST_OBJID(1) 
      SNSEP      = DBLE( SNHOST_ANGSEP(1) )
      GALMAG     = DBLE( SNHOST_MAGOBS(ifilt,1) )
      SBFLUX     = DBLE( SNHOST_SBFLUXCAL(ifilt) )
      SBMAG      = DBLE( SNHOST_SBMAG(ifilt) )
      FLUXCAL    = DBLE( SNLC_FLUXCAL(ep) )
      PSFSIG1    = DBLE( SNLC_PSF_SIG1(EP) )  ! Gauss sigma, pixel
      PSFSIG2    = DBLE( SNLC_PSF_SIG2(EP) )  ! idem, 2nd component
      PSFRATIO   = DBLE( SNLC_PSF_RATIO(EP) )
      GAIN       = DBLE( SNLC_GAIN(ep) )
      SKYSIG     = DBLE( SNLC_SKYSIG(ep) )          ! sigma, ADU/pixel
      RDNOISE_pe = DBLE(SNLC_RDNOISE(ep) )  ! e-/pix
      ZP         = DBLE( SNLC_ZEROPT(ep) )
      ZPDIF      = ZP - ZEROPOINT_FLUXCAL_DEFAULT
      MJD        = SNLC8_MJD(EP)
      SNR        = FLUXCAL/ERR1

c --------------------------------------------
c  Check for map corrections

      IF ( DOFUDGE_HOSTNOISE  ) THEN  ! compute ERRHOST
c call function to return
c  noisePar(1) =  FLUXCAL noise per pixel
c  noisePar(2) =  ERRSCALE to multiply skynoise  
         CALL GEN_NOISEMODEL_HOST_LEGACY(cBAND,cFIELD,GALID, 
     &           GALMAG, SBMAG, SNSEP, noisePar, 2,30);
         SQTMP     = NOISEPAR(2)**2 - 1.0 ! don't double-count error
         SQERRHOST = SQERR1 * SQTMP
      ENDIF


      IF ( DOFUDGE_FLUXERRMODEL  ) THEN ! compute ERRMAP
        OPT = 0 ; NPAR=0
        SNR_PROTECT = MAX(SNR,0.126)    ! --> LOGSNR >= -0.9 
        LOGSNR = log10(SNR_PROTECT)

c  grep IPAR_FLUXERRMAP sntools_fluxErrModels.h
        NPAR = NPAR+1;  PARLIST(NPAR) = MJD 
        NPAR = NPAR+1;  PARLIST(NPAR) = PSFSIG1
        NPAR = NPAR+1;  PARLIST(NPAR) = SKYSIG
        NPAR = NPAR+1;  PARLIST(NPAR) = ZP
        NPAR = NPAR+1;  PARLIST(NPAR) = LOGSNR
        NPAR = NPAR+1;  PARLIST(NPAR) = SBMAG
        NPAR = NPAR+1;  PARLIST(NPAR) = GALMAG
        NPAR = NPAR+1;  PARLIST(NPAR) = SNSEP
        CALL  get_FLUXERRMODEL(OPT,ERR1,cBAND,cFIELD,NPAR, PARLIST,
     &            ERR_SIM, ERR_DATA )  ! <== return ERR_SIM, ERR_DATA

        SQERRMAP = (ERR_DATA*ERR_DATA) - SQERR1 ! note: can be negative
      ENDIF


c avoid invalid fluxes.
      IF ( FLUXCAL .EQ. -9.0 ) RETURN

c bail if nothing to do
      DOFUDGE = 
     &     ( ERR1  > 0.0 ) .or.
     &     ( ERR2a > 0.0 ) .or.
     &     ( ERR2b > 0.0 ) .or.
     &     ( ERR3  > 0.0 ) .or.
     &     ( SQERRHOST  > 0.0 ) .or.
     &     ( SQERRMAP   > 0.0 ) 

      if ( .NOT. DOFUDGE ) GOTO 880  ! jump to nonlinearity flux-fudge

      AREA = 0.0 
      IF ( ERR2b > 0.0 ) THEN
         ! sum noise over pixels in effective background area
         if ( PSFSIG1 < 0.002 ) then
            c1err = 'Undefined PSF for FUDGE_FLUXCAL_ERRPIX'
            write(c2err,62) SNLC_CCID, MJD, cfilt
 62         format('CID=',A10,' for MJD=', F9.3,'-', A)
            CALL MADABORT(FNAM, c1err, c2err )
         endif
         AREA  = NoiseEquivAperture(PSFsig1,PSFsig2,PSFratio)  
      ENDIF


      SQERR = SQERR1 + SQERR2a + (SQERR2b*AREA) + SQERR3 
     &      + SQERRHOST + SQERRMAP

      IF ( SQERR .LE. 0.0 ) THEN
         CALL PRINT_PREABORT_BANNER(FNAM(1:18)//char(0),40)
         print*,'   ERR1(from data file): ',          sngl(ERR1)
         print*,'   ERR2a(user-fluxcal fudge): ',     sngl(ERR2a)
         print*,'   ERR2b(user-fluxcal fudge/pix): ', sngl(ERR2b)
         print*,'   ERR3(user magerr fudge): ' ,      sngl(ERR3)
         print*,'   ERRHOST(FUDGE_HOSTNOISE_FILE): ', 
     &                  sngl( sqrt(SQERRHOST) )
         print*,'   ERRMAP(FLUXERRMODEL_FILE): ', 
     &                  sngl( sqrt(SQERRMAP) )
         write(c1err,61) 
     &        SNLC_CCID(1:ISNLC_LENCCID), cfilt, MJD
 61      format('Negative flux error for CID=',A, '-',A,
     &         3x, 'and MJD=',F9.3)
         c2err = 'Check error fudges in &SNLCINP'
         CALL MADABORT(FNAM, c1err, c2err )
      ENDIF

      SNLC_FLUXCAL_ERRTOT(ep) = SNGL ( SQRT(SQERR) )

      CALL SETMASK_FLUXCOR_SNANA(MASK_FLUXERRCOR_SNANA)

c ---------------------------
880   CONTINUE
c ---------------------------

c check GET_NONLIN option in sntools_nonlinearity.c
      IF ( DOFUDGE_NONLIN ) THEN

        if ( GAIN < 0.01 .or. SKYSIG < 0.0001 .or. ZP < 0.01 ) then
           CALL PRINT_PREABORT_BANNER(FNAM(1:18)//char(0),40)
           print*,'    BAND    = ', CFILT
           print*,'    GAIN    = ', sngl(GAIN), ' e-/pix'
           print*,'    ZP      = ', sngl(ZP),'  (ADU->MAG)'
           print*,'    SKYSIG  = ', sngl(SKYSIG),' ADU/pix '
           print*,'    RDNOISE = ', sngl(RDNOISE_pe),' e-/pix'
           c1err = 'Canot compute NON-LINEARITY'
           c2err = 'See above values'
           CALL MADABORT(FNAM, c1err, c2err )
        endif

      ! sum noise over pixels in effective background area
        AREA  = NoiseEquivAperture(PSFsig1,PSFsig2,PSFratio) !pixels       
        FLUXADU = FLUXCAL * 10.0**(0.4*ZPDIF)

        Fpe_source = FLUXADU * GAIN
        IF ( Fpe_source < 0.0 ) Fpe_source = 0.01 ! must be positive
        Fpe_sky    = AREA * (SKYSIG*GAIN)**2   ! xxx NOT TESTED
        GENMAG     = DBLE( SNLC_MAG(ep) )

        Fscale = get_nonlin(cfilt(1:1)//char(0),
     &                      Fpe_source, Fpe_sky, GENMAG, 2 )
        SNLC_FLUXCAL(ep) = SNLC_FLUXCAL(ep) * SNGL(Fscale)
        CALL SETMASK_FLUXCOR_SNANA(MASK_FLUXCOR_SNANA)
      ENDIF

c ---------------------
c mag-corrections; e.g.. chromatic corrections from FGCM
      CALL EXEC_MAGCOR(ep) 

      RETURN
      END        ! end EXEC_FUDGE_FLUXCAL

C ===========================================
+DECK,SETFORCE_FLUXCOR_SNANA.
      SUBROUTINE SETFORCE_FLUXCOR_SNANA(MASK,INFILE)

c Created Nov 14 2018
c INFILE = '<fileName>'       --> do nothing
c INFILE = '<fileName FORCE>' --> set MASK bit of FORCEMASK_FLUXCOR
c                                 and set INFILE = fileName
c - - - - - -
      IMPLICIT NONE

      INTEGER MASK         ! (I) mask to set for FORCEMASK
      CHARACTER INFILE*(*) ! (I) name of input file

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER NAME_forC*(MXCHAR_FILENAME), cwd*(MXCHAR_FILENAME)
      INTEGER iwd, NWD, LENFILE,MSKOPT

      INTEGER  STORE_PARSE_WORDS, IGNOREFILE
      EXTERNAL STORE_PARSE_WORDS

C ---------------- BEGIN --------------

      if ( INFILE .EQ. ''  ) RETURN
cc      if ( IGNOREFILE(INFILE,) > 0 ) RETURN

      MSKOPT    = MSKOPT_PARSE_WORDS_STRING
      LENFILE   = INDEX(INFILE,' ') + 10 ! allow FORCE key after space
      NAME_forC = INFILE(1:LENFILE-1)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT, NAME_forC, LENFILE)

      IF ( NWD <= 1 ) RETURN

c with more than 1 word, check for FORCE key

      DO 10 iwd = 1, NWD
         CALL get_PARSE_WORD_fortran(iwd,cwd,LENFILE)

         if ( iwd==1 ) then
            INFILE = cwd
         else if ( cwd(1:5) .EQ. 'FORCE' ) then
            FORCEMASK_FLUXCOR = IOR(FORCEMASK_FLUXCOR,MASK)
         endif
10    CONTINUE


      RETURN
      END ! end of SETFORCE_FLUXCOR_SNANA

C ===========================================
+DECK,SETMASK_FLUXCOR_SNANA.
      SUBROUTINE SETMASK_FLUXCOR_SNANA(MASK)

      IMPLICIT NONE

      INTEGER MASK  ! (I) mask to set
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER ALREADY_SET, FORCE
      CHARACTER FNAM*24

C --------------- BEGIN ------------------

      FNAM = 'SETMASK_FLUXCOR_SNANA'

c first check mask read from data file to see if fluxcor fudge
c was already applied

      ALREADY_SET = IAND(ISNLC_RDMASK_FLUXCOR_SNANA,MASK)
      FORCE       = IAND(FORCEMASK_FLUXCOR,MASK)

      if ( ALREADY_SET > 0 .and. FORCE == 0 ) RETURN

c xxxxxxxxxxxxxxxx
c      if ( ALREADY_SET > 0 .and. FORCE == 0 ) then
c         CMASK(MASK_FLUXCOR_SNANA)    = 'FLUXCOR/MAGCOR'
c         CMASK(MASK_FLUXERRCOR_SNANA) = 'FLUXERRCOR'
c         C1ERR = 'Will not apply ' // CMASK(MASK)
c         C2ERR = 'because data files already include '//CMASK(MASK)
c         CALL MADABORT(FNAM, c1err, c2err )
c      endif 
c xxxxxxxxxxxxxxxx

      ISNLC_WRMASK_FLUXCOR_SNANA = 
     &     IOR(ISNLC_WRMASK_FLUXCOR_SNANA,MASK)

      RETURN
      END   ! end of SETMASK_FLUXCOR_SNANA

C =================================
+DECK,COUNTFIELDS.
      SUBROUTINE COUNTFIELDS()
c
c Jun 8, 2009 R.Kessler
c
c Fill ISNLC_NFIELD with number of 
c different fields used by this SN.
c NFIELD = 1 for isolated field, but can be
c > 1 for overlapping fields.
c
c
c Jul 16, 2013:
c   Fill SNLC_FIELDS_OVPLIST(NFIELD_OVP) 
c   Error check that NFIELD <= MXFIELD_OVP
c   Change logic to use local IDF_OVLIST array
c
c Aug 5, 2013: use FIELD-string instead of IDF integer so that
c              it works even if user does not specify fields.
c
c Jan 6 2014: if FIELD string is blank, set it to NULL
c
c --------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER 
     &   ep, NEP, i, ovp
     &  ,IDF, IDF_OVPLIST(MXFIELD_OVP)
     &  ,NFIELD, LENTMP, LENTOT, L2

      CHARACTER FIELDTMP*(MXCHAR_FIELDNAME)
      LOGICAL USE, FIRST

C ------------- BEGIN ----------

      NEP    = ISNLC_NEPOCH_STORE
      NFIELD = 0

      DO 101 ep = 1, NEP
          IDF   = ISNLC_IDFIELD(ep)

          USE = .FALSE.
          DO 102 i = 1, NFIELD
            if ( SNLC_FIELD(ep).EQ.SNLC_FIELD_OVPLIST(i) ) USE=.TRUE.
 102      CONTINUE          

          if ( .NOT. USE ) THEN
             NFIELD = NFIELD + 1
             SNLC_FIELD_OVPLIST(NFIELD) = SNLC_FIELD(ep)
             IDF_OVPLIST(NFIELD) = IDF             
          endif  ! end of USE
101   CONTINUE  ! ep loop


      IF ( NFIELD > MXFIELD_OVP ) THEN
         write(c1err,61) NFIELD
         write(c2err,62) MXFIELD_OVP
 61      format('NFIELD_OVP = ', I3,' exceeds bound of')
 62      format('MXFIELD_OVP = ', I3 )
         CALL MADABORT("COUNTFIELDS", c1err, c2err )
      ENDIF

      ISNLC_NFIELD_OVP = NFIELD

c prepare catenated string SNLC_FIELD_forC that is sorted based 
c on survey fields.  e.g., if SURVEY_FIELDS = 'E1', 'E2' then 
c SNLC_FIELDS = E2,E1 gets constructed as SNLC_FIELD_forC = 'E1+E2'

      SNLC_FIELDLIST = ''
      LENTOT = 0
      FIRST  = .TRUE.

      DO 300 i = 1, NFIELD_SURVEY 
        FIELDTMP = SURVEY_FIELDNAME(i)  ! from SURVEY.DEF file
        LENTMP   = INDEX(FIELDTMP,' ')-1

        DO 301 ovp = 1, NFIELD  ! overlap fields in this SN
          L2 = INDEX(SNLC_FIELD_OVPLIST(ovp),' ')-1
          IF ( LENTMP .NE. L2 ) GOTO 301 

          IF ( SNLC_FIELD_OVPLIST(ovp) .EQ. FIELDTMP ) THEN

             if ( FIRST ) then
               SNLC_FIELDLIST = FIELDTMP
               LENTOT = LENTOT + LENTMP
               FIRST  = .FALSE.
             else
                SNLC_FIELDLIST =
     &          SNLC_FIELDLIST(1:LENTOT) // '+' // FIELDTMP(1:LENTMP)
                LENTOT = LENTOT + LENTMP + 1
             endif

          ENDIF
 301    CONTINUE
 300  CONTINUE

      IF ( LENTOT .EQ. 0  ) THEN
         SNLC_FIELDLIST = 'NULL'
      ENDIF

      RETURN
      END


C ========================================
+DECK,U3BAND.
      SUBROUTINE U3BAND()
c
c Created Sep 13, 2008 by R.Kessler
c
c Special flag to require exactly three passbands
c that pass the global SNRCUT, and one of the passbands
c must be U-band. If only two passbands exist, the SN
c is rejected. If 4 or more passbands exist, then the
c reddest extra passbands are erased and the SN is used.
c For example, if griz -> UBVR, then all z-band fluxes
c and errors are set to -9.0, and SNRECON is called 
c again; this SN is then processed as if z-band had
c never existed.
c
c
c Jul 16, 2011: pass ISN as argument and remove IERR arg
c --------------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.

      INTEGER 
     &   NBAND, NTMP
     &  ,IFILT, IFILT_OBS, IFILT_OBS_LIST(MXFILT_ALL)
     &  ,ORDER
     &  ,INDEX_SORT(MXFILT_ALL)
     &  ,i, isort
     &  ,NERASE

      REAL 
     &   ZZ, RESTLAM
     &  ,RESTLAM_LIST(MXFILT_ALL)

      LOGICAL LSNRMAX, LU, LKEEP

      character cfilt*2, ccid*(MXCHAR_CCID), cdiscard*32

      REAL ULAMMAX
      PARAMETER ( ULAMMAX = 3900.0 ) ! max U-band lambda in rest-frame

      EXTERNAL SORTFLOAT

C ---------- BEGIN ---------

      NERASE = 0

      if ( .not. LTEST_U3BAND ) RETURN

      CCID = SNLC_CCID
      LKEEP = .TRUE.  ! keep SN by default

c require at least 3 passbands with SNRMAX cut.
c If not, set PEAKMJD = -9.0 and return so that
c this SN is rejected.

        NBAND = ISNLC_NFILT_SNRMAX
        IF ( NBAND .LT. 3 ) THEN
          LKEEP  = .FALSE.
          cdiscard = 'NBAND(SNRMAX) < 3'
          GOTO 150
        ENDIF

        ZZ          = 1.0  + SNLC_REDSHIFT


c filter loop: get list of observer passbands and check if
c U-band is there.

        NTMP = 0
        LU   = .FALSE.

        DO 101 ifilt = 1, NFILTDEF_SURVEY

           if ( .NOT. EXIST_FILT(ifilt) ) goto 101

           ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)

           RESTLAM = FILTOBS_LAMAVG(ifilt_obs) / ZZ
           LSNRMAX = SNLC_SNRMAX_FILT(ifilt) .GT. CUTWIN_SNRMAX(1) 

           if ( .NOT. LSNRMAX ) GOTO 101

           IF ( RESTLAM .LT. ULAMMAX .and. 
     &          RESTLAM .GT. CUTWIN_RESTLAM(1) ) LU = .TRUE.

           NTMP = NTMP + 1
           IFILT_OBS_LIST(NTMP) = IFILT_OBS
           RESTLAM_LIST(NTMP)   = RESTLAM

101     CONTINUE  ! UFILT loop


        if ( .NOT. LU ) then
           LKEEP = .FALSE.
           cdiscard = 'No filter maps onto rest-U'
           goto 150
        endif

        if ( LU .and. NBAND .EQ. 3 ) GOTO 150

c here we have more than 3 bands with good SNRMAX.
c Erase reddest bands until we have the 3 bluest.

       ORDER = + 1 ! increasing order
       CALL SORTFLOAT( NBAND, RESTLAM_LIST, ORDER, INDEX_SORT)

c erase reddest filters as if they never existed
      DO i = 4, NTMP
        isort = INDEX_SORT(i)
        IFILT_OBS = IFILT_OBS_LIST(isort)
        cfilt = filtdef_string(ifilt_obs:ifilt_obs) 
        RESTLAM   = RESTLAM_LIST(isort)

        write(6,440) CCID, cfilt, RESTLAM
440     format(T8,'U3BAND CID=',A8, ' : erase filter=',A,
     &       ' with rest-Lambda=',F6.0,' A' )
        
        NERASE =  NERASE + 1
        CALL ERASE_FILTER(ifilt_obs)
      ENDDO

c --------
150     CONTINUE
        IF ( .NOT. LKEEP ) THEN
          SNLC_SEARCH_PEAKMJD = -9.0
          write(6,441) CCID, cdiscard
441       format(T8,'U3BAND CID=',A8, ' => DISCARD because ', A )
        ENDIF

c ------------------------
c call SNRECON again after erasing filter(s)
      IF ( NERASE .GT. 0 ) THEN
        CALL SNRECON()
      ENDIF


      RETURN
      END


C ========================================
+DECK,ERASEFLT.
      SUBROUTINE ERASE_FILTER(ifilt_obs)
c
c Created Sep 13, 2008 by R.Kessler
c
c Erase "ifilt_obs" for SN index ISN.
c Erasing is done by setting fluxes and errors to -9.
c
c --------

      IMPLICIT NONE
      INTEGER IFILT_OBS   !(O) SN index, and filter index

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.


      INTEGER NEWMJD, EPMIN, EPMAX, ep, ifilt

      LOGICAL LTMP 

C -------- BEGIN -------

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        DO EP = EPMIN, EPMAX

          LTMP = IFILT_OBS .EQ. ISNLC_IFILT_OBS(ep)

          IF ( LTMP ) THEN
            SNLC_FLUXCAL(ep)        = -9.0
            SNLC_FLUXCAL_ERRTOT(ep) = -9.0
            SNLC_MAG(ep)        = -9.0
            SNLC_ZEROPT(ep)     = -9.0
            SNLC_ZEROPT_ERR(ep) = -9.0

            IFILT  = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
            EXIST_FILT(ifilt)         = .FALSE.
            ISNLC_NEPOCH_FILT(ifilt)   =  0
            SNLC_SNRMAX_FILT(0)       = -9.
            SNLC_SNRMAX_FILT(ifilt)   = -9.
            SNLC_SNRMAX_SORT(ifilt)   = -9.
            SNLC_FLUXCALMAX(ifilt)    = -9.

          ENDIF

        ENDDO
      
200   CONTINUE

      RETURN
      END

C =============================================
+DECK,DLMAG8_REF.
      DOUBLE PRECISION FUNCTION DLMAG8_REF(Z8)
      IMPLICIT NONE
      REAL*8  Z8  ! (I) redshift
+CDE,SNPAR.
      REAL*8  DL
      REAL*8  DLZ8_REF  ! function
C ------------------- BEGIN -----------------
      DL           = DLZ8_REF(Z8)
      DLMAG8_REF   = -5.0 * LOG10(10.0*PARSEC/DL)  
      RETURN
      END
C ===========================================
+DECK,DLZ8_REF.
      DOUBLE PRECISION FUNCTION DLZ8_REF(Z8)
c
c Shell function to call DLZ8 with REFERENCE 
c cosmological parameters.
c These XXX_REF parameters are specified by the
c user via SNLCINP namelist.
c
c -----------------------------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
      REAL*8 Z8  ! (I) redshift
c function
      REAL*8 DLZ8
C --------------- BEGIN ---------------
      DLZ8_REF = DLZ8( H0_REF(1), Z8, OMAT_REF(1), OLAM_REF(1), 
     &                 ORAD_REF(1), W0_REF(1), DWDA_REF(1) )
      RETURN
      END
C =======================
+DECK,DLZ8.
       DOUBLE PRECISION FUNCTION 
     &        DLZ8( H0, Z0, OMAT, OLAM, ORAD, w, dWdz )
c
c Return luminosity-distance, D_L = 1+z integral-of-bla
c Apr 23 2019: add ORAD argument

      IMPLICIT NONE

c define function args

      REAL*8 
     &    H0      ! Hubble constant today (km/s/Mpc)
     &   ,Z0      ! redshift
     &   ,OMAT    ! Omega-matter
     &   ,OLAM    ! Omega-energy
     &   ,ORAD    ! Omega_rad (4/2019)
     &   ,W       ! P/rho
     &   ,dWdz    ! dW/dz

c local var

      INTEGER NZBIN, iz
      DOUBLE PRECISION 
     &    SQHZ, Hz
     &   ,Dzint   ! size of integration Z-bin
     &   ,RZint
     &   ,Ztmp, dz
     &   ,ZCUBE, ZSQ, Z4th, ZW, Wexp
     &   ,OTOT
     &   ,KAPPA
     &   ,SQRT_KAPPA
     &   ,CLIGHT

      PARAMETER ( CLIGHT = 3.0E5 )  ! km/sec
      
c ------------- begin ------------

      DZint     = 0.001  ! size of z-integration bin
      RZint     = 0.0
      DLZ8      = 0.0

      NZBIN = int( Z0 / DZint )
      NZBIN = MAX(10,NZBIN)  ! make sure at least 10 bins
      dZ    = Z0 / float(NZBIN)

      OTOT  = OMAT + OLAM
      KAPPA = 1.0 - OTOT   ! curvature
      SQRT_KAPPA = SQRT( abs(KAPPA) )

      DO iz   = 1, NZBIN
        Ztmp  = dz * (float(iz) - 0.5 )
        ZCUBE = (1.0 + Ztmp)**3
        ZSQ   = (1.0 + Ztmp)**2
        Z4th  = ZSQ*ZSQ

        IF ( W .EQ. -1.0 .and. dWdz .EQ. 0.0 ) then
           ZW = 1.0
        ELSE
          Wexp  = (1.0 + W - dWdz)*LOG(1.0+Ztmp) + dWdz*Ztmp          
          ZW    = EXP(3*Wexp)
        ENDIF

        SQHZ  = OMAT*ZCUBE + OLAM*ZW + ORAD*Z4th + (1.0 - OTOT)*ZSQ

        IF ( SQHZ .LE. 0.0 ) RETURN

        HZ    = SQRT(SQHZ)           ! Hubble const. at Z

        RZint = RZint + dz / HZ
      END DO

c take into account the curvature if OTOT .ne. 1:

      IF ( KAPPA .LT. -0.0000001 ) THEN
         RZint = sin( SQRT_KAPPA * RZint ) / SQRT_KAPPA
      ELSE IF ( KAPPA .GT. 0.0000001 ) THEN
         RZint = sinh( SQRT_KAPPA * RZint ) / SQRT_KAPPA
      ENDIF

c get luminosity-distance

      DLZ8  =  (1+Z0) * (Clight/H0) * RZint   ! luminosity-distance

      RETURN
      END

C =============================
+DECK,SNTYPESTAT.
      INTEGER FUNCTION SNTYPESTAT(itype)
c
c Dec 2010
c Returns 0 if ITYPE is valid; returns -1 otherwise.
c Also increments global NACCEPT_TYPE if ITYPE is valid.
c
c Dec 2013: check SNTYPE_IGNORE
c -------------------------

      IMPLICIT NONE

c function args

      INTEGER  ITYPE  ! SN-integer type

c local args

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i, ibit
      LOGICAL LTYPE

C -------------- BEGIN --------------

      ibit = CUTBIT_SNTYPE
      APPLY_HEADER_CUTMASK = IBSET(APPLY_HEADER_CUTMASK,ibit-1)

      do i = 1, NSNTYPE_IGNORE
        if ( SNTYPE_IGNORE(i) .EQ. ITYPE ) then
           SNTYPESTAT = -1
           RETURN
        endif
      enddo

      IF ( NSNTYPE_LIST .LE. 0 ) THEN  
         ! don't check  anything
         SNTYPESTAT = 0
         RETURN
      ENDIF

      LTYPE = .FALSE.
      do i = 1, NSNTYPE_LIST
        if ( SNTYPE_LIST(i) .EQ. ITYPE ) LTYPE = .TRUE.
      enddo


      IF ( LTYPE ) THEN
         NACCEPT_TYPE = NACCEPT_TYPE + 1
         SNTYPESTAT   = 0
      ELSE 
         SNTYPESTAT = -1
         IF ( LDMP_SNFAIL ) then
              print*,'  ** WARNING ** CID= ',snlc_ccid,
     &       ' (TYPE=',itype,')  FAILS TYPE CUT '
         endif
      endif

      RETURN
      END  ! end SNTYPESTAT


C =============================
+DECK,CCDNUMSTAT.
      INTEGER FUNCTION CCDNUMSTAT(CCDNUM)
c
c Dec 2017
c Returns 0 if CCDNUM is valid; returns -1 otherwise.
c -------------------------

      IMPLICIT NONE

c function args

      INTEGER CCDNUM

c local args

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i
      LOGICAL LCCDNUM

C -------------- BEGIN --------------

      IF ( NCCDNUM_LIST .LE. 0 ) THEN  
         ! don't check  anything
         CCDNUMSTAT = 0
         RETURN
      ENDIF

      LCCDNUM = .FALSE.
      do i = 1, NCCDNUM_LIST
        if ( CCDNUM_LIST(i) .EQ. CCDNUM ) LCCDNUM = .TRUE.
      enddo


      IF ( LCCDNUM ) THEN
         CCDNUMSTAT   = 0
      ELSE 
         CCDNUMSTAT = -1
      endif

      RETURN
      END  ! end CCDNUMSTAT

C ==============================
+DECK,CHCKHEADER.
      SUBROUTINE CHECK_HEADER()

c Created May 7, 2009 by R.Kessler
c Abort if any header info is missing of invalid.
c
c Dec 23, 2010: make sure header-cuts have been applied
c               (see APPLY_HEADER_CUTMASK)
c
c Jun 11, 2013: before ABORT, list each cut with message to
c               see more clearly what cut is missing.
c               Needed because ABORT message is too obscure.
c
c ----------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

c local var

      LOGICAL LCUTS, LTMP
      INTEGER CUTMASK_EXPECT, LL
      INTEGER CUTBIT_LIST(20), NCUT, icut
      CHARACTER msg*40, MSGCUT(20)*40

C --------- BEGIN ---------

      IF ( SNLC_CCID .EQ. '' ) THEN
         C1ERR = 'no SNID in ' // SNDATA_FILE_CURRENT(1:60)
         C2ERR = 'Check SNID: keyword'
         CALL MADABORT("CHECK_HEADER", c1err, c2err)
      ENDIF

      IF ( .NOT. FOUND_SURVEY ) THEN
         C1ERR = 'no SURVEY in ' // SNDATA_FILE_CURRENT(1:60)
         C2ERR = 'Check SURVEY: keyword'
         CALL MADABORT("CHECK_HEADER", c1err, c2err)
      ENDIF

c -------------------------------------------------
c check that header cuts have been applied in case 
c required header info is missing.
     
      NCUT = 0

c -------------
c Create list of required cut-bits, along with string-def in case of error.

      NCUT = NCUT + 1 ;  
      CUTBIT_LIST(NCUT) = CUTBIT_SNTYPE
      MSGCUT(NCUT)      = 'SNTYPE'
          
      CUTMASK_EXPECT = 0
      DO icut = 1, NCUT
         CUTMASK_EXPECT = 
     &       IBSET( CUTMASK_EXPECT , CUTBIT_LIST(icut)-1 )
      ENDDO

      LCUTS = APPLY_HEADER_CUTMASK .EQ. CUTMASK_EXPECT

      IF ( .NOT. LCUTS ) THEN

c print info for each required cut
        DO icut = 1, NCUT
           LTMP = BTEST( APPLY_HEADER_CUTMASK , CUTBIT_LIST(icut)-1 )
           IF ( LTMP ) THEN
              MSG = 'was Applied.'
           ELSE
              MSG = 'was NOT Applied ???'
           ENDIF
           LL = INDEX( MSGCUT(icut), ' ' ) - 1
           write(6,610) CUTBIT_LIST(icut), MSGCUT(icut), MSG
 610       format(T5,'Header CUTBIT ',I2, 2x, A20, A20 )
        ENDDO

        msg = 'something is wrong.'
        C1ERR = 'Header cuts not all applied for CID=' // 
     &           SNLC_CCID(1:ISNLC_LENCCID) // '; ' // msg
        write(C2err,620) APPLY_HEADER_CUTMASK, CUTMASK_EXPECT
620     format('APPLY_HEADER_CUTMASK=', I5, 4x,'Expected CUTMASK=',I5)
        CALL MADABORT("CHECK_HEADER", c1err, c2err)
      ENDIF

      RETURN
      END   ! end CHECK_HEADER

C ==============================
+DECK,CHECKEPIGNORE.
      LOGICAL FUNCTION CHECK_EPOCH_IGNORE(OPTMASK,iepoch)
c
c Returns TRUE of this epoch is to be ignored for any of
c the following reasons:
c   + in the [VERSION].IGNORE file
c   + fails PHOTFLAG bits
c   + fails SELECT_EARLYLC
c
c OPTMASK=1 --> increment global counters
c
c ------------
c Apr 23, 2008: check both the OR and AND logic 
c
c May 6, 2008: change name from CHECK_PHOTFLAG to 
c              CHECK_EPOCH_IGNORE since it now includes
c              user-masked epochs as well as PHOTFLAG cuts.
c
c Dec 6, 2009: for BAD photflag, set FLUX to -9E5 (instead of -9)
c              so that it does not show up in light curve plots.
c
c Mar 2015: 
c   + change to logical fun; returns TRUE --> ignore epoch
c   + real MJD -> real*8 MJD8
c
c Dec 21 2017: add OPTMASK argument to increment global counters
c   
c ---------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER iepoch  ! (I) SN & epoch indices
      INTEGER OPTMASK ! (I) options
c local var

      INTEGER MSKTMP, MSKOV, i, LL, ifilt_obs
      LOGICAL IGNORE, LMJD, LCID, LFILT, BADPHOT
      CHARACTER cflt*4, CCID*(MXCHAR_CCID)
      REAL*8 MJD8

c function(s)
      LOGICAL SELECT_EARLYLC

C ------------ BEGIN -------------

      IGNORE  = .FALSE.
      BADPHOT = .FALSE.

c May 6, 2008: first check for epochs to ignore from IGNORE file.

      DO 100 i = 1, NEPOCH_IGNORE

        CCID = SNLC_CCID
        LL   = ISNLC_LENCCID
        LCID = EPOCH_IGNORE_CCID(i)(1:LL) .EQ. CCID(1:LL)
        IF ( .NOT. LCID ) GOTO 100

c leave big margin for MJD check (.002 days) in case IGNORE 
c file has round-off errors for the MJD.
        MJD8 = SNLC8_MJD(iepoch)
        LMJD = ( ABS(EPOCH_IGNORE_MJD(i)-MJD8) < 0.002 )
        IF ( .NOT. LMJD ) GOTO 100

        ifilt_obs = ISNLC_IFILT_OBS(iepoch)
        cflt      = filtdef_string(ifilt_obs:ifilt_obs)
        LFILT     = EPOCH_IGNORE_FILT(i)(1:1) .EQ. CFLT(1:1)
        IF ( .NOT. LFILT ) GOTO 100

c if we get here, then give message to ignore epoch 
c and skip down to over-write part.

        IGNORE = .TRUE.

        IF ( STDOUT_UPDATE) THEN
          write(6,101) CCID, MJD8, cflt
        ENDIF
101     format(T8,'IGNORE EPOCH FOR: CID=',A8, 
     &         3x,'MJD=',F9.3, 3x,'FILT=',A )
        GOTO 600

100   CONTINUE

c ----------------------------------
c now check PHOTFLAG mask.
      MSKTMP  = ISNLC_PHOTFLAG(iepoch)

c check OR-logic 
c ==> reject epoch if any PHOTFLAG_MSKREJ bit is set
      MSKOV   = IAND ( PHOTFLAG_MSKREJ(1), MSKTMP )
      IF ( MSKOV .NE. 0 ) THEN
         BADPHOT = .TRUE.
         IGNORE  = .TRUE.
      ENDIF

c Now check AND logic 
c ==> reject epoch if all PHOTFLAG_MSKREJ(2:5) bits are set

      do i = 2, 5
        MSKOV   = IAND ( PHOTFLAG_MSKREJ(i), MSKTMP )
        IF ( MSKOV .GT. 0 .and.  
     &       MSKOV .EQ. PHOTFLAG_MSKREJ(i) ) THEN
             BADPHOT = .TRUE.
             IGNORE = .TRUE.
        ENDIF
      enddo

c ----------------------
c Check EARLY-epoch select logic (Mar 2015)

      IF ( .not. SELECT_EARLYLC(iepoch) ) IGNORE = .TRUE.

c -------------------------------------

600   CONTINUE

      IF ( BTEST(OPTMASK,0) ) THEN
        IF ( .NOT. IGNORE)  NEPOCH_TOT = NEPOCH_TOT + 1
        IF ( BADPHOT ) THEN
           NEPOCH_BADPHOT     = NEPOCH_BADPHOT     + 1
           NEPOCH_BADPHOT_SUM = NEPOCH_BADPHOT_SUM + 1
        ENDIF
      ENDIF

c -------------------------------------
c set function value and return
      CHECK_EPOCH_IGNORE = IGNORE ! Mar 2015

      RETURN
      END   ! end of  CHECK_EPOCH_IGNORE


C ================================================
+DECK,MAKE_SIMLIB_FILE.
      SUBROUTINE MAKE_SIMLIB_FILE(OPT_FLAG)

c Created Feb 2016
c Create LIBID entry in simlib file, based on info from data file.
c Beware that event distribution is not necessarily uniform since
c it has the data distribution.
c
c OPT_FLAG = 1 --> open simlib file and write header
c OPT_FLAG = 2 --> add next LIBID
c OPT_FLAG = 3 --> close file
c
c  OPT_SIMLIB_OUT & 1 -> write SIM_MAGOBS for all obs, 
c                        even for true flux = 0 and mag=99.
c  OPT_SIMLIB_OUT & 2 -> write SIM_MAGOBS only for true flux > 0
c
c
c Oct 15, 2019: fix format for SKYSIG : 6.2f -> 7.2f
c Nov 22, 2019: adapt to work on fakes and sims, and write MAG column.

      IMPLICIT NONE

      INTEGER OPT_FLAG ! 1=> init file, 2=> add simlib entry

+CDE,SNDATCOM.
c +CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SIMLIBCOM.
c +CDE,KCORCOM,IF=R4KCOR,I2KCOR.

      REAL*8  MJD, GAIN, RDNOISE, SKYSIG, PSF1, PSF2, PSFRAT
      REAL*8  ZP, ZPERR, MAG, FLUX, FLUXERR, PIXSIZE, LAMOBS
      INTEGER LIBID, IFILT, IFILT_OBS, LASTEP(MXFILT_OBS)
      INTEGER LEN0, LEN1, LEN2, EPMIN, EPMAX, NEWMJD, NOBS, iep, EP,i
      LOGICAL IS_REAL_DATA, WRALL_SIM_MAGOBS, WRSET_SIM_MAGOBS
      LOGICAL WR_SIM_MAGOBS
      CHARACTER BAND*4, FNAM*20, SEDCMD*200
      CHARACTER cMAG*10, cNCUTS*12, STR_OLD*40, STR_NEW*60

C ------------------ BEGIN ------------------

      IF( SIMLIB_OUT .EQ. '' ) RETURN

      FNAM = 'MAKE_SIMLIB_FILE'
      IS_REAL_DATA = ( .NOT. (LSIM_SNANA .or. LSIM_MAGOBS) )

c check option to write ALL SIM_MAGOBS, even for SIM_MAGOBS=99 where
c no fake or sim event was generated and there is zero flux.
      WRALL_SIM_MAGOBS = 
     &    BTEST(OPT_SIMLIB_OUT,0) .and. (.not.IS_REAL_DATA)

c check option to write SIM_MAGOBS  only for true flux > 0
      WRSET_SIM_MAGOBS = 
     &    BTEST(OPT_SIMLIB_OUT,1) .and. (.not.IS_REAL_DATA)
      WR_SIM_MAGOBS = WRALL_SIM_MAGOBS .or.  WRSET_SIM_MAGOBS

c -------------------------------------------

      IF ( OPT_FLAG == 1 ) THEN

+SELF,IF=SNANA.
        if ( NFILTDEF_RDKCOR == 0 ) then
           C1ERR = 'NFILTDEF_RDKCOR=0 --> no defined filters'
           C2ERR = 'Check &SNLCINP input KCOR_FILE'
           CALL MADABORT(FNAM, c1err, c2err)
        endif
+SELF.

+SELF,IF=SNFIT,PSNID.
      C1ERR = 'Cannot use SIMLIB_OUT option with snlc_fit.'
      C2ERR = 'Use snana.exe instead. '
      CALL MADABORT(FNAM, c1err, c2err)
+SELF.
        GLOBAL_BANNER = 
     &      'Prepare to write SIMLIB file from data'
        CALL PRBANNER (GLOBAL_BANNER(1:60) )
        LEN1 = INDEX(SIMLIB_OUT,' ') -1 
        print*,'   Open output SIMLIB file: ', SIMLIB_OUT(1:LEN1)
        
        OPEN(   UNIT   = LUNOUT
     &        , FILE   = SIMLIB_OUT
     &        , STATUS = 'UNKNOWN'
     &           )

        WRITE(LUNOUT,11) 
     &       'Created from snana.exe using SIMLIB_OUT option.'
        WRITE(LUNOUT,11) 
     &       'VERSION_PHOTOMETRY: ' // VERSION_PHOTOMETRY(1)(1:60)
        if ( WR_SIM_MAGOBS ) then
           WRITE(LUNOUT,11)
     &        'SIM_MAGOBS are copied to MAG column.'   
        endif
        WRITE(LUNOUT,11) ' ' 

        LEN1 = INDEX(SURVEY_NAME,' ') - 1
        LEN2 = INDEX(SURVEY_FILTERS,' ') - 1
        WRITE(LUNOUT,10) 'SURVEY:      ',  SURVEY_NAME(1:LEN1)        
        WRITE(LUNOUT,10) 'FILTERS:     ',  SURVEY_FILTERS(1:LEN2)
10      FORMAT(A, 1x, A)  ! KEY VAL
11      FORMAT('# ', A)

        if ( IS_REAL_DATA ) then   
          WRITE(LUNOUT,10) 'PSF_UNIT:    ',  'ARCSEC_FWHM'
          WRITE(LUNOUT,10) 'SKYSIG_UNIT: ',  'ADU_PER_SQARCSEC'  
          CALL SET_SIMLIB_SKYMAG()
          CALL SET_SIMLIB_ZPERR()
       endif

        WRITE(LUNOUT,10) 'NLIBID:     ',  'NLIBID_REPLACE'

        WRITE(LUNOUT, '(/,A,/)' ) 'BEGIN LIBGEN' 
cc90      FORMAT(/, 'BEGIN LIBGEN',/  )

        CALL FLUSH(LUNOUT)
        CALL FLUSH(6)

        RETURN
      ENDIF

      IF ( OPT_FLAG == 3 ) THEN
         write(LUNOUT,400) 
400      format(/, 'END_OF_SIMLIB: ', / )
         close(UNIT = LUNOUT)

c replace N_SNLC_CUTS with comment giving number of SIMLIB entries
         write(cNCUTS,'(I6,2x)') N_SNLC_CUTS
	 STR_OLD = 'NLIBID_REPLACE '
	 STR_NEW = cNCUTS
	 LEN0    = index(STR_OLD,' ') - 1
	 LEN1    = 8    ! for cNCUT
         LEN2    = INDEX(SIMLIB_OUT,' ') - 1
	 write(SEDCMD,505) 
     &       STR_OLD(1:LEN0), STR_NEW(1:LEN1), SIMLIB_OUT(1:LEN2)
c	 print*,' xxx SEDCMD = ', SEDCMD
         CALL SYSTEM(SEDCMD)

505      FORMAT('sed -i ', "'s/", A, '/',A, "/g1'", 2x, A)

c is SUBSURVEY_LIST is not blank, use system 'sed' command
c to insert its comma-separate list at top of SIMLIB file.
         IF ( SUBSURVEY_NAME_LIST .NE. '' ) THEN
            LEN1   = INDEX(SUBSURVEY_NAME_LIST,' ') - 1
            LEN2   = INDEX(SIMLIB_OUT,' ') - 1
            SEDCMD = "sed -i '1i SUBSURVEY_LIST: " 
     &          // SUBSURVEY_NAME_LIST(1:LEN1) // "' " 
     &          // SIMLIB_OUT(1:LEN2)
            CALL SYSTEM(SEDCMD)
         ENDIF

         return
      ENDIF

C ------------- OPT_FLAG=2 below -------------------------

      IF ( ISNLC_NEWMJD_STORE < 4 ) RETURN

      DO IFILT_OBS = 1, MXFILT_OBS
         LASTEP(IFILT_OBS) = -9
      ENDDO


c ----------
c first loop through and count NOBS
      NOBS = 0
      DO 25 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 21 EP = EPMIN, EPMAX
           if ( WR_SIM_MAGOBS ) then
              MAG = SIM_EPMAGOBS(ep)
              if ( WRSET_SIM_MAGOBS .and. MAG > 98.0 ) goto 21
           endif
           NOBS = NOBS + 1
21     CONTINUE
25    CONTINUE

ccc xxx mark delete      IF ( NOBS < CUTWIN_NEPOCH(1) ) RETURN  

c -----------
      PIXSIZE = SNLC_PIXSIZE
      if ( PIXSIZE < 0.0 ) PIXSIZE = PIXSIZE_GUESS

      WRITE(LUNOUT,66)
66    FORMAT('#--------------------------------------------' )
 
      LIBID = SNLC_CID      ! UNIQUE_CIDINT(SNLC_CCID)
      WRITE(LUNOUT,101) LIBID, SNLC_CCID
 101  FORMAT('LIBID: ', I8, 5x, '# cadence from SNID=', A )

      WRITE(LUNOUT,103) SNLC8_RA, SNLC8_DEC, SNLC_MWEBV
 103  FORMAT('RA: ', F12.6, 8x, 'DEC:', F12.6, 5x, 'MWEBV: ',F7.4)

      WRITE(LUNOUT,105) NOBS, PIXSIZE, 
     &       SNLC_REDSHIFT,  SNLC_SEARCH_PEAKMJD 
 105  FORMAT('NOBS: ', I4, 5x, 'PIXSIZE: ', F6.3, 5x,
     &       'REDSHIFT: 'F8.5, 5x, 'PEAKMJD: ', F9.3 )

      WRITE(LUNOUT,10) 'SUBSURVEY:', SUBSURVEY_NAME

c Nov 23 2019: add more info for simulated data
      IF ( WR_SIM_MAGOBS  ) THEN
         write(LUNOUT,"('GALID: ',I9)" ) SNHOST_OBJID(1)
         write(LUNOUT,"('FIELD: ',A )" ) SNLC_FIELDLIST ! includes overlaps

c         write(LUNOUT,"('SALT2x1: ',F6.3,5x,'SALT2c: ',F6.3)" )
c     &          SIM_SHAPEPAR, SIM_COLORPAR 
      ENDIF


c write column header
      WRITE(LUNOUT,110) 
110   FORMAT(/,'#  MJD     IDUM  BAND  GAIN RDNOISE  SKYSIG    ', 
     &         'PSF1 PSF2 PSFRAT    ZP  ZPERR   MAG' )

      DO IFILT_OBS = 1, MXFILT_OBS
         LASTEP(IFILT_OBS) = -9
      ENDDO

c --------
      DO 300 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        DO 301 IEP = EPMIN, EPMAX

           EP        = IEP
           MJD       = SNLC8_MJD(EP)
           IFILT_OBS = ISNLC_IFILT_OBS(ep)
           IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
           BAND      = FILTDEF_STRING(ifilt_obs:ifilt_obs)

           if ( EP < 0 ) goto 301  ! nothing valid to print

           GAIN      = SNLC_GAIN(ep)
           RDNOISE   = SNLC_RDNOISE(ep)
           SKYSIG    = SNLC_SKYSIG(ep)  
           PSF1      = SNLC_PSF_SIG1(ep)  
           PSF2      = SNLC_PSF_SIG2(ep)  
           PSFRAT    = SNLC_PSF_RATIO(ep) 
           ZP        = SNLC_ZEROPT(ep)
           ZPERR     = SNLC_ZEROPT_ERR(ep)

           cMAG      = '99'
           if ( WR_SIM_MAGOBS ) then
              MAG = SIM_EPMAGOBS(ep)
              if ( WRSET_SIM_MAGOBS .and. MAG > 98.0 ) goto 301
              write(cMAG,"(F8.4)") MAG
           endif

           IF ( PSF1 < 1.0E-5 .and. SKYSIG > 1.0E-5 ) GOTO 301

c if simlib info is not available, estimate it from FLUX and FLUXERR.
c Mainly for low-z sample which has no meta data. 
           IF ( PSF1 < 1.0E-5 .and.  SKYSIG < 1.0E-5 ) THEN
              GAIN    = 1.0 ;  RDNOISE = 1.0 
              ZPERR   = DBLE( SIMLIB_ZPERR(ifilt_obs) )
              PSF2    = 0.0 ;  PSFRAT  = 0.0           
              FLUX    = SNLC_FLUXCAL(EP)
              FLUXERR = SNLC_FLUXCAL_ERRTOT(EP)
              LAMOBS  = FILTOBS_LAMAVG(IFILT_OBS)
              CALL COMPUTE_SIMLIB_INFO(
     &               SNLC_CCID,FLUX,FLUXERR,LAMOBS,PIXSIZE,
     &               PSF1, SKYSIG, ZP)     ! returned
           ENDIF

           write(LUNOUT,120)  
     &        MJD, EP, BAND,    ! EP is a dummy ID
     &        GAIN, RDNOISE, 
     &        SKYSIG, PSF1, PSF2, PSFRAT,
     &        ZP, ZPERR, cMAG

120        format('S: ', 
     &            F9.3, I4, 2x, A2, 2x,      ! MJD, ID, BAND
     &            F5.2, 2x, F5.2, 2x,        ! GAIN, RDNOISE
     &            F7.2, 1x, 3(F6.2),2x,      ! SKYSIG, PSF info
     &            F6.3, 1x, F5.3, 1x, A      ! ZP, ZPERR, MAG
     &                )

301   CONTINUE
300   CONTINUE

      WRITE(LUNOUT,199) SNLC_CID
199   FORMAT('END_LIBID: ', I8, / )
      CALL FLUSH(6)

      RETURN
      END  ! end of MAKE_SIMLIB_FILE

C ====================================
+DECK,SET_SIMLIB_SKYMAG.
      SUBROUTINE SET_SIMLIB_SKYMAG()

c Check SURVEY_NAME for space or ground missing;
c set SKYMAG_LIST and PSF_FWHM accordingly.
c Beware that list of space surveys is hard-wired.

      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM. 
+CDE,SIMLIBCOM.

      INTEGER i, LENS

C -------------- BEGIN --------------

      ISGROUND = .TRUE.  ! default
      IF ( INDEX(SURVEY_NAME,'HST'     ) > 0 ) ISGROUND = .FALSE.
      IF ( INDEX(SURVEY_NAME,'JWST'    ) > 0 ) ISGROUND = .FALSE.
      IF ( INDEX(SURVEY_NAME,'WFIRST'  ) > 0 ) ISGROUND = .FALSE.
      IF ( INDEX(SURVEY_NAME,'CANDELS' ) > 0 ) ISGROUND = .FALSE.

      LENS = INDEX(SURVEY_NAME,' ') - 1

      IF ( ISGROUND ) THEN
          write(6,20) SURVEY_NAME(1:LENS), 'GROUND'
          NLIST_SKY = NLIST_SKY_GROUND
          DO i = 1, NLIST_SKY_GROUND
            SKYLAM_LIST(i) = SKYLAM_GROUND_LIST(i)
            SKYMAG_LIST(i) = SKYMAG_GROUND_LIST(i)
          ENDDO
          PSF_FWHM_GUESS   = 1.0   ! arcSec
          PIXSIZE_GUESS    = 0.5   ! arcSec
          ADD_SKYSIG_PIX   = 0.05  ! skySigma per pixel to add in loop

      ELSE
          write(6,20) SURVEY_NAME(1:LENS), 'SPACE'
          NLIST_SKY = NLIST_SKY_SPACE
          DO i = 1, NLIST_SKY_SPACE
            SKYLAM_LIST(i) = SKYLAM_SPACE_LIST(i)
            SKYMAG_LIST(i) = SKYMAG_SPACE_LIST(i)
          ENDDO
          PSF_FWHM_GUESS   = 0.2  ! arcSec
          PIXSIZE_GUESS    = 0.1
          ADD_SKYSIG_PIX   = 0.01
      ENDIF

20    format(T5,'Survey ',A, ' --> ', A, ' instrument params.' )
      write(6,40) 'PSF_FWHM ' , PSF_FWHM_GUESS, 'arcSeconds'
      write(6,40) 'PIXSIZE  ' , PIXSIZE_GUESS, 'arcSeconds'
40    format(T10, 'Set ', A,' = ', F6.3, 2x, A )

      DO i = 1, NLIST_SKY
         write(6,50) SKYLAM_LIST(i), SKYMAG_LIST(i)
50       format(T10, 'Set SKYMAG(',F7.0,' A) = ', F5.2, ' / asec^2'  ) 
      ENDDO

c - - - - - - 
c Write info to SIMLIB file
      if ( ISGROUND ) then
         write(LUNOUT,11) 'GROUND'
      else
         write(LUNOUT,11) 'SPACE'
      endif
11      format(/, '# Assume instrument parameters for ', A)
        DO i = 1, NLIST_SKY
           write(LUNOUT,12) SKYLAM_LIST(i), SKYMAG_LIST(i)
12         format('# Assume SKYMAG(',F7.0,') = ', F5.2,' mag/asec^2')
        ENDDO

      RETURN
      END     ! end SET_SIMLIB_SKYMAG

C ====================================
+DECK,SET_SIMLIB_ZPERR.
      SUBROUTINE SET_SIMLIB_ZPERR()

c Set SIMLIB_ZPERR(ifilt_obs) using &SNLCINP input 
c   SIMLIB_ZPERR_LIST = 'abc .01 def .02 hij .014'
c
c If SIMLIB_ZPERR_LIST='', set all ZPERR = 0.01
c

      IMPLICIT NONE
c +CDE,SNPAR.
c +CDE,CTRLCOM. 
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SIMLIBCOM.
+CDE,FILTCOM.

      INTEGER ifilt, IFILTDEF, NF, iafilt(MXFILT_OBS)
      REAL xafilt(MXFILT_OBS), ZPERR

C -------------- BEGIN --------------

      DO IFILT = 1, MXFILT_ALL
        SIMLIB_ZPERR(IFILT) = 0.01  ! default
      ENDDO

      IF ( SIMLIB_ZPERR_LIST .EQ. '' ) RETURN

      CALL PARSE_FILTSTRING(0, SIMLIB_ZPERR_LIST, NF,iafilt,xafilt)
      DO ifilt    = 1, NF
         ifiltdef = IAFILT(ifilt)
         ZPERR    = xafilt(ifilt)
         SIMLIB_ZPERR(ifiltdef) = ZPERR
         
c         CFILT = filtdef_string(ifiltdef:ifiltdef)
c         write(6,60) CFILT, IFILTDEF, ZPERR 
c60       format(' xxx : ZPERR(', A1,I3, ') = ', F6.3 )
      ENDDO

      RETURN
      END   ! ene SET_SIMLIB_ZPERR


C =======================================================
+DECK,COMPUTE_SIMLIB_INFO.
      SUBROUTINE COMPUTE_SIMLIB_INFO(CCID,FLUX,FLUXERR,LAMOBS,PIXSIZE,
     &                               PSF,SKYSIG,ZP)

c
c Created Jan 26 2017 by R.Kessler
c When &SNLCINP namelist SIMLIB_OUT is specified (fileName),
c and the data files have no meta data, this function is called
c as a hack to compute SIMLIB row entries for PSF, SKYSIG and ZP.
c 
c Strategy here is numerical solution with assumptions on 
c the PSF and sky brightness. Maybe can be done analytically, 
c but I didn't try. 

c * Fix PSF.
c * assume a sky brightness vs. wavelength estimate from LSST 
c     deep-drill cadence. Interpolate SKYMAG_REF based on 
c     input LAMOBS = central wavelength of filter.
c * loop over grid of SKYSIG values, increments of 0.1
c * for each SKYSIG, SNR_meas = Fpe/sqrt(Fpe+SQSKYSG) is solved
c    (quadratic equation) for ZP(pe) between FLUXCAL and MAG.
c * Use ZP and SKYSIG to compute "SKYMAG_predict"
c * SKYSIG with smallest |SKYMAG_predict - SKYMAG_REF| 
c    is the result.
c
c Something similar was previously done for the low-z similb 
c using only CFA3_KEPLERCAM; the resulting CFA3_KEPLERCAM.SIMLIB
c was used to simulate low-z in
c    http://adsabs.harvard.edu/abs/2013ApJ...764...48K
c and also in the JLA(Betoule 2014) and PS1(Sconlic 2014)
c analyses.
c Unfortunately, I cannot find the script or used to create
c CFA3_KEPLERCAM.SIMLIB .
c
c ----------------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SIMLIBCOM.
+CDE,CTRLCOM.
 
c subroutine args
      CHARACTER CCID*(MXCHAR_CCID)  ! (I) for error message only

      DOUBLE PRECISION 
     &   FLUX              ! (I) FLUXCAL
     &  ,FLUXERR           ! (I) error on above
     &  ,LAMOBS            ! (I) central wavelength of filter
     &  ,PIXSIZE           ! (I) pixel size, arcsec
     &  ,PSF, SKYSIG, ZP   ! (O)
 
    
c local args
      INTEGER NLOOP, MXLOOP
      REAL*8  
     &   PSF_SIG, SKYMAG, TMP_SKYMAG
     &  ,TMP_SKYSIG_PIX, TMP_SKYSIG_ASEC, TMP_SQSKYSIG_TOT
     &  ,TMP_ZP, TMP_Fsky_pix,  TMP_FSKY_ASEC, TMP_Fpe
     &  ,SNR, SQSNR, NEA, MAG, MAG_MAX,  ARG, AREA_PIXEL
     &  ,SKYMAGDIF, SKYMAGDIF_MIN, SKYMAGDIF_LAST, SNR_CHECK

      CHARACTER FNAM*20, C1ERR*80, C2ERR*80

      REAL*8   INTERP_1DFUN
      EXTERNAL INTERP_1DFUN

      LOGICAL LDMP

C --------------- BEGIN ---------------

c init output
      PSF = 0.0; SKYSIG=0.0 ; ZP=0.0

c      LDMP = .TRUE. 
      LDMP = .FALSE.

      FNAM = 'COMPUTE_SIMLIB_INFO' 

c set MAG_MAX based on Flux = FluxErr
      MAG_MAX = ZEROPOINT_FLUXCAL_DEFAULT - 2.5*LOG10(FLUXERR)
      if ( FLUX > FLUXERR ) then
         MAG = ZEROPOINT_FLUXCAL_DEFAULT - 2.5*LOG10(FLUX) 
      else
         MAG = MAG_MAX
      endif

c abort on insane FLUXERR
      IF ( FLUXERR < 1.0E-8 ) THEN
         write(c1err,161) 'FLUXERR', FLUXERR, FLUX
161      format('Insane ', A,' value = ', F12.4,
     &         3x, 'for FLUX=',F12.4)
         c2err = 'Check CID = ' // CCID
         CALL MADABORT(FNAM, c1err, c2err)
      ENDIF

c hard-wire PSF since we can't solve for all 3 items
      PSF      = PSF_FWHM_GUESS         ! set output
      PSF_SIG  = PSF_FWHM_GUESS/2.355   ! PSF in sigma, arcsec
      NEA      = 4.0*PI * (PSF_SIG*PSF_SIG)  ! Noise-equiv area, arcSec^2
      AREA_PIXEL = PIXSIZE**2     ! area of 1 pixel, arcsec^2

      SQSNR = (FLUX**2) / ( FLUXERR**2 + (0.0*FLUX)**2 )
      IF ( SQSNR < 2.0 ) SQSNR = 2.0  ! protect crazy SIMLIB values
      SNR   = sqrt(SQSNR)
      SKYMAGDIF_MIN = 9999.

c linear interpolation to get estimate of Sky mag per asec^2
      SKYMAG = interp_1dfun(1, LAMOBS, NLIST_SKY, 
     &                  SKYLAM_LIST, SKYMAG_LIST,
     &                  FNAM//char(0), 20)

      IF ( LDMP ) THEN
        print*,' xxx --------------------------------- '
        print*,' xxx FLUX = ', sngl(FLUX), ' +- ', sngl(FLUXERR)
        print*,' xxx LAMOBS, SKYMAG = ', sngl(LAMOBS), sngl(SKYMAG)
        print*,' xxx NEA  = ', sngl(NEA)
        print*,' xxx PSF  = ', sngl(PSF_FWHM_GUESS), ' FWHM '
        print*,' xxx SNR  = ', sngl(SNR)
        print*,' xxx AREA_PIXEL = ', sngl(AREA_PIXEL)
      ENDIF

      SKYMAGDIF_LAST = 9999; SKYMAGDIF = 999. ; 
      TMP_SKYSIG_PIX = ADD_SKYSIG_PIX
      NLOOP = 0 ; MXLOOP = 100000

      DO WHILE ( SKYMAGDIF < SKYMAGDIF_LAST ) 
         NLOOP = NLOOP + 1
         SKYMAGDIF_LAST   = SKYMAGDIF

c  increment skysig (pe) per pix
         TMP_SKYSIG_PIX   = TMP_SKYSIG_PIX + ADD_SKYSIG_PIX  
         TMP_SKYSIG_ASEC  = TMP_SKYSIG_PIX / PIXSIZE  ! sqrt(AREA_PIXEL)

         TMP_SQSKYSIG_TOT = NEA * (TMP_SKYSIG_ASEC**2) ! total SQSKYSIG 
         TMP_FSKY_PIX     = TMP_SKYSIG_PIX**2         ! sky val/pix, pe
         TMP_FSKY_ASEC    = TMP_FSKY_PIX / AREA_PIXEL ! sky val/asec^2

         ARG           = 1.0 + 4.0 * TMP_SQSKYSIG_TOT / SQSNR
         TMP_Fpe       = (SQSNR/2.0) * ( 1.0 + sqrt(ARG) )
         TMP_ZP        = MAG + 2.5*LOG10(TMP_Fpe)

c check how close computed TMP_SKYMAG is to expected SKYMAG
         TMP_SKYMAG    = TMP_ZP - 2.5*log10(TMP_FSKY_ASEC)
         SKYMAGDIF     = abs(TMP_SKYMAG - SKYMAG)
         
         if ( SKYMAGDIF < SKYMAGDIF_MIN ) then
            SKYMAGDIF_MIN = SKYMAGDIF
            SKYSIG    = TMP_SKYSIG_PIX/PIXSIZE     ! per arcSec^2 
            ZP        = TMP_ZP                     ! pe per exposure
         endif

         IF ( NLOOP > MXLOOP ) THEN
            CALL PRINT_PREABORT_BANNER(FNAM(1:18)//char(0),40)
            print*,'   FLUX = ', sngl(FLUX), ' +- ', sngl(FLUXERR)
            print*,'   LAMOBS, SKYMAG = ', sngl(LAMOBS), sngl(SKYMAG)
            print*,'   NEA  = ', sngl(NEA)
            print*,'   PSF  = ', sngl(PSF_FWHM_GUESS), ' FWHM '
            print*,'   SNR  = ', sngl(SNR)
            print*,'   AREA_PIXEL = ', sngl(AREA_PIXEL)
            print*,'   NLOOP = ', NLOOP
            print*,'   last SKYSIG = ', sngl(TMP_SKYSIG_PIX/PIXSIZE)
            print*,'   last ZP     = ', sngl(TMP_ZP)
            C1ERR = 'Cannot determine SKYSIG '
            C2ERR = 'after NLOOP tries '
            CALL MADABORT(FNAM, c1err, c2err)
         ENDIF

         IF ( LDMP ) THEN
            SNR_CHECK = TMP_Fpe / sqrt(TMP_Fpe + TMP_SQSKYSIG_TOT )
           write(6,60) NLOOP, TMP_SKYSIG_PIX, SKYMAGDIF, SNR_CHECK/SNR
60         format(' xxx ', I3,' SkySig=',F5.2, 5x, 'SKYMAGDIF=',F8.5,
     &         5x,'SNR(test)=',F6.4 )
         ENDIF
      ENDDO

      IF ( LDMP ) THEN
        print*,' xxx FINAL PSF,SKYSIG,ZP = ',
     &       sngl(PSF), sngl(SKYSIG), sngl(ZP)
          print*,' xxx DEBUG STOP' ; CALL FLUSH(6)
          CALL EXIT(EXIT_ERRCODE)
      ENDIF

      RETURN
      END      ! end COMPUTE_SIMLIB_INFO

C =======================================================
+DECK,FLUXERRCALC,IF=SNANA,SNFIT.
      SUBROUTINE FLUXERRCALC(iepoch, FLUXCAL, FLUXCAL_ERR )
c 
c Compute error from SKY,PSF and ZPT the same way as the
c simulation does. 
c
c Fill
c   SNLC_SKYFLUXCAL(iepoch)           ! fluxcal per pixel
c   SNLC_FLUXCAL_ERRCALC(iepoch)      ! calculated flux error
c   SNLC_FLUXCAL_HOSTERRCALC(iepoch)  ! idem for host noise contribution
c where
c   SKYFLUX_ERR_PHOTO^2 = TOTAL_ERR^2 - SIGNAL_ERR^2
c
c and SKYFLUX_ERR_CALC is determined from the
c effective aperture.
c
c Feb 12,2012 - complete re-write.
c   The ZEROPT is now for the search run instead of for the
c   template run, so no need for obsolete KSUM to translate ZPT.
c   The 'template' noise is ingored since we assume that
c   many template images exist. To include template noise,
c   the SKY_SIG entry in the data file can be increased.
c   Another caveat is that FLUXERR is computed here in ADU,
c   but the reference FLUX can be in ADU or uJy.  To avoid 
c   this confusion, the FLUXCAL error is computed from 
c     FLUXCAL_ERRCALC = FLUXADU_ERRCALC * ADUSCALE / 10**[0.4*ZPT]
c   Thus comparing the calculated FLUXCAL_ERRCALC to the real
c   FLUXCAL_ERRTOT is always unamgiguous
c
c   The calibrated FLUXCAL and its error are passed as arguments
c   to allow using fitted quantities that may work better for 
c   low SNR.
c
c
c Sep 21 2017: 
c  + implement CHECK_SNANA_DUMP
c  + check PIXSIZE !!!
c  + allow calc for any format (previously skipped TERSE)
c
c Mar 2 2018:
c  + REAL -> REAL*8
c
c Nov 15 2019: load SNLC_FLUXCAL_ERRTEST = ERRCALC/ERRTRUE
c
c --------------------------------------------
      IMPLICIT NONE
  
      INTEGER iepoch                ! (I) epoch & SN indices
      REAL    FLUXCAL, FLUXCAL_ERR  ! (I) FLUXCAL and its error

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.
+CDE,FILTCOM.

c local var

      REAL
     &   GAIN
     &  ,RDNOISE_pe, RDNOISE_ADU
     &  ,SQERR_TOT
     &  ,SQERR_SIGNAL
     &  ,SQERR_SKY      ! integrated over effective aperture
     &  ,SQERR_ZP
     &  ,SQSUM, TMPRAT, TMPERR
     &  ,SKY_SIG_ADU, SKY_SIG2_ADU ! search and template (ADU/pixel)
     &  ,SKY_SIGTOT_ADU
     &  ,SKY_AVG_ADU
     &  ,SBFLUXCAL, SBFLUXCAL_ERR, SBFLUXADU
     &  ,FLUXADU, FLUXADU_ERR
     &  ,ZP,  ZPERR, ZPSCALE, ZPDIF
     &  ,SQ1, SQRD,  SQERR_HOST, HOST_SKY_RATIO, ERRCALC, ERRTRUE
     &  ,SKYFLUX_ERR_PHOTO
     &  ,SKYFLUX_ERR_CALC 
     &  ,PIXSIZE

      INTEGER IFILT_OBS, IFILT, DUMPFLAG, LENS
      CHARACTER cfilt*2, FNAM*12, STRING_INVALID*200

c function
      EXTERNAL NoiseEquivAperture, CHECK_SNANA_DUMP, ABORT_SNANA_DUMP
      REAL*8   NoiseEquivAperture
      INTEGER  CHECK_SNANA_DUMP_forC

      REAL*8  AREA, PSFSIG1, PSFSIG2, PSFRATIO, MJD8  ! args for above

C ------------- BEGIN --------------

      ERRCALC = -9.0 
      SNLC_FLUXCAL_ERRCALC(iepoch)     = -9.0
      FNAM = 'FLUXERRCALC'

c initialize output

      SKYFLUX_ERR_PHOTO                = -9.0
      SKYFLUX_ERR_CALC                 = -9.0

c strip off observing conditions into local variables.

      ifilt_obs  = ISNLC_IFILT_OBS(iepoch)
      IFILT      = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 

      SKY_SIG_ADU   = SNLC_SKYSIG(iepoch)   ! search sky-sigma, ADU/pix
      SKY_SIG2_ADU  = max(0.0,SNLC_SKYSIG_T(iepoch))   ! idem for template
      PSFSIG1       = SNLC_PSF_SIG1(iepoch)    ! Gauss sigma, pixel
      PSFSIG2       = SNLC_PSF_SIG2(iepoch)    ! idem, 2nd component
      PSFRATIO      = SNLC_PSF_RATIO(iepoch) 
      GAIN          = SNLC_GAIN(iepoch)             ! e-/ADU
      RDNOISE_pe    = SNLC_RDNOISE(iepoch)          ! e-/pix
      ZP            = SNLC_ZEROPT(iepoch)
      ZPERR         = SNLC_ZEROPT_ERR(iepoch)
      SBFLUXCAL     = SNHOST_SBFLUXCAL(ifilt)
      SBFLUXCAL_ERR = SNHOST_SBFLUXCAL_ERR(ifilt)
      PIXSIZE       = SNLC_PIXSIZE
      ERRTRUE       = SNLC_FLUXCAL_ERRTOT(iepoch)

      SKY_SIGTOT_ADU = SQRT(SKY_SIG_ADU**2 + SKY_SIG2_ADU**2)

c check a few things.
      IF ( FLUXERRCALC_ZPTERR  .GE. 0.0 ) THEN
          ZPERR = FLUXERRCALC_ZPTERR 
      ENDIF

      IF ( GAIN > 0.0 ) THEN
        RDNOISE_ADU  = RDNOISE_pe/GAIN     ! translate RDNOISE from e- to ADU
        SKY_AVG_ADU  = GAIN * (SKY_SIGTOT_ADU**2) ! needed to scale host noise
      ELSE
        SKY_AVG_ADU  = 0.0
        RDNOISE_ADU  = 0.0
      ENDIF

c ----------------------------------------------
c check for invalid/undefined values

      STRING_INVALID = ''
      if ( SKY_SIG_ADU   < 1.0E-4  ) then
         CALL APPEND_STRING(STRING_INVALID, 'SKY_SIG_ADU')
      endif
      if ( RDNOISE_ADU   < 0.0  ) then
         CALL APPEND_STRING(STRING_INVALID, 'RDNOISE')
      endif
      if ( PSFSIG1       < 0.001   ) then
         CALL APPEND_STRING(STRING_INVALID, 'PSFSIG1')
      endif
      if ( PSFSIG2       < 0.0     ) then
         CALL APPEND_STRING(STRING_INVALID, 'PSFSIG2')
      endif
      if ( PSFRATIO      < 0.0     ) then
         CALL APPEND_STRING(STRING_INVALID, 'PSFRATIO')
      endif
      if ( GAIN          < 0.01    ) then
         CALL APPEND_STRING(STRING_INVALID, 'GAIN')
      endif
      IF ( ZP < 0.01 .or. ZP > 60.0    ) then
         CALL APPEND_STRING(STRING_INVALID, 'ZP')
      endif
      IF ( ZPERR < 0.0 .or. ZPERR > 3.99     ) then
         CALL APPEND_STRING(STRING_INVALID, 'ZPERR')
      endif
      IF ( PIXSIZE       < 0.0001  ) then
         CALL APPEND_STRING(STRING_INVALID, 'PIXSIZE')
      endif

      IF ( STRING_INVALID .NE. '' ) GOTO 777  ! skip to dump

c set logical as soon as we get here.
      DO_FLUXERRCALC = .TRUE.

c use ZPT to convert calibated flux back into ADU
c (since FLUX in the data file can be either ADU or uJy)

      ZPDIF       = ZP - ZEROPOINT_FLUXCAL_DEFAULT
      ZPSCALE     = 10**(0.4*ZPDIF)   ! FLUXADU/FLUXCAL ratio
      FLUXADU     = ZPSCALE * FLUXCAL
      FLUXADU_ERR = ZPSCALE * FLUXCAL_ERR

c get signal error, but avoid problems with large negative fluxes
      tmprat = FLUXADU / FLUXADU_ERR
      if ( tmprat .GT. 0.5 ) then
         SQERR_SIGNAL = FLUXADU / GAIN   ! ADU^2
      else
         SQERR_SIGNAL = 0.0
      endif
          
c get effective area for sky-bkg = 1/[integral PSF^2], pixelsize^2
      AREA  = NoiseEquivAperture(PSFsig1,PSFsig2,PSFratio)  
      SNLC_AREA_NOISE(iepoch) = AREA

c multiply skyerr^2 (per pixel) by effective area.
c Include optional read noise 

      SQ1  = SKY_SIGTOT_ADU  * SKY_SIGTOT_ADU
      SQRD = RDNOISE_ADU  * RDNOISE_ADU
      SQERR_SKY = AREA * ( SQ1 + SQRD )

c Include host noise if surface brightness (SB) is defined.

      SQERR_HOST = 0.0
      IF ( SBFLUXCAL > 0.001 .and. SKY_AVG_ADU > 0.0 ) THEN
         SBFLUXCAL  = SBFLUXCAL*(PIXSIZE**2)  ! -> FLUXCAL per pixel
         SBFLUXADU  = SBFLUXCAL * ZPSCALE
         SQERR_HOST = AREA*SQ1*(SBFLUXADU/SKY_AVG_ADU)   ! scale sky noise^2
         SQERR_SKY  = SQERR_SKY + SQERR_HOST
      ENDIF
      HOST_SKY_RATIO = sqrt ( SQERR_HOST / ( SQERR_SKY-SQERR_HOST) )

      SKYFLUX_ERR_CALC = SQRT(SQERR_SKY)    ! ADU

c compute calibrated skyflux per pixel^2
c  (not for error calc, but to compare with host surface brightess)
      
      SNLC_SKYFLUXCAL(iepoch) = 
     &   ((SKY_SIGTOT_ADU**2)*GAIN) / ZPSCALE

c compute error from zero-point smearing

      TMPERR    = 10**(0.4*ZPERR) - 1.0
      SQERR_ZP  = (FLUXADU * TMPERR)**2

c now combine calculated sky error and signal poisson noise
c for best estimate of flux error. This is what the simulation does.

      SQSUM = SQERR_SKY + SQERR_SIGNAL + SQERR_ZP
      ERRCALC                          = SQRT(SQSUM)/ZPSCALE
      SNLC_FLUXCAL_ERRCALC(iepoch)     = ERRCALC
      SNLC_FLUXCAL_HOSTERRCALC(iepoch) = SQRT(SQERR_HOST)/ZPSCALE

      IF ( ERRCALC > 0.0 .and. ERRTRUE > 0.0 ) THEN
        SNLC_FLUXCAL_ERRTEST(iepoch)  = ERRCALC/ERRTRUE
      ENDIF

c ------------------------------------
c Get photometry sky-error by subracting
c photo-stat signal error from total error

      SQERR_TOT    = FLUXADU_ERR * FLUXADU_ERR
      SQERR_SKY    = SQERR_TOT - SQERR_SIGNAL

      IF ( SQERR_SKY .GT. 0.0  ) THEN
         SKYFLUX_ERR_PHOTO = SQRT(SQERR_SKY)  ! ADU
      ELSE
         SKYFLUX_ERR_PHOTO = -9.0
      ENDIF

c --------------------------
c check for DUMP

777   CONTINUE
      IF ( DUMP_STRING .EQ. '' ) RETURN
      cfilt    = filtdef_string(ifilt_obs:ifilt_obs) 
      MJD8     = SNLC8_MJD(iepoch)
      DUMPFLAG = CHECK_SNANA_DUMP_forC(FNAM,SNLC_CCID,CFILT,MJD8)
 
cc    IF ( SIM_LIBID .EQ. 121 .and. ifilt_obs.EQ.5 ) DUMPFLAG=2 ! XXX REMOVE

      if ( DUMPFLAG > 0 ) then

        print*,' '
        print*,' XXX ---------------------------------------------- '       
        print*,' XXX FLUXERRCALC DUMP: '
        print*,' XXX CID=', SNLC_CCID(1:ISNLC_LENCCID),
     &         '  MJD=', sngl(MJD8), '  FILTER=',CFILT
        print*,' XXX FLUXADU = ', FLUXADU,' +- ', FLUXADU_ERR
        print*,' XXX FLUXCAL = ', FLUXCAL,' +- ', FLUXCAL_ERR
        print*,' XXX ZPT(AVG,ERR,SCALE) = ', 
     &               ZP, ZPERR, ZPSCALE
        print*,' XXX PSFSIG1, PSFSIG2   = ', 
     &               sngl(PSFSIG1), sngl(PSFSIG2),' Gauss pix'
        print*,' XXX GAIN               = ', GAIN
        print*,' XXX PIXSIZE, AREA      = ', PIXSIZE, sngl(AREA)
        print*,' XXX RDNOISE_ADU        = ', RDNOISE_ADU
        print*,' XXX SKY_SIG_ADU        = ', SKY_SIG_ADU, 
     &             ' ADU/pix (search)'
        print*,' XXX SKY_SIG2_ADU       = ', SKY_SIG2_ADU, 
     &             ' ADU/pix (template)'
        print*,' XXX SIG(HOST)/SIG(SKY) = ', HOST_SKY_RATIO
        print*,' XXX SKY_AVG_ADU        = ', SKY_AVG_ADU
        print*,' XXX SQERR_SIGNAL       = ', SQERR_SIGNAL,' ADU'
        print*,' XXX SQERR[SKY,TOT]     = ', 
     &        SQERR_SKY, SQERR_TOT,' ADU '
        print*,' XXX SIM_MAGOBS         = ', SIM_EPMAGOBS(iepoch)
        print*,' XXX SIM_LIBID          = ', SIM_LIBID

        write(6,60) SKYFLUX_ERR_PHOTO, SKYFLUX_ERR_CALC
60      format(T2,' XXX SKYERR_ADU(PHOTO,CALC) =',F10.3,F10.3 )


        write(6,61) ERRTRUE, ERRCALC
61      format(T3,'XXX FLUXCAL_ERR(PHOTO,CALC)=',F10.3,F10.3 )
        print*,'   '

        IF ( STRING_INVALID .NE. '' ) THEN
          LENS = INDEX(STRING_INVALID,' ' ) - 1
          print*,' XXX Invalid quantities: ', STRING_INVALID(1:LENS)
        ENDIF

        if ( DUMPFLAG == 2 ) CALL ABORT_SNANA_DUMP()

      endif

      RETURN
      END
+SELF.

C =====================================
+DECK,APPEND_STRING.
      SUBROUTINE APPEND_STRING(STRING,APPEND)
c return STRING = STRING // ':' // APPEND
c Note that there are no blank spaces. Each item is separated by colon.
      IMPLICIT NONE
      CHARACTER STRING*(*), APPEND*(*)
      INTEGER LENS
C ----------- BEGIN ------------
      LENS = INDEX(STRING,' ' ) - 1
      IF ( LENS == 0 ) then
        STRING = APPEND
      ELSE
        STRING = STRING(1:LENS) // ':' // APPEND
      ENDIF

      RETURN
      END

C =====================================
+DECK,CHECK_SNANA_DUMP_forC.
      INTEGER FUNCTION CHECK_SNANA_DUMP_forC(FUN,CCID,BAND,MJD)
   
C add char(0) terminators to strings and then call
C C function CHECK_SNANA_DUMP(...)

      IMPLICIT NONE

c inputs
      CHARACTER FUN*(*), CCID*(*), BAND*(*)
      REAL*8  MJD

c local args  
      INTEGER LEN_FUN, LEN_CCID, LEN_BAND, DUMPFLAG

c Declare C function
      EXTERNAL CHECK_SNANA_DUMP
      INTEGER CHECK_SNANA_DUMP
C ------------- BEGIN --------------

      LEN_FUN  = INDEX(FUN,  ' ' ) - 1
      LEN_CCID = INDEX(CCID, ' ' ) - 1
      LEN_BAND = INDEX(BAND, ' ' ) - 1

c      print*,' xxx FUN = ', FUN, LEN_FUN
c      print*,' xxx CCID = ', CCID, LEN_CCID
c      print*,' xxx BAND = ', BAND, LEN_BAND

      DUMPFLAG = CHECK_SNANA_DUMP(
     &        FUN(1:LEN_FUN) // char(0) ,
     &        CCID(1:LEN_CCID) // char(0) ,
     &        BAND(1:LEN_BAND) // char(0),
     &        MJD  )

      CHECK_SNANA_DUMP_forC = DUMPFLAG

      RETURN
      END

C ==========================================
+DECK,AREAFRAC,IF=SNANA,SNFIT.
      SUBROUTINE CCD_AREAFRAC(ep)

c Created aug 2014 by R.Kessler
c Use input globals NXPIX,NYPIX, XPIX(ep), YPIX(ep)
c to compute SNLC_AREAFRAC(ep) = A/ AMAX where
c
c A    = area of largest rectangle containing XPIX, YPIX
c AMAX = area of CCD.
c
c --------------
      IMPLICIT NONE

      INTEGER ep  ! (I) epoch index

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      REAL XCEN, YCEN, YSCALE, X, Y, xy, A, AMAX

C ------------- BEGIN -------

      SNLC_AREAFRAC(ep) = -9.0 ;
      if ( SNLC_NXPIX < 0.0 ) RETURN

      XCEN   = SNLC_NXPIX/2.0
      YCEN   = SNLC_NYPIX/2.0
      YSCALE = SNLC_NYPIX/SNLC_NXPIX

      X  = ABS(SNLC_XPIX(ep) - XCEN)
      Y  = ABS(SNLC_YPIX(ep) - YCEN) / YSCALE  ! --> scale to square

      if ( X > Y ) THEN
         xy = X  ! half-len of square
      else
         xy = Y
      endif

      AMAX = SNLC_NXPIX**2  ! max possible area
      A    = 4. * xy * xy   ! area containing XPIX, YPIX/Yscale

      SNLC_AREAFRAC(ep) = A/AMAX

      RETURN
      END   ! end of CCD_AREAFRAC
+SELF.

C ==========================================
+DECK,MON_SNANA.
      SUBROUTINE MON_SNANA(IFLAG)

c Re-Created Feb 2013
c Driver for monitor tables.

      IMPLICIT NONE

      INTEGER IFLAG   ! (I) see IFLAG_XXX params

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.

      LOGICAL   LTMP
      CHARACTER FNAM*10

C ------------ BEGIN ---------
      FNAM = 'MON_SNANA'

      IF( .NOT. USE_TABLEFILE ) RETURN

c ------------------------------------------------------
      IF ( MADE_LCPLOT )  N_SNLC_PLOT = N_SNLC_PLOT + 1 
c ------------------------------------------------------


      IF ( OPT_TABLE(ITABLE_SNANA) > 0 ) THEN
         CALL TABLE_SNANA(IDTABLE_SNANA,IFLAG)   
      ENDIF

      LTMP = ( IFLAG .EQ. IFLAG_INI .or. MADE_LCPLOT )  
      IF ( LTMP ) THEN
         CALL TABLE_CIDPTR(IFLAG)     ! init CID pointers for LC plots
      ENDIF

      RETURN
      END     ! end of MON_SNANA

C ========================================
+DECK,MON_HUBBLEREF.
      SUBROUTINE MON_HUBBLEREF ( IERR )
c
c Plot theory MAG vs. Z for various Omega_{M,LAM,w}
c to have convenient theory references, and to 
c crosscheck DLZ8 function.
c
c May 29, 2007: add 407 with Omega_MAT=1
c Feb 02, 2013: switch to SNHIST_XXX functions in sntools_output.c.
c Jul 08, 2016: plot curves from z=0-2 (instead of 0-1)
c Apr 23, 2019: add 8th plot with Orad = 1.2E-5

      IMPLICIT NONE
      INTEGER IERR ! (O) 0=> OK

+CDE,SNPAR.

c local var

      INTEGER iz, NBZ, iplot, hid, LENTIT
      REAL*8  Z0, zbinsize, ZLIM(2), DLMAG
      character chis*80

c define parameters for theory plots

      INTEGER NPL, NDIM
      PARAMETER (NPL = 8, NDIM=1 )

      REAL*8
     &   OM(NPL)  / 0.3,  0.3,  0.3, 0.3,  0.0,  0.0,  1.0,  0.3 /
     &  ,OL(NPL)  / 0.7,  0.7, 0.705,0.0,  0.0,  1.0,  0.0,  0.7 /
     &  ,OR(NPL)  / 0.0,  0.0,  0.0, 0.0,  0.0,  1.0,  0.0,  1.2E-5/
     &  ,W(NPL)   /-1.0, -0.9, -1.0, 0.0,  0.0, -1.0, -1.0, -1.0 /
     &  ,DWDZ(NPL)/ 0.0,  0.0,  0.0, 0.0,  0.0,  0.0,  0.0,  0.0 / 
     &  ,DL

c functions

      REAL*8 DLZ8
c ---------------- BEGIN ------------
      IERR = 0

      CALL PRBANNER ( "PLOT THEORY HUBBLE DIAGRAMS for REFERENCE")

c define Z bins for each plot

      ZLIM(1) = 0.0
      ZLIM(2) = 2.0
      NBZ     = 200

ccccc
      ZLIM(2) = 4.0
      NBZ     = 200
ccccc

      Zbinsize = ( ZLIM(2)-ZLIM(1) ) / float(NBZ)

c book histos

      LENTIT = LEN(chis)

      DO iplot = 1, NPL
         write(chis,20) OM(iplot), OL(iplot), 
     &                  OR(iplot)/1.0E-5, w(iplot) 
20       format('MU  vs. z (OM,OL,Or/E5 =', 3(F5.3,',') , ')',
     &            2x, 'w = ',F5.2, ')'  )
         hid = 400 + iplot
         chis = chis(1:40) // char(0)
         CALL SNHIST_INIT(NDIM, hid, chis, NBZ, zlim(1), zlim(2), 
     &                      LENTIT )
      END DO

c comput Mag vs. Z and fill histograms

      DO 100 iz    = 1, NBZ
        Z0 = zbinsize * ( float(iz)-0.5 )
      DO 200 iplot = 1, NPL
 
c use H0_DEFAULT instead of namelist H0_REF so that plot is always the same.

        DL = DLZ8( H0_DEFAULT, dble(Z0), 
     &    OM(iplot), OL(iplot), OR(iplot), W(iplot), dWdz(iplot) )
 
        DLMAG   = -5.0 * LOG10 ( 10.0*PARSEC/DL )

        HID = 400 + iplot
        CALL SNHIST_FILL( NDIM, HID, Z0, DLMAG ) 

200   CONTINUE
100   CONTINUE   ! iz


      RETURN
      END   ! end of MON_HUBBLEREF

C =======================================
+DECK,IDTELSELECT.
      LOGICAL FUNCTION IDTELSELECT(IDTEL)
c
c Returns TRUE if this IDTEL is accepted.
c 
      IMPLICIT NONE
      INTEGER IDTEL  ! (I) telescope id of current epoch

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER i
c ------------- BEGIN ---------

      IF ( DOALL_SNTEL .or. FORMAT_TERSE ) THEN
         IDTELSELECT = .TRUE. 
         RETURN
      ENDIF

c check specific telescopes in user-list

      IDTELSELECT = .FALSE.
      DO i  = 1, NIDTEL_LIST
         if ( IDTEL .EQ. IDTEL_LIST(i) ) then
           IDTELSELECT = .TRUE.
         endif
      ENDDO
      RETURN
      END

C ===============================================
+DECK,MJDSELECT.
      LOGICAL FUNCTION MJDSELECT ( imjd, cutbit )
c
c Returns TRUE if this IMJD passes cuts
c CUTBIT = 0 => apply all cuts.
c
c If cutbit < 0, then all cuts are applied EXCEPT
c for |cutbit|; i.e., the cut on |cutbit| is ignored.
c This is useful to plot variables with cuts on all other 
c variables except the one of interest. This allows you to
c see what gets cut.
c
c Note that if |cutbit| <= CUTBIT_MJD_MARKER,
c then this function really just selects from the 
c SN-dependent cuts (like RA, redshfit, etc ...) 
c and ignores the epoch index.
c
c Aug 22, 2007: modify to select NEWMJD instead of epoch.
c Nov 12, 2018: real MJD -> real*8 MJD
c -------------------------------------------
      IMPLICIT NONE

c declare subroutine args

      INTEGER 
     &   imjd     ! (I) epoch index
     &  ,cutbit   ! (I) cut to ignore (if negative)

+CDE,SNDATCOM.
+CDE,SNLCINP.

c local var

      INTEGER EPMIN, acutbit   ! abs(cutbit)
      REAL*8    MJD         
      INTEGER*8 CUTMASK8_ALL, CUTMASK8_TMP, OVP8
     
      LOGICAL LCUT_MJD, LCUT_SN

c -------------- BEGIN ------------------
 
      MJDSELECT =  .FALSE.

c -----------------------------------------------
c first make a few idiot checks

      EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd) 
      MJD   = SNLC8_MJD(EPMIN) 
      if ( MJD .LT. 40000. ) return

c ----------------------------------------

      IF ( CUTBIT .GE. 0 ) THEN
         MJDSELECT =  MJDMASK(imjd) .GT. 0
         RETURN
      ENDIF

c --------------------------------------------------
c Now we have a negative cutbit; 
c check all cuts except |cutbit|

      acutbit = abs(cutbit)

      if ( acutbit .GT. NCUTBIT ) then
          write(c1err,60) cutbit
60        format('bad value of CUTBIT = ', I4 )
          CALL MADABORT("MJDSELECT", c1err, "")
      endif

c get cut-mask with all bits set.
c Note "SN" and EPOCHS have different cutmask.

      if ( acutbit .LE. CUTBIT_MJD_MARKER ) then
           CUTMASK8_ALL =  CUTMASK8_SN_ALL
           LCUT_SN    = .TRUE.
           LCUT_MJD   = .FALSE.
      else 
           CUTMASK8_ALL =  CUTMASK8_MJD_ALL
           LCUT_SN      = .FALSE.
           LCUT_MJD     = .TRUE.
      endif

c define mask with all cuts except IBIT cut

      CUTMASK8_TMP = IBCLR ( CUTMASK8_ALL, acutbit-1 )

      IF ( LCUT_SN ) then
        OVP8  = IAND ( CUTMASK8_TMP, CUTMASK8_SN )
      ELSE
        OVP8  = IAND ( CUTMASK8_TMP, CUTMASK8_MJD(imjd))
      ENDIF

c  MJD passes if overlap mask equals mask with all
c  cuts EXCEPT |cutbit|

      MJDSELECT = ( OVP8 .EQ. CUTMASK8_TMP )

      RETURN
      END


   

C ==========================================
+DECK,GET_TRVAR.
      SUBROUTINE GET_TRESTVAR(
     &     NTLIST, TLIST, FLIST               ! (I)
     &   , CUTWIN_TREST                       ! (I)
     &   , CUTWIN_TRESTMIN, CUTWIN_TRESTMAX   ! (I)
     &   , CUTWIN_TREST2                      ! (I)
     &   , NFILT, TMIN, TMAX                  ! (O)
     &   , NFTMIN, NFTMAX, NFT2               ! (O)
     &   , TGAPMAX, T0GAPMAX )                ! (O) 

c Created May 25, 2009 by R.Kessler
c Return rest-frame variables related to TREST,
c where TREST = 0 at peak.
c NOTES:
c   - assumes that TLIST is ordered from min to max.
c
c
c Aug 16, 2009: add more arguments: FLIST, NFTMIN, NFTMAX
c Aug 23, 2009: add NFILT output arg               
c Oct 09, 2012: new args, CUTWIN_TREST2 and NFT2
c --------------------

      IMPLICIT NONE
+CDE,SNPAR.

      INTEGER 
     &   NTLIST        ! (I) size of TLIST array
     &  ,FLIST(NTLIST) ! (I) obs-filter list (to count NFTMIN[MAX])

      REAL  
     &   TLIST(NTLIST)         ! (I) rest-frame list
     &  ,CUTWIN_TREST(2)       ! (I) global Trest-window
     &  ,CUTWIN_TRESTMIN(2)    ! (I) window to count NFTMIN 
     &  ,CUTWIN_TRESTMAX(2)    ! (I) idem for NFTMAX
     &  ,CUTWIN_TREST2(2)      ! (I) generic window
     
      REAL 
     &   TMIN, TMAX      ! (O) min, max Trest
     &  ,TGAPMAX         ! (O) max rest-frame gap (days)
     &  ,T0GAPMAX        ! (O) idem near peak

      INTEGER 
     &   NFILT           ! (O) NFILT in FLIST array
     &  ,NFTMIN          ! (O) Nfilt passing CUTWIN_TRESTMIN
     &  ,NFTMAX          ! (O) Nfilt passing CUTWIN_TRESTMAX
     &  ,NFT2            ! (O) Nfilt passing CUTWIN_TREST2

c local car

      INTEGER 
     &   i, ORDER, isort
     &  ,INDEX_SORT(MXEPOCH)
     &  ,IFILT_obs
    
      REAL 
     &  Trest, Tlast, TGAP
     & ,T0GAPWIN(2)

      LOGICAL 
     &   LT0GAP, LTMP
     &  ,LTMIN(MXFILT_ALL)
     &  ,LTMAX(MXFILT_ALL)
     &  ,LT2(MXFILT_ALL)
     &  ,LFILT(MXFILT_ALL)

c function

      EXTERNAL SORTFLOAT

C ------------------- BEGIN ---------------

c init output args
      Tmin      = +999.
      Tmax      = -999.       
      TGAPMAX   = -999.
      T0GAPMAX  = -999.
      NFTMIN    = 0
      NFTMAX    = 0
      NFILT     = 0
      NFT2      = 0

c local stuff
      Tlast     =  999.

c construct T0GAP-window from other cuts
      T0GAPWIN(1)  = CUTWIN_TRESTMIN(2)
      T0GAPWIN(2)  = CUTWIN_TRESTMAX(1)
 
      DO IFILT_OBS = 1, MXFILT_ALL
        LFILT(IFILT_OBS) = .FALSE.
        LTMIN(IFILT_OBS) = .FALSE.
        LTMAX(IFILT_OBS) = .FALSE.
        LT2(IFILT_OBS)   = .FALSE.
      ENDDO 


      ORDER = +1 
      CALL sortFloat(NTLIST, TLIST, ORDER, INDEX_SORT )
     
      DO 444 i   = 1, NTLIST

         isort      = INDEX_SORT(i)
         Trest      = TLIST(isort)
         ifilt_obs  = FLIST(isort)

         if ( Trest .LT. CUTWIN_TREST(1)   ) GOTO 444          
         if ( Trest .GT. CUTWIN_TREST(2)   ) GOTO 444          

         IF ( .not. LFILT(ifilt_obs) ) then
            NFILT = NFILT + 1
            LFILT(ifilt_obs) = .TRUE.
         ENDIF

         LTMP = Trest .GE. CUTWIN_TRESTMIN(1) .and.
     &          Trest .LE. CUTWIN_TRESTMIN(2)
         IF ( LTMP .and.  .not. LTMIN(ifilt_obs) ) then
            NFTMIN = NFTMIN + 1
            LTMIN(ifilt_obs) = .TRUE.
         ENDIF

         LTMP = Trest .GE. CUTWIN_TRESTMAX(1) .and.
     &          Trest .LE. CUTWIN_TRESTMAX(2) 
         IF ( LTMP .and.  .not. LTMAX(ifilt_obs) ) then
            NFTMAX = NFTMAX + 1
            LTMAX(ifilt_obs) = .TRUE.
         ENDIF

         LTMP = Trest .GE. CUTWIN_TREST2(1) .and.
     &          Trest .LE. CUTWIN_TREST2(2) 
         IF ( LTMP .and.  .not. LT2(ifilt_obs) ) then
            NFT2 = NFT2 + 1
            LT2(ifilt_obs) = .TRUE.
         ENDIF

         Tmin = MIN ( Tmin, Trest )
         Tmax = MAX ( Tmax, Trest )

         if ( i .EQ. 1 ) then
           Tlast = Trest
           GOTO 444
         endif

         TGAP = Trest - Tlast
         if ( TGAP .GT. TGAPMAX ) then
             TGAPMAX = TGAP
         endif

         LT0GAP = .FALSE.
         if ( Trest > T0GAPWIN(1) .and. Trest < T0GAPWIN(2) ) 
     &       LT0GAP = .TRUE.
         if ( Tlast > T0GAPWIN(1) .and. Tlast < T0GAPWIN(2) ) 
     &       LT0GAP = .TRUE.
         if ( Trest > T0GAPWIN(2) .and. Tlast < T0GAPWIN(1) ) 
     &       LT0GAP = .TRUE.

         if ( LT0GAP .and. TGAP .GT. T0GAPMAX ) then
           T0GAPMAX = TGAP
         endif

         Tlast = Trest

444   CONTINUE

      RETURN
      END    ! GET_TRESTVAR



C ==================================================
+DECK,DMP_README.
      SUBROUTINE DMP_README(IVERS,IERR)

c Created Jun 2011
c Dump README file to stdout for this version.
c
C Use global SNDATA_PREFIX to construct the name
C of the README file for this version.
c This code was moved from RDSNDATA so that it can be
c called for both TEXT and FITS format.
c
c Feb 26 2015: SNFILE_README already filled, so don't fill it here.
c

      IMPLICIT NONE

      INTEGER IVERS, IERR  ! (I/O) 

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER LEN_README, IERROPEN, L1, LL
      CHARACTER 
     &   CMD*(MXCHAR_FILENAME+20)
     &  ,FILENAME*(MXCHAR_FILENAME)
     &  ,VERSION*(MXCHAR_VERSION)

c --------------- BEGIN --------------

      IERR = 0

      L1 = INDEX( SNDATA_PREFIX, ' ' ) - 1


      FILENAME = SNREADME_FILE(IVERS)

      OPEN(UNIT = LUNDMP, FILE = FILENAME, 
     &     IOSTAT = IERROPEN, STATUS='OLD')


      LEN_README = INDEX ( FILENAME, ' ' ) - 1
      CLOSE ( UNIT = LUNDMP )

      IF ( IERROPEN .NE. 0 ) THEN
        C1err = 'Could not find README file '
        C2err = FILENAME(1:LEN_README)
        CALL MADABORT("DMP_README", c1err, c2err )
      ENDIF


      write(cmd,50) FILENAME(1:LEN_README)
50    format('cat ', A )

      VERSION  = VERSION_PHOTOMETRY(ivers) 
      LL       = index(VERSION,' ') - 1

      GLOBAL_BANNER = " DUMP README FILE for VERSION " 
     &       // VERSION(1:LL)
      CALL PRBANNER ( global_banner(1:80) )


      print*, cmd
        CALL FLUSH(6)
        CALL SYSTEM ( cmd )
        CALL FLUSH(6)
      print*,' '


      RETURN
      END

C ====================================================
+DECK,DMP_CUTFAIL.
      SUBROUTINE DMP_CUTFAIL ( IMJD, idebug ) 
c
c Created Jan 31, 2006 by R.Kessler
c
c Dump CUTBITS that fail for this 'IMJD'
c 
c IDEBUG = 1 : general info for users
c IDEBUG = 2 : include detailed cut-masks for development
c
c Aug 2007: make special note when telescope is not found.
c Nov 2019: remove telescope logic and CUTBIT_IDTEL

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER IMJD   ! (I) sparse SN index and epoch
      INTEGER idebug     ! (I) debug level

c local var

      INTEGER  cid, ibit, ii, EPMIN
      character ccid*(MXCHAR_CCID)
      LOGICAL LCUT, LTEST

C ------------------- BEGIN --------------

      cid  = SNLC_CID
      ccid = SNLC_CCID

      EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,IMJD)

c write MJD-cutmask in hex format

      IF ( IDEBUG .GT. 1 ) then
        write(6,20) CUTMASK8_MJD(IMJD), ccid, IMJD
20      format(T5, 'CUTMASK8_MJD = x', z16.16, 2x, 
     &        'for  SN ', A12, 2x, 'NEWMJD ',I3 )
      ENDIF

c list failed bits for epoch-dependent cuts only

      DO ibit = CUTBIT_MJD_MARKER+1, NCUTBIT

        LTEST = BTEST ( CUTMASK8_MJD_ALL,        ibit-1 ) 
        LCUT  = BTEST ( CUTMASK8_MJD(IMJD),  ibit-1 )

        if ( LTEST .and.  .not. LCUT ) then
           ii = INDEX(cutvar_name(ibit),':') - 1

           write(6,30) 
     &        IMJD, snlc8_MJD(EPMIN),
     &        ibit, cutvar_name(ibit)(1:ii)

30         format(T5,'NEWMJD ',I2,1x,'(MJD=',F9.3,')',2x,
     &         'Failed CUTBIT ', I3, ' : ', A  )

cc xxx mark delete      if ( ibit.EQ. CUTBIT_IDTEL ) NOTEL = .TRUE.
        endif

      ENDDO

      RETURN
      END  ! end DMP_CUTFAIL
  
C =============================================
+DECK,DMP_SNFAIL.
      SUBROUTINE DMP_SNFAIL()
c
c Dump utility for SN that fails cuts
c Shows cuts that fail for SN, and cuts that fail for each epoch.
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER imjd, ibit, ii
      LOGICAL LCUT, LTEST

C ---------------- BEGIN ------------

      print*,' '
      print*,' ========== DMP_SNFAIL for CID ', SNLC_CID,
     &        ' ================= '

      DO 100 ibit = 1, CUTBIT_MJD_MARKER 

        LTEST = BTEST ( CUTMASK8_SN_ALL,  ibit-1 )
        LCUT  = BTEST ( CUTMASK8_SN,      ibit-1 )

        if ( LTEST .and.  .not. LCUT ) then
           ii = INDEX(cutvar_name(ibit),':') - 1
           
           write(6,30) ibit, cutvar_name(ibit)(1:ii)
     &          ,SNLC_CUTVAR(ibit)
     &          ,CUTWIN_VAR(1,ibit)
     &          ,CUTWIN_VAR(2,ibit)
30         format(T5, 'Failed SN cut ',I2,' : ', A,
     &        ' =', F8.2, ' (cutwin=',F8.1,' to ',G10.3,  ')'  )
        endif

100   CONTINUE

      do imjd = 1, ISNLC_NEWMJD_STORE
         CALL DMP_CUTFAIL ( IMJD, 1 )  ! MJD cut-failures
      enddo

      print*,' ===================================== '
      print*,' '
      RETURN
      END


C ==================================================
+DECK,SET_CUTMASK.
      SUBROUTINE SET_CUTMASK()

c
c Created Jan 31, 2006 by R.Kessler
c
c After SN data are read in, this routine
c sets CUTMASK8_SN and CUTMASK8_MJD(epoch), 
c and then determines which SN and epochs pass/fail cuts.
c
c To test SN 
c   if ( CUTMASK8_SN .EQ. CUTMASK8_SN_ALL ) then
c      use this SN
c   endif
c
c To test epochs,
c
c    if (  btest(EPOCHMASK(isn),epoch-1 )  ) then
c       use this epoch
c    endif
c
c       HISTORY
c    ~~~~~~~~~~~~~
c Feb 7, 2014 ZZ->1 if SNLC_REDHIFT < 0 ; fixes TOBSMIN/TOBSMAX.
c
c Jan 11 2015: call REJECT_PRESCALE to set LCUT for CUTBIT_PRESCALE
c
c Jan  8 2017: abort if ISNLC_TYPE > MXTYPE 
c Jul 11 2017: declare PS8 as REAL*8, not INT*8
c Dec 09 2017: remove REJECT_PRESCALE() and move it to SNANA_DRIVER
c Dec 18 2017: set cut for PSF
c Feb 27 2018: set cut for ZP in Npe; see CUTWIN_ZP
c -----------------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

c local var

      INTEGER
     &   NEWMJD, imjd, NEWMJD_CUTS
     &  ,EPMIN, EPMAX, ep, ifilt, ifilt_obs
     &  ,ICUT, i, cid, IDTEL, NTLIST
     &  ,FLIST(MXEPOCH)
     &  ,NFILT, NFTMIN, NFTMAX, NFT2

      INTEGER*8  CUTMASK8_TMP, OVP8_SN, OVP8_ALL

      LOGICAL LTEST, LCUT
 
      REAL  TMP, Tmin, Tmax, ZZ, TGAPMAX, T0GAPMAX, TLIST(MXEPOCH)

c functions
      LOGICAL MJDSELECT, IDTELSELECT, LCIDSELECT

c ---------------- BEGIN ---------------

      NEWMJD       = ISNLC_NEWMJD_STORE
      NEWMJD_CUTS  = 0

c init common block var output

      CUTMASK8_SN   = 0


      Do imjd = 1, NEWMJD
         CUTMASK8_MJD(imjd) = 0
         MJDMASK(imjd)      = 0  ! init
      End Do

      CID = SNLC_CID

      IF ( SNLC_REDSHIFT > 0. ) THEN
         zz  = 1.0 + SNLC_REDSHIFT
      ELSE
         zz = 1.0  ! avoid crazy Tobsmin/max
      ENDIF

c check privat-var cuts and user cuts from private code
      IF ( .not. PASS_USRCUTS  ) ISNLC_CUTFLAG_USRCUTS = 0 
      IF ( .not. PASS_PRIVCUTS ) ISNLC_CUTFLAG_PRIVATE = 0 
      IF ( .not. PASS_SIMCUTS  ) ISNLC_CUTFLAG_SIMVAR  = 0 

c --------------------------------------------------------
c first evaluate SNLC_CUTVAR array for MJD-dependent
c SNLC_XXX arrays.

      DO 100 imjd = 1, NEWMJD

        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,imjd)

c Dec 18 2017: replace cloudAVG with PSF cut. Note that cut is in ARCSEC
         SNEP_CUTVAR(CUTBIT_PSF,imjd)  = 
     &       SNLC_PSF_SIG1(EPMIN) * (SNLC_PIXSIZE * 2.355)

         SNEP_CUTVAR(CUTBIT_ZP,imjd) = 
     &       SNLC_ZEROPT_forCUT(EPMIN) 

         SNEP_CUTVAR(CUTBIT_PHOTPROB,imjd)  = 
     &       SNLC_PHOTPROB(EPMIN)

         SNEP_CUTVAR(CUTBIT_ERRTEST,imjd)  =   ! Nov 2019
     &       SNLC_FLUXCAL_ERRTEST(EPMIN)

c xxxxxxx mark delete Nov 2019 xxxxxx
c         SNEP_CUTVAR(CUTBIT_NBAND_THRESH,imjd)  = 
c     &       ISNLC_NFILT_THRESH(IMJD)
c xxxxxxxxxxxxxxxxxxxxxxxx

         SNEP_CUTVAR(CUTBIT_TREST,imjd)  = 
     &       SNLC_TREST(EPMIN)

         SNEP_CUTVAR(CUTBIT_TOBS,imjd)  = 
     &       SNLC_TOBS(EPMIN)

         SNEP_CUTVAR(CUTBIT_MJD,imjd)  = 
     &       SNLC8_MJD(EPMIN)


100   CONTINUE
  
c ----------------------------------------------------
c Evaluate cutmask for each epoch

      DO 200 imjd = 1, NEWMJD

        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,imjd)

        CUTMASK8_TMP = 0
        CUTMASK8_MJD(imjd) = CUTMASK8_TMP

      DO 201 icut  = CUTBIT_MJD_MARKER+1, NCUTBIT

          LTEST = BTEST ( CUTMASK8_MJD_ALL, icut-1 )
          if ( .NOT. LTEST ) goto 201

          tmp = snep_cutvar(icut,imjd)
          LCUT = tmp .GE. cutwin_var(1,icut) .and.
     &           tmp .LE. cutwin_var(2,icut)

c set cut-bit if cut is satisfied
          if ( LCUT ) then
             CUTMASK8_TMP = IBSET ( CUTMASK8_TMP, icut-1 )
          endif 


201   CONTINUE   ! end ICUT loop

c if all cuts are satisfied for this epoch, then set MJDMASK

        CUTMASK8_MJD(imjd) = CUTMASK8_TMP

        if ( CUTMASK8_TMP .EQ. CUTMASK8_MJD_ALL ) then
           MJDMASK(imjd) = 1
           NEWMJD_CUTS   = NEWMJD_CUTS + 1
        endif

200   CONTINUE  ! end of IMJD loop

c -----------------------------------------------
c store number of epochs passing cuts,

      ISNLC_NEWMJD_CUTS = NEWMJD_CUTS

c -------------------------------------------
c fill SNLC_CUTVAR array for SN-dependent variables
c Note that this is done AFTER epoch-dependent cutmask
c so that NEWMJD_CUTS can be evaluated correctly.

         imjd  = 1

         SNLC_CUTVAR(CUTBIT_CID)       = 
     &        float ( SNLC_CID )

         SNLC_CUTVAR(CUTBIT_REDSHIFT)  = 
     &       SNLC_REDSHIFT

         SNLC_CUTVAR(CUTBIT_REDSHIFT_ERR)  = 
     &       SNLC_REDSHIFT_ERR

         SNLC_CUTVAR(CUTBIT_RA)  = 
     &       SNLC8_RA
         SNLC_CUTVAR(CUTBIT_DEC)  = 
     &       SNLC8_DEC

         SNLC_CUTVAR(CUTBIT_HOSTSEP)  = 0.0 ! xx

         SNLC_CUTVAR(CUTBIT_PEAKMJD)  = 
     &       SNLC_SEARCH_PEAKMJD

         SNLC_CUTVAR(CUTBIT_NMJD_INCLUDE)  = 
     &       float ( ISNLC_NMJD_INCLUDE )  ! Aug 11 2015

         SNLC_CUTVAR(CUTBIT_SNRMAX)  = 
     &       SNLC_SNRMAX_FILT(0)
         SNLC_CUTVAR(CUTBIT_SNRMAX2)  = 
     &       SNLC_SNRMAX_FILT(0)

         SNLC_CUTVAR(CUTBIT_NEPOCH)  = 
     &       float ( ISNLC_NEPOCH_STORE )

         SNLC_CUTVAR(CUTBIT_SEARCH)  = 
     &       SIM_SEARCHEFF_MASK

         SNLC_CUTVAR(CUTBIT_NFIELD)  = 
     &       float ( ISNLC_NFIELD_OVP )

         SNLC_CUTVAR(CUTBIT_MWEBV)  = 
     &        SNLC_MWEBV               ! added May 2012

         SNLC_CUTVAR(CUTBIT_NSEASON_ACTIVE)  = 
     &        float(NSEASON_ACTIVE)

         SNLC_CUTVAR(CUTBIT_REQEP)  = 
     &        float( ISNLC_CUTFLAG_REQEP )   ! added Sep 17 2017

         SNLC_CUTVAR(CUTBIT_PRIVATE)  = 
     &        float( ISNLC_CUTFLAG_PRIVATE )   ! added Nov 3 2014

         SNLC_CUTVAR(CUTBIT_USRCUTS)  = 
     &        float( ISNLC_CUTFLAG_USRCUTS)    ! added Aug 2015

         SNLC_CUTVAR(CUTBIT_SIMVAR)  = 
     &        float( ISNLC_CUTFLAG_SIMVAR )    ! added Dec 2018

c ---------------------------------------
c set TREST-related variables.
c Warning: this code must go here after evaluating
c cutmask from all other cuts.

c first build TLIST array for epochs that pass MJDSELECT()
       NTLIST = 0
       DO 444 imjd = 1, NEWMJD
         if ( .NOT. MJDSELECT(imjd,0)  ) GOTO 444
         EPMIN     = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd)
         EPMAX     = ISNLC_EPOCH_RANGE_NEWMJD(2,imjd) 
         DO EP     = EPMIN, EPMAX
           NTLIST  = NTLIST + 1
           TLIST(NTLIST) = SNLC_Trest(EP)  
           FLIST(NTLIST) = ISNLC_IFILT_OBS(EP)
         ENDDO
444    CONTINUE

       CALL GET_TRESTVAR(NTLIST, TLIST, FLIST     ! (I)
     &       ,CUTWIN_TREST                        ! (I)
     &       ,CUTWIN_TRESTMIN, CUTWIN_TRESTMAX    ! (I)
     &       ,CUTWIN_TREST2                       ! (I)
     &       ,NFILT, TMIN, TMAX                   ! (O)
     &       ,NFTMIN, NFTMAX, NFT2                ! (O)
     &       ,TGAPMAX, T0GAPMAX )                 ! (O) 

       SNLC_TGAPMAX  = TGAPMAX
       SNLC_T0GAPMAX = T0GAPMAX

       SNLC_Trestmin = Tmin
       SNLC_Trestmax = Tmax
       SNLC_TrestRange = Tmax - Tmin    ! Dec 2017

       SNLC_Tobsmin = Tmin * ZZ
       SNLC_Tobsmax = Tmax * ZZ

       ISNLC_NFILT_TRESTMIN  = NFTMIN
       ISNLC_NFILT_TRESTMAX  = NFTMAX
       ISNLC_NFILT_TREST2    = NFT2

c ----------------------------------------------------

       imjd  = 1
       EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,imjd)

       SNLC_CUTVAR(CUTBIT_TRESTMIN)  = 
     &       SNLC_TRESTMIN
       SNLC_CUTVAR(CUTBIT_TRESTMAX)  = 
     &       SNLC_TRESTMAX
       SNLC_CUTVAR(CUTBIT_TRESTRANGE)  = 
     &       SNLC_TRESTRANGE

       SNLC_CUTVAR(CUTBIT_TobsMIN)  = 
     &       SNLC_TobsMIN
       SNLC_CUTVAR(CUTBIT_TobsMax)  = 
     &       SNLC_TobsMax

       SNLC_CUTVAR(CUTBIT_TGAPMAX)  = 
     &       SNLC_TGAPMAX
       SNLC_CUTVAR(CUTBIT_T0GAPMAX)  = 
     &       SNLC_T0GAPMAX

       SNLC_CUTVAR(CUTBIT_NFILT_SNRMAX)  = 
     &       float ( ISNLC_NFILT_SNRMAX )

       SNLC_CUTVAR(CUTBIT_NFILT_SNRMAX2)  = 
     &       float ( ISNLC_NFILT_SNRMAX2 )

       SNLC_CUTVAR(CUTBIT_NFILT_TRESTMIN)  = 
     &       float ( ISNLC_NFILT_TRESTMIN )

       SNLC_CUTVAR(CUTBIT_NFILT_TRESTMAX)  = 
     &       float ( ISNLC_NFILT_TRESTMAX )

       SNLC_CUTVAR(CUTBIT_NFILT_TREST2)  = 
     &       float ( ISNLC_NFILT_TREST2 )

c always make sure TREST2 cut passes since the only cut of
c interest in in NFILT_TREST2.
       SNLC_CUTVAR(CUTBIT_TREST2)  = CUTWIN_TREST2(1) + 0.1


c be careful with the SNRMAX indices.
       DO i         = 1, NFILT_SNRMAX  ! sparse index for SNRMAX cut
          ifilt_obs = IFILT_SNRMAX(i)  ! absolute filtetr index
          ifilt     = IFILTDEF_INVMAP_SURVEY(ifilt_obs)   ! sparse filt index
          icut      = CUTBIT_OFFSET_SNRMAX + i
          SNLC_CUTVAR(icut) = SNLC_SNRMAX_FILT(ifilt)
       ENDDO

c be careful with the HOST_SBFLUX indices.
       DO i         = 1, NFILT_HOST_SBFLUX  ! sparse index for SNRMAX cut
          ifilt_obs = IFILT_HOST_SBFLUX(i)  ! absolute filtetr index
          ifilt     = IFILTDEF_INVMAP_SURVEY(ifilt_obs)   ! sparse filt index
          icut      = CUTBIT_OFFSET_SBFLUX + i
          SNLC_CUTVAR(icut) = 
     &         SNHOST_SBFLUXCAL(ifilt)
       ENDDO

c -----------------------------------------------------
c After epochs, evaluate SN cut-mask 
c  (epoch-independent => use 1st epoch of SNLC_CUTVAR)
c This part comes AFTER epochmask so that we can cut
c on NEWMJD_CUTS

         CUTMASK8_TMP = 0

      DO 300 icut  = 1, CUTBIT_MJD_MARKER

          LTEST = BTEST (CUTMASK8_SN_ALL , icut-1 )
          if ( .NOT. LTEST ) GOTO 300

          tmp = snlc_cutvar(icut)
          LCUT = tmp .GE. cutwin_var(1,icut) .and.
     &           tmp .LE. cutwin_var(2,icut)

c special check for CID cut. This cut is probably redundant
c with the cut in PARSE_CID.

          if ( icut .EQ. CUTBIT_CID ) then
            LCUT = LCIDSELECT(SNLC_CID,SNLC_CCID,SNLC_IAUC)
          endif

c set cut-bit if cut is satisfied

          if ( LCUT ) then
             CUTMASK8_TMP = IBSET ( CUTMASK8_TMP, icut-1 )
             NACCEPT_CUT(icut) = NACCEPT_CUT(icut) + 1
          endif

300   CONTINUE   ! end ICUT loop

      CUTMASK8_SN = CUTMASK8_TMP

c set SN cut-logical

      IF ( CUTMASK8_SN .EQ. CUTMASK8_SN_ALL .and. PASS_USRCUTS ) THEN
         LSNCUTS       = .TRUE.
         CUTFLAG_SNANA = IBSET(CUTFLAG_SNANA,0)
         N_SNLC_CUTS   = N_SNLC_CUTS + 1
      ENDIF

c Jan 3, 2013
c increment Number of SN passing each incremental cut,
c and versus type. This info is dumped at the end of the
c job to trace where SN are lost.

      IF ( ISNLC_TYPE < 0 ) RETURN

      IF ( ISNLC_TYPE > MXTYPE ) THEN
        write(C1err,661) ISNLC_TYPE, MXTYPE
661     format('TYPE=',I5,' exceeds bound: MXTYPE=',I4 )
        C2err = 'Check CID = ' // SNLC_CCID
        CALL MADABORT("SET_CUTMASK", c1err, c2err ) 
      ENDIF

      CUTMASK8_TMP = 0
      DO icut = 1, NCUTBIT_SNLC
         CUTMASK8_TMP = IBSET(CUTMASK8_TMP,icut-1)
         OVP8_ALL     = IAND(CUTMASK8_TMP,CUTMASK8_SN_ALL)
         OVP8_SN      = IAND(CUTMASK8_SN,OVP8_ALL)
         IF ( OVP8_SN .EQ. OVP8_ALL ) THEN
            NPASSCUT_INCREMENT(ISNLC_TYPE,ICUT) =
     &      NPASSCUT_INCREMENT(ISNLC_TYPE,ICUT) + 1

c increment all types with ITYPE=-1 (Aug 2013)
            NPASSCUT_INCREMENT(-1,ICUT) =
     &      NPASSCUT_INCREMENT(-1,ICUT) + 1
         ENDIF
      ENDDO

      RETURN
      END  ! end of SET_CUTMASK

C ==============================================
+DECK,LCIDSELECT.
      LOGICAL FUNCTION LCIDSELECT(CID,CCID,IAUC)
c
c Created Dec 4, 2012 by R.Kessler
c Returns TRUE if current CID/CCID is accepted by
c any of 
c  CUTWIN_CID     (integer window of CID to accept)
c  SNCID_LIST     (integer list of CID to accept)
c  SNCCID_LIST    (char list of CCID to accept)
c
c and is NOT rejected by
c  SNCID_IGNORE   (integer list of CID to ignore)
c  SNCCID_IGNORE  (char list of CCID to ignore)
c
c This function replaces much of the obsolete CIDMASK(CID) array
c to avoid declaring such a large array.
c
c Nov 12, 2013: process SNCID_LIST_ALL instead of SNCID_LIST to include
c               CIDs from user text file SNCID_LIST_FILE.
c
c Dec 2 2015: new input arg IAUC to check for user-list option
c             Change input CCID -> IAUC if there is IAUC name match.
c
C ---------------------------

      IMPLICIT NONE

c input function args
      INTEGER CID
      CHARACTER CCID*(*), IAUC*(*)

+CDE,SNPAR. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,INTERPCM.
cc +CDE,SNLCCOM.
   
      INTEGER i, LEN, LENCCID
      REAL XCID     
      CHARACTER CCIDTMP*(MXCHAR_CCID)

      LOGICAL  STRINGMATCH   ! function
c ------------------ BEGIN ---------------

      LCIDSELECT = .FALSE.
      LENCCID = INDEX(CCID//' ' , ' ') - 1

c ----------------------------
c first check IGNORE Lists

      i = 1
      DO 30 WHILE ( SNCID_IGNORE(i) .GE. 1 ) 
        if ( CID .EQ. SNCID_IGNORE(i) ) GOTO 800
        i = i + 1
30    CONTINUE

      DO 40 i = 1, NCCID_IGNORE
        LEN   = INDEX(SNCCID_IGNORE(i),' ') - 1
        IF ( LEN .NE. LENCCID ) GOTO 40
        if ( CCID(1:LEN) .EQ.SNCCID_IGNORE_ALL(i)(1:LEN)) GOTO 800
40    CONTINUE

c -----------------------------
c Check integer window

      XCID = FLOAT(CID)
      IF ( XCID .GE. CUTWIN_CID(1) .and. 
     &     XCID .LE. CUTWIN_CID(2) ) then
        LCIDSELECT = .TRUE.
        GOTO 800
      ENDIF

c check user lists (integer and character)
c of individual CIDs to process

      i = 1
      DO 130 WHILE ( SNCID_LIST(i) .GE. 1 ) 
         if ( CID .EQ. SNCID_LIST(i) ) then
            LCIDSELECT = .TRUE.
            GOTO 800
         endif
         i = i + 1
130   CONTINUE


      DO 140 i = 1, NCCID_LIST
        CCIDTMP = SNCCID_LIST_ALL(i)
        IF ( STRINGMATCH(CCIDTMP,CCID) ) THEN
          LCIDSELECT = .TRUE.
          GOTO 800
        ENDIF

c Dec 2015: also check match with IAUC name
        IF ( STRINGMATCH(CCIDTMP,IAUC) ) THEN
          CCID       =  IAUC  ! so that IAUC is written to output
          LCIDSELECT = .TRUE.
          GOTO 800
        ENDIF

140   CONTINUE


c finally, check list of CIDs on the MJD-interpolation list;
c see &SNLCINP namelist input SNMJD_LIST_FILE 

      DO 240 i = 1, N_INTERP_MJDLIST
        CCIDTMP = INTERP_CCIDLIST(i)
        IF ( STRINGMATCH(CCIDTMP,CCID) ) THEN
           LCIDSELECT = .TRUE.
           GOTO 800
        ENDIF

c Dec 2015: also check match with IAUC name
        IF ( STRINGMATCH(CCIDTMP,IAUC) ) THEN
           CCID       = IAUC  ! so that IAUC is written to output
           LCIDSELECT = .TRUE.
           GOTO 800
        ENDIF

240   CONTINUE


800   CONTINUE

      RETURN
      END

C ====================================
+DECK,STRINGMATCH.
      LOGICAL FUNCTION STRINGMATCH(STR1,STR2)

C Created Dec 2015
C Return True of STR1=STR2

      IMPLICIT NONE
      CHARACTER STR1*(*), STR2*(*)
      INTEGER   LEN1, LEN2

C ------------------ BEGIN -------------

      STRINGMATCH = .FALSE.
      LEN1 = INDEX(STR1,' ') -1
      LEN2 = INDEX(STR2,' ') -1
      IF ( LEN1 .NE. LEN2 ) RETURN

      IF ( STR1(1:LEN1) .EQ. STR2(1:LEN2) ) THEN
        STRINGMATCH = .TRUE.
      ENDIF
      
      RETURN
      END

C ======================
+DECK,STEPFUN8.
      DOUBLE PRECISION FUNCTION SMOOTH_STEPFUN8(SEP,SEPMAX)
c
c Created Sep 8, 2009 by R.Kessler
c 
c Define smooth function that goes from 0 to 1 between
c -SEPMAX and SEPMAX, and returns 0.5 at SEP=0.
c Return value of function at SEP.
c Function is atan.
c --------------------------
+CDE,SNPAR.
      REAL*8 SEP, SEPMAX  ! (I)
      REAL*8 TAU, F
c ----------- BEGIN ----------

      IF ( SEP .GT. SEPMAX ) THEN
         SMOOTH_STEPFUN8 = 1.0
         RETURN
      ENDIF
      IF ( SEP .LT. -SEPMAX ) THEN
         SMOOTH_STEPFUN8 = 0.0
         RETURN
      ENDIF

      TAU  = .1 * SEPMAX
      F    = 0.5 * (1. + ATAN(SEP/TAU)/ATAN(SEPMAX/TAU) )
      SMOOTH_STEPFUN8 = F

      RETURN
      END


C =======================================
+DECK,GET_HOSTXTINCT8.
      DOUBLE PRECISION FUNCTION GET_HOSTXTINCT8 ( AV, RV, Lambda )
      IMPLICIT NONE

c input args

      REAL*8
     &   AV      ! (I) extinction at  5495 A
     &  ,RV      ! (I) assumed A(V)/E(B-V) (e.g., = 3.1 in the LMC)
     &  ,Lambda  ! (I) wavelen, A

c local var

      REAL*8 x, y, a, b, fa, fb, dx, dx2, dx3
      REAL*8 y2, y3, y4, y5, y6, y7

C --------------- BEGIN --------------
      
      x = 10000./lambda    ! inverse wavelength in microns
      y = x - 1.82;

      if (x .GE. 0.3 .and. x .LT. 1.1) then   !  IR

         a =  0.574*(x**1.61)
         b = -0.527*(x**1.61)

      else if (x .GE. 1.1 .and. x .LT. 3.3) then    ! Optical/NIR

         y2 = y**2
         y3 = y**3
         y4 = y**4
         y5 = y**5
         y6 = y**6
         y7 = y**7

         a = 1. + 0.17699*y  - 0.50447*y2 - 0.02427*y3
     &          + 0.72085*y4 + 0.01979*y5 - 0.77530*y6
     &          + 0.32999*y7

         b = 1.41338*y + 2.28305*y2 + 1.07233*y3 - 5.38434*y4
     &                 - 0.62251*y5 + 5.30260*y6 - 2.09002*y7

      else if ( x .GE. 3.3 .and. x .LT. 8.0) then    ! UV

         if (x .GT. 5.9) then
          dx  = x - 5.9
          dx2 = dx  * dx
          dx3 = dx2 * dx
          fa = -0.04473*dx2 - 0.009779*dx3
          fb =  0.21300*dx2 + 0.120700*dx3
        else 
          fa = 0.0
          fb = 0.0
        endif

        a =  1.752 - 0.316*x - 0.104/((x-4.67)**2 + 0.341) + fa
        b = -3.090 + 1.825*x + 1.206/((x-4.62)**2 + 0.263) + fb

      else if (x .GE. 8.0 .and.  x .LE. 10.0 ) then  ! Far-UV

         dx  = x - 8.0
         dx2 = dx * dx
         dx3 = dx2 * dx

         a = -1.073 - 0.628*dx + 0.137*dx2 - 0.070*dx3
         b = 13.670 + 4.257*dx - 0.420*dx2 + 0.374*dx3

      else
          a = 0.0
          b = 0.0
      ENDIF

      GET_HOSTXTINCT8 = av*(a + b/RV)

      RETURN
      END

C ====================================================
+DECK,DFINT.
C
C Revision 1.1.1.1  1996/02/15 17:48:36  mclareni
C Kernlib
C
C
C#include "kernnum/pilot.h"

          DOUBLE PRECISION FUNCTION DFINT(NARG,ARG,NENT,ENT,TABLE)
C
          IMPLICIT NONE
C
C   INTERPOLATION ROUTINE. AUTHOR C. LETERTRE.
C   MODIFIED BY B. SCHORR, 1.07.1982.
C
C   Modified from CERNLIB funtion FINT to double precision
C by David Cinabro Feb 2006.  I did not make stylistic changes,
C even though those would seem to be called for.
C
c Oct 30, 2006 RSK : change arg dimensions from 9 to 90
c
c May 08, 2012: RSK replace hard-wired '90' with NARG in arg declarations
c Jul 10, 2012: RSK replace NARG with 500 (fix bug when NARG=1)
c
c Oct 26 2015: replace XXX(500) with  XXX(NARG) to avoid compile warnings.
c Jan 07 2016: ENT(NARG) -> ENT(500)
c Jan 11 2019: use NARG as argument instead of 500

          INTEGER   NARG         
          INTEGER   NENT(NARG+100)
ccc          REAL*8    ARG(NARG), ENT(500), TABLE(500)
          REAL*8    ARG(NARG+100), ENT(NARG+100), TABLE(NARG+100)

          INTEGER   INDEX(32)
          REAL*8    WEIGHT(32)
          LOGICAL   MFLAG
C
          INTEGER I,K,N
          INTEGER LOCA,LOCB,LOCC
          INTEGER LMAX,LMIN
          INTEGER ISTEP,KNOTS,NDIM,ISHIFT
          INTEGER LGFILE
          REAL*8 X,H,ETA, DX
C
C----------------------------------------------
          DFINT  =  0.
          IF(NARG .LT. 1  .OR.  NARG .GT. 5)  GOTO 300
          LMAX      =  0
          ISTEP     =  1
          KNOTS     =  1
          INDEX(1)  =  1
          WEIGHT(1) =  1.
          DO 100    N  =  1, NARG
             X     =  ARG(N)
             NDIM  =  NENT(N)
             LOCA  =  LMAX
             LMIN  =  LMAX + 1
             LMAX  =  LMAX + NDIM
             IF(NDIM .GT. 2)  GOTO 10
             IF(NDIM .EQ. 1)  GOTO 100
             H  =  X - ENT(LMIN)
             IF(H .EQ. 0.)  GOTO 90
             ISHIFT  =  ISTEP
             IF(X-ENT(LMIN+1) .EQ. 0.)  GOTO 21
             ISHIFT  =  0
             ETA     =  H / (ENT(LMIN+1) - ENT(LMIN))
             GOTO 30
  10         LOCB  =  LMAX + 1
  11         LOCC  =  (LOCA+LOCB) / 2
C
C Wow.  A computed goto.  Amazing.
C
             DX = X-ENT(LOCC)
             IF( DX .LT. 0.0  ) GOTO 12
             IF( DX .EQ. 0.0  ) GOTO 20
             IF( DX .GT. 0.0  ) GOTO 13
ccc             IF(X-ENT(LOCC))  12, 20, 13   ! obsolete


  12         LOCB  =  LOCC
             GOTO 14
  13         LOCA  =  LOCC
  14         IF(LOCB-LOCA .GT. 1)  GOTO 11
             LOCA    =  MIN0( MAX0(LOCA,LMIN), LMAX-1 )
             ISHIFT  =  (LOCA - LMIN) * ISTEP
             ETA     =  (X - ENT(LOCA)) / (ENT(LOCA+1) - ENT(LOCA))
             GOTO 30
  20         ISHIFT  =  (LOCC - LMIN) * ISTEP
  21         DO 22  K  =  1, KNOTS
                INDEX(K)  =  INDEX(K) + ISHIFT
  22            CONTINUE
             GOTO 90
  30         DO 31  K  =  1, KNOTS
                INDEX(K)         =  INDEX(K) + ISHIFT
                INDEX(K+KNOTS)   =  INDEX(K) + ISTEP
                WEIGHT(K+KNOTS)  =  WEIGHT(K) * ETA
                WEIGHT(K)        =  WEIGHT(K) - WEIGHT(K+KNOTS)
  31            CONTINUE
             KNOTS  =  2*KNOTS
  90         ISTEP  =  ISTEP * NDIM
 100         CONTINUE
          DO 200    K  =  1, KNOTS
             I  =  INDEX(K)
             DFINT  =  DFINT + WEIGHT(K) * TABLE(I)
 200         CONTINUE
          RETURN
 300      CONTINUE

c+SELF,IF=xxCERNLIB.
c          CALL KERMTR('E104.1',LGFILE,MFLAG,RFLAG)
c+SELF.
          IF(MFLAG) THEN
             IF(LGFILE .EQ. 0) THEN
                WRITE(*,1000) NARG
             ELSE
                WRITE(LGFILE,1000) NARG
             ENDIF
          ENDIF

c+SELF,IF=xxCERNLIB.
c          IF(.NOT. RFLAG) CALL ABEND
c+SELF.
          RETURN
1000      FORMAT( 7X,'FUNCTION DFINT ... NARG = ',I6,
     +              ' NOT WITHIN RANGE')
          END


C =========================
+DECK,POLINT8.
C
C snana.car,v 1.595 2012/05/04 01:13:13 
C
C
C Revision 1.1.1.1  1996/02/15 17:48:35  mclareni
C Kernlib
C
C Sep 2011: change to double precision
C
C #include "kernnum/pilot.h"
      SUBROUTINE POLINT8(F,ARG,MMMM,Z,SUM)
C         NEW VERSION OF E100 POLINT WRITTEN BY F.JAMES     DEC. 1976
C         LIMITED TO ORDER 19  (20 POINTS)  BY DIMENSION OF COF
C         BUT SUCH INTERPOLATION IS ALREADY UNSTABLE FOR ORDER 10

      IMPLICIT NONE

C subroutine args
      INTEGER MMMM
      DOUBLE PRECISION F(MMMM), ARG(MMMM), Z, SUM

c local var
      DOUBLE PRECISION COF(20)
      INTEGER M, MM, I, J, JNDEX, INDEX, LGFILE

      LOGICAL MFLAG
C ---------- BEGIN ----------
      IF(MMMM .LT. 2) GOTO 1900
      MM = MIN0(MMMM, 20)
      M = MM - 1
      DO 1780 I= 1, MM
 1780    COF(I) = F(I)
      DO 1800 I= 1, M
      DO 1790 J= I, M
         JNDEX = MM - J
         INDEX = JNDEX + I
         COF(INDEX) = (COF(INDEX)-COF(INDEX-1))/(ARG(INDEX)-ARG(JNDEX))
 1790 CONTINUE
 1800 CONTINUE
      SUM = COF(MM)
      DO 1810 I= 1, M
         INDEX = MM - I
         SUM = (Z-ARG(INDEX))*SUM + COF(INDEX)
 1810 CONTINUE
      RETURN
 1900 CONTINUE

c+SELF,IF=xxCERNLIB.
c      CALL KERMTR('E100.1', LGFILE, MFLAG, RFLAG)
c+SELF.
      IF(MFLAG) THEN
         IF(LGFILE .EQ. 0) THEN
            WRITE(*,2000) MMMM
         ELSE
            WRITE(LGFILE,2000) MMMM
         ENDIF
      ENDIF

c+SELF,IF=xxCERNLIB.
c      IF(.NOT. RFLAG) CALL ABEND
c+SELF.

      RETURN
 2000 FORMAT( 7X, 'SUBROUTINE POLINT8 ... K =', I6,
     +        ' IS LESS THAN 2')
      END



C ======================================
+DECK,FIRSTBIN_INTERP.
      INTEGER FUNCTION FIRSTBIN_INTERP (
     &   VALUE      ! (I) value to find bin for
     &  ,RANGE      ! (I) allowed range for VALUE
     &  ,BINSIZE    ! (I) binsize for RANGE
     &    )

c
c Return first bin to use for interpoliation.
c Asumes interp is done with 3 bins, where 2nd
c bin contains VALUE.
c
c ------------------------------

      IMPLICIT NONE
      REAL  VALUE, RANGE(2), BINSIZE  ! (I)

c local args    

      INTEGER ibin_cen, ibin_start, NBIN
      REAL dif

C ----------------- BEGIN ------------

      FIRSTBIN_INTERP  = -9

      dif      = value - range(1)
      ibin_cen = int ( (dif / binsize) + 0.5 ) + 1

      dif      = range(2) - range(1) + binsize/10000. 
      NBIN     = int( dif / binsize ) + 1 

c find starting bin for grid interpolation

      if ( ibin_cen .LE. 1 ) then
          ibin_start = 1
      else if ( ibin_cen .GE. NBIN ) then
          ibin_start = NBIN - 2
      else
          ibin_start = ibin_cen - 1   ! nominal case
      endif

      FIRSTBIN_INTERP  = ibin_start

      RETURN
      END

C =========================================
+DECK,LCUTEPOCH.
      LOGICAL FUNCTION LCUTEPOCH(Z, PKMJD, MJD, IDTEL, IDFIELD)

c ------------------------------------------- 
c Created Jun 18, 2011
c Return TRUE if this epoch passes epoch-cuts.
c The input are the epoch values rather than the SN ID.
c
c May 2012: ZZ=1 if z<0 to avoid ZZ=0
c May 29 2019: do NOT apply Trest cut if OPT_SETPKMJD > 0
c
c ------------------------------------------

      IMPLICIT NONE

      REAL 
     &   Z, PKMJD      ! (I) redshift and time of peak brightness
     &  ,MJD           ! (I) MJD of epoch 

      INTEGER IDTEL    ! (I) telescope ID
      INTEGER IDFIELD  ! (I) FIELD ID

c local variables

+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,SNLCINP.

      REAL TREST, ZZ
      LOGICAL LTMP, LTREST, LMJD, LXMJD

C --------------- BEGIN -----------

      LCUTEPOCH = .FALSE.

      IF ( Z .GT. 0.0 ) then
         ZZ    = 1.0 + Z
      ELSE
         ZZ    = 1.0
      ENDIF

      LTMP = ( PKMJD < 40000. .or. OPT_SETPKMJD > 0  )
      IF ( RESTORE_DES3YR ) LTMP = ( PKMJD < 40000. )

c evaluate epoch cut in rest-frame
      IF ( LTMP ) THEN
c       PKMJD not yet determined, so no TREST cut
         LTrest = .TRUE.
      ELSE
         Trest = (MJD - PKMJD) / ZZ
         LTrest = ( Trest .GE. cutwin_Trest(1) .and. 
     &              TRest .LE. cutwin_Trest(2) )
      ENDIF

      LXMJD = ( MJD .GE. CUTWIN_MJD_EXCLUDE(1) .and.
     &          MJD .LE. CUTWIN_MJD_EXCLUDE(2) )

      LMJD = ( MJD .GE. cutwin_MJD(1) .and.
     &         MJD .LE. cutwin_MJD(2) )

      LTMP = LTREST .and. LMJD .and. (.not. LXMJD)
      IF ( .NOT. LTMP ) RETURN

c check selected telescope
      LTMP = DOALL_SNTEL   .or. IDTEL .GT. 0
      IF ( .NOT. LTMP ) RETURN

c check selected field.
      LTMP = DOALL_SNFIELD .or. IDFIELD .GT. 0          
      IF ( .NOT. LTMP ) RETURN

      LCUTEPOCH = .TRUE.

      RETURN
      END

C ==================================================
+DECK,LCUTVAR.
      LOGICAL FUNCTION LCUTVAR ( var, icut, VBOSE )
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,SNLCINP.

      REAL    VAR   ! (I) variable to  test cutwin
      INTEGER ICUT  ! (I) points to cutwin
      LOGICAL VBOSE ! (I) T=> print PASS or FAIL for each cut

c local var

      INTEGER ITMP
      CHARACTER CTMP*6

C -------------- BEGIN --------------

      LCUTVAR = var .GE. cutwin_var(1,icut) .and.
     &          var .LE. cutwin_var(2,icut)

      IF ( VBOSE ) THEN
          if ( LCUTVAR ) then
             CTMP = 'PASSES'
          else
             CTMP = 'FAILED'
          endif

          ITMP = INDEX(cutvar_name(icut),':') - 1
          ITMP = MIN(ITMP,14)
          write(6,20) cutvar_name(icut)(1:ITMP), var, CTMP
20        format(T10,A18,' = ', G10.3, 1x, A, ' CUT.' )
      ENDIF
 
      RETURN
      END

C ====================================
+DECK,DMPTRACE.
      SUBROUTINE DMPTRACE ( banner )
      IMPLICIT NONE
      character banner*(*)
      print*,'  XXXXX ', BANNER
      CALL FLUSH(6)
      RETURN
      END


C ========================================
+DECK,IPLOTSPLIT.
      INTEGER FUNCTION IPLOT_JOBSPLIT(NPLOT)
c
c Created Sep 28, 2012 by R.Kessler
c
c For single job, returns IPLOT = NPLOT is the 
c incremental (sparse) index. For non-trivial JOBSPLIT input,
c      IPLOT = (NPLOT-1) * NSPLIT_TOT + ISPLIT 
c so that the IPLOT are unique among each split job.
c Needed so that snana#fitres plot-macro works on merged
c histo files from split_and_fit.pl script.
c
c -----------------------------

      IMPLICIT NONE

      INTEGER NPLOT  ! (I) sequential plot number for this job

c local variables.

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER NJOBTOT, IJOB, IPLOT
      
C -------------- BEGIN ---------------     

c set default for non-split jobs.
      IPLOT = NPLOT

c check for internal split (mainly for FITS format)
      NJOBTOT = JOBSPLIT(2) ! total number of split jobs
      IJOB    = JOBSPLIT(1) ! do IJOB of NJOBTOT
      IF ( NJOBTOT .GT. 1 ) THEN
        IPLOT = (NPLOT-1) * NJOBTOT + IJOB        
      ENDIF

c check for text-format where SPLIT has been done externally
      NJOBTOT = JOBSPLIT_EXTERNAL(2) ! total number of split jobs
      IJOB    = JOBSPLIT_EXTERNAL(1) ! do IJOB of NJOBTOT
      IF ( NJOBTOT .GT. 1 ) THEN
        IPLOT = (NPLOT-1) * NJOBTOT + IJOB        
      ENDIF

c load output
      IPLOT_JOBSPLIT = IPLOT

      RETURN
      END

C =============================================
+DECK,GTSIMTYPE.
      SUBROUTINE GET_SIMNAME_TYPE(name)
      IMPLICIT NONE
      CHARACTER NAME*(*)
      INTEGER LL
+CDE,SNDATCOM.
+CDE,SNLCINP.
      NAME = ''
      IF ( .NOT. LSIM_SNANA ) RETURN
      LL = INDEX(SIMNAME_TYPE,' ') - 1
      NAME = SIMNAME_TYPE(1:LL) // char(0)  ! Ia, Ib, IIN, etc ...
      RETURN
      END


C =============================
+DECK,DOPLOT_SNLC.
      LOGICAL FUNCTION DOPLOT_SNLC()

C Created Aug 30 2013
C Returns T to make light curve plot for this SN.
C 
C ----------

      IMPLICIT NONE
+CDE,SNDATCOM. 
+CDE,SNLCINP.

      INTEGER i, LENTMP
      LOGICAL DOPLOT

C ------------ BEGIN -------------

      DOPLOT = .FALSE.

      if ( OPT_TABLE(ITABLE_SNLCPAK) == 0 ) goto 888  ! Sep 8 2014

      if ( N_SNLC_PLOT < MXLC_PLOT ) THEN
         DOPLOT = .TRUE.
         GOTO 888
      endif

c check list of CCIDs to plot

      DO 100 i = 1, NCCID_PLOT
        LENTMP = INDEX( SNCCID_PLOT(i)//' ', ' ') - 1

        IF ( LENTMP .NE. ISNLC_LENCCID ) GOTO 100

        if ( SNCCID_PLOT(i) .EQ. SNLC_CCID ) then
          DOPLOT = .TRUE.
          GOTO 888
        endif

100   CONTINUE

888   CONTINUE
      DOPLOT_SNLC = DOPLOT

      RETURN
      END

C -----------------------------------------
+DECK,GETNLCPLOT,IF=SNANA.
      INTEGER FUNCTION SNANA_GET_NLCPLOT()

C Created May 17 2014 by R.Kessler
C Return NFIT_PER_SN = 0 or 1 based on SNLCINP options.
C For snana.exe job only.
c Sep 7 2014: use OPT_TABLE.

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
      INTEGER NLCPLOT, OPT
c --------------- BEGIN ------------

      NLCPLOT = 0  ! default -> no LC plotted
      OPT = OPT_TABLE(ITABLE_SNLCPAK)
      if ( OPT > 0 ) NLCPLOT = 1

c return function value
      SNANA_GET_NLCPLOT = NLCPLOT

      RETURN
      END
+SELF.

C ==============================
+DECK,SNLCPLOT,IF=SNANA.
      SUBROUTINE SNLCPLOT()

c Created Feb 2013 by R.Kessler
c Called only by snana.exe to 
c  * create sub dir
c  * pack light curves and PKMJD fit-curve
c  * cdtopdir
c
c Call wrappers in sntools_output.c to that there
c no native calls to CERNLIB or ROOT.
c
c
c Apr 11 2019:  MXEP_SNLCPAK -> 4*MXEPOCH (was 10*MXEPOCH)
c Jan 16 2020:  pass sim fluxes (see VSIMFLUX)
c -----------------------------------------------------------
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PKMJDCOM.

      CHARACTER  CCID*(MXCHAR_CCID), TEXT_forC*80

      LOGICAL  OVMODEL_ANYFUN, LTMP, DOPLOT_FILT(MXFILT_OBS)
      INTEGER 
     &   LENCCID, LENTEXT, NEWMJD, EPMIN, EPMAX, EP
     &  ,IFILT_OBS, IFILT, ipar, NBT, i, NFILT

      REAL*8  
     &    Z, Z1, Tobs, Trest, MJD
     &   ,FLUX_DATA,  FLUXERR_DATA, FLUX_MODEL
     &   ,SQDIF, SQERR, CHI2, TMIN, TMAX, DT
     &   ,XVAL8(NPAR_ANYLC)
     
c SNLCPAK arrays

      INTEGER MXEP_SNLCPAK
      PARAMETER ( MXEP_SNLCPAK = 4*MXEPOCH )
      
      REAL*8
     &   VMJD(MXEP_SNLCPAK)
     &  ,VTOBS(MXEP_SNLCPAK)
     &  ,VFLUX(MXEP_SNLCPAK)
     &  ,VFLUX_ERR(MXEP_SNLCPAK)
     &  ,VSIMFLUX(MXEP_SNLCPAK)  ! Jan 2020
     &  ,VCHI2(MXEP_SNLCPAK)
     &  ,VREJECT(MXEP_SNLCPAK)
     &  ,VERRCALC(MXEP_SNLCPAK)
     &  ,VDUMERR(MXEP_SNLCPAK)  ! all zeros
c
     &  ,VBAND_NDOF(MXFILT_OBS)
     &  ,VBAND_CHI2(MXFILT_OBS)
     &  ,VBAND_PKFLUX(MXFILT_OBS)
     &  ,VBAND_PKFLUX_ERR(MXFILT_OBS)
     &  ,VBAND_PKMJD(MXFILT_OBS)
     &  ,VBAND_PKMJD_ERR(MXFILT_OBS)

      INTEGER
     &   NOBS
     &  ,VFILTOBS(MXEP_SNLCPAK)

c functions
      EXTERNAL  ANYLCFUN
      REAL*8    ANYLCFUN

      LOGICAL DOPLOT_SNLC

C ---------------- BEGIN --------------

c check if we should make the plot
      IF ( .NOT. DOPLOT_SNLC() ) RETURN

      CALL SNLCPAK_NFIT(1)      ! May 11 2014

      LENCCID = ISNLC_LENCCID
      CCID = SNLC_CCID(1:LENCCID) // char(0)

      OVMODEL_ANYFUN = (SNLC_SNANAFIT_PEAKMJD > 10.0) !show best peak-MJD fit
      NFILT   = NFILTDEF_SURVEY

      write(6,10) SNLC_CCID(1:LENCCID)
 10   format(T8,'SNLCPLOT: pack CID=',A,' for plotting.')
      call flush(6)

c create subdir
      CALL MAKEDIR_OUTPUT(CCID, SNLC_CID, LENCCID)

c prepare text string(s) to display on plot
      LENTEXT = LEN(TEXT_forC)

      write(TEXT_forC,20) ISNLC_TYPE, SNLC_REDSHIFT, char(0)
 20   format('TYPE = ', I3, 3x,'z=',F5.3, 3x, A )
      CALL SNLCPAK_DISPLAYTEXT(CCID, TEXT_forC, LENCCID, LENTEXT )
   
      IF ( OVMODEL_ANYFUN ) THEN
         TEXT_forC = 'Fit  ANYFUN  to estimate peak MJD' // char(0)
         CALL SNLCPAK_DISPLAYTEXT(CCID, TEXT_forC, LENCCID, LENTEXT )
      ENDIF

c flag which filter(s) to plot
      DO IFILT = 1, NFILT
        VBAND_NDOF(ifilt)   = 0.0           ! init this array
        VBAND_CHI2(ifilt)   = 0.0           ! init this array
        VBAND_PKFLUX(ifilt) = 0.0 
        VBAND_PKMJD(ifilt)  = 0.0

        DOPLOT_FILT(IFILT) = .TRUE.  ! default is all 
        IFILT_OBS = IFILTDEF_MAP_SURVEY(ifilt)
        LTMP = ( PKMJD_FIT(ifilt_obs) .GT. 100.0 )
        IF ( OVMODEL_ANYFUN .and. .NOT. LTMP ) then
          DOPLOT_FILT(IFILT) = .FALSE.
        ENDIF

c set default PKMJD
        VBAND_PKMJD(IFILT)     = SNLC_SEARCH_PEAKMJD
        VBAND_PKMJD_ERR(IFILT) = 0.0

      ENDDO

c -------------------------------
      Z    = SNLC_REDSHIFT
      Z1   = 1 + Z
c -----------------------------

      NOBS = 0
      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

        MJD   = SNLC8_MJD(EPMIN)
        Tobs  = MJD - SNLC_SEARCH_PEAKMJD
        Trest = Tobs / Z1

        DO 201 EP = EPMIN, EPMAX

          FLUX_DATA     = SNLC_FLUXCAL(ep)
          FLUXERR_DATA  = SNLC_FLUXCAL_ERRTOT(ep)
          if ( FLUXERR_DATA .LE. 0.0 ) GOTO 201

          IFILT_OBS = ISNLC_IFILT_OBS(ep)
          IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 

          IF ( .NOT. DOPLOT_FILT(IFILT) ) GOTO 201

          VBAND_NDOF(ifilt) = VBAND_NDOF(ifilt) + 1.0 ! note this is real*8
          NOBS = NOBS + 1

          IF ( NOBS .GT. MXEP_SNLCPAK ) THEN
            write(C1ERR,661) NOBS, MXEP_SNLCPAK
 661        format('NOBS=',I5,' exceeds bound of MXEP_SNLCMAX=',I5)
            c2err = 'Increase bound for data array.'
            CALL MADABORT('SNLCPLOT(SNANA)', C1ERR, C2ERR)
          ENDIF

          VMJD(NOBS)      = MJD
          VTOBS(NOBS)     = TOBS
          VFLUX(NOBS)     = SNLC_FLUXCAL(ep)
          VFLUX_ERR(NOBS) = SNLC_FLUXCAL_ERRTOT(ep)
          VERRCALC(NOBS)  = SNLC_FLUXCAL_ERRCALC(ep)
          VSIMFLUX(NOBS) = SIM_EPFLUXCAL(ep)   ! Jan 2020

          VFILTOBS(NOBS)  = IFILT_OBS
          VREJECT(NOBS)   = DBLE( 1 - ISNLC_SNRECON_USE(ep) )
          VDUMERR(NOBS)   = 0.0  ! dummy arguments

c fetch model value and VCHI2 (if we fit the "ANYLC" function)

          if ( OVMODEL_ANYFUN ) then
            do ipar = 1, NPAR_ANYLC
              XVAL8(ipar) = 
     &        SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar)
            enddo

            FLUX_MODEL  = ANYLCFUN(MJD,XVAL8)
            SQDIF       = (FLUX_DATA - FLUX_MODEL)**2
            SQERR       = FLUXERR_DATA**2
            CHI2        = SQDIF/SQERR
            VCHI2(NOBS) = CHI2
            VBAND_CHI2(IFILT) = VBAND_CHI2(IFILT) + CHI2

c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
            if ( ifilt_obs == 4 .and. MJD < 56600. ) then
               write(6,621) MJD, TOBS, FLUX_DATA, 
     &             FLUX_MODEL, FLUXERR_DATA
 621           format(' xxx MJD=',F9.3, '  TOBS=',F6.1, 
     &             '  FLUX(D,M)=',2G10.3, '  FLUX_ERR=', G8.3 )
            endif
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


          endif  ! end of OVMODEL

201     CONTINUE  ! EP
200   CONTINUE   ! NEWMJD

c ------------------------------------------
c store data fluxes
      CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VFLUX, VFLUX_ERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_FLUXDATA, LENCCID)

c store REJECT flags
      CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VREJECT, VDUMERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_REJECT, LENCCID)

c store data-FITFUN chi2 
      IF ( OVMODEL_ANYFUN ) THEN
        CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VCHI2, VDUMERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_CHI2, LENCCID)
      ENDIF

c check for sim fluxes (Jan 2020)
      IF ( LSIM_SNANA .or. LSIM_MAGOBS ) THEN
        CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, 
     &     VSIMFLUX, VFLUX_ERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_FLUXSIM, LENCCID)
      ENDIF

c ------------------------------------------
      IF ( .NOT. OVMODEL_ANYFUN ) GOTO 500
c ------------------------------------------

c plot smooth best-fit ANYFUN function in 2-day bins.

      TMIN = -40.0
      TMAX = 140.0
      NBT  = int(TMAX-TMIN) / DTOBS_MODEL_PLOT
      DT   = (TMAX - TMIN) / float(NBT)
      NOBS = 0

      DO 300 ifilt = 1, NFILT
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
 
         VBAND_PKFLUX(ifilt)     = DBLE( PKFLUX_FIT(ifilt_obs) )
         VBAND_PKFLUX_ERR(ifilt) = DBLE( PKFLUX_ERR(ifilt_obs) )

         IF ( .not. EXIST_FILT(ifilt) ) GOTO 300 
         
         DO 320 i = 1, NBT
            Tobs  = TMIN + dT * ( float(i) - 0.5 )
            MJD   = Tobs + SNLC_SEARCH_PEAKMJD
            do ipar = 1, NPAR_ANYLC
               XVAL8(ipar) = SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar)
            enddo
            
            NOBS = NOBS + 1
            
            IF ( NOBS .GT. MXEP_SNLCPAK ) THEN
               write(C1ERR,661) NOBS, MXEP_SNLCPAK
               c2err = 'Increase bound for best-fit (ANYFUN) array.'
               CALL MADABORT('SNLCPLOT(SNANA)', C1ERR, C2ERR)
            ENDIF

            FLUX_MODEL       = ANYLCFUN(MJD,XVAL8)          
            
c avoid plotting artifacts with very small numbers (Oct 29 2014)
            IF( FLUX_MODEL < 1.0E-20 ) FLUX_MODEL = 0.0

            VMJD(NOBS)       = MJD
            VTOBS(NOBS)      = TOBS
            VFLUX(NOBS)      = FLUX_MODEL
            VFLUX_ERR(NOBS)  = 0.0
            VFILTOBS(NOBS)   = IFILT_OBS
            
320     CONTINUE  ! epoch-bin

300   CONTINUE  ! ifilt


c -------------------------------------------------

c store best-fit ANYLCFUN

      CALL SNLCPAK_DATA(CCID, NOBS, VMJD, VTOBS, VFLUX, VFLUX_ERR, 
     &     VFILTOBS, SNLCPAK_EPFLAG_FITFUN, LENCCID)

c store filter-dependent quantities.
      VMJD(1)  = -9999.0 
      VTOBS(1) = -9999.0  ! dummy for unused TOBS arg

      CALL SNLCPAK_DATA(CCID, NFILT, VMJD, VTOBS, VBAND_NDOF, VDUMERR, 
     &     IFILTDEF_MAP_SURVEY, SNLCPAK_BANDFLAG_NDOF, LENCCID)

      CALL SNLCPAK_DATA(CCID, NFILT, VMJD,VTOBS, VBAND_CHI2, VDUMERR, 
     &     IFILTDEF_MAP_SURVEY, SNLCPAK_BANDFLAG_CHI2, LENCCID)

      CALL SNLCPAK_DATA(CCID, NFILT, VTOBS, VMJD,
     &   VBAND_PKFLUX, VBAND_PKFLUX_ERR, 
     &   IFILTDEF_MAP_SURVEY, SNLCPAK_BANDFLAG_PKFLUX, LENCCID)

c --------------------------------------------------
c fill output structure with above; here iy goes to a disk file.

 500  CONTINUE

      CALL SNLCPAK_DATA(CCID, NFILT, VMJD, VTOBS,
     &    VBAND_PKMJD,VBAND_PKMJD_ERR, 
     &    IFILTDEF_MAP_SURVEY, SNLCPAK_BANDFLAG_PKMJD, LENCCID)            

      CALL SNLCPAK_FILL(CCID, LENCCID)

c back to topdir
      CALL CDTOPDIR_OUTPUT()

c set global flag.
      MADE_LCPLOT = .TRUE.

      RETURN
      END            ! end of SNLCPLOT
+SELF.


C ==============================
+DECK,SPECPLOT.
      SUBROUTINE SPECPLOT()

c Apr 2019
c Prepare spectra table for plotting (analog of SNLCPLOT)
c Works only for TEXT output; not for HBOOK or ROOT
c
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SPECCOM.

      INTEGER LENCCID, LENTEXT, ispec
      CHARACTER  CCID_forC*(MXCHAR_CCID)
      LOGICAL DOPLOT_SNLC

C ----------------- BEGIN ---------------

c check if we should make the plot
      IF ( .NOT. DOPLOT_SNLC() ) RETURN

      LENCCID = ISNLC_LENCCID
      CCID_forC = SNLC_CCID(1:LENCCID) // char(0)

      write(6,10) SNLC_CCID(1:LENCCID)
 10   format(T8,'SPECPLOT: pack CID=',A,' for plotting.')
      call flush(6)

c load each spectrum into SPECPAK C-function util

      DO 100 ispec = 1, NSPECTRUM
         CALL SPECPAK_DATA(
     &         CCID_forC
     &       , ID_SPECTRUM(ispec)
     &       , MJD_SPECTRUM(ispec)
     &       , TOBS_SPECTRUM(ispec)    ! May 7 2019
     &       , TEXPOSE_SPECTRUM(ispec)
     &       , NLAMBIN_SPECTRUM(ispec)
     &       , LAMMIN_SPECTRUM(1,ispec)
     &       , LAMMAX_SPECTRUM(1,ispec)
     &       , FLAM_SPECTRUM(1,ispec)
     &       , FLAMERR_SPECTRUM(1,ispec)
     &       , LENCCID )
 100     CONTINUE

c write out spectrum to TEXT table (HBOOK,ROOT not enabled)
      CALL SPECPAK_FILL(CCID_forC, LENCCID)

      RETURN
      END


C ==============================================
+DECK,CHECK_DUPLMJD.
      SUBROUTINE CHECK_DUPLICATE_MJDBAND(iep)

c Created Jun 13, 2017
c print & count error if current MJD & BAND is the same
c as previous epoch.

      IMPLICIT NONE

      INTEGER IEP ! (I) epoch index

c local var
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      REAL*8 MJD, MJD_LAST
      INTEGER IFILTOBS, IFILTOBS_LAST, i
      CHARACTER CFILT*2

c ---------------- BEGIN --------------

cc      IF ( .NOT. ABORT_ON_DUPLMJD  ) RETURN
      IF ( IEP <= 1 ) RETURN

      MJD      = SNLC8_MJD(IEP)
      MJD_LAST = SNLC8_MJD(IEP-1)
      IFILTOBS = ISNLC_IFILT_OBS(IEP)
      IFILTOBS_LAST = ISNLC_IFILT_OBS(IEP-1) 
 
      IF ( MJD      .NE. MJD_LAST      ) RETURN
      IF ( IFILTOBS .NE. IFILTOBS_LAST ) RETURN

      N_DUPLICATE_MJD = N_DUPLICATE_MJD + 1

c check if this MJD was already flagged as duplicate
      DO i = 1, min(200,NSTORE_DUPLICATE_MJD)
        IF ( MJD .EQ. DUPLICATE_MJDLIST(i) ) RETURN
      ENDDO

      NSTORE_DUPLICATE_MJD = NSTORE_DUPLICATE_MJD + 1

      if ( NSTORE_DUPLICATE_MJD < 200 ) then
         DUPLICATE_MJDLIST(NSTORE_DUPLICATE_MJD) = MJD
         CFILT = filtdef_string(ifiltobs:ifiltobs)
         write(6,666) SNLC_CCID(1:ISNLC_LENCCID), MJD, CFILT,
     &        SNLC_FIELDLIST
666      format(/,T5,'*** DUPLICATE MJD WARNING *** CID=',A, 3x,
     &        'MJD=', F9.3, 3x, 'BAND=', A, 2x,'FIELD=',A6, /)
         CALL FLUSH(6)
      endif

      RETURN
      END     

C =======================
+PATCH,*SNTABLE.
C =======================

C call utilities to call table-interface C-functions


C ===========================================
+DECK,TABLE_SNANA.
      SUBROUTINE TABLE_SNANA(IDTABLE,IFLAG)
c
c Created Feb, 2013 by R.Kessler
c Driver for SNANA table in user-selected format(s).
c
c Jan 7 2014:  CALL TABLE_STRING_TERMINATION()
c Sep 6, 2014: replace hard-wired 'KEY' format with 
c              TEXTFORMAT_TABLE(ITABLE_SNANA)
c
c Mar 2, 2015:  call  INIT_TABLE_SNOBSVAR
c
c Apr 26 2017: check PRESCALE_TABLE
c ------------------------------
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,CTRLCOM.
+CDE,SNLCINP.

      INTEGER IDTABLE  ! (I) table ID
      INTEGER IFLAG    ! (I) see IFLAG_XXX params

c local var

      LOGICAL   DO_FILL, LPS
      REAL*8    PS
      INTEGER   LENNAME, LENFMT
      CHARACTER NAME*40, TEXTFMT*20, TEXTFMT_forC*20, FNAM*12
      EXTERNAL SNTABLE_CREATE, SNTABLE_FILL
     
      LOGICAL REJECT_PRESCALE  ! function

C -------------------- BEGIN -----------------
      FNAM = 'TABLE_SNANA'

      IF ( IFLAG .EQ. IFLAG_INI ) THEN

         NAME     = 'SNANA' // char(0)
         LENNAME  = INDEX(NAME,    ' ') - 1

         TEXTFMT  = TEXTFORMAT_TABLE(ITABLE_SNANA)
         LENFMT   = INDEX(TEXTFMT, ' ') - 1
         TEXTFMT_forC = TEXTFMT(1:LENFMT) // char(0)

         CALL SNTABLE_CREATE(IDTABLE,NAME,TEXTFMT_forC, 
     &          LENNAME,LENFMT)  ! C fun

c make table of scalars
         CALL INIT_TABLE_SNANAVAR(IDTABLE, 'SNANA', 1)

c check option to store variables for each obs (Mar 2015)
         IF ( OPT_TABLE(ITABLE_SNANA) .EQ. 2 ) THEN
           CALL INIT_TABLE_SNOBSVAR(IDTABLE, 'SNOBS')
         ENDIF

         IF ( OPT_TABLE(ITABLE_SNANA) .EQ. 4 ) THEN ! Jan 2019
           CALL INIT_TABLE_SIM_MAGOBS(IDTABLE, 'MODELMAG')
         ENDIF

c for sims ...

         CALL INIT_TABLE_SIMVAR(IDTABLE, 'SIM')
         CALL FLUSH(6)
         RETURN
      ENDIF

c --------------------------
c fill table.

      DO_FILL = .FALSE.

      IF ( CUTMASK_SNANA_TABLE == 63 ) 
     &          DO_FILL = .TRUE.   ! default --> include everything

c check subset options
      IF (CUTFLAG_SNANA == 0 .and. CUTMASK_SNANA_TABLE == 0 )
     &          DO_FILL = .TRUE.
      IF( IAND(CUTFLAG_SNANA,CUTMASK_SNANA_TABLE) > 0 ) 
     &          DO_FILL = .TRUE.


      IF ( DO_FILL ) THEN

c       terminate strings for C table-functions (snana.car routine)
        CALL TABLE_STRING_TERMINATION(+1)

c check option to store MODEL-MAG on epoch grid (Feb 2019)
        IF ( OPT_TABLE(ITABLE_SNANA) .EQ. 4 ) THEN 
           CALL LOAD_TABLE_SIM_MAGOBS()
        ENDIF

        PS  = PRESCALE_TABLE(ITABLE_SNANA)
        LPS = REJECT_PRESCALE(NCALL_SNANA_DRIVER,PS)
        IF ( .not. LPS ) THEN
          CALL SNTABLE_FILL(IDTABLE)  ! generic C function
        ENDIF
   
        CALL TABLE_STRING_TERMINATION(-1)  ! remove termination
      ENDIF

      RETURN
      END    ! end of TABLE_SNANA


C =====================================
+DECK,TBSNVAR.
      SUBROUTINE INIT_TABLE_SNANAVAR(ID,BLOCK,IFLAG)
c
c Created Feb 1, 2013
c
c Initialize variables for snana-analysis table.
c Call generic function SNTABLE_ADDCOL() that loads a table 
c for each selected format: CERNLIB, ROOT, HDF5 ...
c
c IFLAG = 1 => regular SNANA variables
c IFLAG = 2 => use _FIT variables instead (if they exist) since
c              post-fit variables may be different than the
c              original SNANA variables (e.g., SNRMAX3 can change
c              if a filter is excluded from a fit.
c
c
c May 31 2016: add zCMB[ERR] to text file and remove legacy "z,zerr"
c              from text file [since z=zHELIO]
c
c Jan 8 2018: write zHEL[ERR] to text file
c Mar 9 2018: add PHOTPROB info, MIN and Nepochs
c Mar 10 2019: add HOST_OBJID with BLOCK_LL for long long int
c May 23 2019: bug fix: book HOST_RA[DEC] as double instead of float.
c
c --------------------------------------------------

      IMPLICIT NONE
      INTEGER   ID          ! (I) table ID
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)
      INTEGER   IFLAG       ! (I) SNANA or _FIT variables

c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,FILTCOM.g
+CDE,SNLCINP.
+CDE,USRTAGCM.
+CDE,PRIVCOM.
+CDE,NNCOM.
+CDE,PKMJDCOM.
+CDE,REQEPCOM.

      INTEGER 
     &   IFILT, IFILT_OBS, ITEXT
     &  ,LENBLOCK, LENBLOCK_L, LENLIST, LENNAME, LENV, ipar, ivar

      LOGICAL LTMP, ADDCOL_SETPKMJD
      CHARACTER varlist*1000, CTMP*60, CBLOCK*40, CBLOCK_L*40
      CHARACTER FNAM*20, VARNAME*40, CFILT*2
      EXTERNAL  SNTABLE_ADDCOL

C ---------------- BEGIN ------------

      FNAM = 'INIT_TABLE_SNANAVAR'

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5 )
      call flush(6)

      LENBLOCK     = INDEX(BLOCK//' ',' ') - 1
      LENBLOCK_L  = LENBLOCK+2
      CBLOCK       = BLOCK(1:LENBLOCK) // char(0)
      CBLOCK_L     = BLOCK(1:LENBLOCK) // "_L" // char(0)
      LENLIST      = LEN(VARLIST)

c check filter list for filter-dependent columns (Feb 2017)
      ADDCOL_FILTERS = SURVEY_FILTERS  ! default
      IF ( NFILT_REMAP_TABLE > 0 ) THEN
         ADDCOL_FILTERS = FILTLIST_REMAP_TABLE 
      ENDIF

      LTMP = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_SAVEPAR)
      ADDCOL_SETPKMJD = ( LTMP .and. OPT_SETPKMJD > 0 ) 

c - - - - - - ID variables - - - - - - 


      VARLIST = 'CID:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_CID, VARLIST,0, 
     &                   LENBLOCK, 20 )

c  for CCID, use special variable SNLC_CCID_forC that has char(0)
c  termination so that parsing CCID with C code is easier.

      VARLIST = 'CCID:C*20' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_CCID, VARLIST,1,
     &                   LENBLOCK, 20 )

c to do: when combined low-z is ready change IDSURVEY -> IDSUBSURVEY,
c but keep same name 'IDSURVEY'
      VARLIST = 'IDSURVEY:I' //  char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, IDSUBSURVEY, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'TYPE:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, ISNLC_TYPE, VARLIST,1, 
     &                   LENBLOCK, 20 )

      VARLIST = 'NFIELD_OVP:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, ISNLC_NFIELD_OVP, VARLIST, 0,
     &                   LENBLOCK, 20 )

      VARLIST = 'FIELD:C*20' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_FIELDLIST, VARLIST,1,
     &                   LENBLOCK, 20 )

c Feb 15 2018: remove condition on CCDNUM 
      ITEXT = 0 ;     IF(NCCDNUM_LIST>0) ITEXT = 1  
      VARLIST = 'CCDNUM:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, ISNLC_CCDNUM(1), VARLIST,ITEXT,
     &                   LENBLOCK, 20 )

c -------------------------------------------
c CUTFLAG_SNANA is a mask as follows:
c 0    -> failed SNANA cuts
c bit0 -> passed SNANA cuts
c bit1 -> passed FIT cuts (i.e, valid fit + re-applied snana cuts)

      VARLIST = 'CUTFLAG_SNANA:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, CUTFLAG_SNANA, VARLIST,1,
     &                   LENBLOCK, 20)

c -------------------------------------------
c ERRFLAG_FIT = -9 -> no fit, just SNANA job
c ERRFLAG_FIT =  0 -> no fitting errors.
c ERRFLAG_FIT >  0 -> fit failed, see ERRFLAG codes in fitting program.

      VARLIST = 'ERRFLAG_FIT:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, ERRFLAG_FIT, VARLIST,0,
     &                   LENBLOCK, 20 )

c --------------------------------------------
      IF ( N_USERTAGS .GT. 0) then
        VARLIST = 'USERTAG:I'  // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, USERTAG, VARLIST,1,
     &                   LENBLOCK, 20)
      endif

      VARLIST = 'RA:D,DEC:D' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC8_RA, VARLIST,0,
     &                   LENBLOCK, 20 )

c -- NEPOCH ( Aug 2013)
 
      VARLIST = 'NEPOCH:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, ISNLC_NEPOCH_STORE, VARLIST,0,
     &                   LENBLOCK, 20 )

      VARLIST = 'NEPOCH_BADPHOT:I' // char(0)      ! added Jun 2016
      CALL SNTABLE_ADDCOL(ID, CBLOCK, NEPOCH_BADPHOT, VARLIST, 0,
     &                   LENBLOCK, 20 )


c Mar 2018: add info about PHOTPROB
      VARLIST = 'NEPOCH_PHOTPROB:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, ISNLC_NEPOCH_PHOTPROB, VARLIST,0,
     &                   LENBLOCK, 20 )

      VARLIST = 'PHOTPROB_MIN:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_PHOTPROB_MIN, VARLIST,0,
     &                   LENBLOCK, 20 )

c Sep 2018: add optonal info about detections
      IF ( PHOTFLAG_DETECT > 0 ) THEN
         VARLIST = 'NEPOCH_DETECT:I' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, ISNLC_NEPOCH_DETECT,VARLIST,0,
     &        LENBLOCK, 20 )
         VARLIST = 'TLIVE_DETECT:F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_TLIVE_DETECT, VARLIST,0,
     &        LENBLOCK, 20 )
      ENDIF
c - - - - -  redshift - - - - - 

      VARLIST = 'zHEL:F,zHELERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_ZHELIO, VARLIST, 1,
     &                   LENBLOCK, 20 )

      VARLIST = 'zCMB:F,zCMBERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_ZCMB, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'zHD:F,zHDERR:F' // char(0)  ! Hubble diagram redshift
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_ZHD, VARLIST,1,
     &                   LENBLOCK, 20 )

      VARLIST = 'z:F,zERR:F'  // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_REDSHIFT, VARLIST, 0, 
     &                   LENBLOCK, 20)

c tack on VPEC
      VARLIST = 'VPEC:F,VPECERR:F'  // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_VPEC, VARLIST, 1,
     &                       LENBLOCK, 20 )

c - - - - -  Galactic extinction - - - -  -

      VARLIST = 'MWEBV:F,MWEBVERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_MWEBV, VARLIST, 0, 
     &                   LENBLOCK, 20 )

c - - - - - - HOST GALAXY - - - - 
      ITEXT = 0
      if ( WRTABLEFILE_HOST_TEXT ) ITEXT=1

      VARLIST =  'HOST_NMATCH:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_NMATCH, VARLIST,ITEXT, 
     &     LENBLOCK, 20 )
      VARLIST =  'HOST_NMATCH2:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_NMATCH2, VARLIST,ITEXT, 
     &     LENBLOCK, 20 )

c      VARLIST =  'HOST_OBJID:L' // char(0)
c      CALL SNTABLE_ADDCOL(ID, CBLOCK_L, SNHOST_OBJID, VARLIST,0, 
c     &     LENBLOCK_L, 20)

c store HOST_OBJID as double precision because
c  * root tree supports Long64_t, but does not read back correctly
c  * hbook cwnt does not support long long int.
c  * sntable_dump extraction will write real*8 as integer.

      VARLIST =  'HOST_OBJID:D' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, DSNHOST_OBJID, VARLIST,ITEXT, 
     &     LENBLOCK, 20 )

      VARLIST =  'HOST_ZPHOT:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_ZPHOT, VARLIST,ITEXT, 
     &     LENBLOCK, 40 )
      VARLIST =  'HOST_ZPHOTERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_ZPHOT_ERR, VARLIST,ITEXT, 
     &     LENBLOCK, 40 )

      VARLIST =  'HOST_ZSPEC:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_ZSPEC, VARLIST,ITEXT, 
     &     LENBLOCK, 40 )
      VARLIST =  'HOST_ZSPECERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_ZSPEC_ERR, VARLIST,ITEXT, 
     &     LENBLOCK, 40 )

      VARLIST = 'HOST_RA:D'  // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST8_RA, VARLIST,ITEXT, 
     &     LENBLOCK, 20 )
      VARLIST = 'HOST_DEC:D'  // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST8_DEC, VARLIST,ITEXT, 
     &     LENBLOCK, 20 )

      VARLIST = 'HOST_ANGSEP:F'  // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_ANGSEP, VARLIST,ITEXT, 
     &     LENBLOCK, 20 )

      VARLIST = 'HOST_DDLR:F'  // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_DDLR, VARLIST,ITEXT, 
     &     LENBLOCK, 20 )

      VARLIST = 'HOST_CONFUSION:F'  // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_CONFUSION, VARLIST,ITEXT, 
     &     LENBLOCK, 20 )

c always write LOGMASS and SFR
      VARLIST =  'HOST_LOGMASS:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_LOGMASS, VARLIST, 1, 
     &         LENBLOCK, 40 )
      VARLIST =  'HOST_LOGMASS_ERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_LOGMASS_ERR, VARLIST, 1, 
     &         LENBLOCK, 40 )


      VARLIST =  'HOST_sSFR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_sSFR, VARLIST, 1,
     &         LENBLOCK, 40 )
      VARLIST =  'HOST_sSFR_ERR:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_sSFR_ERR, VARLIST, 1,
     &         LENBLOCK, 40 )

      IF ( EXIST_SNHOST_MAGOBS ) THEN    ! host mags
        CALL TABLE_VARLIST_FILTERS('HOST_MAG', 'F', ADDCOL_FILTERS,
     &           VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, ADDCOL_SNHOST_MAGOBS(1,1),
     &      VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)
      ENDIF

      IF ( EXIST_SNHOST_SB ) THEN    ! host surface brightness
        CALL TABLE_VARLIST_FILTERS('HOST_SB','F', ADDCOL_FILTERS, 
     &           VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, ADDCOL_SNHOST_SBFLUXCAL(1),
     &      VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)
      ENDIF

c Feb 2019: a few things for 2nd match, data only
      IF ( .NOT. LSIM_SNANA ) THEN

c         VARLIST = 'HOST2_OBJID:L'  // char(0)
c         CALL SNTABLE_ADDCOL(ID, CBLOCK_L, SNHOST_OBJID(2), VARLIST,0,
c     &     LENBLOCK_L, 20 )

         VARLIST = 'HOST2_OBJID:D'  // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, DSNHOST_OBJID(2), VARLIST,0,
     &     LENBLOCK, 20 )

         VARLIST = 'HOST2_ANGSEP:F'  // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_ANGSEP(2), VARLIST,0,
     &     LENBLOCK, 20 )

         VARLIST = 'HOST2_DDLR:F'  // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNHOST_DDLR(2), VARLIST,0,
     &       LENBLOCK, 20 )
      ENDIF

c - - - - -  initial PEAKMJD  - -  - 
      ITEXT = 0                       ! default is no TEXT output ...
      IF ( OPT_SETPKMJD > 0 ) ITEXT=1  ! unless this option is set
      VARLIST = 'PKMJDINI:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_SEARCH_PEAKMJD, 
     &           VARLIST, ITEXT, LENBLOCK, 20 )

c - - - - time above threshold for REQUIRE_EPOCHS - - - - - - 

      IF( NFILT_REQEP > 0 ) THEN
        VARLIST = 'NDAYS_ABOVE_SNRMIN:F' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, NDAYS_ABOVE_SNRMIN_REQEP, 
     &                    VARLIST, 1, 
     &                    LENBLOCK, 40 )
      ENDIF

c - - - - - max flux per band (May 2016) - - - - - - - - -
        CALL TABLE_VARLIST_FILTERS('FLUXCALMAX','F', ADDCOL_FILTERS, 
     &           VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, ADDCOL_FLUXCALMAX,
     &      VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)

c - - - - - - optional fit-params from PKMJD fit (Oct 20 2014) - - - 

      IF ( ADDCOL_SETPKMJD ) THEN
         DO ipar = IPAR_T0, IPAR_A2
            VARNAME = 'FIT_' // PKPARNAME(ipar)
            LENV    = INDEX(VARNAME,' ') - 1
            CALL TABLE_VARLIST_FILTERS(VARNAME(1:LENV),'F',
     &           SURVEY_FILTERS, VARLIST, LENLIST)
            
            CALL SNTABLE_ADDCOL(ID, CBLOCK, 
     &           SNLC_SNANAFIT_PEAKMJD_FITPAR(1,ipar),
     &           VARLIST(1:LENLIST)//char(0), 1, LENBLOCK, LENLIST)
         ENDDO

c ----------------------------
c  PKMJD per filter

       DO 222 ifilt  = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          cfilt     = filtdef_string(ifilt_obs:ifilt_obs)

          IF( IFILTOBS_REPLACE(IFILT_OBS) .NE. IFILT_OBS) GOTO 222

          VARNAME   = 'PKMJD_FIT_' // cfilt(1:1) // ':F'
          CALL SNTABLE_ADDCOL(ID, CBLOCK, PKMJD_FIT(ifilt_obs),
     &        VARNAME(1:20)//char(0), 1, LENBLOCK, 20 )

          VARNAME   = 'PKMJD_ERR_' // cfilt(1:1) //  ':F'
          CALL SNTABLE_ADDCOL(ID, CBLOCK, PKMJD_ERR(ifilt_obs),
     &        VARNAME(1:20)//char(0), 1, LENBLOCK, 20 )

222    CONTINUE

c --------------------------
c      fit chi2 per filter
          CALL TABLE_VARLIST_FILTERS('FIT_CHI2','F', ADDCOL_FILTERS,
     &           VARLIST, LENLIST )
          CALL SNTABLE_ADDCOL(ID, CBLOCK, ADDCOL_CHI2_FITPKMJD,
     &        VARLIST(1:LENLIST)//char(0), 1, LENBLOCK, LENLIST)

c --------------------------
c      fit NDOF per filter
          CALL TABLE_VARLIST_FILTERS('FIT_NDOF','I', SURVEY_FILTERS,
     &           VARLIST, LENLIST)
          CALL SNTABLE_ADDCOL(ID, CBLOCK, NDOF_FITPKMJD,
     &        VARLIST(1:LENLIST)//char(0), 1, LENBLOCK, LENLIST)

      ENDIF  ! end of SAVEPAR if-block

c - - - - -  min and max MJD (Aug 5 2013)
      VARLIST = 'MJDMIN:D,MJDMAX:D' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC8_MJDMIN, VARLIST, 0,
     &                   LENBLOCK, 20 )

c - - - -  multi-season variability - - - -
      IF( MULTISEASON_OPTMASK > 0 ) THEN

c Aug 15 2018: include NTOT and NLC in output and TEXT output
        VARLIST = 'NSEASON_TOT:I' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, NSEASON_TOT, VARLIST,1,
     &                   LENBLOCK, 40 )

        VARLIST = 'NSEASON_ACTIVE:I' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, NSEASON_ACTIVE, VARLIST,1,
     &                   LENBLOCK, 40 )

        VARLIST = 'MULTISEASON_CHI2RED_1:F,' //
     &            'MULTISEASON_CHI2RED_2:F,' //
     &            'MULTISEASON_CHI2RED_3:F,' //
     &            'MULTISEASON_CHI2RED_4:F,' //
     &            'MULTISEASON_CHI2RED_5:F'  //
     &          char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, MULTISEASON_CHI2RED, VARLIST,0, 
     &                   LENBLOCK, 160 )

        VARLIST = 'MULTISEASON_AVGFLUX_1:F,' //
     &            'MULTISEASON_AVGFLUX_2:F,' //
     &            'MULTISEASON_AVGFLUX_3:F,' //
     &            'MULTISEASON_AVGFLUX_4:F,' //
     &            'MULTISEASON_AVGFLUX_5:F' //
     &          char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, MULTISEASON_AVGFLUX, VARLIST,0, 
     &                   LENBLOCK, 160 )
      ENDIF

c ------------------------------------


      IF ( IFLAG .EQ. 1 ) THEN

c snana variables with no fitting.

         VARLIST = 'TrestMIN:F,TrestMAX:F,TrestRange:F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_TRESTMIN, VARLIST, 0, 
     &                   LENBLOCK, 40 )

         VARLIST = 'TobsMIN:F,TobsMAX:F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_TOBSMIN, VARLIST, 0,
     &                   LENBLOCK,  40 )

         VARLIST = 'TGAPMAX:F,T0GAPMAX:F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_TGAPMAX, VARLIST, 0,
     &                   LENBLOCK, 40 )

         VARLIST =  
     &      'NFILT_Tmin:I,NFILT_Tmax:I,NFILT_Trest2:I' // char(0) 
         CALL SNTABLE_ADDCOL(ID, CBLOCK,ISNLC_NFILT_TRESTMIN,VARLIST,0,
     &                   LENBLOCK, 40 )

         VARLIST = 'NFILT_SNRMAX:I,NFILT_SNRMAX2:I'  // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, ISNLC_NFILT_SNRMAX,VARLIST,0, 
     &                   LENBLOCK, 40 )

         VARLIST = 'SNRMAX:F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_SNRMAX_SORT(1),VARLIST,0,
     &                   LENBLOCK, 20 )

         VARLIST = 'SNRMAX1:F,SNRMAX2:F,SNRMAX3:F' // char(0) 
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNLC_SNRMAX_SORT(1),VARLIST,1,
     &                   LENBLOCK, 40 )

c ----------
c Below are SNANA variables for which the FIT analog is not
c available here -> book FIT-analogs in snlc_fit.car

         CALL TABLE_VARLIST_FILTERS('SNRMAX', 'F', ADDCOL_FILTERS,
     &                    VARLIST, LENLIST )
         CALL SNTABLE_ADDCOL(ID, CBLOCK, ADDCOL_SNRMAX(1), 
     &      VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)

         CALL TABLE_VARLIST_FILTERS('XTMW', 'F', ADDCOL_FILTERS, 
     &                    VARLIST, LENLIST )
         CALL SNTABLE_ADDCOL(ID, CBLOCK, ADDCOL_XTMW(1),
     &      VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)

      ELSE

c variables re-evaluated after fit

         VARLIST = 'TrestMIN:F,TrestMAX:F,TrestRange:F'  // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, TRESTMIN_FIT, VARLIST, 0,
     &                   LENBLOCK, 40 )

         VARLIST = 'TobsMIN:F,TobsMAX:F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, TOBSMIN_FIT, VARLIST, 0,
     &                   LENBLOCK, 40 )

         VARLIST = 'TGAPMAX:F,T0GAPMAX:F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, TGAPMAX_FIT, VARLIST, 0,
     &                   LENBLOCK, 40 )

         VARLIST = 'NFILT_Tmin:I,NFILT_Tmax:I' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, NFILT_TRESTMIN_FIT,VARLIST,0,
     &                   LENBLOCK, 40 )


         VARLIST = 'NFILT_SNRMAX:I,NFILT_SNRMAX2:I' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, NFILT_SNRMAX_FIT, VARLIST,0,
     &                   LENBLOCK, 40 )

         VARLIST = 'SNRMAX:F' // char(0)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNRMAX_SORT_FIT(1), VARLIST,0, 
     &                   LENBLOCK, 20 )

         VARLIST = 'SNRMAX1:F,SNRMAX2:F,SNRMAX3:F' // char(0) 
         CALL SNTABLE_ADDCOL(ID, CBLOCK, SNRMAX_SORT_FIT(1), VARLIST,1,
     &                   LENBLOCK, 40 )

      ENDIF


c - - - - - -  nearest nbr (Apr 2014) - - - - - 
      LTMP = ( IFLAG .EQ. 2 )     .and.
     &       ( NVAR_NEARNBR > 0 ) .and. 
     &       ( FLAG_NEARNBR .EQ. NNFLAG_APPLY ) 
      LTMP = LTMP .or. 
     &       (IFLAG.EQ.2 .and. NN_ITYPE_FIX .GE. 0 )  ! Jan 18 2016

      IF ( LTMP ) THEN
         VARLIST = 'NN_ITYPE:I' // char(0) 
         CALL SNTABLE_ADDCOL(ID, CBLOCK, NN_ITYPE, VARLIST,1, 
     &                   LENBLOCK, 20 )

         VARLIST = 'NN_NCELL:I' // char(0)   ! with training cuts (no NN)
         CALL SNTABLE_ADDCOL(ID, CBLOCK, NN_NCELL, VARLIST,0,
     &                   LENBLOCK, 20 )

         VARLIST = 'NN_PROB_IA:F' // char(0)  ! Bayesian prob with NN cut
         CALL SNTABLE_ADDCOL(ID, CBLOCK, NN_PROB_IA, VARLIST, 1,
     &                   LENBLOCK, 20) 

      ENDIF

c - - - - - - private vars - - - - -

c for PRIVATE variables in data files, 
c glue together variables in comma-separate VARLIST

      IF ( NVAR_PRIVATE .GT. 0 ) THEN 
           CTMP    = PRIVATE_VARNAME(1)(1:MXCHAR_FILEWORD-1) // ' '
           LENNAME = INDEX(CTMP,' ') - 1
           VARLIST = CTMP(1:LENNAME) // ':D'
        do ivar = 2, NVAR_PRIVATE
           CTMP    = PRIVATE_VARNAME(ivar)
           LENNAME = INDEX(CTMP,' ') - 1
           LENLIST = INDEX(VARLIST,' ') - 1
           VARLIST = VARLIST(1:LENLIST) // ',' // 
     &        CTMP(1:LENNAME) // ':D'

        enddo

        LENLIST = INDEX(VARLIST,' ') - 1
        VARLIST = VARLIST(1:LENLIST) // char(0)

        CALL SNTABLE_ADDCOL(ID, CBLOCK, PRIVATE_VALUE(1), VARLIST, 0,
     &                   LENBLOCK, LENLIST)
      ENDIF     ! end of NPAR_PRIVATE if-block


c --- Sep 23 2017: user variables --------
      IF ( NTABLEVAR_USER > 0 ) THEN
        DO ivar = 1, NTABLEVAR_USER
          VARLIST = TABLEVARNAME_USER(ivar)
          LENLIST = INDEX(VARLIST,' ') - 1
          VARLIST = VARLIST(1:LENLIST) // ':F' // char(0)
          CALL SNTABLE_ADDCOL(ID, CBLOCK, TABLEVALUE_USER(1), 
     &               VARLIST, 1, LENBLOCK, LENLIST+2)           
        ENDDO
      ENDIF
 
      RETURN
      END   !  end of INIT_TABLE_SNANAVAR


C =============================================
+DECK,TBOBSVAR.
      SUBROUTINE INIT_TABLE_SNOBSVAR(ID, BLOCK)

c Mar 2 2015: 
c Book epoch info in SNANA table.
c 
c Sep 23 2017: reduce MXOBS down to 1000 so that MJD*8 is handled by hbook.
c Oct 16 2017: include CCDNUM if it is there.
c Mar 03 2018: include SIM_FLUXCAL_HOSTERR(NOBS):F
c Mar 18 2018: include DTOBS(NOBS):F and DTOBS_SAMEFILT(NOBS):F

      IMPLICIT NONE

      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

      INTEGER MXOBS_SNTABLE
      PARAMETER (MXOBS_SNTABLE = 900) ! cannot exceed 1000 for MJD*8

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
      INTEGER LENV, LENB, LENTMP
      CHARACTER CBLK*40, CNOBS*14, VARNAME*40
      LOGICAL  IGNORE

      EXTERNAL SNTABLE_ADDCOL
      INTEGER  IGNOREFILE

C --------------- BEGIN -------------

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENV   = LEN(VARNAME)
      LENB   = INDEX(BLOCK//' ',' ') - 1
      CBLK   = BLOCK(1:LENB) // char(0)

      write(CNOBS,15) MXOBS_SNTABLE
15    format('NOBS[',I4.4,']' )  ! no spaces or commas in string
      VARNAME = CNOBS(1:12)  // char(0)  ! Nobs used in fit + NREJECT
      CALL SNTABLE_ADDCOL(ID, CBLK, ISNLC_NEWMJD_STORE,
     &     VARNAME, 0, LENB, LENV)

      VARNAME = 'USEFLAG(NOBS):I' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, ISNLC_SNRECON_USE,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'PHOTFLAG(NOBS):I' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, ISNLC_PHOTFLAG,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'PHOTPROB(NOBS):R' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_PHOTPROB,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'IFILTOBS(NOBS):I' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, ISNLC_IFILT_OBS,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'MJD(NOBS):D' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC8_MJD,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'DTOBSLAST(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_DTOBS,
     &      VARNAME, 0, LENB,LENV)
      VARNAME = 'DTOBSLAST_SAMEFILT(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_DTOBS_SAMEFILT,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXCAL(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_FLUXCAL,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'FLUXCAL_ERR(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_FLUXCAL_ERRTOT,
     &      VARNAME, 0, LENB,LENV)

c -- observing conditions

      VARNAME = 'ZEROPT(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_ZEROPT,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'PSF(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_PSF_SIG1,
     &      VARNAME, 0, LENB,LENV)

      VARNAME = 'SKYSIG(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_SKYSIG,
     &      VARNAME, 0, LENB,LENV)

c --- error calculated from PSF+SKY+ZP, as the simulation would do

      VARNAME = 'FLUXCAL_ERRCALC(NOBS):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_FLUXCAL_ERRCALC,
     &      VARNAME, 0, LENB,LENV)
 
      VARNAME = 'FLUXCAL_HOSTERRCALC(NOBS):F' // char(0) 
      CALL SNTABLE_ADDCOL(ID,CBLK, SNLC_FLUXCAL_HOSTERRCALC,
     &      VARNAME, 0, LENB,LENV)

c - - - - - - - - - - - - - - - - 

      IF ( LSIM_SNANA .or. LSIM_MAGOBS ) THEN
         VARNAME = 'SIM_FLUXCAL(NOBS):F' // char(0) 
         CALL SNTABLE_ADDCOL(ID,CBLK, SIM_EPFLUXCAL,
     &        VARNAME, 0, LENB,LENV)

         VARNAME = 'SIM_MAGOBS(NOBS):F' // char(0) 
         CALL SNTABLE_ADDCOL(ID,CBLK, SIM_EPMAGOBS,
     &        VARNAME, 0, LENB,LENV)
      ENDIF

      IF ( LSIM_SNANA ) THEN
         VARNAME = 'SIM_FLUXCAL_HOSTERR(NOBS):F' // char(0) 
         CALL SNTABLE_ADDCOL(ID,CBLK, SIM_EPFLUXCAL_HOSTERR,
     &        VARNAME, 0, LENB,LENV)
      ENDIF

c include SNR_MAG[mag] if it exists.
      LENTMP  = INDEX(SIMNAME_SNRMON,' ')-1
      IGNORE  = ( IGNOREFILE(SIMNAME_SNRMON,LENTMP) > 0 ) 
      IF ( LSIM_SNANA .and. (.not.IGNORE)  ) THEN
         VARNAME = SIMNAME_SNRMON(1:LENTMP)// '(NOBS):F' // char(0)
         CALL SNTABLE_ADDCOL(ID,CBLK, SIM_EPSNRMON,
     &        VARNAME, 0, LENB,LENV)         
      ENDIF

      RETURN
      END   ! end INIT_TABLE_SNOBSVAR


C =============================================
+DECK,INIT_TABLE_SIM_MAGOBS.
      SUBROUTINE INIT_TABLE_SIM_MAGOBS(ID, BLOCK)

c Feb 2019
c Book only MODEL-MAG vs. EPOCH (much smaller output than SNANA+EPOCHS)
c MODEL-MAG is interpolated on a grid to enable plotting model colors. 
c
c  NEP_SIM_MODELGRID, SIM_MODELGRID_TOBS, SIM_MODELGRID_MAGOBS

      IMPLICIT NONE

      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER LENV, LENB, IFILT, IFILT_OBS
      LOGICAL IGNORE
      CHARACTER CBLK*40, CNOBS*20, VARNAME*40, cfilt*2

      EXTERNAL SNTABLE_ADDCOL
      INTEGER  IGNOREFILE

C --------------- BEGIN -------------

      IF ( .not. LSIM_SNANA ) RETURN ! sim only

      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENV   = LEN(VARNAME)
      LENB   = INDEX(BLOCK//' ',' ') - 1
      CBLK   = BLOCK(1:LENB) // char(0)

      write(CNOBS,15) MXEP_MODELGRID
15    format('NEP_MODEL[',I4.4,']' )  ! no spaces or commas in string
      VARNAME = CNOBS(1:15)  // char(0) 
      CALL SNTABLE_ADDCOL(ID, CBLK, NEP_SIM_MODELGRID,
     &     VARNAME, 0, LENB, LENV)

      VARNAME = 'EPOCH_MODEL(NEP_MODEL):F' // char(0)  
      CALL SNTABLE_ADDCOL(ID,CBLK, SIM_MODELGRID_TOBS,
     &      VARNAME, 0, LENB,LENV)

      DO ifilt = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)         
          cfilt     = filtdef_string(ifilt_obs:ifilt_obs)
          VARNAME   = 'MAGOBS_MODEL_' // cfilt(1:1) // 
     &                    '(NEP_MODEL):F' // char(0)
          CALL SNTABLE_ADDCOL(ID,CBLK, SIM_MODELGRID_MAGOBS(1,ifilt),
     &          VARNAME, 0, LENB,LENV )
      ENDDO

      RETURN
      END   ! end INIT_TABLE_SIM_MAGOBS

C =============================================
+DECK,FILL_TABLE_SIM_MAGOBS.
      SUBROUTINE LOAD_TABLE_SIM_MAGOBS()

c Feb 2019: 
c   load SIM_MODELGRID arrays for MODELMAG table.
c   This CWNT is designed to enable plotting model color vs. epoch
c
c NEP_SIM_MODELGRID, SIM_MODELGRID_TOBS, SIM_MODELGRID_MAGOBS
    
      IMPLICIT NONE

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IGRID, NEP, IFILT, IFILT_OBS
      REAL MAGOBS, TOBS

c function
      REAL SIM_MAGOBS_INTERP

C ---------- BEGIN ----------

      IF ( .not. LSIM_SNANA ) RETURN ! sim only
      
c define arbitrary epoch grid

      NEP = 0
      DO IGRID = -40, 100, 2
         NEP  = NEP + 1
         TOBS = FLOAT(IGRID)
         SIM_MODELGRID_TOBS(NEP) = TOBS
         
         DO ifilt = 1, NFILTDEF_SURVEY
            MAGOBS = SIM_MAGOBS_INTERP(ifilt,TOBS)
            SIM_MODELGRID_MAGOBS(NEP,IFILT) = MAGOBS
         ENDDO
      ENDDO
      NEP_SIM_MODELGRID = NEP
      RETURN
      END

+DECK,SIM_MAGOBS_INTERP.
      REAL FUNCTION SIM_MAGOBS_INTERP(IFILT,Tobs)

C Return interpolated SIM_MAGOBS for inputs:
c   * IFILT  = sparse filter index 
c   * Tobs   = MJD - SIM_PEAKMJD
     
      IMPLICIT NONE

      INTEGER IFILT
      REAL Tobs

+CDE,SNDATCOM.
+CDE,FILTCOM.

      INTEGER NEWMJD, EP, EPMIN, EPMAX, IFILT_OBS, EP0, EP1
      REAL MAGOBS, Tobs_tmp, T0, T1, MAG0, MAG1, frac
      REAL*8 MJD8
C ------------ BEGIN -----------

      MAGOBS = 99.0  ! init value

      T0=-9999. ; T1=-9999. ; EP0 = -9; EP1 = -9
      DO 100 NEWMJD = 1, ISNLC_NEWMJD_STORE
        EPMIN  = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX  = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        DO 101 EP = EPMIN, EPMAX
            IFILT_OBS = ISNLC_IFILT_OBS(ep)
            IF ( IFILT .NE. IFILTDEF_INVMAP_SURVEY(ifilt_obs)) GOTO 101
            MJD8      = SNLC8_MJD(EP)
            Tobs_tmp  = MJD8 - SIM_PEAKMJD
            MAGOBS    = SIM_EPMAGOBS(ep)
            if ( Tobs_tmp < Tobs ) then
               EP0 = EP; T0 = Tobs_tmp; MAG0 = MAGOBS
            endif
            if ( Tobs_tmp > Tobs .and. T1 < -999. ) THEN
               EP1 = ep; T1 = Tobs_tmp ; MAG1 = MAGOBS ; goto 444
            endif
 101     CONTINUE
 100  CONTINUE

 444  CONTINUE

      IF ( EP0 > 0 .and. EP1 > 0 ) THEN
         FRAC   = (Tobs-T0)/(T1-T0)
         MAGOBS = MAG0 + (MAG1-MAG0) * frac
      ENDIF

      SIM_MAGOBS_INTERP = MAGOBS

      RETURN
      END

C ========================================
+DECK,TBSIMVAR..
      SUBROUTINE INIT_TABLE_SIMVAR(ID,BLOCK)

c Created Feb 02, 2013
c Initialize table for simulated variables.
c
c Jun  9, 2013: replace SIM_MODEL_INDEX with SIM_TYPE_INDEX
c Dec 26, 2015: add SIM_NGEN_LIBID:I
c Apr 21, 2016: add SIM_alpha
c Jul 16, 2016: add SIM_AV; check for WRTABLEFILE_SIMVAR
c Nov 26, 2016: add SIM_MWEBV
c Jan 08, 2018: add SIM_VPEC to text-FITRES output
c Feb 28, 2018: add LCLIB params
c Dec 10, 2018: add BYOSED params
c Feb 01, 2019: add SIM_LCWIDTH

      IMPLICIT  NONE
      INTEGER   ID          ! (I) table id
      CHARACTER BLOCK*(*)   ! (I) name of BLOCK (optional)

c local var

+CDE,SNDATCOM.
+CDE,SNLCINP.

      CHARACTER 
     &    CTMP*(MXCHAR_FILEWORD)
     &  , VARLIST*400, CBLOCK*40
      INTEGER LENLIST, IPAR, LENBLOCK, LENTMP

      EXTERNAL SNTABLE_ADDCOL

C ---------------- BEGIN ---------------

      IF ( .NOT. LSIM_SNANA         ) RETURN 
      IF ( .NOT. WRTABLEFILE_SIMVAR ) RETURN


      write(6,10) BLOCK, ID
 10   format(T6,'Create BLOCK = ',A,'  for TABLE ID = ', I5)
      call flush(6)

      LENBLOCK = INDEX(BLOCK//' ',' ') - 1
      LENLIST  = LEN(VARLIST)
      CBLOCK   = BLOCK(1:LENBLOCK) // char(0)


      IF ( SIM_SUBSAMPLE_INDEX >= 0 ) THEN
        VARLIST = 'SIM_SUBSAMPLE_INDEX:I' // char(0)  
        CALL SNTABLE_ADDCOL(ID,CBLOCK,SIM_SUBSAMPLE_INDEX,VARLIST, 0,
     &                     LENBLOCK, LENLIST)   ! added Jun 16 2017
      ENDIF

      VARLIST = 'SIM_TYPE_INDEX:I' //char(0)  ! June 9, 2013
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_GENTYPE,  VARLIST, 1,  ! legacy name
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_TEMPLATE_INDEX:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_TEMPLATE_INDEX,VARLIST,1,
     &                   LENBLOCK, LENLIST)

c Mar 22 2016: always output SIM_LIBID
cc      IF ( BTEST(SIMLIB_MSKOPT,1) ) THEN
        VARLIST = 'SIM_LIBID:I' // char(0)  
        CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_LIBID,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)   ! added Dec 2015
        VARLIST = 'SIM_NGEN_LIBID:I' // char(0)  
        CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_NGEN_LIBID,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)   ! added Dec 2015
cc      ENDIF

      VARLIST = 'SIM_NOBS_UNDEFINED:I' // char(0)  
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_NOBS_UNDEFINED,VARLIST,0,
     &                   LENBLOCK, LENLIST)   ! added Mar 22 2017

      VARLIST = 'SIM_SEARCHEFF_MASK:I' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_SEARCHEFF_MASK, VARLIST, 0,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_MAGSMEAR_COH:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_MAGSMEAR_COH,  VARLIST, 0,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_MWEBV:F' // char(0)  ! added Nov 26 2016
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_MWEBV,  VARLIST, 0,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_ZCMB:F' // char(0) 
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_REDSHIFT_CMB,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_ZHELIO:F' // char(0) 
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_REDSHIFT_HELIO,  VARLIST, 0,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_ZHOST:F' // char(0) 
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_REDSHIFT_HOST,  VARLIST, 0,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_ZFLAG:I' // char(0) 
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_REDSHIFT_FLAG,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_VPEC:F' // char(0) 
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_VPEC,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_DLMAG:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_DLMAG,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_LENSDMU:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_LENSDMU,  VARLIST, 0,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_PKMJD:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_PEAKMJD,  VARLIST, 1, 
     &                   LENBLOCK, LENLIST)

      LENTMP = INDEX(SIMNAME_SHAPEPAR,' ') - 1  ! x1, delta, dm15
      VARLIST = SIMNAME_SHAPEPAR(1:LENTMP) // ':F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_SHAPEPAR,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

      LENTMP = INDEX(SIMNAME_COLORPAR,' ') - 1  ! c, AV
      VARLIST = SIMNAME_COLORPAR(1:LENTMP) // ':F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_COLORPAR,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

      LENTMP = INDEX(SIMNAME_SHAPELAW,' ') - 1   ! SIM_alpha
      VARLIST = SIMNAME_SHAPELAW(1:LENTMP) // ':F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_SHAPELAW,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

      LENTMP = INDEX(SIMNAME_COLORLAW,' ') - 1   ! SIM_beta
      VARLIST = SIMNAME_COLORLAW(1:LENTMP) // ':F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_COLORLAW,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

c Jun 25 2019: add SIM_SALT2gammaDM, but not in TEXT file until later.
      VARLIST = 'SIM_gammaDM:F' // char(0) 
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_SALT2gammaDM, VARLIST,0,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_x0:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_SALT2x0,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

      VARLIST = 'SIM_mB:F' // char(0)
      CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_SALT2mb,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)

c add SIM_AV only if not already defined. 
c This is for the SALT2 model with intinsic color (c) and 
c external scatter (SIM_AV) from dust.

      if ( SIMNAME_COLORPAR(1:6) .NE. 'SIM_AV' ) then
        VARLIST = 'SIM_AV:F' // char(0)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_AV,  VARLIST, 1,
     &                   LENBLOCK, LENLIST)
      endif

c  SIMSED model params; glue SIMSED_ prefix (Feb 2014)
c  Apr 28 2015: set DOTEXT flag to 1

      DO IPAR    = 1, NPAR_SIMSED
         CTMP    = SIMSED_PARNAME(ipar)
         LENTMP  = INDEX(CTMP,' ') - 1
         VARLIST = 'SIMSED_' // CTMP(1:LENTMP) // ':F' // char(0)
         CALL SNTABLE_ADDCOL(ID,CBLOCK, SIMSED_PARVAL(ipar),VARLIST,1,
     &        LENBLOCK, LENLIST)
      ENDDO


c Dec 2018: BYOSED model params 
      DO IPAR    = 1, NPAR_BYOSED
         CTMP    = BYOSED_PARNAME(ipar)
         LENTMP  = INDEX(CTMP,' ') - 1
         VARLIST = 'BYOSED_' // CTMP(1:LENTMP) // ':F' // char(0)
         CALL SNTABLE_ADDCOL(ID,CBLOCK, BYOSED_PARVAL(ipar),VARLIST,1,
     &          LENBLOCK, LENLIST)
      ENDDO

c Feb 2018: LCLIB model params 
      IF ( SIM_MODEL_INDEX == MODEL_LCLIB ) THEN        
        CALL TABLE_VARLIST_FILTERS('SIM_TEMPLATEMAG','F',ADDCOL_FILTERS, 
     &           VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL(ID,CBLOCK, SIM_TEMPLATEMAG,
     &          VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)

        DO IPAR    = 1, NPAR_LCLIB
           CTMP    = LCLIB_PARNAME(ipar)
           LENTMP  = INDEX(CTMP,' ') - 1
           VARLIST = 'LCLIB_' // CTMP(1:LENTMP) // ':F' // char(0)
           CALL SNTABLE_ADDCOL(ID,CBLOCK, LCLIB_PARVAL(ipar),VARLIST,1,
     &          LENBLOCK, LENLIST)
        ENDDO
      ENDIF

c SIM_HOSTLIB params

      DO IPAR    = 1, NPAR_SIM_HOSTLIB
         CTMP    = SIM_HOSTLIB_PARNAME(ipar)
         LENTMP  = INDEX(CTMP,' ') - 1
         VARLIST = 'SIM_HOSTLIB_' // CTMP(1:LENTMP) // ':F' // char(0)
         CALL SNTABLE_ADDCOL(ID,CBLOCK,SIM_HOSTLIB_PARVAL(ipar),
     &        VARLIST, 0, 
     &        LENBLOCK, LENLIST)
      ENDDO  


c - - - - - optional LCWIDTH for simulated MAGOBS -----
      if ( OPTSIM_LCWIDTH > 0 ) then
        CALL TABLE_VARLIST_FILTERS('SIM_LCWIDTH','F', ADDCOL_FILTERS, 
     &           VARLIST, LENLIST)
        CALL SNTABLE_ADDCOL(ID, CBLOCK, SIM_LCWIDTH,
     &      VARLIST(1:LENLIST)//char(0), 0, LENBLOCK, LENLIST)
      endif

      RETURN
      END    ! end of INIT_TABLE_SIMVAR


C ===========================
+DECK,TBCIDPTR.
      SUBROUTINE TABLE_CIDPTR(IFLAG)
c
c Created Feb 2013
c
c Replacement for obsolete function HFCIDPTR.
c Plot list of CIDs with light curve plots.
c Fits that fail have CID=-9.
c Used by the lc-plotting tool
c
c ----------------------------------------------------

      IMPLICIT NONE

      INTEGER IFLAG  ! (I) see IFLAG_XXX params

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER   ID, CID, IPLOT
      INTEGER   LENNAME, LENBLOCK, LENLIST
      CHARACTER CNAME*20, CBLOCK*20, VARLIST*20, TEXTFMT*4

      COMMON / IPLOTCOM / CID, IPLOT 
c function
      INTEGER IPLOT_JOBSPLIT

C ------------ BEGIN ------------

      ID    = IDTABLE_CIDPTR

      IF ( IFLAG .EQ. IFLAG_INI ) THEN
        CNAME    = 'CIDPTR' // char(0)
        LENNAME  = INDEX(CNAME,' ') - 1
        TEXTFMT  = ' ' // char(0)  ! never make a text table 
        CALL SNTABLE_CREATE(ID, CNAME, LENNAME, TEXTFMT, 1 )  ! C function

        CBLOCK = 'IPLOT' // char(0)
        LENBLOCK = INDEX(CBLOCK,' ') - 1
        LENLIST  = LEN(VARLIST)       
        VARLIST = 'CID:I,IPLOT:I' // char(0)
        CALL SNTABLE_ADDCOL(ID,CBLOCK,CID,VARLIST,0, LENBLOCK,LENLIST)

        RETURN
      ENDIF

c --------------------------
c fill table.

      IPLOT = IPLOT_JOBSPLIT(N_SNLC_PLOT)
      CID   = SNLC_CID
      CALL SNTABLE_FILL(ID)  ! generic C function

      RETURN
      END   ! end TABLE_CIDPTR


C ===================================================
+DECK,TBVFILT.
      SUBROUTINE TABLE_VARLIST_FILTERS(PREFIX,CAST,FILTERS,
     &            VARLIST,LENLIST)

c Created Sep 28, 2012
c
c For input PREFIX  and defined FILTERS,  return 
c comma-separate list of variable names for column-wise ntuple.
c Example for FILTERS=gri,
c
c VARLIST = '[PREFIX]_g,[PREFIX]_r,[PREFIX]_i'
c
c If a filter is case-insensitive duplicate (i.e., u & U) 
c then append '2' at the end of the variable name. 
c The returned VARLIST is used in the HBNAME calls,
c and hence case-insensitive duplicates must be distiguished
c for ntuples.
c
c Feb  1, 2013: include ':F' after each variable.
c Feb  5, 2013: return LENLIST
c Feb 15, 2013: set max of MXFILT = 30 filters.
c Jun 24, 2013: ignore remapped filter(s)
c Oct 21, 2014: add CAST as input argument
c
c ------------------------------------

      IMPLICIT NONE

      CHARACTER 
     &   PREFIX*(*)   ! (I) prefix for variable names
     &  ,CAST*(*)     ! (I) 'F', 'I', 'D'
     &  ,FILTERS*(*)  ! (I) list of filters; i.e, 'gri'
     &  ,VARLIST*(*)  ! (O) output list of varnames.

      INTEGER LENLIST    ! (O) length of VARLIST

c local var

+CDE,SNPAR.
+CDE,FILTCOM.

      INTEGER NFILT, ifilt, lenv, MXFILT, LENMAX, LENSUM
      INTEGER IFILTOBS
      LOGICAL LTMP
      character varname*32, cfilt*1, c1err*76, c2err*76

c function
      LOGICAL DUPLICATE_FILTER
      INTEGER FILTINDX

C ---------------- BEGIN ----------
  
      LENMAX = LEN(VARLIST)  ! abort if larger than this
      LENSUM = 0
      MXFILT = 30

      NFILT = INDEX(FILTERS,' ' ) - 1
      IF ( NFILT > MXFILT ) NFILT = MXFILT
      VARLIST = ''

c -----------
      DO 100 ifilt = 1, NFILT
         cfilt     = FILTERS(ifilt:ifilt)
         LTMP      = DUPLICATE_FILTER(ifilt,FILTERS)

         IFILTOBS = FILTINDX(cfilt // ' ')
         IF( IFILTOBS_REPLACE(IFILTOBS) .NE. IFILTOBS) GOTO 100

         varname   = PREFIX // '_' //  cfilt
         LENV = INDEX(VARNAME,' ') - 1
         if ( LTMP ) VARNAME = VARNAME(1:LENV) // '2'

         LENV = INDEX(VARNAME,' ') - 1
         LENSUM = LENSUM + LENV + 2  ! for error message only

         IF ( ifilt .eq. 1 ) then
            varlist = VARNAME(1:LENV) // ':' // CAST
         else if ( LENSUM < LENMAX ) then
            lenlist = INDEX(varlist,' ') - 1
            varlist = varlist(1:LENLIST) // ',' // 
     &            VARNAME(1:LENV) // ':' // CAST
         endif

100   CONTINUE

c ---------------------
c abort if required size (LENSUM) of VARLIST exceed size passed (LENMAX)

      IF ( LENSUM > LENMAX ) THEN
        write(c1err,661) LENSUM, LENMAX
661     format('LENSUM=',I4, ' but LEN(VARLIST)=',I4,
     &          ' is too short.')
        write(c2err,662) PREFIX, NFILT, FILTERS(1:NFILT)
662     format('PREFIX=',A,2x,'NFILT=',I3,'(',A,'+)'  )
        CALL MADABORT("TABLE_VARLIST_FILTERS", c1err, c2err)
      ENDIF

      LENLIST = INDEX(VARLIST,' ') - 1

      RETURN
      END     ! end of TABLE_VARLIST_FILTERS

C ======================================
+DECK,TABLE_ADDCOL_LOAD.
      SUBROUTINE TABLE_ADDCOL_LOAD()

c Created Feb 2017
c Load filter-dependent ADDCOL_XXX arrays.
c Use nominal filter indices, or REMAPED filters if
c &SNLCINP namelist input SNTABLE_FILTER_REMAP is set.

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PKMJDCOM.
c+CDE,SNHOSTCOM.

      INTEGER ifilt, NFILT, IFILTOBS, IFILTOBS_REMAP, IFILT_REMAP
      INTEGER LEN
      CHARACTER  CFILTOBS*2, CFILTOBS_REMAP*2, FNAM*18
      LOGICAL DO_NOMINAL, DO_REMAP, VALID_BAND
      LOGICAL USE, USEFILT_REMAP(MXFILT_ALL)
      REAL    SNRMAX, VAL_OLD, VAL_NEW
c function
      INTEGER FILTINDX

C ------------- BEGIN --------------

      FNAM = 'TABLE_ADDCOL_LOAD'

      DO_NOMINAL = ( NFILT_REMAP_TABLE == 0 ) 
      DO_REMAP   = ( .NOT. DO_NOMINAL)

      NFILT   = NFILTDEF_SURVEY

      IF ( DO_REMAP) THEN
        DO  ifilt=1, MXFILT_ALL
          USEFILT_REMAP(ifilt) = .FALSE.
        ENDDO
      ENDIF

      DO IFILT_REMAP = 1, NFILT_REMAP_TABLE
           ADDCOL_SNRMAX(IFILT_REMAP)     = -9.0
           ADDCOL_XTMW(IFILT_REMAP)       = -9.0
           ADDCOL_FLUXCALMAX(IFILT_REMAP) = -9.0
           ADDCOL_SNHOST_MAGOBS(IFILT_REMAP,1)    = -9.0 
           ADDCOL_SNHOST_MAGOBS(IFILT_REMAP,2)    = -9.0 
           ADDCOL_SNHOST_SBFLUXCAL(IFILT_REMAP) = -9.0
      ENDDO

      DO 100 ifilt = 1, NFILT
         IFILTOBS = IFILTDEF_MAP_SURVEY(ifilt)
         CFILTOBS = filtdef_string(ifiltobs:ifiltobs)

         IF ( DO_NOMINAL ) then
           ADDCOL_SNRMAX(ifilt)     = SNLC_SNRMAX_FILT(ifilt)
           ADDCOL_XTMW(ifilt)       = SNLC_MWXT_FLUXFRAC(ifilt)
           ADDCOL_FLUXCALMAX(ifilt) = SNLC_FLUXCALMAX(ifilt)
           ADDCOL_CHI2_FITPKMJD(ifilt)    = CHI2_FITPKMJD(ifilt)
           ADDCOL_SNHOST_MAGOBS(ifilt,1)  = SNHOST_MAGOBS(ifilt,1) 
           ADDCOL_SNHOST_MAGOBS(ifilt,2)  = SNHOST_MAGOBS(ifilt,2) 
           ADDCOL_SNHOST_SBFLUXCAL(ifilt) = SNHOST_SBFLUXCAL(ifilt) 
         ELSE 
           CALL FILTER_REMAP_FETCH(IFILTOBS,  ! (I)
     &           IFILTOBS_REMAP,IFILT_REMAP)  ! (O)

           SNRMAX         = SNLC_SNRMAX_FILT(ifilt)
           VALID_BAND     = (SNRMAX > -8.999)
           if ( .NOT. VALID_BAND ) GOTO 100

           IFILT_REMAP    = IFILT_REMAP + 1  ! C -> fortran index
           CFILTOBS_REMAP = ADDCOL_FILTERS(ifilt_remap:ifilt_remap) 
           USE            = USEFILT_REMAP(IFILTOBS_REMAP)

c check that each band is mapped.
           if ( IFILTOBS_REMAP<0 .or. IFILT_REMAP<0 ) then
             C1ERR = 'Missing REMAP for Band= ' // CFILTOBS(1:1) //
     &          '  for CID=' // SNLC_CCID(1:ISNLC_LENCCID)
             C2ERR = 'Check SNTABLE_FILTER_REMAP in &SNLCINP'
             CALL MADABORT(FNAM, c1err, c2err)
           endif

           USEFILT_REMAP(IFILTOBS_REMAP) = .TRUE.

           VAL_OLD = ADDCOL_SNRMAX(IFILT_REMAP)
           VAL_NEW = SNLC_SNRMAX_FILT(ifilt)
           ADDCOL_SNRMAX(IFILT_REMAP) = MAX(VAL_OLD,VAL_NEW)

           ADDCOL_XTMW(IFILT_REMAP) = SNLC_MWXT_FLUXFRAC(ifilt)

           VAL_OLD = ADDCOL_FLUXCALMAX(IFILT_REMAP)
           VAL_NEW = SNLC_FLUXCALMAX(ifilt)
           ADDCOL_SNRMAX(IFILT_REMAP) = MAX(VAL_OLD,VAL_NEW)

           VAL_OLD = ADDCOL_CHI2_FITPKMJD(IFILT_REMAP)
           VAL_NEW = CHI2_FITPKMJD(ifilt)
           ADDCOL_CHI2_FITPKMJD(IFILT_REMAP) = VAL_OLD + VAL_NEW
     
           ADDCOL_SNHOST_MAGOBS(IFILT_REMAP,1) = 
     &            SNHOST_MAGOBS(ifilt,1)      ! any band
           ADDCOL_SNHOST_MAGOBS(IFILT_REMAP,2) = 
     &            SNHOST_MAGOBS(ifilt,2)      ! any band
           ADDCOL_SNHOST_SBFLUXCAL(IFILT_REMAP) = 
     &            SNHOST_SBFLUXCAL(ifilt)   ! any band

         ENDIF

100   CONTINUE

      RETURN  
      END   ! end TABLE_ADDCOL_LOAD

C ======================================
+DECK,TBSTRTERM.
      SUBROUTINE TABLE_STRING_TERMINATION(OPT)

c Created Jan 2014 by R.Kessler
c For ROOT, terminate strings with char(0) to be used by C++/root code.
c For HBOOK, leave blank-space padding for fortran/hbook code.
c Note that the list of table string-variables is hard-wired;
c initial set is SNLC_CCID and SNLC_FIELDLIST.
c
c Warning: if using both hbook and root, the hbook strings 
c          will have lots of extra padding in the ntuple.
c
c OPT > 0 --> add termination
c OPT < 0 --> remove termination

      IMPLICIT NONE

      INTEGER OPT  ! (I) integer option

+CDE,SNDATCOM.
+CDE,SNLCINP.

      INTEGER LENCID, LENFLD

C ------------ BEGIN --------------

      IF ( USE_TABLEFILE_ROOT ) THEN
         LENCID  = INDEX(SNLC_CCID,     ' ') - 1
         LENFLD  = INDEX(SNLC_FIELDLIST,' ') - 1

         IF ( OPT > 0 ) THEN 
           ! add termination
           SNLC_CCID      = SNLC_CCID(1:LENCID)      // char(0)
           SNLC_FIELDLIST = SNLC_FIELDLIST(1:LENFLD) // char(0)
         ELSE
           ! remove termination char 
           SNLC_CCID(LENCID+1:LENCID+1)      = ' '
           SNLC_FIELDLIST(LENFLD+1:LENFLD+1) = ' '
         ENDIF
      ENDIF

      RETURN
      END

C =============================================
+DECK,CWNDUP.
      LOGICAL FUNCTION DUPLICATE_FILTER(i1,FILTERS)

c Created Sep 29, 2012
c Return TRUE if any previous filter in FILTERS
c is defined after using LOCASE on both filters.
c
c Example 1: i1=3 and FILTERS='ugrizUGRIZ'
c            i1=3 corresponds to r, and previous filters are unique.
c                --> returns FALSE since there are no duplicates.
c
c Example 2: i1=8 and FILTERS='ugrizUGRIZ'
c            i1=8 corresponds to R, which is the same as 'r' after
c            converting to lower case --> returns TRUE.
c
c ------------------------------------------
      IMPLICIT NONE

      INTEGER i1             ! (I) check this filter in the list
      CHARACTER FILTERS*(*)  ! (I) list of filster; i.e, 'gri'

c local var

      INTEGER i2
      character cfilt1*2, cfilt2*2, cfilt1_lower*2, cfilt2_lower*2

c ----------------- BEGIN ------------

      DUPLICATE_FILTER = .FALSE.

      if ( i1 .eq. 1 ) return

      cfilt1      = FILTERS(i1:i1)
      CALL LOCASE(cfilt1, cfilt1_lower)

      DO i2 = 1, i1-1
         cfilt2      = FILTERS(i2:i2)
         CALL LOCASE(cfilt2, cfilt2_lower)
         if ( cfilt1_lower .EQ. cfilt2_lower ) then
            DUPLICATE_FILTER = .TRUE.
            return
         endif
      ENDDO

      RETURN
      END

C ================================================
+DECK,INITGALXT.
      SUBROUTINE INIT_GALextinct()

c Created Sep 19 2013 by R.Kessler
c
c - Hierarchy of OPT_MWCOLORLAW (and RV) for data, in order of priority
c    -> OPT_MWCOLORLAW         (if >=0 -> read from &SNLCINP namelist)
c    -> OPT_MWCOLORLAW_DEFAULT 
c
c - Hierarchy of OPT_MWCOLORLAW for sim
c    -> OPT_MWCOLORLAW         (if >=0 -> read from &SNLCINP namelist)
c    -> SIMOPT_MWCOLORLAW      (from sim files)
c
c
c - ABORT on invalid option
c
c - print info for colorLaw and MWEBV-updates
c
c ------------------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,SNSIMCOM.
c +CDE,KCORCOM.

      LOGICAL   LDATA, SETMWCL_USER, SETEBV_USER, SETRV_USER
      INTEGER   LENTEXT
      CHARACTER nameOpt*20, CTEXT*60
      EXTERNAL  text_MWoption

C ---------------- BEGIN -----------

      CALL PRBANNER("INIT_GALextinct") 
                             
      LDATA         = .NOT. LSIM_SNANA
      SETMWCL_USER  = ( OPT_MWCOLORLAW  > -1   ) 
      SETEBV_USER   = ( OPT_MWEBV       > -1   ) 
      SETRV_USER    = ( RV_MWCOLORLAW   > -0.01 ) 

c ---------------------------------

      IF ( LDATA ) THEN

c     ---------- check RV ---------
         if ( SETRV_USER ) then
            write(6,22) RV_MWCOLORLAW, 'User (&SNLCINP)'
         else
            RV_MWCOLORLAW = RV_MWCOLORLAW_DEFAULT
            write(6,22) RV_MWCOLORLAW, 'Default'
         endif

c     --------- check color law ------------
         if ( SETMWCL_USER ) then
            write(6,20) OPT_MWCOLORLAW, 'User (&SNLCINP)'
         else
            OPT_MWCOLORLAW = OPT_MWCOLORLAW_DEFAULT
            write(6,20) OPT_MWCOLORLAW, 'Default'
         endif

      ENDIF


      IF ( LSIM_SNANA ) THEN

         if ( SETRV_USER ) then
            write(6,22) RV_MWCOLORLAW, 'User (&SNLCINP)'
         else
            ! use simulated RV if not set by user
            RV_MWCOLORLAW = SIM_MWRV
            write(6,22) RV_MWCOLORLAW, 'Simulation'
         endif

         if ( SETMWCL_USER ) then
            write(6,20) OPT_MWCOLORLAW, 'User (&SNLCINP)'
         else
            ! use simulated color law if not set by user
            OPT_MWCOLORLAW = SIMOPT_MWCOLORLAW
            write(6,20) OPT_MWCOLORLAW, 'Simulation'
         endif

      ENDIF
        
 20   format(T5, 'OPT_MWCOLORLAW -> ',I3   , ' from ', A)
 22   format(T5, 'RV_MWCOLORLAW  -> ',F5.2 , ' from ', A)


      nameOpt = "COLORLAW" // char(0)
      call text_MWoption(nameOpt, OPT_MWCOLORLAW, CTEXT, 8,40)

      LENTEXT = INDEX(CTEXT,char(0)) - 1
      write(6,30) OPT_MWCOLORLAW, CTEXT(1:LENTEXT)
 30   format(T5,'OPT_MWCOLORLAW =  ', I3,' -> ', A )
      call flush(6)

c ---------------------------------------------
c check for option to modify MWEBV; 

      print*,' ' 


      IF ( LDATA ) THEN
         if ( SETEBV_USER ) then
            write(6,21) OPT_MWEBV, 'User (&SNLCINP)'
         else
         ! use default MWEBV map if not set by user
            OPT_MWEBV = OPT_MWEBV_DEFAULT
            write(6,21) OPT_MWEBV, 'Default'
         endif
      ENDIF

 21   format(T5, 'OPT_MWEBV -> ',I3,' from ', A)

      IF ( LSIM_SNANA ) THEN
         if ( SETEBV_USER ) then
            write(6,21) OPT_MWEBV, 'User (&SNLCINP)'
         else
         ! use simulated MWEBV value if option is not set by user
            OPT_MWEBV = 1       ! don't change  MWEBV in sim-data file
            write(6,21) SIMOPT_MWEBV, 'Simulation'
         endif
      ENDIF
        
      nameOpt = "EBV" // char(0)
      call text_MWoption(nameOpt, OPT_MWEBV, CTEXT, 3,40)
      LENTEXT = INDEX(CTEXT,char(0)) - 1
      write(6,40) OPT_MWEBV, CTEXT(1:LENTEXT)
 40   format(T5,'OPT_MWEBV =  ',I3,' -> ', A )
      call flush(6)

      RETURN
      END     ! end of INIT_GALextinct()

C =======================
+PATCH,*CALIB.
C =======================

+DECK,RDKCOR.
      SUBROUTINE RDKCOR( KCORFILE, IERR)

C Created Dec 2012 by R.Kessler
C shell to RDKCOR_FITS.

      IMPLICIT NONE
 
      character KCORFILE*(*)     ! (I) name of hbook file with Kcor tables
      INTEGER IERR               ! (O) 0=OK
     
c local var

+CDE,SNPAR.
+CDE,KCORCOM.

      INTEGER J0, J1, KLEN
      CHARACTER C1ERR*76, C2ERR*76

c function
      INTEGER IGNOREFILE
C --------------- BEGIN --------------

      CALL RDKCOR_INIT()
      KLEN = INDEX(KCORFILE,' ') - 1
      if ( IGNOREFILE(KCORFILE,KLEN) > 0 ) then
        C1ERR = 'Must specifiy kcor/calib file with KCOR_FILE key'
        C2ERR = 'KCOR_FILE contains filter trans, primary ref,' // 
     &             ' AB off, etc'
        CALL MADABORT("RDKCOR", c1err, c2err)
      endif

      J0 = INDEX(KCORFILE,".fits")
      J1 = INDEX(KCORFILE,".FITS")
      ISFITS_RDKCOR = ( J0 .GT. 0 .or. J1 .GT. 0 ) 

      IF ( ISFITS_RDKCOR ) THEN
        CALL RDKCOR_FITS(KCORFILE,IERR)
      ELSE
        C1ERR = 'KCOR_FILE must be a FITS-formatted file.'
        C2ERR = 'see kcor.exe program'
        CALL MADABORT("RDKCOR", c1err, c2err)
      ENDIF

      CALL RDKCOR_SUMMARY

      print*,' '
      print*,'  RDKCOR: Done. '
      print*,' ---------------------------------------------- '
      CALL FLUSH(6)            

c set zeropoints
      CALL SET_ZPOFF

      RETURN
      END  ! end RDKCOR



C ============================
+DECK,RDKINI.
      SUBROUTINE RDKCOR_INIT

C
C Created Dec 2012
c Misc. initializations before reading calib/kcor file.
c [and clean up RDKCOR code]

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.

      INTEGER ifilt, ikcor, i2

C ------------------ BEGIN ----------------

      LVERBOSE_RDKCOR   = .FALSE.

      NCALL_RDKCOR      = NCALL_RDKCOR + 1      
      NKCOR_STORE       = 0
      RDKCOR_STANDALONE = NFILTDEF_SURVEY .EQ. 0

      NFILTDEF_RDKCOR   = 0
      NFILTOBS_RDKCOR   = 0
      NFILT_DUPLICATE_RDKCOR  = 0

      IAV0    = -9  ! bin with AVwarp=0
      IZ0     = -9  ! bin with redshift = 0

c set default Zrange_KCOR to user z-range in case
c there are no K-corrections (i.e, for SALT2)

      Zrange_KCOR(1) = CUTWIN_REDSHIFT(1)
      Zrange_KCOR(2) = CUTWIN_REDSHIFT(2)
      Zbinsize_KCOR  = 0.0


      DO IFILT = 1, MXFILT_ALL
        MAG_PRIMARY_RDKCOR(IFILT)     = 0.0
        ZPOFF_PRIMARY_RDKCOR(ifilt)  = 0.0
        ZPOFF_SNPHOT_RDKCOR(ifilt)   = 0.0
        INDX_PRIMARY_RDKCOR(ifilt)    = 0
        NLAMBIN_FILTOBS(ifilt)        = 0
        NLAMBIN_FILTREST(ifilt)       = 0
        IFILTDEF_RDKCOR(ifilt)        = -9
        IFILTOBS_RDKCOR(ifilt)        = -9

        DO i2 = 1, MXFILT_ALL
            EXIST_KCOR(ifilt,i2) = .FALSE.
        ENDDO

      ENDDO

      DO ikcor = 1, MXKCOR 
        IFILT2_RDKCOR(1,ikcor)       = -9
        IFILT2_RDKCOR(2,ikcor)       = -9
      ENDDO

      RETURN
      END

C ====================
+DECK,RDKCOR_FITS.
      SUBROUTINE RDKCOR_FITS(KCORFILE,IERR)

C Created Dec 2012 by R.Kesseler
C Read calib/kcor file in fits format.
C Long-term goal is to replace HBOOK files with kcor-fits files.

      IMPLICIT NONE
 
      character KCORFILE*(*)   ! (I) name of hbook file with Kcor tables
      INTEGER IERR               ! (O) 0=OK

c local var

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNFILECOM.
+CDE,KCORCOM.

      INTEGER IRDONLY
      PARAMETER ( IRDONLY = 0 )    ! FTOPEN flag
    
      INTEGER  LENF, LENROOT, BLSIZE, ISTAT

      CHARACTER  FNAM*12, TMPFILE*(MXCHAR_FILENAME)

C ------------------ BEGIN ----------------

      IERR = 0
      FNAM = 'RDKCOR_FITS'

      print*,' ' 
      print*,' ============================================= '
      print*,' RDKCOR_FITS: Read Calib/Kcor tables.'
      CALL FLUSH(6)

      LVERBOSE_RDKCOR = .FALSE.

      NULLF_RDKCOR = -999.9  
      NULLI_RDKCOR = -999 
      NULLS_RDKCOR = 'NULL'

c first try to open local file
      TMPFILE = KCORFILE
      ISTAT   = 0
      CALL FTOPEN(LUNKCOR,  TMPFILE, IRDONLY, BLSIZE, ISTAT )
            
      IF ( ISTAT .EQ. 0 ) THEN
          LENF = INDEX(TMPFILE//' ',' ') - 1
          write(6,20) TMPFILE(1:LENF), BLSIZE, ISTAT
          GOTO 400
      ENDIF

c try reading from official area
      LENROOT = INDEX(SNDATA_ROOT,' ')  - 1
      TMPFILE = SNDATA_ROOT(1:LENROOT) // '/kcor/' // KCORFILE
      ISTAT = 0      
      CALL FTOPEN(LUNKCOR,  TMPFILE, IRDONLY, BLSIZE, ISTAT )
      IF ( ISTAT .EQ. 0 ) THEN
          LENF = INDEX(TMPFILE//' ',' ') - 1
          write(6,20) TMPFILE(1:LENF), BLSIZE, ISTAT
          GOTO 400
      ENDIF

20    format(T5,'Opened ', A, /, T5, 
     &    'with Blocksize=',I3, 3x, 'and ISTAT=',I6)


c if we get here, abort.
      lenf = INDEX(KCORFILE//' ',' ') - 1
      c1err = 'Could not open ' // KCORFILE(1:LENF)
      c2err = 'Check local dir and $SNDATA_ROOT/kcor'
      CALL MADABORT(FNAM, C1ERR, C2ERR )

c -----------------------
400   CONTINUE
c -----------------------

      print*,' ' ; call flush(6)

      CALL RDKCOR_FITS_HEAD(LUNKCOR)
      CALL RDKCOR_FITS_ZPT(LUNKCOR)
      CALL RDKCOR_FITS_SNSED(LUNKCOR)
      CALL RDKCOR_FITS_KCOR(LUNKCOR)
      CALL RDKCOR_FITS_MAGS(LUNKCOR)
      CALL RDKCOR_FITS_FILTERS(LUNKCOR)
      CALL RDKCOR_FITS_PRIMARYSED(LUNKCOR)

c -------------------------
      print*,'     FTCLOSE  ' ; call flush(6)
      ISTAT = 0
      CALL FTCLOS(LUNKCOR, ISTAT)

      RETURN
      END


C =======================================
+DECK,RDKFIHDU.
      SUBROUTINE RDKCOR_FITS_NEXTHDU(LUN,FNAM)

      IMPLICIT NONE

c subroutine args
      INTEGER LUN         ! (I) 
      CHARACTER FNAM*(*)  ! (I) name of calling function 

c local args

      INTEGER NMOVE, HDUTYPE, ISTAT
      CHARACTER C1ERR*72, C2ERR*72

C ------------- BEGIN --------------

      NMOVE = 1
      CALL FTMRHD(LUN, NMOVE, HDUTYPE, ISTAT)

      IF ( ISTAT .NE. 0 ) THEN
         CALL PRINT_PREABORT_BANNER("RDKCOR_FITS_NEXTHDU"//char(0),40)
         print*, ' FTMRHD ISTAT=', ISTAT
         write(C1ERR,61) LUN
61       format('Error moving to next HDU: LUN=',I4);
         C2ERR = 'called from ' // FNAM(1:40)
         CALL MADABORT('RDKCOR_FITS_NEXTHDU', C1ERR, C2ERR)
      ENDIF

      RETURN
      END

C =======================================
+DECK,RDKCOR_FITS_HEAD.
      SUBROUTINE RDKCOR_FITS_HEAD(LUN)
      IMPLICIT NONE


c Dec 5 2013: set ZRANGE_KCOR only if ZMAX > 0
c July  2016: read optional spectrograph info

c subroutine args.
      INTEGER LUN  ! (I) read from this LUN


c local args

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,CTRLCOM.

      INTEGER  i, ISTAT, LL, IFILTDEF, ISTAT1, ISTAT2, NFLAMSHIFT

      CHARACTER  
     &   FNAM*20, KEYWORD*40
     &  ,COMMENT*80, STRING_TMP*60, CFILT*4
     &  ,C1ERR*72, C2ERR*72

      INTEGER FILTINDX
      REAL    ZMIN, ZMAX

C ------------------ BEGIN ----------------

      FNAM = 'RDKCOR_FITS_HEAD'
      print*,'     ', FNAM
      call flush(6)

c read header keys
      ISTAT = 0

c - - - - -  RDKCOR VERSION - - - - - - -
      KEYWORD = 'VERSION'
      CALL FTGKYJ(LUN, KEYWORD, IVER_RDKCOR, COMMENT, istat)
      IF ( ISTAT .EQ. 0 ) THEN
         write(6,600) KEYWORD, IVER_RDKCOR, '(kcor.exe version)'
      ELSE
         CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)
      ENDIF

c - - - - - NPRIM - - - - - - -
      KEYWORD = 'NPRIM'
      CALL FTGKYJ(LUN, KEYWORD, NPRIM_RDKCOR, COMMENT, istat)
      IF ( ISTAT .EQ. 0 ) THEN
         write(6,600) KEYWORD, NPRIM_RDKCOR, 'primary refs'
      ELSE
         CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)
      ENDIF


c read and store PRIMARY_NAME_RDKCOR(iprim)
      DO 110 i = 1, NPRIM_RDKCOR
         write(KEYWORD,111) i
111      format('PRIM', I3.3)

         CALL FTGKYs(LUN, KEYWORD, STRING_TMP, COMMENT, istat)
         IF ( ISTAT .EQ. 0 ) THEN
           LL = INDEX(STRING_TMP,' ') - 1
           PRIMARY_NAME_RDKCOR(i) = STRING_TMP(1:LL)
           IF ( LVERBOSE_RDKCOR ) write(6,610) STRING_TMP(1:LL)           
         ELSE
           CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)
         ENDIF

110   CONTINUE

c - - - - - NFILTERS - - - - - - -
      KEYWORD = 'NFILTERS'
      ISTAT = 0
      CALL FTGKYJ(LUN, KEYWORD, NFILTDEF_RDKCOR, COMMENT, istat)
      IF ( ISTAT .EQ. 0 ) THEN
         write(6,600) KEYWORD, NFILTDEF_RDKCOR, 'filters'
      ELSE
         CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)
      ENDIF


c read FILTER strings.
      NFLAMSHIFT = 0 ; ISLAMSHIFT_RDKCOR(0) = .FALSE.

      DO 210 i = 1, NFILTDEF_RDKCOR
         write(KEYWORD,211) i
211      format('FILT', I3.3)

         CALL FTGKYs(LUN, KEYWORD, STRING_TMP, COMMENT, istat)
         IF ( ISTAT .EQ. 0 ) THEN
           LL = INDEX(STRING_TMP,' ')-1
           IFILTDEF = FILTINDX(STRING_TMP)    ! convert to int index
           IFILTDEF_RDKCOR(i)    = IFILTDEF
           FILTER_NAME_RDKCOR(i) = STRING_TMP(1:40)
           MASKFILT_RDKCOR(i)    = 0    ! bit0,1 -> rest,obs

           IF ( STRING_TMP(1:1) .EQ. '*' ) THEN
              ISLAMSHIFT_RDKCOR(i) = .TRUE.  ! lam-shifted band
              NFLAMSHIFT = NFLAMSHIFT + 1
           ELSE
              ISLAMSHIFT_RDKCOR(i) = .FALSE.
           ENDIF

           IF ( LVERBOSE_RDKCOR ) then
              write(6,608) IFILTDEF, STRING_TMP(1:20)
           ENDIF
         ELSE
           CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)
         ENDIF

210   CONTINUE

c check for global set of LAM-shifted bands
      IF ( NFLAMSHIFT > 0 ) THEN
        IF ( NFLAMSHIFT == NFILTDEF_RDKCOR/2 ) THEN
           NFILTDEF_RDKCOR = NFLAMSHIFT 
           ISLAMSHIFT_RDKCOR(0) = .TRUE.  
        ELSE
           write(C1ERR,61) NFLAMSHIFT, NFILTDEF_RDKCOR
 61        format('NFLAMSHIFT=',I3,' != NFILT_RDKCOR/2 =',I3,'/2' )
           C2ERR = 'Check LAM-shifted bads in kcor file.'
           CALL MADABORT(FNAM,C1ERR,C2ERR)
        ENDIF
      ENDIF
c - - -  RV and color law - - - -
c These are there only if NKCOR > 0, so no error checking.

      RVMW_RDKCOR = -9.0
      OPT_MWCOLORLAW_RDKCOR = 94 ! this is value if not in header

      KEYWORD = 'RV'
      CALL FTGKYE(LUN, KEYWORD, RVMW_RDKCOR, COMMENT, istat)

      KEYWORD = 'OPT_MWCOLORLAW'
      CALL FTGKYJ(LUN, KEYWORD, OPT_MWCOLORLAW_RDKCOR, COMMENT, istat)      

c - - - - - NKCOR - - - - - - -
      KEYWORD = 'NKCOR'
      ISTAT = 0
      CALL FTGKYJ(LUN, KEYWORD, NKCOR_RDKCOR, COMMENT, istat)
      IF ( ISTAT .EQ. 0 ) THEN
         write(6,600) KEYWORD, NKCOR_RDKCOR, 'K-COR tables'
      ELSE
         CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)
      ENDIF
      IF ( NKCOR_RDKCOR > MXKCOR ) THEN
        write(C1ERR,261) NKCOR_RDKCOR, MXKCOR
261     format('NKCOR_RDKCOR =', I3,' exceeds bound of MXKCOR=',I3)
        C2ERR = 'Check NKCOR in header and MXKCOR in snana.car'
        CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF 

c read KCOR strings.
      DO 220 i = 1, NKCOR_RDKCOR
         write(KEYWORD,221) i
221      format('KCOR', I3.3)

         CALL FTGKYs(LUN, KEYWORD, STRING_TMP, COMMENT, istat)

         IF ( ISTAT .EQ. 0 ) THEN         
           KCORINFO_STRING_RDKCOR(i) = STRING_TMP
           IF (LVERBOSE_RDKCOR) write(6,610) STRING_TMP
         ELSE
           CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)
         ENDIF

220   CONTINUE

600   format(T10, 'Read ',A12, ' = ',I3, 2x, A)
608   format(T15,'-> (',I2.2,') ', A)
610   format(T15,'-> ', A)

c -------------------------
c read kcor binning info

      ISTAT = 0


c Lambda bins
      KEYWORD = 'NBL'
      CALL FTGKYJ(LUN, KEYWORD, NLBIN_SNSED, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)      

      KEYWORD = 'LBIN'
      CALL FTGKYE(LUN, KEYWORD, LBINSIZE_SNSED, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)

      KEYWORD = 'LMIN'
      CALL FTGKYE(LUN, KEYWORD, LRANGE_SNSED(1), COMMENT, istat)
      IF ( ISTAT .NE. 0 ) CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)    

      KEYWORD = 'LMAX'
      CALL FTGKYE(LUN, KEYWORD, LRANGE_SNSED(2), COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)    

c epoch bins
      KEYWORD = 'NBT'
      CALL FTGKYJ(LUN, KEYWORD, NTBIN_KCOR, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)      


      KEYWORD = 'TBIN'
      CALL FTGKYE(LUN, KEYWORD, TBINSIZE_KCOR, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)

      KEYWORD = 'TMIN'
      CALL FTGKYE(LUN, KEYWORD, TRANGE_KCOR(1), COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)    

      KEYWORD = 'TMAX'
      CALL FTGKYE(LUN, KEYWORD, TRANGE_KCOR(2), COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)    

c redshift bins
      KEYWORD = 'NBZ'
      CALL FTGKYJ(LUN, KEYWORD, NZBIN_KCOR, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)      

      KEYWORD = 'ZBIN'
      CALL FTGKYE(LUN, KEYWORD, ZBINSIZE_KCOR, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)

      KEYWORD = 'ZMIN'
      CALL FTGKYE(LUN, KEYWORD, ZMIN, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)    

      KEYWORD = 'ZMAX'
      CALL FTGKYE(LUN, KEYWORD, ZMAX, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)    

      IF ( ZMAX > 0.0 ) THEN   ! Dec 2013
        ZRANGE_KCOR(1) = ZMIN
        ZRANGE_KCOR(2) = ZMAX
      ENDIF


c set Kcor lookup range to table size by default.
c User can extend the ranage if extrapolation is desired.

        Zrange_KCOR_LU(1) = Zrange_KCOR(1)
        Zrange_KCOR_LU(2) = Zrange_KCOR(2)

c Av bins
      KEYWORD = 'NBAV'
      CALL FTGKYJ(LUN, KEYWORD, NAVBIN_KCOR, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)      

      KEYWORD = 'AVBIN'
      CALL FTGKYE(LUN, KEYWORD, AVBINSIZE_KCOR, COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)

      KEYWORD = 'AVMIN'
      CALL FTGKYE(LUN, KEYWORD, AVRANGE_KCOR(1), COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)    

      KEYWORD = 'AVMAX'
      CALL FTGKYE(LUN, KEYWORD, AVRANGE_KCOR(2), COMMENT, istat)
      CALL RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)     

c --------------------------------------------------------
c  July 2016 : read optional spectrograph information
      KEYWORD = 'SPECTROGRAPH_INSTRUMENT'
      CALL FTGKYs(LUN, KEYWORD, SPECTROGRAPH_INSTRUMENT,COMMENT,istat1)
      KEYWORD = 'SPECTROGRAPH_FILTERLIST'
      CALL FTGKYs(LUN, KEYWORD, SPECTROGRAPH_FILTERLIST,COMMENT,istat2)
      IF ( ISTAT1 == 0 .and. ISTAT2 == 0 ) THEN
         NFILTDEF_SPECTROGRAPH = INDEX(SPECTROGRAPH_FILTERLIST,' ')-1
         do i = 1, NFILTDEF_SPECTROGRAPH
           cfilt    = SPECTROGRAPH_FILTERLIST(i:i)
           IFILTDEF = FILTINDX(cfilt // ' ')
           IFILTDEF_SPECTROGRAPH(i) = IFILTDEF
         end do
      ENDIF

c --------------------------------------------------------

c -----------
c error checking on number of bins
      CALL RDKCOR_CHECK_BINS()

c compute element for each grid point in each dimension
      CALL RDKCOR_SETGRIDVAL()

      RETURN
      END           ! RDKCOR_FITS_HEAD


C =======================================
+DECK,RDKFZPT.
      SUBROUTINE RDKCOR_FITS_ZPT(LUN)

c read filter-dependent info:
c FilterName  PrimaryName  PrimaryMag  ZPTOFF(prim)  ZPTOFF(filt)
c

      IMPLICIT NONE

      INTEGER LUN  ! (I) read from this LUN

+CDE,SNPAR.
+CDE,KCORCOM.

      CHARACTER 
     &   FNAM*16
     &  ,NAME_PRIM1*80, NAME_PRIM2*80
     &  ,C1ERR*72, C2ERR*72

      INTEGER  
     &   firstrow, firstelem
     &  ,ifilt, istat, L1, L2
     &  ,iprim, iprim_store

      INTEGER
     &   ICOL_FILTER_NAME
     &  ,ICOL_PRIMARY_NAME
     &  ,ICOL_PRIMARY_MAG
     &  ,ICOL_PRIMARY_ZPTOFF
     &  ,ICOL_FILTER_ZPTOFF

      PARAMETER ( 
     &   ICOL_FILTER_NAME    = 1
     &  ,ICOL_PRIMARY_NAME   = 2
     &  ,ICOL_PRIMARY_MAG    = 3
     &  ,ICOL_PRIMARY_ZPTOFF = 4
     &  ,ICOL_FILTER_ZPTOFF  = 5
     &     )

C ----------------- BEGIN ----------------

      FNAM = 'RDKCOR_FITS_ZPT'
      print*,'     ', FNAM
      call flush(6)

      firstrow  = 1
      firstelem = 1
      istat     = 0

      CALL RDKCOR_FITS_NEXTHDU(LUN,FNAM)

c read one string at a time.

      DO 100 IFILT=1, NFILTDEF_RDKCOR
        
        CALL FTGCVS(LUN, ICOL_PRIMARY_NAME, IFILT, firstelem, 
     &       ONE, nulls_rdkcor, 
     &       NAME_PRIM1, anyf_rdkcor, istat)  ! return args
        CALL RDKCOR_ABORT(FNAM, 'PRIMARY_NAME', ISTAT)

        iprim_store = -9
        L1 = INDEX(NAME_PRIM1,' ') - 1

c find IPRIM index
         DO 101 iprim = 1, NPRIM_RDKCOR
            NAME_PRIM2 = PRIMARY_NAME_RDKCOR(iprim)
            L2 = INDEX(NAME_PRIM2,' ') - 1
            if ( L1 .NE. L2 ) goto 101
            if ( NAME_PRIM1(1:L1) .EQ. NAME_PRIM2(1:L2) ) then
               iprim_store = iprim
            endif        
101      CONTINUE

         if ( iprim_store .LT. 0 ) then
            c1err = 'Unrecognized PRIMARY_NAME = ' // NAME_PRIM1(1:L1)
            c2err = 'Check ZPT table'
            CALL MADABORT(FNAM, C1ERR,C2ERR)
         endif         
 
         INDX_PRIMARY_RDKCOR(ifilt) = IPRIM_STORE
100   CONTINUE
      
      CALL FTGCVe(LUN, ICOL_PRIMARY_MAG, firstrow, firstelem, 
     &    NFILTDEF_RDKCOR, nullf_RDKCOR, 
     &    MAG_PRIMARY_RDKCOR, anyf_rdkcor, istat)  ! return args
      CALL RDKCOR_ABORT(FNAM, 'MAG_PRIMARY', ISTAT)


      CALL FTGCVe(LUN, ICOL_PRIMARY_ZPTOFF, firstrow, firstelem, 
     &    NFILTDEF_RDKCOR, nullf_rdkcor, 
     &    ZPOFF_PRIMARY_RDKCOR, anyf_rdkcor, istat)  ! return args
      CALL RDKCOR_ABORT(FNAM, 'ZPOFF_PRIMARY', ISTAT)


      CALL FTGCVe(LUN, ICOL_FILTER_ZPTOFF, firstrow, firstelem, 
     &    NFILTDEF_RDKCOR, nullf_rdkcor, 
     &    ZPOFF_SNPHOT_RDKCOR, anyf_rdkcor, istat)  ! return args
      CALL RDKCOR_ABORT(FNAM, 'ZPOFF_SNPHOT', ISTAT)

      LRDZPOFF = .TRUE.  ! flag to NOT read legacy ZPOFF from disk

c -----------------------------
      IF ( LVERBOSE_RDKCOR ) THEN

        print*,' ' 
        print*,' DUMP FOR: ', FNAM
        print*,' ' 
        print*,'            Prim.   Prim.    Prim.    Filter'
        print*,'  Filter    Index   Mag      ZPTOFF   ZPTOFF'
        print*,' -------------------------------------------'
        DO ifilt = 1, NFILTDEF_RDKCOR
          write(6,660) 
     &       FILTER_NAME_RDKCOR(ifilt)
     &      ,INDX_PRIMARY_RDKCOR(ifilt)
     &      ,MAG_PRIMARY_RDKCOR(ifilt)
     &      ,ZPOFF_PRIMARY_RDKCOR(ifilt)
     &      ,ZPOFF_SNPHOT_RDKCOR(ifilt)
        ENDDO
660     format(T2,A12, T16,I2, T21,F6.3, T28,2F9.3)
      ENDIF

      RETURN
      END

C =======================================
+DECK,RDKCOR_FITS_SNSED.
      SUBROUTINE RDKCOR_FITS_SNSED(LUN)

c Read template SN SED vs. epoch i.e., Hsiao 2007 

      IMPLICIT NONE

      INTEGER LUN  ! (I) read from this LUN

+CDE,SNPAR.
+CDE,KCORCOM.

      INTEGER ICOL, FIRSTELEM, FIRSTROW, NROW, ISTAT 
      CHARACTER  FNAM*18

C ----------------- BEGIN ---------------

      FNAM = 'RDKCOR_FITS_SNSED'
      print*,'     ', FNAM
      call flush(6)

      CALL RDKCOR_FITS_NEXTHDU(LUN,FNAM)
    
      NROW      = NLbin_SNSED * NTBIN_KCOR
      ISTAT     = 0
      ICOL      = 1
      FIRSTROW  = 1
      FIRSTELEM = 1

      CALL FTGCVe(LUN, ICOL, firstrow, firstelem, 
     &    NROW, nullf_rdkcor, 
     &    FLUX_SNSED, anyf_rdkcor, istat)  ! return args
      CALL RDKCOR_ABORT(FNAM, 'SNSED', ISTAT)

      RETURN
      END


C ========================================
+DECK,RDKCOR_FITS_KCOR.
      SUBROUTINE RDKCOR_FITS_KCOR(LUN)


c Examine K_xy to flag which filters are OBS and REST.
c If there are no K-cor tables, then any SURVEY filter
c is defined as an OBS filter. 
c
c After defining filters, read KCOR tables.
c
c Feb 25 2013: fix bug, check for BX before INIT_KCOR_INDICES
c              (333 loop)
c 
c Aug 4 2019: IBKCOR starts at 0 (not 1) for C function get_1DINDEX


      IMPLICIT NONE

      INTEGER LUN  ! (I) read from this LUN

+CDE,SNDATCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER 
     &   ikcor, i, ifilt_rest, ifilt_obs, ifilt
     &  ,ICOL, FIRSTELEM, FIRSTROW, NROW, ISTAT 
     &  ,ifiltr, ifilto 
     &  ,IBKCOR(NKDIM)
     &  ,IBIN_FIRST, IBIN_LAST, ibin, NBIN_TOT
     &  ,LENr, LENo, LEN

      LOGICAL LBX, LTMP 

      REAL    R4CRAZY

      CHARACTER  
     &   FNAM*18, STRKCOR*60, CKCOR*4
     &  ,CFILT_REST*40
     &  ,CFILT_OBS*40
     &  ,CFILT*40

c functions
      LOGICAL ISBXFILT
      INTEGER FILTINDX, GET_1DINDEX
 
C ----------------- BEGIN ---------------

      FNAM = 'RDKCOR_FITS_KCOR'
      print*,'     ', FNAM
      call flush(6)
       

      CALL RDKCOR_FITS_NEXTHDU(LUN,FNAM)

      if ( NKCOR_RDKCOR .EQ. 0 ) RETURN
    
c loop over kcor strings from header and 
c identify and store REST-frame filters.
c If STANDALONE mode, then load OBS-frame filters as well.

      DO 100 ikcor = 1, NKCOR_RDKCOR
         STRKCOR = KCORINFO_STRING_RDKCOR(ikcor)
         CALL PARSKCOR(STRKCOR, ckcor, cfilt_rest, cfilt_obs)
 
c convert filter strings to absolute filter indices

         ifilt_rest = FILTINDX(cfilt_rest)
         ifilt_obs  = FILTINDX(cfilt_obs )


c if this IFILT_OBS is not a SURVEY filter, then bail.
c i.e., ignore K_xy that include extra unused filters.
         ifilto = IFILTDEF_INVMAP_SURVEY(ifilt_obs)
         if ( ifilto < 0 ) goto 100

         FILTREST_NAME(ifilt_rest)    = cfilt_rest
         FILTOBS_NAME(ifilt_obs)      = cfilt_obs
         
         EXIST_KCOR(ifilt_rest,ifilt_obs) = .TRUE.

c find rdkcor filter index and sent mask for REST or OBS

         LENo = INDEX(cfilt_obs, ' ')-1
         LENr = INDEX(cfilt_rest,' ')-1
         DO 102 i = 1, NFILTDEF_RDKCOR
           CFILT  = FILTER_NAME_RDKCOR(i)
           LEN    = INDEX(CFILT,' ') - 1

           LTMP = cfilt_rest(1:LENr) .EQ. cfilt(1:LEN)
           if ( LEN .EQ. LENr .and. LTMP ) then
             MASKFILT_RDKCOR(i) = IBSET(MASKFILT_RDKCOR(i),0)
           endif

           LTMP = cfilt_obs(1:LENo) .EQ. cfilt(1:LEN)
           if ( LEN .EQ. LENo .and. LTMP ) then
               MASKFILT_RDKCOR(i) = IBSET(MASKFILT_RDKCOR(i),1)
           endif

102      CONTINUE

c check if this is a BX filter (global logicals are set)         
         LBX = ISBXFILT(ifilt_obs,  cfilt_obs,  'OBS')
         LBX = ISBXFILT(ifilt_rest, cfilt_rest, 'REST')

         IF ( RDKCOR_STANDALONE .and. 
     &         IFILTDEF_INVMAP_SURVEY(ifilt_obs) .LE. 0 ) THEN
            NFILTDEF_SURVEY = NFILTDEF_SURVEY + 1
            IFILTDEF_MAP_SURVEY(NFILTDEF_SURVEY) = IFILT_OBS
            IFILTDEF_INVMAP_SURVEY(ifilt_obs)    = NFILTDEF_SURVEY   
         ENDIF

c if we have an undefined filter, then abort
          LTMP = ( ifilt_rest .LE. 0 .or. ifilt_obs .LE. 0 ) 
          if ( LTMP .and. ABORT_ON_BADKCOR ) then
            write(c1err,668) ckcor, ifilt_rest, ifilt_obs
668         format('Undefined Kcor: ',A, 3x,'IFILT(REST,OBS)=',2I3)
            c2err = 'Check filters in Kcor file.'
            CALL MADABORT(FNAM, c1err, c2err)
          endif

c define new rest-filter only if not already defined.
          CALL RDKCOR_ADDFILT_REST(ifilt_rest)
         
c if obs filter is not part of the survey, just skip it;
c allows defining filter sub-sets of a survey without having 
c to change the Kcor file.

c xxx this line does nothing since IFILT isn't set
c xxx mark delete Oct 29 2019  IF ( IFILT .GT. NFILTDEF_SURVEY ) GOTO 100

          if ( EXIST_BXFILT_OBS .and. RDKCOR_STANDALONE ) goto 100

c increment number of KCOR tables to read.
          NKCOR_STORE                   = NKCOR_STORE + 1
          IFILT2_RDKCOR(OPT_FILTREST,NKCOR_STORE) = ifilt_rest
          IFILT2_RDKCOR(OPT_FILTOBS,NKCOR_STORE)  = ifilt_obs

          IKCOR_RDKCOR(NKCOR_STORE)     = ikcor  ! store orig. column

100   CONTINUE  ! ikcor



c ----------------------------------------
c BX check:
c loop over defined filters (from header) ;
c if undefined rest-frame X filter exists, then add it
c to the rest-frame list. This allows Landolt option 
c in fitting program without having to explicitly
c define a K-correction the X filter.
c Feb 25 2013: must call before INIT_KCOR_INDICES !!!


      DO 333 i = 1, NFILTDEF_RDKCOR
         CFILT = FILTER_NAME_RDKCOR(i)
         if ( FILTINDX(CFILT) .NE. IFILT_BESS_BX ) goto 333

         CALL RDKCOR_ADDX_REST(cfilt) 

c set mask-bit if BX is set.
         ifiltr    = IFILTDEF_INVMAP_REST(IFILT_BESS_BX)
         if ( ifiltr > 0 ) then
            MASKFILT_RDKCOR(i) = IBSET(MASKFILT_RDKCOR(i),0)
         endif

         if ( LVERBOSE_RDKCOR ) then
            write(6,44) CFILT(1:16), MASKFILT_RDKCOR(i)
44          format(T12,'MASKFRAME(',A,') = ', I3 )
         endif
333   CONTINUE


c ----------------------------------------------

c init multi-dimensional array to store KCOR tables
      CALL INIT_KCOR_INDICES

c =============================
c if user has specified any MAGOBS_SHIFT_PRIMARY, MAGOBS_SHIFT_ZP,
c (and same for REST) for a non-existant filter, then ABORT ...
c 
      CALL  RDKCOR_CHECK_MAGSHIFTS


c Loop again over Kcors that have been flagged for reading/storage.
c i.e,, ignore those for which the obs-frame filter is not defined.

      NROW      = NTBIN_KCOR * NZbin_KCOR * NAVbin_KCOR
      NBIN_TOT  = NROW * NFILTDEF_REST * NFILTDEF_SURVEY
      ISTAT     = 0
      FIRSTROW  = 1
      FIRSTELEM = 1

      R4CRAZY = 9999.9
      DO ibin = 1, NBIN_TOT
        R4KCORTABLE1D(ibin)  = R4CRAZY  ! init to crazy value
      ENDDO

      DO 200 i      = 1, NKCOR_STORE
         ifilt_obs  = IFILT2_RDKCOR(OPT_FILTOBS,i)
         ifilt_rest = IFILT2_RDKCOR(OPT_FILTREST,i)
         ikcor      = IKCOR_RDKCOR(i)
         icol       = ikcor + 3  ! skip T,Z,AV columns

         STRKCOR = KCORINFO_STRING_RDKCOR(ikcor)
         CALL RDKCOR_CHECK_IFILT(ifilt_rest,ifilt_obs,STRKCOR)

c     get sparse filter indices
         ifiltr = IFILTDEF_INVMAP_REST(ifilt_rest)
         ifilto = IFILTDEF_INVMAP_SURVEY(ifilt_obs)

         if ( ifilto .LE. 0 ) then
            c1err = 'Invalid obs-filter for'
            c2err = STRKCOR  
            CALL MADABORT(FNAM,C1ERR,C2ERR)   
         endif

c get starting 1D bin for this KCOR
         IBKCOR(KDIM_ifiltr) = ifiltr - 1
         IBKCOR(KDIM_ifilto) = ifilto - 1
         IBKCOR(KDIM_T)      = 0
         IBKCOR(KDIM_Z)      = 0
         IBKCOR(KDIM_AV)     = 0
         IBIN_FIRST          = GET_1DINDEX(IDMAP_KCOR,NKDIM,IBKCOR)+1
         IBIN_LAST           = IBIN_FIRST + NROW - 1

c read table from fits file.
         CALL FTGCVe(LUN, ICOL, firstrow, firstelem, 
     &      NROW, nullf_rdkcor, 
     &      R4KCORTABLE1D(IBIN_FIRST),     ! return arg
     &      anyf_rdkcor, istat)            ! return arg

         CALL RDKCOR_ABORT(FNAM, STRKCOR, ISTAT) ! error check

c apply user mag-shifts
         DO ibin = IBIN_FIRST, IBIN_LAST
            R4KCORTABLE1D(ibin) 
     &         = R4KCORTABLE1D(ibin) 
     &         - MAGREST_SHIFT_PRIMARY_FILT(ifilt_rest)
     &         + MAGOBS_SHIFT_PRIMARY_FILT(ifilt_obs)
         ENDDO 

200   CONTINUE

c xxxxxxxxxxxx
c      DO ibin = 1, NBIN_TOT
c        write(6,690) ibin-1, R4KCORTABLE1D(ibin) 
c690     format(' xxx KCORTABLE1D(',I7,') = ', F10.5 );   call flush(6)
c      ENDDO
c xxxxxxxxx


      RETURN
      END

C ========================================
+DECK,RDKFMAGS.
      SUBROUTINE RDKCOR_FITS_MAGS(LUN)

c Read LCMAG table for each rest-filter,
c and read MWXT-slope for each obs-filter.
c The columns for this table are
c   1-3: T,Z,AV
c   4 - 3+NFILTDEF_RDKCOR      :  MAGOBS(T,Z,AV)
c   Next NFILTDEF_RDKCOR bins  :  MWXTSLP(T,Z,AV) 
c
c Store info only for filters that are used in a K-cor.
c 
c Aug 4 2019: IBLCMAG & IBMWXT starts at 0 instead of 1
c
c ---------------

      IMPLICIT NONE

      INTEGER LUN  ! (I) read from this LUN

+CDE,SNDATCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.


      INTEGER 
     &   ifilt_rest, ifilt_obs, ifilt, MASK
     &  ,FIRSTELEM, FIRSTROW, NROW, ISTAT 
     &  ,ICOL_LCMAG, ICOL_MWXT
     &  ,ifiltr, ifilto
     &  ,IBLCMAG(N4DIM)
     &  ,IBMWXT(N4DIM)
     &  ,IBIN_FIRST, IBIN_LAST, ibin, NBTOT

      LOGICAL LBX, ISREST, ISOBS, USE
      CHARACTER   FNAM*18, ERRMSG*60, CFILT*40 

c functions
      LOGICAL ISBXFILT
      INTEGER FILTINDX, GET_1DINDEX
 
C ----------------- BEGIN ---------------

      FNAM = 'RDKCOR_FITS_MAGS'
      print*,'     ', FNAM
      call flush(6)
       
      CALL RDKCOR_FITS_NEXTHDU(LUN,FNAM)

      if ( NKCOR_RDKCOR .EQ. 0 ) RETURN

      NROW      = NTBIN_KCOR * NZbin_KCOR * NAVbin_KCOR
      ISTAT     = 0
      FIRSTROW  = 1
      FIRSTELEM = 1

      IBMWXT(KDIM_T)  = 0
      IBMWXT(KDIM_Z)  = 0
      IBMWXT(KDIM_AV) = 0

      IBLCMAG(KDIM_T)  = 0
      IBLCMAG(KDIM_Z)  = 0
      IBLCMAG(KDIM_AV) = 0

      DO 200 ifilt  = 1, NFILTDEF_RDKCOR

        CFILT  = FILTER_NAME_RDKCOR(ifilt)
        MASK   = MASKFILT_RDKCOR(ifilt)

        ISREST = BTEST(MASK,OPT_FILTREST-1)
        ISOBS  = BTEST(MASK,OPT_FILTOBS -1)
        USE    = (ISOBS .OR. ISREST)
        IF ( .NOT.  USE  ) GOTO 200

        IFILT_REST = FILTINDX(CFILT)
        IFILT_OBS  = FILTINDX(CFILT)

        ICOL_LCMAG   = 3 + ifilt  ! skip T,Z,AV columns
        ICOL_MWXT    = ICOL_LCMAG + NFILTDEF_RDKCOR

        IF ( ISREST ) then
          ifiltr       = IFILTDEF_INVMAP_REST(ifilt_rest)
          IBLCMAG(4)   = ifiltr - 1
          IBIN_FIRST   = GET_1DINDEX(IDMAP_LCMAG,N4DIM,IBLCMAG)+1
          IBIN_LAST    = IBIN_FIRST + NROW - 1

          IF ( IBIN_FIRST .LE. 0 ) THEN
             write(c1err,61) 'LCMAG', IBIN_FIRST
             write(c2err,62) 'REST', CFILT(1:12), ifiltr
             CALL MADABORT(FNAM,C1ERR,C2ERR)
          ENDIF
61         format('Invalid IBIN_FIRST(', A, ') = ', I8)
62         format('for ', A,'-filter = ', A, '(', I2,')' )
  
c read table from fits file.
          CALL FTGCVe(LUN, ICOL_LCMAG, firstrow, firstelem, 
     &       NROW, nullf_rdkcor, 
     &       LCMAG_TABLE1D(IBIN_FIRST),     ! return arg
     &       anyf_rdkcor, istat)            ! return arg

           ERRMSG = 'LCMAG-' // cfilt(1:30)
           CALL RDKCOR_ABORT(FNAM, ERRMSG, ISTAT) ! error check

c apply user mag-shifts
           DO ibin = IBIN_FIRST, IBIN_LAST
              LCMAG_TABLE1D(ibin) =
     &           LCMAG_TABLE1D(ibin) 
     &         + MAGREST_SHIFT_PRIMARY_FILT(ifilt_rest)
     &         + PEAKMAG_AT_10PC
           ENDDO

        ENDIF

c now get MWXT cor for obs-frame filters.

        LBX = (RDKCOR_STANDALONE .and. 
     &             ISBXFILT(ifilt_obs,'','OBS'))

        IF ( ISOBS .and. (.not.LBX) ) then
          ifilto       = IFILTDEF_INVMAP_SURVEY(ifilt_obs)
          IBMWXT(4)    = ifilto-1
          IBIN_FIRST   = GET_1DINDEX(IDMAP_MWXT,N4DIM,IBMWXT)+1
          IBIN_LAST    = IBIN_FIRST + NROW - 1

          IF ( IBIN_FIRST .LE. 0 ) THEN
             write(c1err,61) 'MWXT', IBIN_FIRST
             write(c2err,62) 'OBS', CFILT(1:12), ifilto              
             CALL MADABORT(FNAM,C1ERR,C2ERR)
          ENDIF

c read table from fits file.
          CALL FTGCVe(LUN, ICOL_MWXT, firstrow, firstelem, 
     &       NROW, nullf_rdkcor, 
     &       MWXT_TABLE1D(IBIN_FIRST),     ! return arg
     &       anyf_rdkcor, istat)            ! return arg

           ERRMSG = 'MWXT-slope-' // cfilt(1:20)
           CALL RDKCOR_ABORT(FNAM, ERRMSG, ISTAT) ! error check
        ENDIF


200   CONTINUE


c - - - - - -
+SELF,IF=DUMP_ENTIRE_TABLE.
      NBTOT = NROW * NFILTDEF_REST
      DO ibin = 1, NBTOT
         write(6,661) ibin, LCMAG_TABLE1D(ibin)
661      format(' CHECK LCMAG_TABLE1D[',I6,'] = ', F8.4)
      ENDDO

      NBTOT = NROW * NFILTDEF_SURVEY
      DO ibin = 1, NBTOT
         write(6,662) ibin, MWXT_TABLE1D(ibin)
662      format(' CHECK MWXT_TABLE1D[',I6,'] = ', F8.4)
      ENDDO
+SELF.

      RETURN
      END  ! end RDKCOR_FITS_MAGS

C ========================================
+DECK,RDKFFILT.
      SUBROUTINE RDKCOR_FITS_FILTERS(LUN)

C
C Dec 2012 
c read filter transmissions and call LOAD_FILTTRANS
c separately for REST and OBS filters.
C
C May 2017:  fetch filter column from integer function 
C            ICOL_FILTER_RDKCOR(IFILT) to check option of reading
C            lam-shifted band (see DUPLICATE_LAMSHIFT_GLOBAL key
C            in kcor-input file).
C

      IMPLICIT NONE

      INTEGER LUN  ! (I) read from this LUN

+CDE,SNDATCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER 
     &   IFILT, IFILTDEF, IFILT_REST, IFILT_OBS
     &  ,FIRSTROW, FIRSTELEM, ISTAT, ICOL, MASK, NMATCH_OBS

      REAL
     &   ARRAY_LAM(MXLAMBIN_PRIM)
     &  ,ARRAY_TRANS(MXLAMBIN_PRIM)
     &  ,LAMSHIFT

      CHARACTER FNAM*20, ERRMSG*60, CFILT*40, FILTLIST_RDKCOR*80

      LOGICAL  LBX  

c functions
      LOGICAL  ISBXFILT 

C ------------ BEGIN ------------

      FNAM = 'RDKCOR_FITS_FILTERS'
      print*,'     ', FNAM
      call flush(6)
       
      CALL RDKCOR_FITS_NEXTHDU(LUN,FNAM)

c ----------------------

c read lambda array.
       FIRSTROW = 1
       FIRSTELEM = 1
       ISTAT     = 0
       ICOL      = 1
       CALL FTGCVe(LUN, ICOL, firstrow, firstelem, 
     &       NLBIN_SNSED, nullf_rdkcor, 
     &       ARRAY_LAM,                     ! return arg
     &       anyf_rdkcor, istat)            ! return arg

      ERRMSG = 'LAMBDA-array'
      CALL RDKCOR_ABORT(FNAM, ERRMSG, ISTAT) ! error check

       IF ( NLBIN_SNSED > MXLAMBIN_FILT ) THEN
         write(C1ERR,61) NLBIN_SNSED
61       format('NLAMBIN_FILT=',I5,' > bound.')
         write(C2ERR,62) MXLAMBIN_FILT
62       format('Check bound MXLAMBIN_FILT = ', I5)
         CALL MADABORT(FNAM,C1ERR,C2ERR)
       ENDIF


      NMATCH_OBS = 0
      FILTLIST_RDKCOR = ''

      DO 100 IFILT = 1, NFILTDEF_RDKCOR

         CALL ICOL_FILTER_RDKCOR(IFILT, ICOL,CFILT) ! return ICOL,CFILT

         MASK      = MASKFILT_RDKCOR(ifilt)
         IFILTDEF  = IFILTDEF_RDKCOR(ifilt)

         FILTLIST_RDKCOR = FILTLIST_RDKCOR(1:IFILT-1) // 
     &       FILTDEF_STRING(IFILTDEF:IFILTDEF)

         CALL FTGCVe(LUN, ICOL, firstrow, firstelem, 
     &       NLBIN_SNSED, nullf_rdkcor, 
     &       ARRAY_TRANS,                   ! return arg
     &       anyf_rdkcor, istat)            ! return arg

         ERRMSG = 'FiltTrans-' // CFILT(1:20)
         CALL RDKCOR_ABORT(FNAM, ERRMSG, ISTAT) ! error check

c ------------------------------------------------
c match CFILT to get IFILT_REST & IFILT_OBS
         CALL FILTMATCH(cfilt, IFILT_REST, IFILT_OBS )

c         write(6,2600) cfilt, IFILT_REST, IFILT_OBS ! xxx REMOVE
c2600     format(' xxx F: ', A12, 3x, ' IFILT[REST,OBS] = ', 2I4 )

c for rest-filters, just load filter transmissions.
c The arrays were set in RDKCOR_FITS_KCOR.

         IF ( IFILT_REST > 0 ) THEN
            
c check if duplicate IFILT_REST (abort later to see all duplicates)
            CALL CHECK_DUPLICATE_FILTER('REST', CFILT, IFILT_REST)

            LFILTDEF_REST(IFILT_REST) = .TRUE.
            CALL LOAD_FILTTRANS(OPT_FILTREST, ifiltdef,
     &                      NLBIN_SNSED, ARRAY_LAM, ARRAY_TRANS)           

c store primary mag and ZP offset
            FILTREST_MAG_PRIMARY(ifilt_rest) = 
     &         MAG_PRIMARY_RDKCOR(ifilt) +
     &         MAGREST_SHIFT_PRIMARY_FILT(ifilt_rest)

            FILTREST_ZPOFF_PRIMARY(ifilt_rest) = 
     &         ZPOFF_PRIMARY_RDKCOR(ifilt) +
     &         MAGREST_SHIFT_PRIMARY_FILT(ifilt_rest) 

c xxxxxxxxxxxxxxxxxxxx
c           write(6,2700) 
c     &        IFILT_REST, FILTREST_MAG_PRIMARY(ifilt_rest),
c     &        FILTREST_ZPOFF_PRIMARY(ifilt_rest)
c2700       format(' xxx F: IFILT_REST=', I2, 3x, 
c     &          'PRIMARY(MAG,ZPOFF)=', 2F9.3 )
c xxxxxxxxxxxxxxxxxxxx

         ENDIF

c for obs filters, LOAD_FILTTRANS and increment arrays.
c OBS arrays are set here (instead of in RDKCOR_FITS_KCOR)
c to include obs-filters that are not defined in a KCOR.

         IF ( IFILT_OBS > 0 ) THEN
            NMATCH_OBS = NMATCH_OBS + 1

c check if duplicate IFILT_OBS (abort later to see all duplicates)
            CALL CHECK_DUPLICATE_FILTER('OBS', CFILT, IFILT_OBS)

C set BX logical for obs-frame
            LBX   = ISBXFILT(ifilt_obs, cfilt, 'OBS')

            LFILTDEF_OBS(IFILT_OBS) = .TRUE.
            NFILTOBS_RDKCOR = NFILTOBS_RDKCOR + 1
            IFILTOBS_RDKCOR(NFILTOBS_RDKCOR) = IFILT_OBS
            MASKFILT_RDKCOR(ifilt) = IBSET(MASK,1)
            FILTOBS_NAME(ifilt_obs)  = cfilt

            LAMSHIFT = FILTER_LAMSHIFT_FILT(IFILTDEF) 
            CALL SHIFT_FILTTRANS(IFILT_OBS, LAMSHIFT, NLBIN_SNSED, 
     &                ARRAY_LAM, ARRAY_TRANS)  ! <= modified

c store transmission vs. lambda
            CALL LOAD_FILTTRANS(OPT_FILTOBS, ifiltdef,
     &                      NLBIN_SNSED, ARRAY_LAM, ARRAY_TRANS)

c load primary mag
            FILTOBS_MAG_PRIMARY(ifilt_obs) = 
     &         MAG_PRIMARY_RDKCOR(ifilt) +
     &         MAGOBS_SHIFT_PRIMARY_FILT(ifilt_obs) ! user shift of primary 

c load filter zeropoint, and apply same shift as above
            FILTOBS_ZPOFF_PRIMARY(ifilt_obs) = 
     &         ZPOFF_PRIMARY_RDKCOR(ifilt) +
     &         MAGOBS_SHIFT_PRIMARY_FILT(ifilt_obs)   ! user shift of primary

c load ZPOFF (AB offsets) separately since they can
c be over-written later.
           FILTOBS_ZPOFF_SNPHOT(ifilt_obs) = ZPOFF_SNPHOT_RDKCOR(ifilt)

         ENDIF

100   CONTINUE  ! ifilt

c --------------
c Abort if duplicate filters were detected (May 2012)

      IF ( NFILT_DUPLICATE_RDKCOR .GT.  0 ) THEN
          write(c1err,631) NFILT_DUPLICATE_RDKCOR
631       format('Found ',I2,' duplicate filter definitions.')
          c2err = 'See ERROR messages above.'
          CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

     
c Mar 13 2013: abort if there are no observer-frame matches

      IF ( NMATCH_OBS .EQ. 0 ) THEN
        CALL PRINT_PREABORT_BANNER(FNAM(1:20)//char(0),40)
        print*,' KCOR filters:   ', FILTLIST_RDKCOR(1:NFILTDEF_RDKCOR)
        print*,' SURVEY_FITLERS: ', SURVEY_FILTERS(1:NFILTDEF_SURVEY)

        c1err = 'KCOR filters do not match any SURVEY_FILTERS.'
        c2err = 'see PRE-ABORT dump above.'
        CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF

      RETURN
      END    ! RDKCOR_FITS_FILTERS


C ============================================
+DECK,ICOL_FILTER_RDKCOR.
      SUBROUTINE ICOL_FILTER_RDKCOR(IFILT, ICOL,FILTNAME)

c Created May 2017 by R.Kessler
c For input filter index IFILT, default column is ICOL = 1+IFILT.
c But if lam-shifted band is requested, then ICOL += NFILTDEF
c
c Nov 30 2017: abort if FILTLIST_LAMSHIFT is used.

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER IFILT           ! (I) sparse filter index
      INTEGER ICOL            ! (O) table column to read
      CHARACTER FILTNAME*40   ! (O) filter name 

c local args
      LOGICAL LAMSHIFT_DEFINED, LAMSHIFT_USER
      INTEGER J, LENF 
      CHARACTER BAND*2

C ------------- BEGIN -------------
 
      ICOL      = 1 + IFILT  ! default column in kcor-fits file
      FILTNAME  = FILTER_NAME_RDKCOR(ifilt)

c check for lam-shifted band
      LAMSHIFT_DEFINED = ISLAMSHIFT_RDKCOR(0) 
      LAMSHIFT_USER    = FILTLIST_LAMSHIFT .NE. ''

      IF ( LAMSHIFT_USER ) THEN
         C1ERR = 'FILTLIST_LAMSHIFT no longer supported.'
         C2ERR = 'Use FILTER_LAMSHIFT instead (see manual).'
         CALL MADABORT('ICOL_FILTER_RDKCOR', C1ERR, C2ERR)
      ENDIF

      IF ( LAMSHIFT_DEFINED .and. LAMSHIFT_USER ) THEN
         LENF      = INDEX(FILTNAME,' ') - 1
         BAND      = FILTNAME(LENF:LENF)

c check if current band is any of the user-FILTLIST_LAMSHIFT bands  
         j = INDEX(FILTLIST_LAMSHIFT,BAND) 
         IF ( j > 0 ) THEN
           ICOL      = 1 + IFILT + NFILTDEF_RDKCOR
           FILTNAME  = FILTER_NAME_RDKCOR(ifilt+NFILTDEF_RDKCOR)
         ENDIF
      ENDIF

      RETURN
      END

C ========================================
+DECK,RDKPRIM.
      SUBROUTINE RDKCOR_FITS_PRIMARYSED(LUN)

C
C Dec 2012: read primary SED
C Nov 2019: abort if 2 or more primary references

      IMPLICIT NONE

      INTEGER LUN  ! (I) read from this LUN

+CDE,SNDATCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER IFILT, ICOL, MASK, LP, IPRIM1, IPRIM2
      INTEGER FIRSTROW, FIRSTELEM, ISTAT
      CHARACTER ERRMSG*60, FNAM*24

C ------------ BEGIN ------------

      FNAM = 'RDKCOR_FITS_PRIMARYSED'
      print*,'     ', FNAM
      call flush(6)

      CALL RDKCOR_FITS_NEXTHDU(LUN,FNAM)

c -------
c determine IPRIM of observer filter

      IPRIM_REF_RDKCOR = -9

      NERR_PRIM_RDKCOR = 0 
      IPRIM_FIRST2_RDKCOR(1) = -9; IPRIM_FIRST2_RDKCOR(2) = -9; 

      DO ifilt = 1, NFILTDEF_RDKCOR
         MASK = MASKFILT_RDKCOR(ifilt)
         if ( BTEST(MASK,OPT_FILTOBS-1) ) then           
           IPRIM_REF_RDKCOR = INDX_PRIMARY_RDKCOR(ifilt)
	   if ( IPRIM_FIRST2_RDKCOR(1) < 0 ) then
              IPRIM_FIRST2_RDKCOR(1) = IPRIM_REF_RDKCOR
           endif
	   if ( IPRIM_FIRST2_RDKCOR(1) .NE. IPRIM_REF_RDKCOR ) then
	      NERR_PRIM_RDKCOR = NERR_PRIM_RDKCOR + 1
	      IPRIM_FIRST2_RDKCOR(2) = IPRIM_REF_RDKCOR
	   endif
         endif
      ENDDO


      IF ( IPRIM_REF_RDKCOR < 0 ) THEN
         C1ERR = 'Could not find primary reference. '
         C2ERR = 'Something is messed up. '
         CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF

      PRIMARY_NAME = PRIMARY_NAME_RDKCOR(IPRIM_REF_RDKCOR)
      LP = INDEX(PRIMARY_NAME, ' ') - 1
      IF (LVERBOSE_RDKCOR) THEN
        print*,'    Primary Ref = ', PRIMARY_NAME(1:LP)
        print*,'    NLAMBIN     = ', NLBIN_SNSED
      ENDIF

c --------------------
c read lambda array.
       FIRSTROW  = 1
       FIRSTELEM = 1
       ISTAT     = 0
       NLAMBIN_PRIMARY = NLBIN_SNSED

       IF ( NLAMBIN_PRIMARY > MXLAMBIN_PRIM ) THEN
         write(C1ERR,61) NLAMBIN_PRIMARY
61       format('NLAMBIN_PRIM=',I5,' > bound.')
         write(C2ERR,62) MXLAMBIN_PRIM
62       format('Check bound MXLAMBIN_PRIM = ', I5)
         CALL MADABORT(FNAM,C1ERR,C2ERR)
       ENDIF

       ICOL      = 1
       CALL FTGCVe(LUN, ICOL, firstrow, firstelem, 
     &       NLAMBIN_PRIMARY, nullf_rdkcor, 
     &       PRIMARY_LAM,                   ! return arg
     &       anyf_rdkcor, istat)            ! return arg

      ERRMSG = 'LAMBDA-' // PRIMARY_NAME(1:LP)
      CALL RDKCOR_ABORT(FNAM, ERRMSG, ISTAT) ! error check

c read flux array

       ICOL      = 1 + IPRIM_REF_RDKCOR
       CALL FTGCVe(LUN, ICOL, firstrow, firstelem, 
     &       NLAMBIN_PRIMARY, nullf_rdkcor, 
     &       PRIMARY_FLUX,                   ! return arg
     &       anyf_rdkcor, istat)            ! return arg

      ERRMSG = 'FLUX-' // PRIMARY_NAME(1:LP)
      CALL RDKCOR_ABORT(FNAM, ERRMSG, ISTAT) ! error check


      RETURN
      END    ! end RDKCOR_FITS_PRIMARYSED


C ============================
+DECK,RDKSUMM.
      SUBROUTINE RDKCOR_SUMMARY
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.

      INTEGER 
     &   ifilt_tmp, ifiltdef, ifilt, i, L1, L2
     &  ,ifilt_rest, ifilt_obs, IPRIM1, IPRIM2

      REAL  BINFRAC, KCORSIZE
      CHARACTER CFILT*40, FNAM*16, C1ERR*80, C2ERR*80

C ----------------- BEGIN ---------------

      FNAM = 'RDKCOR_SUMMARY'

      print*,'        ---------------------- '
      print*,'        !!! RDKCOR_SUMMARY !!! '
      print*,'        ---------------------- '

      print*,'   Primary spectrum: ', PRIMARY_NAME

      print*,' '
      print*,' FILTER SUMMARY (RDKCOR) : '
      print*, ' internal                    ', 
     &          'LAM  LAM   rest-lam      primary'
      print*, ' index name                  ',
     &          'AVG  RMS   kcor range    mag   ZP'

      write(6,60)
60    format(T2, 66('-') ) 


c Sep 1, 2010: 
c  print filters in the same order as in the KCOR file, 
c  rather than in the order they appear in the FILTDEF_STRING .
c    

      DO 135 ifilt_tmp = 1, NFILTOBS_RDKCOR

        ifiltdef = IFILTOBS_RDKCOR(ifilt_tmp)     
        CFILT    = FILTOBS_NAME(ifiltdef)

        if ( NLAMBIN_FILTOBS(ifiltdef) .LE. 0 ) goto 135

        write(6,132) ifiltdef, cfilt
     &       , int(FILTOBS_LAMAVG(ifiltdef)+0.5)
     &       , int(FILTOBS_LAMRMS(ifiltdef)+0.5)
     &       , 0, 0
     &       , FILTOBS_MAG_PRIMARY(ifiltdef)
     &       , FILTOBS_ZPOFF_PRIMARY(ifiltdef)

132       format(T3,I2.2,1x, A20, T28,I6,I5,  T41,I5,'-',I5, 
     &            T53,2F7.3 )

135   CONTINUE

c -----
c print rest-frame filters, and also SET_LAMREST_RANGE

      if ( NFILTDEF_REST    .GT. 0 ) print*,' ' 

      DO 136 ifilt_tmp = 1, NFILTDEF_REST
        ifiltdef = IFILTDEF_MAP_REST(ifilt_tmp)

        CFILT =  FILTREST_NAME(ifiltdef)

        if ( NLAMBIN_FILTREST(ifiltdef) .LE. 0 ) goto 136

        CALL SET_LAMREST_RANGE(ifiltdef)

        write(6,132) ifiltdef, cfilt
     &       , int(FILTREST_LAMAVG(ifiltdef)+0.5)
     &       , int(FILTREST_LAMRMS(ifiltdef)+0.5)
     &       , int(FILTREST_LAMRANGE(1,ifiltdef)+0.5)
     &       , int(FILTREST_LAMRANGE(2,ifiltdef)+0.5)
     &       , FILTREST_MAG_PRIMARY(ifiltdef)
     &       , FILTREST_ZPOFF_PRIMARY(ifiltdef)

        CALL FLUSH(6)

136   CONTINUE


      write(6,60)

      write(6,138) NFILTDEF_SURVEY, NFILTDEF_REST
138   format(T5,'NFILTDEF[SURVEY,REST] = ', 2I4)

      print*,' '
      CALL FLUSH(6)

c -----------------------------------------------
c Apr 2013: abort if any NONSURVEY_FILTER is undefined.

      CALL RDKCOR_VERIFY_NONSURVEY_FILTERS()

c -----------------------------------------------
      if ( NKCOR_STORE .EQ. 0 ) RETURN

c ================

      write(6,22) NKCOR_STORE
22    format(T4,'KCOR SUMMARY (',I3,' tables)' )

      DO i = 1, NKCOR_STORE

        ifilt_rest = IFILT2_RDKCOR(OPT_FILTREST,i)
        ifilt_obs  = IFILT2_RDKCOR(OPT_FILTOBS,i)

        L1 = INDEX(FILTREST_NAME(ifilt_rest),' ') - 1
        L2 = INDEX(FILTOBS_NAME(ifilt_obs),  ' ') - 1

        write(6,32) i
     &    ,filtdef_string(ifilt_rest:ifilt_rest)
     &    ,filtdef_string(ifilt_obs:ifilt_obs)
     &    ,ifilt_rest, ifilt_obs
     &    ,FILTREST_NAME(ifilt_rest)(1:L1)
     &    ,FILTOBS_NAME(ifilt_obs)(1:L2)


      CALL FLUSH(6)

32        format(T8,I2, 2x, 'Found K_',A1,A1,' table',
     &       3x, '(',I2,'->',I2, ' : ', A,' -> ',A ,')' )
      ENDDO


c print rest-frame summary info.

      write(6,240) 'Rest-frame', RESTKCOR_FILTERS(1:NFILTDEF_REST)
240   format(T5,A, ' filters : ', A, '  (ifiltdef= ', $ )
      do ifilt = 1, NFILTDEF_REST
         write(6,241) IFILTDEF_MAP_REST(ifilt)
241      format(I3, $)
      enddo
      write(6,242) 
242   format( ')' )


c ---------------------------
c print summary of fraction of table bins used and total memory

+SELF,IF=R4KCOR. 
      KCORSIZE = 4.0E-6 * float(MXTABLE1D_KCOR)  ! R*4 size in MB
+SELF,IF=I2KCOR.
      KCORSIZE = 2.0E-6 * float(MXTABLE1D_KCOR)  ! I*2 size in MB
+SELF.


      print*,'  '

      BINFRAC = 100.*FLOAT(NBINTOT_KCOR)/FLOAT(MXTABLE1D_KCOR)
      write(6,250) 'K-CORR TABLE', BINFRAC, MXTABLE1D_KCOR, KCORSIZE

      BINFRAC = 100.*FLOAT(NBINTOT_AVWARP)/FLOAT(MXTABLE1D_AVWARP)
      write(6,250) 'AVWARP TABLE', BINFRAC, MXTABLE1D_AVWARP, 
     &       4.0E-6*float(MXTABLE1D_AVWARP)

      BINFRAC = 100.*FLOAT(NBINTOT_LCMAG)/FLOAT(MXTABLE1D_LCMAG)
      write(6,250) 'LCMAG  TABLE', BINFRAC, MXTABLE1D_LCMAG, 
     &       4.0E-6*float(MXTABLE1D_LCMAG)

      BINFRAC = 100.*FLOAT(NBINTOT_MWXT)/FLOAT(MXTABLE1D_MWXT)
      write(6,250) 'MWXT   TABLE', BINFRAC, MXTABLE1D_MWXT, 
     &       4.0E-6*float(MXTABLE1D_MWXT)

250   format(T4, A,' uses ',F6.2, '% of ',
     &            I8,' available bins (', F6.1, ' MB)' )
        
      write(6,260) RVMW_RDKCOR, OPT_MWCOLORLAW_RDKCOR
 260  format(T4,'MWXT   TABLE params: RV=',F5.2, 3x,
     &          'and OPT_MWCOLORLAW=',I3)

      CALL FLUSH(6)

c ------------------------------------
      print*,' ' 
      write(6,430) NLBIN_SNSED, 'Lambda  ',  
     &       Lrange_SNSED, LBINSIZE_SNSED
      write(6,440) NTBIN_KCOR,  'Trest   ', 
     &       Trange_kcor, TBINSIZE_KCOR
      write(6,440) NZBIN_KCOR,  'Redshift', 
     &       Zrange_kcor, ZBINSIZE_KCOR
      write(6,440) NAVBIN_KCOR, 'AVwarp  ', 
     &       AVrange_kcor, AVBINSIZE_KCOR

430   format(T8,'Read ',I4,2x,A,' bins, ', F6.0,' - ',F6.0,2x,
     &        'binSize=',F5.1 )

440   format(T8,'Read ',I4,2x,A,' bins, ', F6.2,' - ',F6.2,2x,
     &        'binSize=',F5.3 )

      CALL FLUSH(6)

c -----------
c check too many PRIMARY error after dump to help see the problem.

      IF ( NERR_PRIM_RDKCOR > 0 ) THEN
         IPRIM1 = IPRIM_FIRST2_RDKCOR(1)
         IPRIM2 = IPRIM_FIRST2_RDKCOR(2)
         CALL PRINT_PREABORT_BANNER(FNAM(1:15)//char(0),40)
         print*,'   Found Primary ', PRIMARY_NAME_RDKCOR(IPRIM1)
         print*,'   Found Primary ', PRIMARY_NAME_RDKCOR(IPRIM2)
         C1ERR = 'More than 1 PRIMARY ref not allowed.' 
	 C2ERR = 'Check kcor file and above list of primary refs.'
         CALL MADABORT(FNAM,C1ERR,C2ERR)
      ENDIF

c      CALL RDKCOR_DMPTABLE(5)

      RETURN
      END         ! RDKCOR_SUMMARY

C =====================================
+DECK,RDKVER.
      SUBROUTINE RDKCOR_VERIFY_NONSURVEY_FILTERS()

c Apr 2013: 
c abort if any NONSURVEY_FILTER is undefined in the kcor file.
c For each udefined filter, print ERROR message; then abort
c at the end with full list of undefined filters.
c
c Also set LFILTDEF_NONSURVEY(ifilt_obs) array.
c

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.

      INTEGER
     &   NFILT_ADD,  IFILT, IFILTDEF
     &  ,ifilt_tmp, ifiltdef_tmp, NBAD

      CHARACTER CFILT*2, FNAM*32, C1ERR*72, C2ERR*72, BADLIST*60
      LOGICAL   LDEF

c functions
      INTEGER FILTINDX

c ---------------- BEGIN -----------

      FNAM = 'RDKCOR_VERIFY_NONSURVEY_FILTERS'
      NFILT_ADD = INDEX(NONSURVEY_FILTERS_ADD,' ') - 1

      NBAD = 0
      DO 100 IFILT    = 1, NFILT_ADD
        LDEF      = .FALSE.
        CFILT     = NONSURVEY_FILTERS_ADD(IFILT:IFILT)
        IFILTDEF  = FILTINDX(CFILT)
        LFILTDEF_NONSURVEY(IFILTDEF) = .TRUE.

        DO 102 IFILT_TMP = 1, NFILTDEF_RDKCOR
           IFILTDEF_TMP  = IFILTDEF_RDKCOR(ifilt_tmp)
           IF ( IFILTDEF .EQ. IFILTDEF_TMP ) LDEF = .TRUE.
 102    CONTINUE

        IF ( .NOT. LDEF ) THEN
           BADLIST = BADLIST(1:NBAD) // CFILT(1:1)
           NBAD    = NBAD + 1
           print*,' ERROR: UNDEFINED NON-SURVEY FILTER = ', CFILT
        ENDIF

 100  CONTINUE 

c abort if NBAD > 0

      IF ( NBAD > 0 ) THEN
        write(c1err,61) NBAD, BADLIST(1:NBAD)
 61     format(I2,' NON-SURVEY filters (', A, ') ', 
     &         'are undefined in the kcor file')
        c2err = 'Check NONSURVEY_FILTERS in &SNLCINP'
        CALL MADABORT(FNAM, c1err, c2err)
      ENDIF

      RETURN
      END

C =====================================
+DECK,RDKDMPTA.
      SUBROUTINE RDKCOR_DMPTABLE(ikcor)
   
c Aug 4 2019: IBXXX arg for GET_1DIDEX starts at 0, not 1
   
c Dump entire table for kcor index IKCOR

      IMPLICIT NONE

      INTEGER ikcor  ! (I) kcor table to dump

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.

      INTEGER 
     &   iav, it, iz, IBIN
     &  ,ifilt_rest, ifilt_obs, ifiltr, ifilto
     &  ,IBKCOR(NKDIM)
     &  ,IBLCMAG(N4DIM)
     &  ,IBMWXT(N4DIM)

      REAL  AV, Trest, Z, KCOR, MAG, MWXT

      CHARACTER CFILT_REST*40, CFILT_OBS*40

c function
      INTEGER GET_1DINDEX

C --------------------- BEGIN ----------------

      ifilt_rest = IFILT2_RDKCOR(OPT_FILTREST,ikcor)
      ifilt_obs  = IFILT2_RDKCOR(OPT_FILTOBS,ikcor)
  
      CFILT_OBS  = FILTOBS_NAME(ifilt_obs)
      CFILT_REST = FILTREST_NAME(ifilt_rest)

      ifiltr = IFILTDEF_INVMAP_REST(ifilt_rest)
      ifilto = IFILTDEF_INVMAP_SURVEY(ifilt_obs)

      print*,'# =========================================== '
      print*,'# Dump K-corr table for rest-', 
     &         CFILT_REST(1:12),' ->  obs-', CFILT_OBS(1:12)
      print*,'# IKCOR = ', IKCOR
      print*,' ' 

      print*,
     &  '     IBIN      Trest  Redshift AVwarp    KCOR  LCMAG  MWXTSLP'
      print*,
     &  ' ------------------------------------------------------------ '

      DO 103 iav = 1, NAVBIN_KCOR    
      DO 102 iz  = 1, NZBIN_KCOR
      DO 101 it  = 1, NTBIN_KCOR

         AV    = GRIDVAL_AV(iav)
         Z     = GRIDVAL_Z(iz)
         Trest = GRIDVAL_T(it)

         IBKCOR(KDIM_T)      = it - 1
         IBKCOR(KDIM_Z)      = iz - 1
         IBKCOR(KDIM_AV)     = iav - 1
         IBKCOR(KDIM_ifiltr) = ifiltr - 1
         IBKCOR(KDIM_ifilto) = ifilto - 1
         IBIN = GET_1DINDEX(IDMAP_KCOR,NKDIM,IBKCOR)+1
         KCOR = R4KCORTABLE1D(IBIN) 

         IBLCMAG(1)  = it - 1
         IBLCMAG(2)  = iz - 1
         IBLCMAG(3)  = iav - 1
         IBLCMAG(4)  = ifiltr - 1
         IBIN = GET_1DINDEX(IDMAP_LCMAG,N4DIM,IBLCMAG)+1
         MAG  = LCMAG_TABLE1D(IBIN)

         IBMWXT(1)  = it - 1
         IBMWXT(2)  = iz - 1
         IBMWXT(3)  = iav - 1
         IBMWXT(4)  = ifilto - 1
         IBIN   = GET_1DINDEX(IDMAP_MWXT,N4DIM,IBMWXT)+1
         MWXT   = MWXT_TABLE1D(IBIN)

         write(6,50) IBIN, Trest, Z, AV, KCOR, MAG, MWXT
50       format(T5,I8, T15,3F8.3, T41,3F9.4 )

101   CONTINUE
102   CONTINUE
103   CONTINUE

      RETURN
      END

C =============================
+DECK,RDKDMPF.
      SUBROUTINE RDKCOR_DUMPFILT_REST(COMMENT)
      IMPLICIT NONE
      CHARACTER COMMENT*(*)
+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.
      INTEGER IFILT_TMP, IFILTDEF
      CHARACTER CFILT*40
C -------------- BEGIN ------------

      print*,'### ========================================= '

      write(6,20) NFILTDEF_REST, COMMENT
20    format(' DUMP ', I3,' rest-frame filters: ', A)

      DO 136 ifilt_tmp = 1, NFILTDEF_REST
        ifiltdef = IFILTDEF_MAP_REST(ifilt_tmp)
        CFILT =  FILTREST_NAME(ifiltdef)
        write(6,132) ifiltdef, cfilt(1:12)
132     format(t12,'DUMP IFILT_REST=',I3,' : ' , A)
        CALL FLUSH(6)
136   CONTINUE
      print*,'           IFILT(X=16) = ', IFILTDEF_INVMAP_REST(16)
      print*,'### ========================================= '

      RETURN
      END

C ===========================================
+DECK,RDKADDF.
      SUBROUTINE RDKCOR_ADDFILT_REST(ifilt_rest)

c Dec 2012
c Add rest-frame filter if not already on the list.
c Also do error checking.

      IMPLICIT NONE

      INTEGER IFILT_REST  ! (I) absolute rest-frame filter index

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.

      LOGICAL LTMP
      INTEGER j
      CHARACTER C1ERR*72, C2ERR*72, FNAM*20, CFILT1*2

C -------------- BEGIN ------------

      FNAM = 'RDKCOR_ADDFILT_REST'

      LTMP = IFILTDEF_INVMAP_REST(ifilt_rest) .LE. 0 
      IF ( LTMP ) THEN

         CFILT1 = FILTDEF_STRING(ifilt_rest:ifilt_rest)
         NFILTDEF_REST = NFILTDEF_REST + 1

         if ( NFILTDEF_REST .GT. MXFILT_REST ) then
            write(c1err,966) NFILTDEF_REST
966         format('NFILTDEF_REST = ', I3,' exceeds array bound.')
            c2err = "Check MXFILT_REST parameter in snana.car"
            CALL MADABORT(FNAM, c1err, c2err)
         endif

         IFILTDEF_INVMAP_REST(ifilt_rest) = NFILTDEF_REST
         IFILTDEF_MAP_REST(NFILTDEF_REST) = ifilt_rest

         j = INDEX ( RESTKCOR_FILTERS, ' ') - 1
         RESTKCOR_FILTERS = RESTKCOR_FILTERS(1:j) // CFILT1(1:1)

      ENDIF

      RETURN
      END    ! end of RDKCOR_ADDFILT_REST


C ===========================================
+DECK,RDKCOR_ADDX.
      SUBROUTINE RDKCOR_ADDX_REST(cfilt)

c Dec 2012 [code moved from RDKCOR_HBOOK]
c if CFILT is an X filter that is not part of a K-correction 
c (i.e., an undefined rest-frame filter), then add it to the 
c rest-frame list in case the Landolt-correction option is used.

      IMPLICIT NONE


      CHARACTER CFILT*(*) ! (I) full character string for filter

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.

      INTEGER IFILTDEF, LEN
      LOGICAL LBX, LREST
      CHARACTER FNAM*20

c function
      LOGICAL  ISBXFILT
      INTEGER  FILTINDX

C -------------- BEGIN ------------

      FNAM = 'RDKCOR_ADDX_REST'

c get absolute index
      IFILTDEF = FILTINDX(CFILT)

c bail if not an X filter
      IF ( IFILTDEF .NE. IFILT_BESS_BX ) RETURN

c bail if already defined as a rest-frame filter
      LREST = (IFILTDEF_INVMAP_REST(ifiltdef) .GT. 0 )
      IF ( LREST ) RETURN

C make sure that this is a BX filter;
c if so, set global EXIST_BXFILT_REST.
c Note that a generic X filter (i., BLABLA-X) will be
c fail the LBX test.

      LBX   = ISBXFILT(ifiltdef, cfilt, 'REST')
      if ( .NOT. LBX ) RETURN

c ----------------------------------
c add BX to rest-frame list

      NFILTDEF_REST = NFILTDEF_REST + 1
      IFILTDEF_INVMAP_REST(ifiltdef)   = NFILTDEF_REST
      IFILTDEF_MAP_REST(NFILTDEF_REST) = ifiltdef
      FILTREST_NAME(ifiltdef)          = cfilt

      LEN = INDEX(CFILT//' ',' ') - 1
      write(6,20) CFILT(1:LEN)
20    format(T10,'Added ',A, 1x, 'to rest-frame list.' )

      RETURN
      END    ! end of RDKCOR_ADDX_REST


C ============================
+DECK,RDKCOR_ABORT.
      SUBROUTINE RDKCOR_ABORT(FNAM,KEYWORD,ISTAT)

c shell to set abort comment  and call MADABORT

      IMPLICIT NONE
      CHARACTER FNAM*(*)    ! (I) name of function
      CHARACTER KEYWORD*(*) ! (I) name of keyword  
      INTEGER ISTAT         ! (I) error status 

c local var

      INTEGER LK
      CHARACTER*80 C1ERR, C2ERR

c --------------- BEGIN ---------
      if ( ISTAT .EQ. 0 ) RETURN

      LK    = INDEX(KEYWORD//' ', ' ', BACK = .TRUE. ) - 1
      C1ERR = 'Could not read ' // KEYWORD(1:LK)

      write(C2ERR,662) ISTAT
662   FORMAT('ISTAT = ', I6)

      CALL MADABORT(FNAM,C1ERR,C2ERR)

      RETURN
      END


C ==================================
+DECK,RDKSETGR.
      SUBROUTINE RDKCOR_SETGRIDVAL()

c Dec 2012
c For each kcor dimension (Trest, redsfhit, AVwarp),
c store GRIDVAL_[T,Z,AV] at each grid point.
c Also make sure that there is a valid bin with
c AVwarp=0 and with Redshift=0.
c These pre-computed grids simplify interpolations later.
c
c Dec 2012: no  more offset with FITS-format convention
c Dec 2013: return if NKCOR_RDKCOR = 0
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,KCORCOM.

      INTEGER izbin, itbin, iavbin
      REAL    T, Z, AV, xi
      CHARACTER FNAM*20, C1ERR*72, C2ERR*72

C ---------------- BEGIN -------------

      IF ( NKCOR_RDKCOR .LE. 0 ) RETURN

      FNAM = 'RDKCOR_SETGRIDVAL'

      do izbin = 1,nzbin_kcor
         xi    = float(izbin-1)
         z = ZRANGE_KCOR(1) + xi * ZBINSIZE_KCOR
         GRIDVAL_Z(izbin) = z
         if ( abs(z) .LT. 1.0E-6 ) IZ0 = izbin
      enddo

      do itbin = 1,ntbin_kcor
         xi    = float(itbin-1)
         T = TRANGE_KCOR(1) + xi * TBINSIZE_KCOR
         GRIDVAL_T(itbin) = t
      enddo

      do iavbin = 1, navbin_kcor
         xi    = float(iavbin-1) 
         av = AVRANGE_KCOR(1) + xi * AVBINSIZE_KCOR
         GRIDVAL_AV(iavbin) = av
         if ( abs(av) .LT. 1.0E-6 ) IAV0 = iavbin
      enddo
      
c error checking

      if ( IAV0 .LT. 0 ) THEN
          C1err = 'Could not find bin with AVwarp=0 (IAV0)'
          C2err = 'Check AVwarp grid in kcor-input file.'
          CALL MADABORT(FNAM, C1err, C2err)
      endif

      if ( IZ0 .LT. 0 ) THEN
          C1err = 'Could not find bin with redshift = 0 (IZ0)'
          C2err = 'Check REDSHIFT grid in kcor-input file.'
          CALL MADABORT(FNAM, C1err, C2err)
      endif


      RETURN
      END

C ==================================
+DECK,RDKCOR_CHECK_IFILT.
      SUBROUTINE RDKCOR_CHECK_IFILT(ifilt_rest,ifilt_obs, stringKcor)

c Dec 2012
c Check that rest and obs-filter indices are valid for K-correcton
c defined by STRINGKCOR.
c
c IFILT_REST,IFILT_OBS are absolute indices corresponding
c to a K-cor table 'K_or'.  Checks both absolute and sparse
c indices.
c
c STRINGKCOR is the full string definition and is used only
c for error messaging.
c
c [code moved from RDKCOR_HBOOK for cleanup and to use for
c  both hbook and fits reading]
c
c ------------------

      IMPLICIT NONE

      INTEGER 
     &   IFILT_REST    !(I) absolute rest-frame filter index
     &  ,IFILT_OBS     !(I) idem, obs-frame

      CHARACTER stringKcor*(*)  !(I) for error message only

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,KCORCOM.
+CDE,FILTCOM.

      INTEGER IFILTr, IFILTo, IFILT_TMP, IFILTDEF
      LOGICAL LTMP
      CHARACTER C1ERR*72, C2ERR*72, FNAM*20, CFILT*40, CFILT1

c ------------------ BEGIN -------------

      FNAM = 'RDKCOR_CHECK_IFILT'

c get sparse indices
      ifiltr = IFILTDEF_INVMAP_REST(ifilt_rest)
      ifilto = IFILTDEF_INVMAP_SURVEY(ifilt_obs)

c make sure that we don't exceed KCOR filter-index bound

      c2err = 'Check KCOR_FILE. '
      if ( ifiltr .GT. MXFILT_KCOR ) then
         write(c1err,1660) ifiltr, 'rest', ' ', MXFILT_KCOR
         CALL MADABORT(FNAM, c1err, c2err)
      endif

      if ( ifilto .GT. MXFILT_KCOR ) then
         DO ifilt_tmp = 1, NFILTDEF_SURVEY
            ifiltdef   = IFILTDEF_MAP_SURVEY(ifilt_tmp)
            CFILT      = FILTOBS_NAME(ifiltdef)
            print*,' ABORT-INFO: obs-filter = ', 
     &               CFILT(1:20), ifiltdef
         ENDDO
         write(c1err,1660) ifilto, 'obs',
     &      SURVEY_FILTERS(1:NFILTDEF_SURVEY)
         write(c2err,1661) MXFILT_KCOR
         CALL MADABORT(FNAM, c1err, c2err)
      endif
1660    format('ifilto=',I4, 2x, A,'-frame filters (',A,')' )
1661    format('Exceeds MXFILT_KCOR = ', I3)

c check that sparse indices are valid

      LTMP = ( ifiltr .LE. 0 .or. ifiltr .GT. NFILTDEF_REST)
      if ( LTMP ) then
          cfilt1 = filtdef_string(ifilt_rest:ifilt_rest)
          write(c1err,690) ifiltr, ifilt_rest, cfilt1
690       format('Invalid ifiltr=',I3,' for ifilt_rest=',I3,3x,
     &           '(char=',A,') ' )
          c2err = stringKcor
          CALL MADABORT(FNAM, c1err, c2err)
      endif

      LTMP = ( ifilto .LE. 0 .or. ifilto .GT. NFILTDEF_SURVEY)
      if ( LTMP ) then
          cfilt1 = filtdef_string(ifilt_obs:ifilt_obs)
          write(c1err,691) ifilto, ifilt_obs, cfilt1
691       format('Invalid ifilto=',I3,' for ifilt_obs=',I3,3x,
     &                '(char=',A,') ' )
          c2err = stringKcor
          CALL MADABORT(FNAM, c1err, c2err)
      endif

      RETURN
      END

C ===========================================
+DECK,RDKBINCH.
      SUBROUTINE RDKCOR_CHECK_BINS

c Abort if T,Z or AV has too many bins

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,KCORCOM.

      CHARACTER C1ERR*72, C2ERR*72, FNAM*18

C -------------- BEGIN ------------

      FNAM = 'RDKCOR_NBINCHECK'

      if ( NZbin_KCOR .GT. MXZBIN_KCOR ) then 
          write(c1err,22) NZbin_KCOR, MXZBIN_KCOR
22        format('ERROR: NZBIN=',I4,' but MXZBIN_KCOR=',I4 )
          C2ERR = 'Check KCOR input file and MXZBIN_KCOR'
          CALL MADABORT(FNAM, C1err,C2err)
      endif

      if ( NTbin_KCOR .GT. MXTBIN_KCOR ) then 
          write(c1err,23) NTbin_KCOR, MXTBIN_KCOR
23        format('ERROR: NTBIN=',I4,' but MXTBIN_KCOR=',I4 )
          C2ERR = 'Check KCOR input file and MXTBIN_KCOR'
          CALL MADABORT(FNAM, C1err,C2err)
      endif

      if ( NAVbin_KCOR .GT. MXAVBIN_KCOR ) then 
          write(c1err,24) NAVbin_KCOR, MXAVBIN_KCOR
24        format('ERROR: NAVBIN=',I4,' but MXAVBIN_KCOR=',I4 )
          C2ERR = 'Check KCOR input file and MXAVBIN_KCOR'
          CALL MADABORT(FNAM, C1err,C2err)
      endif


      RETURN
      END  ! end of RDKCOR_CHECK_BINS

C ==========================
+DECK,GTKCORMW.
      SUBROUTINE GET_KCOR_INFO(NKCOR,RV,OPT_COLORLAW)

c Created Sep 22 2013 by R.Kessler
C fotran wrapper (for snlc_sim.c) to return RV and color 
c law option used to generate the MWXT table in the kcor file.
c Valid only for rest-frame models that use K-corrections.
c
c Rename GET_KCOR_MWPAR -> GET_KCOR_INFO, and return NKCOR.

      IMPLICIT NONE
+CDE,SNPAR.
+CDE,KCORCOM.

      REAL*8  RV                   ! (O)
      INTEGER NKCOR, OPT_COLORLAW   ! (O)
C -------------- BEGIN -----------
      NKCOR        = NKCOR_STORE
      RV           = RVMW_RDKCOR
      OPT_COLORLAW = OPT_MWCOLORLAW_RDKCOR
      RETURN
      END

C ================================================
+DECK,INIXTHOST.
      SUBROUTINE INIT_XTHOST(OPT)
c
c Created Aug 30, 2010 by R.Kessler
c
c Initializing the host galaxy extinction
c as a function of 
c  - rest-frame filter
c  - epoch
c  - 1/RV
c
c This is to replace Saurabh's hard-wired parametrization
c in UBVRI, and to extend to arbitrary rest-frame filters.
c
c BEWARE for lambda > 9100: negative extinction when RV < 1 !!!
c
c OPT=1 => CCM89 with 94 ODonnel update
c
c ---------------------

      IMPLICIT NONE

      INTEGER OPT  ! (I) option 

c local var

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,FILTCOM.
+CDE,KCORCOM.
+CDE,XTCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.

      INTEGER 
     &   IFILT, IFILT_REST, NBLAM
     &  ,ilam, ilam_snsed, iRV, iep, iep0
     &  ,NCALC

      CHARACTER CFILT*1, GLOBAL_BANNER*80

      REAL*8  
     &   LAM, TRANS, XTMAG, XT, FT, RV, RVinv
     &  ,Trest, arg
     &  ,LDIF, LBIN
     &  ,flux, fluxrat, AV1, AX, AX_SJPAR
     &  ,FLUXSUM(0:NRVBIN_XTHOST,MXTBIN_KCOR)

      LOGICAL LSJPAR_COMPARE
c functions

      REAL*8  GALextinct, GET_SNXT8

C ------------ BEGIN -------------

      LSJPAR_COMPARE = .FALSE.

      GLOBAL_BANNER = 'Initialize host extinctions'
      IF ( OPT .EQ. OPT_SNXT_CCM89 ) THEN
          GLOBAL_BANNER = 'Init host extinction ' //
     &                     'with CCM89 law + ODonnel94 udpate'
      ENDIF
      CALL PRBANNER(GLOBAL_BANNER(1:60))

c init a few things
      AV1 = 1.0  ! reference extinction

      DO irv   = 1, NRVBIN_XThost
         RVINV_XTHOST(irv) = -9.0
      DO iep   = 1, MXTBIN_KCOR
      DO ifilt = 1, MXFILT_ALL
         XTHOST(ifilt,iep,irv) = -999.
      ENDDO
      ENDDO
      ENDDO

      RVINV_XTHOST(1) = 0.25
      RVINV_XTHOST(2) = 0.50
      RVINV_XTHOST(3) = 0.75
      RVINV_XTHOST(4) = 1.00
      RVINV_XTHOST(5) = 2.00

      NCALC = 0
      
c begin loop, starting with filter
      DO 100 ifilt = 1, NFILTDEF_REST

        ifilt_rest = IFILTDEF_MAP_REST(ifilt)
cc        if ( IFILT_REST  .EQ.  IFILT_BESS_BX  ) GOTO 100

        CFILT = FILTDEF_STRING(ifilt_rest:ifilt_rest)
        NBLAM = NLAMBIN_FILTREST(ifilt_rest)  ! Number of lambda bins

          DO iep = 1, NTBIN_KCOR
          DO irv = 0, NRVBIN_XTHOST
            FLUXSUM(irv,iep) = 0.0
          ENDDO
          ENDDO

        DO 201 ilam = 1, NBLAM   ! also x axis of SN SED
          LAM   = FILTREST_LAMBDA(ilam,ifilt_rest)
          TRANS = FILTREST_TRANS(ilam,ifilt_rest)

c convert transmission LAM into ilam_snsed index
          LDIF = (LAM - Lrange_SNSED(1)) 
          LBIN = Lbinsize_SNSED
          ilam_snsed = int ( LDIF / LBIN + 0.5 ) + 1

        DO 202 iep = 1, NTBIN_KCOR  ! also y axis of SN SED

          Trest = GRIDVAL_T(iep)
          Flux = FLUX_SNSED(ilam_snsed+(iep-1)*NLbin_SNSED)
          FT   = Flux * Trans
          fluxsum(0,iep) = fluxsum(0,iep) + FT

          DO 205 iRV = 1, NRVBIN_XTHOST
            RVinv  = RVINV_XTHOST(iRV)
            RV     = 1./RVinv
            XTMAG  = GALextinct ( RV, AV1, LAM, 94 );
            arg    = -0.4*XTMAG
            XT     = 10.0**arg  ! flux fraction
            fluxsum(irv,iep) = fluxsum(irv,iep) + (FT*XT)
205       CONTINUE  ! iRV

202     CONTINUE    ! iep loop
201     CONTINUE  ! ilam loop

        DO 302  iep = 1, NTBIN_KCOR
          Trest     = GRIDVAL_T(iep)
        DO 305  iRV = 1, NRVBIN_XTHOST
          NCALC     = NCALC + 1
          RVinv     = RVinv_XTHOST(iRV)
          RV        = 1.0 / RVinv
          fluxrat   = fluxsum(irv,iep)/fluxsum(0,iep)
          AX        = -2.5*log10(fluxrat)
          XTHOST(ifilt_rest,iep,irv) = AX  ! fill global table

          if ( abs(Trest) .LT. 0.5  ) iep0 = iep

          IF ( LSJPAR_COMPARE .and. abs(Trest) .LT. 0.5 ) THEN
            AX_SJPAR = GET_SNXT8(OPT_SNXT_SJPAR,ifilt_rest,Trest,AV1,RV)      
            write(6,399) RVinv, CFILT, AX, AX_sjpar, AX/AX_sjpar
399         format(T12,'1/RV =',F7.4, 4x,'A_',A,'(new/SJPAR) = ', 
     &           F5.3, '/', F5.3, ' = ', F5.3 )
          ENDIF

305     CONTINUE
302     CONTINUE


100   CONTINUE  ! ifilt loop


      TREST = 0.0
      CALL DMP_XTHOST(Trest)

      TREST = 20.0
      CALL DMP_XTHOST(Trest)

      write(6,700) NCALC
700   format(/, T4,'Finished XTHOST table with ',I6,' entries. ')
      CALL FLUSH(6)

      IF ( LSJPAR_COMPARE ) THEN
         print*,' '
         print*,' xxxxx DEBUG EXIT xxxxxxxxx '
         CALL EXIT(EXIT_ERRCODE)
      ENDIF

      RETURN
      END

C ======================================
+DECK,DMP_XTHOST.
      SUBROUTINE DMP_XTHOST(Trest)

      IMPLICIT NONE
      REAL*8  TREST  ! (I) dump XTHOST for this Trest

c local var

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.
+CDE,XTCOM.

      INTEGER IRV, IFILT, IFILT_REST, iep0, iep
      CHARACTER CFILT*1
      REAL*8  AX, T, DTMIN, DT

C -------------- BEGIN ------------

c find epoch index closest to TREST
      DTMIN = 9999.
      DO iep = 1, NTBIN_KCOR  ! also y axis of SN SED
          T = GRIDVAL_T(iep)
          DT = abs(T-TREST)
          if ( DT .LT. DTMIN ) then
            DTMIN = DT
            iep0 = iep
          endif
      ENDDO

c write table header 

      write(6,20) Trest
20    format(/, T10,'A_X/AV at Trest = ', F5.1,' with 1/RV = ' )
      write(6,720) ' FILT '
      do irv = 1, NRVBIN_XTHOST
         write(6,711) RVINV_XTHOST(irv)
      enddo
      write(6,719) ' '
      write(6,719) ' ----------------------------------------- '


c fill out summary table

      DO 100 ifilt = 1, NFILTDEF_REST

        ifilt_rest = IFILTDEF_MAP_REST(ifilt)
        CFILT = FILTDEF_STRING(ifilt_rest:ifilt_rest)

         write(6,710) cfilt
710      format(T4,A, '  ', $)

         do irv = 1, NRVBIN_XTHOST
             AX = XTHOST(ifilt_rest,iep0,irv) 
             write(6,711) AX
711          format(F7.3, $)
         enddo

         write(6,719) ' '

719      format(A)
720      format(A,$)

100   CONTINUE

      RETURN
      END

C ================================================
+DECK,RDXTPAR.
      SUBROUTINE RDXTPAR(xtdir)
c
c Nov 16, 2006
c
c Initalize host-gal extinction parameters.
c See function GET_SNXT8(...)
c
c --------------
c Jul 15, 2008: allow alpha to be as large as 3 instead of 2
c               (needed for SALT2 color law)
c
c Sep 15, 2008: print extinction/AV for each filter (at Trest=0)
c
c Apr 17, 2009: fix to work with arbitrary NFILTDEF_REST
c               to work for MLCS-IR
c
c Apr 30, 2009: if we don't have [UBVRI] filters in alphabeta.dat,
c               then read polynomial coefficients and interpolate
c               to central wavelength.
c
c May 13, 2009: fix dumb bug reading ZETA.DAT .. <.49 => < .5001
c               and define LMATCH
c
c Sep 09,2010: replace +CDE,SNDATCOM with minimal keeps
c ----------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,FILTCOM.
+CDE,XTCOM.
+CDE,KCORCOM.
c +CDE,PARSECOM.

      CHARACTER XTDIR*(*)  ! (I) subdir to read parameters

c local

      CHARACTER 
     &   XTFILE*(MXCHAR_FILENAME)
     &  ,POLYFILE*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)
     &  ,CFILT2*2, CFILT*20 
     &  ,CWD*(MXCHAR_FILEWORD)
     &  ,CWDTMP*(MXCHAR_FILEWORD)
     &  ,C1ERR*80, C2ERR*80

      INTEGER 
     &   LENDIR, LENFILE, LEN, LUN, NFILT_KCOR
     &  ,NFILT_ALPHABETA, IFILT, izeta
     &  ,IFILT_REST, NRDEP, NLDEP, it, it0
     &  ,IERROPEN, iwd, NWD, i, MSKOPT

      REAL  
     &  alpha, beta, zeta(MXFILT_ALL)
     & ,Trest, dT

      REAL*8
     &   POLY8_ALPHA(0:3)
     &  ,POLY8_BETA(0:3)
     &  ,A8, B8, LAM8, LAMPOW8

      LOGICAL LBAD, LMATCH

c functions
      INTEGER FILTINDX 

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS
C -------------- BEGIN -------------

      LENDIR = INDEX(XTDIR,' ') - 1

      LUN = LUNTMP

      DO IFILT = 1, MXFILT_ALL
        XTPAR_ALPHA(ifilt) = -9.
        XTPAR_BETA(ifilt)  = -9.
      ENDDO

c if BX filter is one of the rest-filters, then exclude
c this from reading the zeta parameters.

      ifilt = IFILTDEF_INVMAP_REST(IFILT_BESS_BX)
      if ( ifilt .GT. 0 ) then
         NFILT_KCOR = NFILTDEF_REST - 1  ! exlcude BX
      ELSE
         NFILT_KCOR = NFILTDEF_REST 
      ENDIF

      IERROPEN = 0

c ---------------------------------------
c start with alpha,beta file

      XTFILE = XTDIR(1:LENDIR) // '/alphabeta.dat'
      LENFILE = INDEX(XTFILE,' ') - 1
      OPEN(UNIT=LUN, FILE=XTFILE, STATUS='OLD', ERR=990 )
      print*,'  Read ', XTFILE(1:LENFILE)

      NFILT_ALPHABETA = 0
2     READ(LUN, *, END = 20) cfilt2, alpha, beta

c get full filter name to avoid conflict with ESSENCE filters.
      CFILT = 'Bessell-' // cfilt2 
      IFILT_REST = FILTINDX(cfilt)
      ifilt = IFILTDEF_INVMAP_REST(IFILT_REST)

c sanity checks

        LBAD = .FALSE.
        IF ( ABS(alpha-1.0) .GT. 2.0 ) LBAD = .TRUE.
        IF ( ABS(beta)      .GT. 5.0 ) LBAD = .TRUE.
 
        if ( LBAD ) then
          print*,' '
          print*,'  RDXTPAR ERROR : bad index or parameter found.'
          print*,'  Check IFILT_REST=', IFILT_REST,'(',cfilt2,')  ', 
     &         'alpha,beta=', alpha,beta
          print*,'   filtdef_string = ', filtdef_string
          print*,' ***** ABORT ***** '
          print*,' '
          CALL EXIT(EXIT_ERRCODE)
        endif

        IF ( IFILT .GT. 0 ) THEN
          XTPAR_ALPHA(ifilt_rest) = alpha
          XTPAR_BETA(ifilt_rest)  = beta
          NFILT_ALPHABETA = NFILT_ALPHABETA + 1
        ENDIF

cc        print*,'  xxxx|',cfilt,'| ',   ifilt_rest, alpha, beta

      GOTO 2
20    CLOSE ( UNIT = LUN )      

      IF ( NFILT_ALPHABETA .EQ. 0 ) THEN
         c1err = 'Could not read anything from alphabeta.dat.'
         write(c2err,620) cfilt2, alpha, beta
620      format('cfilt=',A, 6x, 'alpha,beta = ', 2F10.3 )
         CALL MADABORT("RDXTPAR", C1ERR, C2ERR )
      ENDIF

      IF ( NFILT_ALPHABETA .EQ. NFILT_KCOR ) GOTO 444

c =======================================================
c if we get here, then not all rest-filters have been read, 
c so check for polynomial function to interpolate.

      POLYFILE = XTDIR(1:LENDIR) // '/alphabeta_fit.dat'

      OPEN(UNIT=LUNTMP, FILE = POLYFILE, 
     &     IOSTAT = IERROPEN, STATUS='OLD')
      CLOSE ( UNIT = LUNTMP )

c if polynomial file does not exist, abort later
c after table is printed so that we see what's going on.

      IF ( IERROPEN .NE. 0 ) GOTO 444

      MSKOPT  = MSKOPT_PARSE_WORDS_FILE
      LENFILE = INDEX ( POLYFILE, ' ' ) - 1
      print*,'  Read ', POLYFILE(1:LENFILE)
      NAME_forC = POLYFILE(1:LENFILE)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT,NAME_forC,LENFILE)

      DO 10 iwd = 1, NWD

          CALL get_PARSE_WORD_fortran(iwd,cwd,LEN)

          if ( cwd .EQ. ' ' ) goto 10

          IF ( CWD .EQ. 'ALPHA:' ) then
             do i = 0, 3
               call get_PARSE_WORD_fortran(iwd+i+1, CWDTMP, LEN)
               read(CWDTMP,* ) POLY8_ALPHA(i)
             enddo
          ENDIF

          IF ( CWD .EQ. 'BETA:' ) then
             do i = 0, 3
               call get_PARSE_WORD_fortran(iwd+i+1, CWDTMP, LEN)
               read(CWDTMP,* ) POLY8_BETA(i)
             enddo
          ENDIF
10    CONTINUE

c use polynomial to evaluate rest-filters that
c are not in the original .dat file.
c Use double precision for poly function

      DO 12 ifilt = 1, NFILTDEF_REST

        ifilt_rest = IFILTDEF_MAP_REST(ifilt)
        if ( IFILT_REST  .EQ.  IFILT_BESS_BX  ) GOTO 12
        if ( XTPAR_ALPHA(ifilt_rest) .GT. 0.0 ) GOTO 12

        A8 = 0.0
        B8 = 0.0
        LAM8 = DBLE ( FILTREST_LAMAVG(ifilt_Rest) )
        DO i = 0, 3
           LAMPOW8 = LAM8**i
           A8 = A8 + POLY8_ALPHA(i) * LAMPOW8
           B8 = B8 + POLY8_BETA(i)  * LAMPOW8
        ENDDO        
        XTPAR_ALPHA(IFILT_REST) = SNGL(A8)
        XTPAR_BETA(IFILT_REST)  = SNGL(B8)

12    CONTINUE

c ====================================================
c Read zeta(epoch) file.
c Trick here is to load epoch (in days) that matches
c the epochs in KCORTABLE

444   CONTINUE

      XTFILE = XTDIR(1:LENDIR) // '/zeta.dat'
      LENFILE = INDEX(XTFILE,' ') - 1
      OPEN(UNIT=LUN, FILE=XTFILE, STATUS='OLD', ERR=990 )
      print*,'  Read ', XTFILE(1:LENFILE)

      NRDEP = 0
      NLDEP = 0

3     READ(LUN, *, END = 30 ) 
     &    Trest, ( zeta(ifilt), ifilt=1, NFILT_KCOR )

         NRDEP = NRDEP + 1

c Now look for a match in GRIDVAL_T

        LMATCH = .FALSE.
        do it = 1, NTBIN_KCOR
           dT = Trest - GRIDVAL_T(it)

           if ( abs(dT) .LT. 0.5001 ) then
              LMATCH = .TRUE.
              if ( Trest .EQ. 0.0 ) it0 = it
              do ifilt = 1, NFILTDEF_REST
                 ifilt_rest = IFILTDEF_MAP_REST(ifilt)
                 izeta = ifilt
                 XTPAR_ZETA(ifilt_rest,it) = zeta(izeta)
              enddo
           endif
        enddo

        IF ( LMATCH )  NLDEP = NLDEP + 1

        GOTO 3

30    CLOSE ( UNIT = LUN )
      
    
c --------------------------------
      print*, '  ', NRDEP,' zeta-epochs read, and ', 
     &              NLDEP,' were stored.'
      print*,' '

      print*, 
     &  '                                   ZETA at '
      print*,
     &  '  FILT  ALPHA     BETA      -10d     0d    +10d '

      write(6,60)
60    format(T4, 60('-') )

c print some info for each passband

      DO 55 ifilt = 1, NFILTDEF_REST

          ifilt_rest = IFILTDEF_MAP_REST(ifilt)
          if ( IFILT_REST .EQ. IFILT_BESS_BX ) GOTO 55

          write(6,44) 
     &       filtdef_string(ifilt_rest:ifilt_rest)
     &      ,XTPAR_ALPHA(ifilt_rest)
     &      ,XTPAR_BETA(ifilt_rest)
     &      ,XTPAR_ZETA(ifilt_rest,it0-10)
     &      ,XTPAR_ZETA(ifilt_rest,it0+0)
     &      ,XTPAR_ZETA(ifilt_rest,it0+10)
44        format(T5, A, 2F10.5,2x, 3F8.5 )
55    CONTINUE

      write(6,60)

c -------------------------------------------------
c check for polynomial file here after 
c table is printed

      IF ( IERROPEN .NE. 0 ) THEN
        C1ERR = 'Could not find alphabeta vs. lambda polynomial: '
        C2ERR = POLYFILE(LENDIR+1:LENFILE)
        print*,'  xxxx  NFILT_ALPHABETA = ', NFILT_ALPHABETA 
        print*,'  xxxx  NFILT_KCOR = ', NFILT_KCOR
        CALL MADABORT("RDXTPAR", C1ERR, C2ERR )
      ENDIF

      IF ( NLDEP .EQ. 0 ) THEN
         write(c1err,661) NLDEP
661      format('Invalid # ZETA epochs stored: NLDEP=',I4 )
         c2err = 'Check zeta.dat file.'
         CALL MADABORT("RDXTPAR", C1ERR, C2ERR )
      ENDIF

      RETURN

C ----------------------------------------------------
990   CONTINUE
      PRINT*, '' 
      PRINT*,' RDXTPAR ERROR: could not open ', XTFILE
      PRINT*,'    XTDIR=', XTDIR
      PRINT*,'    LEN(XTDIR)=', LENDIR
      PRINT*,' ***** ABORT ***** '
      PRINT*, ' '
      CALL EXIT(EXIT_ERRCODE)

      END

C ====================
+DECK,PARSKCOR.
      SUBROUTINE PARSKCOR(chtit, ckcor, cfilt_rest, cfilt_obs)
c
c Nov 12, 2010: changed function to return filter string-names
c               instead of filter indices.
c
c Parse histogram title for K-correction symbol
c and filter indices. Returns rest and obs filter strings.
c
c
      IMPLICIT NONE

c subroutine args

      CHARACTER 
     &   chtit*(*)       ! (I) hbook title to parse 
     &  ,ckcor*(*)       ! (O) short K_xy symbol
     &  ,cfilt_rest*(*)  ! (O) rest-filter name: full string
     &  ,cfilt_obs*(*)   ! (O) idem for obs filter name

c local var

+CDE,SNPAR.
+CDE,KCORCOM.

      INTEGER j, j1, j2, n
      
c ----------- BEGIN ---------------


c init output

      ckcor      = 'NULL'
      cfilt_rest = ''
      cfilt_obs  = ''

c check of this histogram really stored a Kcor
      j = INDEX ( chtit, 'Kcor' )
      if ( j .LE. 0 ) RETURN

      cfilt_rest = ''
      cfilt_obs  = ''

c OK, now we have a valid Kcor ... parse string to get info.

c start with K_xy symbol
      j = INDEX ( chtit, 'K_' ) 
      ckcor      = chtit(J:J+3)         ! K_xy

c Now get rest-frame filter
      j  = INDEX ( chtit, 'rest' )
      j1 = j + 5 
      j2 = j1 + INDEX ( chtit(j1:), ' ') - 2
      n  = j2 - j1 + 1
      cfilt_rest(1:n) = chtit(J1:J2)  ! get rest filter
cc      print*,'  rest j, j1 j2 = ',  j, j1, j2

c ... and observer-frame filter

      j  = INDEX ( chtit, 'obs' )
      j1 = j + 4
      j2 = j1 + INDEX ( chtit(j1:), ' ') - 2
      n  = j2 - j1 + 1
      cfilt_obs(1:n) = chtit(J1:J2)  ! get obs filter
cc      print*,' xxxxx  obs  j, j1 j2 = ',  j, j1, j2


      RETURN
      END

C ================================
+DECK,FILTMATCH.
      SUBROUTINE FILTMATCH(cfilt, ifilt_rest, ifilt_obs )
C
C Nov 2010:
C returns ifilt_rest and ifilt_obs corresponding to this 
c 'cfilt' string. Usually only one of the indices is valid,
c but we allow for both to be used. Note that cfilt is the
c full filter-name, not just the last character.
c
c Jul 16, 2011: fix bug when CFILT_TMP='' and LEN=0;
c               now require LEN = LEN_TMP
c
c Dec 30, 2012: 
c    require string-length match for rest-frame filter check.
c    Previously we had Bessell-BX = Bessell-B
c ------------------------------------------------
      
      IMPLICIT NONE

c arguments
      CHARACTER cfilt*(*)  ! (I) filter string name to test
      INTEGER
     &   IFILT_REST  ! (O) rest-frame idex
     &  ,IFILT_OBS   ! (O) rest-frame idex

c local var
+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.

      INTEGER ifilt, ifilt_tmp, ifilt_indx, LEN, LEN_TMP
      CHARACTER cfilt_tmp*40
      LOGICAL LOBS

c function
      INTEGER FILTINDX

C ------------- BEGIN -------------

      IFILT_OBS  =  -9
      IFILT_REST =  -9
      IFILT_INDX =   FILTINDX(cfilt)
      LEN = index(cfilt,' ') - 1

C start with rest-frame filters
      DO 20 ifilt  = 1, NFILTDEF_REST
         ifilt_tmp = IFILTDEF_MAP_REST(ifilt)
         cfilt_tmp = FILTREST_NAME(ifilt_tmp)
         len_tmp   = index(cfilt_tmp,' ') - 1
         if ( len_tmp .NE. len) goto 20
         if ( cfilt(1:len) .EQ. cfilt_tmp(1:len) ) then
            IFILT_REST = IFILT_INDX
         endif
20    CONTINUE


c continue only if this obs-frame filter is defined.
      LOBS = IFILTDEF_INVMAP_SURVEY(ifilt_indx) .GT. 0
      IF ( .NOT. LOBS ) RETURN

c if this is not a rest-frame filter, the it MUST
c be an obs-frame filter.

      IF ( IFILT_REST .LT. 0  ) THEN
         IFILT_OBS = IFILT_INDX
         RETURN
      ENDIF

C this is a rest-frame filter, but check if this is also 
c an obs-frame filter

      DO 10 ifilt  = 1, NFILTDEF_SURVEY
         ifilt_tmp = IFILTDEF_MAP_SURVEY(ifilt)
         cfilt_tmp = FILTOBS_NAME(ifilt_tmp)  

         len_tmp = index(cfilt_tmp,' ') - 1
         if ( LEN .NE. LEN_TMP ) goto 10
         if ( cfilt(1:len) .EQ. cfilt_tmp(1:len) ) then
            IFILT_OBS = IFILT_INDX
         endif
10    CONTINUE


      RETURN
      END

C ====================
+DECK,PARSAV.
      SUBROUTINE PARSAV ( string, AV, IAV )
c
c Used by RDKCOR_HBOOK only
c Not used by RDKCOR_FITS.

      IMPLICIT NONE

      character string*(*)  ! (I) string with AV= xxx
      REAL AV               ! (O) AV float value in string
      INTEGER IAV           ! (O) AV index

+CDE,SNPAR.
+CDE,KCORCOM.

c local var

      INTEGER j
      character cav*8
      REAL  dif, AVMIN

C --------------- BEGIN -----------
      av  = -9.0
      iav = -9

c if AVbinsize is zero, then there is just one AV bin

      if ( AVbinsize_KCOR .EQ. 0.0 ) then
        AV = 0.0
        IAV = 1
        RETURN
      endif

      AVMIN = AVrange_KCOR(1)

      j = INDEX ( string, 'AV=' )
      if ( j .GT. 0.0 ) then
          cav = string(j+3:j+7)
          read(cav,*) av
          dif = av - AVMIN + 0.0001
          iav = int(dif / AVbinsize_KCOR + 0.5) + 1
      endif

      RETURN
      END

C ===============================================
+DECK,SET_LAMRANGE.
      SUBROUTINE SET_LAMREST_RANGE(ifilt)
c
c Created Dec 7, 2006 by R.Kessler
c
c Set lambda range for this "ifilt"
c Hard-wire Bessell ranges from Jha's MLCS code.
c hard-wire SDSS ranges based on inspection of filter responses.
c
c The reason for hard-wiring ranges is so that when
c we change to other 'Bessell-like' systems (Cohen, etc ...),
c then the rest-frame filter won't change.
c
c Apr 17, 2009: check nearest filter using sparse array
c               index of assuming that index is +-1 
c               from current index.  Initial use is MLCS-IR.
c
c Aug 12, 2009: 
c   - set I-band LAM-range based on whether Y-band
c     is defined in the rest-frame.
c
c   - for bluest  unknown  filter, LAMMIN -> LAMMIN/2
c   - for reddest unknown  filter, LAMMAX -> LAMMAX + 1000
c
c
c Nov 3, 2010: 
c   - more than 6 filters, skip to 300 (for CSP BVugriYJH)
c   - fix logic below '300' to handle close-lambda filters 
c       
c ----------------------------------------

      IMPLICIT NONE
       
      integer ifilt  ! (I) filter index

c locaql args

+CDE,SNPAR.
+CDE,FILTCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,KCORCOM.

      LOGICAL LSET, LTMP,  LVALID

      INTEGER 
     &   ilam, ilam_nbr
     &  ,ifilt_nbr
     &  ,IMINMAX, i
     &  ,ifilt_near(2)
     &  ,ifilt_rest
     &  ,ifilt_tmp
     &  ,NBIN_OVP

      REAL 
     &   LAM_NBR, LAMAVG_NBR
     &  ,LAM, LAMAVG, LAMTMP, LAMMAX
     &  ,LAMDIF, LAMDIF_NEAR(2)
     &  ,DLAM, T, TNBR, DT, DTMIN, LAMOVP, LAMOVP_AVG

C ------------------ BEGIN --------------

c if ugriz and UBVRI are mixed, then use the more general
c filter-boundary logic below. Here we just check if there 
c are more than 6 rest-frame filters, but better logic 
c should be included later.

      IF ( RESTKCOR_FILTERS(1:5) .NE. 'UBVRI' ) GOTO 300

c -------------------------------------------------
      IF ( ifilt .EQ.  IFILT_SDSS_u ) THEN
         FILTREST_LAMRANGE(1,ifilt) =  1000.
         FILTREST_LAMRANGE(2,ifilt) =  3900.
      ELSE IF ( ifilt .EQ.  IFILT_SDSS_g ) THEN
         FILTREST_LAMRANGE(1,ifilt) =  3900.
         FILTREST_LAMRANGE(2,ifilt) =  5440.
      ELSE IF ( ifilt .EQ.  IFILT_SDSS_r ) THEN
         FILTREST_LAMRANGE(1,ifilt) =  5440.
         FILTREST_LAMRANGE(2,ifilt) =  6830.
      ELSE IF ( ifilt .EQ.  IFILT_SDSS_i ) THEN
         FILTREST_LAMRANGE(1,ifilt) =  6830.
         FILTREST_LAMRANGE(2,ifilt) =  8260.
      ELSE IF ( ifilt .EQ.  IFILT_SDSS_z ) THEN
         FILTREST_LAMRANGE(1,ifilt) =  8260.
         FILTREST_LAMRANGE(2,ifilt) = 12000.

c -----

      ELSE IF ( ifilt .EQ.  IFILT_BESS_U ) THEN
         FILTREST_LAMRANGE(1,ifilt) = 1000.
         FILTREST_LAMRANGE(2,ifilt) = 3900.
      ELSE IF ( ifilt .EQ.  IFILT_BESS_B ) THEN
         FILTREST_LAMRANGE(1,ifilt) = 3900.
         FILTREST_LAMRANGE(2,ifilt) = 4850.
      ELSE IF ( ifilt .EQ.  IFILT_BESS_BX ) THEN
         FILTREST_LAMRANGE(1,ifilt) = 3615.
         FILTREST_LAMRANGE(2,ifilt) = 5595.
      ELSE IF ( ifilt .EQ.  IFILT_BESS_V ) THEN
         FILTREST_LAMRANGE(1,ifilt) = 4850.
         FILTREST_LAMRANGE(2,ifilt) = 5850.
      ELSE IF ( ifilt .EQ.  IFILT_BESS_R ) THEN
         FILTREST_LAMRANGE(1,ifilt) = 5850. 
         FILTREST_LAMRANGE(2,ifilt) = 7050.
      ELSE IF ( ifilt .EQ.  IFILT_BESS_I ) THEN

         IFILT_TMP = IFILTDEF_INVMAP_REST(IFILT_Y) 
         if ( IFILT_TMP .GT. 0 ) then
            LAMMAX = FILTREST_LAMRANGE(1,IFILT_Y) 
         else
            LAMMAX = 12000.  ! no Y-band in rest-frame
         endif
         FILTREST_LAMRANGE(1,ifilt) = 7050.
         FILTREST_LAMRANGE(2,ifilt) = LAMMAX

      ENDIF

c check option to include buggy lambda ranges.

      IF ( DOBUG_LAMRANGE ) THEN
         FILTREST_LAMRANGE(2,IFILT_BESS_V) = 5800.
         FILTREST_LAMRANGE(1,ifilt_BESS_R) = 5800.  
         FILTREST_LAMRANGE(2,ifilt_BESS_R) = 7300.
         FILTREST_LAMRANGE(1,ifilt_BESS_I) = 7300.
      ENDIF

c check if FILT_LAMRANGE has been set;
c if not, then just use approx calc.

      LSET = FILTREST_LAMRANGE(1,ifilt) .GE. 0.0 .and.
     &       FILTREST_LAMRANGE(2,ifilt) .GE. 0.0 
      IF ( LSET ) RETURN

c -------------------------------------------
c if we are here, set LAMRANGE based on where
c transmission(LAM,ifilt) = transmission of 
c next closest filter.

c first set min and max lambda for this filter to be
c default LAMBDA range.

300   CONTINUE

      LAM = FILTREST_LAMBDA(1,ifilt)
      FILTREST_LAMRANGE(1,ifilt)  = LAM

      LAM = FILTREST_LAMBDA(NLAMBIN_FILTREST(ifilt),ifilt)
      FILTREST_LAMRANGE(2,ifilt)  = LAM

      LAMAVG = FILTREST_LAMAVG(ifilt)

c fetch nearest rest-frame filters needed by SN model

      IFILT_NEAR(1)  = -9
      IFILT_NEAR(2)  = -9
      LAMDIF_NEAR(1) = 99999.
      LAMDIF_NEAR(2) = 99999.

      DO 190 i = 1, NFILTDEF_REST

        ifilt_rest = IFILTDEF_MAP_REST(i)
        if ( ifilt_rest .EQ. IFILT ) goto 190

        LAMTMP  = FILTREST_LAMAVG(ifilt_rest)
        LAMDIF  = ABS(LAMAVG-LAMTMP)

        if   ( LAMTMP .LT. LAMAVG 
     &   .and. LAMDIF .LT. LAMDIF_NEAR(1) ) then
            LAMDIF_NEAR(1) = LAMDIF
            IFILT_NEAR(1) = ifilt_rest
        endif

        if   ( LAMTMP .GT. LAMAVG 
     &   .and. LAMDIF .LT. LAMDIF_NEAR(2) ) then
            LAMDIF_NEAR(2) = LAMDIF
            IFILT_NEAR(2) = ifilt_rest
        endif

190   CONTINUE  ! end of sparse loop over rest filters


c set extreme bound if there is no nbr filter
      IF ( IFILT_NEAR(1) .LE. 0 ) then
         FILTREST_LAMRANGE(1,ifilt) = FILTREST_LAMRANGE(1,ifilt)/2.
      ENDIF
      IF ( IFILT_NEAR(2) .LE. 0 ) then
        FILTREST_LAMRANGE(2,ifilt) = 
     &  FILTREST_LAMRANGE(2,ifilt) + 1000.
      ENDIF

c if voisin filter has smaller LAMAVG,
c then look for where transmissions are the same
      
      DO 200 IMINMAX = 1, 2  ! bluer, redder filter

         ifilt_nbr  = ifilt_near(IMINMAX)
         if ( ifilt_nbr  .LE. 0      ) goto 200

         LAMAVG_NBR = FILTREST_LAMAVG(ifilt_nbr)
         if ( LAMAVG_NBR .EQ. LAMAVG ) goto 200
         if ( LAMAVG_NBR .LT. 0.0    ) goto 200

         LAMOVP      = FILTREST_LAMRANGE(iminmax,ifilt) ! init

         NBIN_OVP    = 0
         DTMIN       = 9.
         DO ilam     = 1, NLAMBIN_FILTREST(ifilt)
         DO ilam_nbr = 1, NLAMBIN_FILTREST(ifilt_nbr)
           LAM       = FILTREST_LAMBDA(ilam,ifilt)
           LAM_NBR   = FILTREST_LAMBDA(ilam_nbr,ifilt_nbr)
           T    = FILTREST_TRANS(ilam,ifilt) / 
     &                 FILTREST_TRANSMAX(ifilt)
           TNBR = FILTREST_TRANS(ilam_nbr,ifilt_nbr) / 
     &                 FILTREST_TRANSMAX(ifilt_nbr)
           DT   = ABS(T-TNBR)
           DLAM = ABS(LAM-LAM_NBR)
           LTMP = (DLAM .LT. 1.0) .and.  (DT .LT. DTMIN)
           IF ( LTMP ) THEN
              DTMIN   = DT
              LAMOVP  = LAM
              NBIN_OVP = NBIN_OVP + 1
           ENDIF

         ENDDO
         ENDDO

c if LAMOVP is unphysical, just take average of filter and nbr 
         LAMOVP_AVG = 0.5 * ( LAMAVG + LAMAVG_NBR ) 

         LVALID = LAMOVP .GE. LAMAVG_NBR .and. LAMOVP .LE. LAMAVG
         if ( IMINMAX .EQ. 1 .and. .not. LVALID ) then
            LAMOVP = LAMOVP_AVG
         endif
         LVALID = LAMOVP .LE. LAMAVG_NBR .and. LAMOVP .GE. LAMAVG
         if ( IMINMAX .EQ. 2 .and. .not. LVALID ) then
            LAMOVP = LAMOVP_AVG
         endif

c if the wavelength ranges do not overlap, just take average
         if ( NBIN_OVP .EQ. 0 ) then
            LAMOVP = LAMOVP_AVG
         endif

         FILTREST_LAMRANGE(iminmax,ifilt)  = LAMOVP

200   CONTINUE  ! loop over bluer/redder filter

      RETURN 
      END

C ==========================================
+DECK,SETZPOFF.
      SUBROUTINE SET_ZPOFF
c
c Created July 17, 2011 by R.Kessler
c Called from RDKCOR to update MAGOBS_SHIFT_ZP_FILT(ifilt_obs) 
c for each filter. Update based on FILTOBS_ZPOFF_SNPHOT(ifilt_obs) 
c that is read either from the KCOR file or from the ZPOFF_FILE.
c
c Feb 22, 2012:
c  Use MAGOBS_SHIFT_ZP_USER(ifilt_obs)  so that final
c  SHIFT_ZP is OK even if RDKCOR is called multiple times.
c -------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,SNFILECOM.  SNDATA_ROOT is here
+CDE,KCORCOM.
+CDE,FILTCOM.

      INTEGER IFILT, IFILT_OBS, jlen
      LOGICAL DO_ZPOFF

+SELF,IF=MARKDELETE.

c xxxxx mark delete Dec 7 2019 xxxxxxxxxxxxxx
c -----------------------------------------------
c set legacy SDSS_web2001 AB offsets if ZPOFF file has not
c been specified in the KCOR file (as hid 252 or 292), 
c and if ZPOFF values have not already been read.
c This logic is needed to read the really old KCOR files
c that do not have the SDSS AB offsets included.

      if (  ZPOFF_FILE .EQ. 'NULL' 
     &  .and. .not. LRDZPOFF         ! not read from KCOR hbook file
     &  .and.  SURVEY_NAME(1:4) .EQ. 'SDSS' ) then
          jlen = INDEX(SNDATA_ROOT,' ') - 1
          ZPOFF_FILE = SNDATA_ROOT(1:jlen) // 
     &       '/filters/SDSS_web2001/ZPOFF.DAT'
      endif

      DO_ZPOFF   = ( ZPOFF_FILE .NE. 'NULL' ) .and. 
     &             ( NCALL_RDKCOR .EQ. 1 ) 

      IF ( DO_ZPOFF ) THEN
         LRDZPOFF = .TRUE.
         CALL RD_ZPOFF(ZPOFF_FILE, FILTOBS_ZPOFF_SNPHOT)  ! return ZPOFF
      ENDIF
c xxxxxxxxxx end mark xxxxxxxxxxx
+SELF.

c update ZP-shift for each filter (i.e., add to user-shift)
      DO ifilt  = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          MAGOBS_SHIFT_ZP_FILT(ifilt_obs) = 
     &    MAGOBS_SHIFT_ZP_USER(ifilt_obs) +
     &    FILTOBS_ZPOFF_SNPHOT(ifilt_obs)
      ENDDO

c check for lambda-dependent MAGOBS_SHIFT (Sep 30, 2015)
      CALL MAGOBS_SHIFT_UPDATE()

c dump ZPOFF values vs. filter
      CALL DMP_ZPOFF 

      RETURN
      END  ! end of SET_ZPOFF

C =======================================
+DECK,MAGOBS_SHIFT_UPDATE.
      SUBROUTINE MAGOBS_SHIFT_UPDATE()

c Created Sep 20 2015
c Loop over filters and apply optional shift-vs-lambda
c for ZP and PRIMARY mag. Allows coherent mag-shifts
c with just a few parameters instead of giving a mag
c shift for each band.
c See &SNLCINP parameters MAGOBS_SHIFT_[ZP,PRIMARY]_PARAMS(3)
c
      IMPLICIT NONE

c local 

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IFILT, IFILTDEF

      REAL MAGOBS_SHIFT_USRFUN  ! function
C --------------- BEGIN -----------

      DO ifilt = 1, NFILTDEF_SURVEY
         IFILTDEF = IFILTDEF_MAP_SURVEY(ifilt)

         magobs_shift_zp_filt(ifiltdef) = 
     &   magobs_shift_zp_filt(ifiltdef) +
     &          MAGOBS_SHIFT_USRFUN(ifiltdef, 'ZP') ! Sep 2015

         magobs_shift_primary_filt(ifiltdef) = 
     &   magobs_shift_primary_filt(ifiltdef) +
     &          MAGOBS_SHIFT_USRFUN(ifiltdef, 'PRIMARY') ! Sep 2015
      ENDDO

      RETURN
      END  ! end of MAGOBS_SHIFT_UPDATE

C =======================================
+DECK,MAGOBS_SHIFT_USRFUN.
      REAL FUNCTION MAGOBS_SHIFT_USRFUN(IFILTDEF, WHAT )

c Created Sep 30 2015
c Compute shift for what='ZP' or what='PRIMARY' for this IFILTDEF.
c Use SNLCINP parameters MAGOBS_SHIFT_[ZP,PRIMARY]_PARAMS to 
c determine polynomial function of wavelength. This allows computing
c correlated systematics among filters using a function of wavelength
c so that you don't have to enter a shift for each band separately.
c
c BEWARE: POLYNOMIAL FUNCTION OF LAMBDA IN MICRONS (NOT ANGSTROMS) 
c
c ----------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER    IFILTDEF   ! (I) absolute filter index
      CHARACTER  WHAT*(*)   ! (I) 'ZP' or 'PRIMARY'

c local var

      REAL LAM_um, SQLAM_um, COEF(0:2)
      CHARACTER FNAM*20

c ------------------- BEGIN ----------------

      FNAM = 'MAGOBS_SHIFT_USRFUN'
      MAGOBS_SHIFT_USRFUN = 0.0 

      IF ( WHAT(1:2) .EQ. 'ZP' ) THEN
         COEF(0) = MAGOBS_SHIFT_ZP_PARAMS(1)
         COEF(1) = MAGOBS_SHIFT_ZP_PARAMS(2)
         COEF(2) = MAGOBS_SHIFT_ZP_PARAMS(3)
      ELSE IF ( WHAT(1:7) .EQ. 'PRIMARY' ) THEN
         COEF(0) = MAGOBS_SHIFT_PRIMARY_PARAMS(1) 
         COEF(1) = MAGOBS_SHIFT_PRIMARY_PARAMS(2)
         COEF(2) = MAGOBS_SHIFT_PRIMARY_PARAMS(3)
      ELSE
         C1ERR = 'Invalid WHAT=' // WHAT
         C2ERR = 'for MAGOBS_SHIFT_XXX'
         CALL  MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF
      
      LAM_um   = FILTOBS_LAMAVG(ifiltdef)/1.0E4
      SQLAM_um = LAM_um * LAM_um

      MAGOBS_SHIFT_USRFUN =
     &      COEF(0)
     &    + COEF(1) * LAM_um
     &    + COEF(2) * SQLAM_um

c xxxxxxxxxxxxxxxxx
c      write(6,66) WHAT(1:2), MAGOBS_SHIFT_USRFUN, IFILTDEF, LAM_um
c66    format(' xxx ', A2, ' = ', F7.4,' for IFILTDEF=',I3, 
c     &      3x,'LAM=',F7.3,' um')
c      CALL FLUSH(6)
c xxxxxxxxxxxxxxxxx

      RETURN
      END  ! end of MAGOBS_SHIFT_USRFUN



C ======================
+DECK,CHKDUPFILT.
      SUBROUTINE CHECK_DUPLICATE_FILTER(FRAME,CFILTNAME,IFILT)
c
c Created May 22, 2012
c Print error message if this is a duplicate filter.
c Increment error counter instead of ABORTing so that
c all duplicate filters are identified before aborting
c from RDKCOR.

      IMPLICIT NONE
      CHARACTER 
     &   FRAME*(*)      ! (I) 'REST' or 'OBS'
     *  ,CFILTNAME*(*)  ! (I) full name of filter
  
      INTEGER IFILT     ! (I) IFILT_OBS or IFILT_REST

c local var
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      LOGICAL   ISDEF
      INTEGER   L1, L2
      CHARACTER CFILT1*1, CFILTDEF*40

C -------------- BEGIN ------------

c don't check on 2nd RDKCOR call
      IF ( NCALL_RDKCOR .GT. 1 ) RETURN

      IF ( FRAME .EQ. 'REST' ) THEN
        ISDEF    = LFILTDEF_REST(IFILT)
        CFILTDEF = FILTREST_NAME(ifilt)  
      ELSE
        ISDEF     = LFILTDEF_OBS(IFILT)  ! obs-filter already defined
        CFILTDEF  = FILTOBS_NAME(ifilt)  ! already defined filter
      ENDIF

      IF ( ISDEF ) THEN
        cfilt1 = filtdef_string(ifilt:ifilt)
        L1 = INDEX(CFILTNAME,' ') - 1
        L2 = INDEX(CFILTDEF,' ') - 1
        write(6,20) FRAME, CFILT1, CFILTNAME(1:L1), CFILTDEF(1:L2)
20      format(T2,'ERROR: ',A,'-',A,' defined twice : ',
     &       A,'  &  ', A)
        NFILT_DUPLICATE_RDKCOR = NFILT_DUPLICATE_RDKCOR + 1
      ENDIF

      RETURN
      END  ! end CHECK_DUPLICATE_FILTER

C ========================================
+DECK,BRACKET.
      INTEGER FUNCTION BRACKET_IFILT_OBS ( 
     &          LAMREST, Z, IFILTOBS_BRACKET )

c -----------------------------------------
c Feb 12, 2012
c Return IFILTOBS_BRACKET(2) (filter indices) that brackets
c LAMREST in the rest-frame. In the loop over SURVEY filters, 
c IFILT_OBS = -999 is a flag to ignore this filter.
c
c Return number of bracket-filters found; 2 => success.
c
c Mar 20, 2012: require EXIST_FILTER(ifiltobs)
c
c ------------------------------------------

      IMPLICIT NONE

c subroutine args.

      REAL LAMREST   ! (I) rest-frame lambda to match
      REAL Z         ! (I) redshift
      INTEGER 
     &  IFILTOBS_BRACKET(2) ! (O) IFILTOBS that brackets LAMREST

c local var
+CDE,SNDATCOM.  from snana.car
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IFILT, IFILTOBS, JLOHI, NFILT
      REAL Z1, LAMZ, LAMDIF, LAMDIFMIN(2)

C ------------- BEGIN ------------

      Z1 = 1.0 + z

      LAMDIFMIN(1) = 99999999.
      LAMDIFMIN(2) = 99999999.

      IFILTOBS_BRACKET(1) = -9 
      IFILTOBS_BRACKET(2) = -9

      DO 100 ifilt = 1, NFILTDEF_SURVEY

         if ( .not. EXIST_FILT(ifilt) ) goto 100

         ifiltobs = IFILTDEF_MAP_SURVEY(ifilt)
         if ( ifiltobs .EQ. -999 ) goto 100
         
         LAMZ   = FILTOBS_LAMAVG(ifiltobs)/Z1
         LAMDIF = ABS(LAMZ-LAMREST)

c xxxxxxxxxxx
c         print*,' xxx BBB ifiltobs=',ifiltobs,'   LAMZ=',LAMZ
c         call flush(6) ! xxxxxxxx
c xxxxxxxxxxxxx

         IF ( LAMZ .LE. LAMREST ) THEN
            JLOHI = 1
         ELSE
            JLOHI = 2
         ENDIF

         if ( LAMDIF .LT. LAMDIFMIN(JLOHI) ) then
             LAMDIFMIN(JLOHI)        = LAMDIF
             IFILTOBS_BRACKET(JLOHI) = IFILTOBS
         endif

c         print*,'      DDDDD ifiltobs = ', ifiltobs
100   CONTINUE

c set function value

      NFILT = 0
      IF ( IFILTOBS_BRACKET(1) .GT. 0 ) NFILT = NFILT + 1
      IF ( IFILTOBS_BRACKET(2) .GT. 0 ) NFILT = NFILT + 1

      BRACKET_IFILT_OBS = NFILT

      RETURN
      END
C ===========================================
+DECK,NEARFLTOBS.
      INTEGER FUNCTION NEAREST_IFILT_OBS(ifilt_rest,Z)

c Nov 2010 R.Kessler
c Return nearest OBS-frame filter corresponding
c to this rest-frame filter.  Just do a brute force
c loop over all obs-frame filters and see which has
c IFILT_REST as the nearest.
c
c Returns -9 if no nearest filter can be found ...
c let calling program decide whether to abort
c or move on.
c -------------------

      IMPLICIT NONE

      INTEGER IFILT_REST  ! rest-frame index
      REAL    Z           ! redshift

+CDE,SNPAR.
+CDE,FILTCOM.

      INTEGER OPT_FRAME, ifilt, ifilt_obs_tmp, ifilt_rest_tmp, irank
      REAL LAMDIF_MIN, LAMDIF, ZZ
      LOGICAL LLAM, LFILT
      CHARACTER CFILT_rest*2

c functions
      INTEGER NEAREST_IFILT_REST

C -------------- BEGIN -------------
  
      NEAREST_IFILT_OBS = -9
      OPT_FRAME = OPT_FILTOBS
      irank     = 1

      LAMDIF_MIN = 1.0E9

      CFILT_rest  = filtdef_string(ifilt_rest:ifilt_rest)

      DO 100 ifilt     = 1, NFILTDEF_SURVEY
        ifilt_obs_tmp  = IFILTDEF_MAP_SURVEY(ifilt)
        ifilt_rest_tmp = 
     &  NEAREST_IFILT_REST(OPT_FRAME,ifilt_obs_tmp,irank,ZZ,LAMDIF)

        LFILT = ifilt_rest_tmp .EQ. ifilt_rest   
        LLAM  = LAMDIF .LT. LAMDIF_MIN

        if ( LFILT .and. LLAM ) then
           NEAREST_IFILT_OBS = ifilt_obs_tmp
           LAMDIF_MIN = LAMDIF
        endif
100   CONTINUE

      RETURN
      END

C ===========================================
+DECK,NEARFLTREST.
      INTEGER FUNCTION NEAREST_IFILT_REST( 
     &   OPT          ! (I) option; see below
     &  ,ifiltdef     ! (I) observer filter index
     &  ,rank_want    ! (I) 1=nearest, 2=2nd nearest, 3=3rd nearest
     &  ,Z            ! (I) redshift
     &  ,LAMDIF_MIN   ! (O) min lam-distance (A) 
     &    )

c Returns IFILT index in rest frame such that
c <lambda_rest> * ( 1+ z ) is closest to the 
c observer frame <lambda>.
c
c OPT bit 1 => rest-frame
c OPT bit 2 => obs-frame
c OPT bit 3 => use MLCS2k2 hard-wire for 2nd closest
c OPT bit 4 => if near-filt not found, then return -9 instead of ABORT
c
c RANK_WANT = 1 => returns closest filter;
c RANK_WANT = 2 => returns 2nd closest filter
c RANK_WANT = 3 => returns 3rd closest filter
c
c Nov 13, 2010: allow ifilt argument to be either obs or rest;
c               see OPT bits.
c
c Nov 15, 2010: change RETURN to "GOTO 900" and abort if 
c               NEAREST_IFILT has not been set.
c
c Apr 27, 2011: if bit 4 (OPT+=8) is set, then do NOT abort if 
c               filter is not found ==> return -9
c
c -----------------------------

      IMPLICIT NONE

      INTEGER 
     &   OPT         ! (I) options (2=> use MLCS2k2 hard-wire for 2nd closest)
     &  ,IFILTDEF    ! (I) absolute filter index
     &  ,RANK_WANT   ! (I) 1st or 2nd closest

      REAL Z           ! (I) redshift
      REAL LAMDIF_MIN  ! (O) min lam-distance

c local var

+CDE,SNPAR.
+CDE,FILTCOM.

c define OPT-bits
      INTEGER 
     &   OPTBIT_FILTOBS, OPTBIT_FILTREST
     &  ,OPTBIT_LEGACY, OPTBIT_NOABORT

      PARAMETER( OPTBIT_FILTREST  = OPT_FILTREST )
      PARAMETER( OPTBIT_FILTOBS   = OPT_FILTOBS  )
      PARAMETER( OPTBIT_LEGACY    = 3 )
      PARAMETER( OPTBIT_NOABORT   = 4 )

      INTEGER 
     &   OPT_FRAME, ifilt
     &  ,ifilt_rest(5) 
     &  ,ifilt2, ifilt3
     &  ,iedge, i, i2, NLAMZ

      REAL  LAMDIF, LAMZ, LAMAVG_IN

      LOGICAL  LZ, LDMP, LEGACY_MLCS2k2, ABORT_FLAG

      CHARACTER C1ERR*68, C2ERR*68, CFILT*2, CFILT1, CFILT2, FNAM*20

c ------------ BEGIN -------------

      FNAM = 'NEAREST_IFILT_REST'

      NEAREST_IFILT_REST = -9  ! init output value to NOT found

      OPT_FRAME = 0
      LEGACY_MLCS2k2 = .FALSE.
      ABORT_FLAG     = .TRUE.  ! default is to abort if no near-filt is found

      IF ( BTEST(OPT,OPTBIT_FILTOBS-1)  ) OPT_FRAME  = OPT_FILTOBS
      IF ( BTEST(OPT,OPTBIT_FILTREST-1) ) OPT_FRAME  = OPT_FILTREST
      IF ( BTEST(OPT,OPTBIT_LEGACY-1)   ) LEGACY_MLCS2k2 = .TRUE.
      IF ( BTEST(OPT,OPTBIT_NOABORT-1)  ) ABORT_FLAG     = .FALSE.

      LDMP = ( Z .EQ. 999999. )

      LAMDIF_MIN = -999.
      ifilt_rest(1) = -9  ! init 

      IF ( OPT_FRAME .EQ. OPT_FILTOBS ) THEN
         LAMAVG_IN = FILTOBS_LAMAVG(ifiltdef)
      ELSE IF ( OPT_FRAME .EQ. OPT_FILTREST ) THEN
         LAMAVG_IN = FILTREST_LAMAVG(ifiltdef)
      ELSE
         write(c1err,664) OPT_FRAME, OPT
664      format('Invalid OPT_FRAME=',I2,' for OPT=',I3)
         c2err = 'Check arguments.'
         CALL MADABORT (FNAM, c1err, c2err)
      ENDIF
    
      lamz   = LAMAVG_IN / ( 1 + z )

      IF ( LDMP ) THEN
          print*,' -------------------------------------'
          print*,' xxxx DUMP NEAREST_IFILT_REST xxxxx '
          print*,' Z=',Z,'   ifiltdef = ', ifiltdef,' (',
     &          filtdef_string(ifiltdef:ifiltdef), ')'
          print*,' xxx LAMAVG_IN, LAM/Z = ', 
     &         FILTOBS_LAMAVG(ifiltdef), LAMZ
      ENDIF

c Always get nearest filter to start

      NLAMZ = 0
      DO 21 i = 1, NFILTDEF_REST
         ifilt = IFILTDEF_MAP_REST(i)

         IF ( IFILT .EQ. IFILT_BESS_BX ) GOTO 21   ! ignore BX filter

         DO i2 = 1, NFILTDEF_IGNORE_REST
           if ( ifilt .EQ. IFILTDEF_IGNORE_REST(i2) ) goto 21
         ENDDO


         LZ = lamz .GE. FILTREST_LAMRANGE(1,ifilt) .and.
     &        lamz. LT. FILTREST_LAMRANGE(2,ifilt) 

         IF ( LDMP ) THEN
            print*,' xxx ifilt_rest=',ifilt
     &         ,'(',FILTDEF_STRING(ifilt:ifilt),')'
     &         ,'  LAMRANGE='
     &         , FILTREST_LAMRANGE(1,ifilt)
     &         , FILTREST_LAMRANGE(2,ifilt)
     &         , '  LZ=',LZ
         ENDIF

c set IFILT_REST. Note that IFILT_REST(2) is NOT the 2nd nearest
c filter; it is a 2nd solution for the nearest filter that
c will result in an abort below.

         if ( LZ ) then
            NLAMZ = NLAMZ + 1
            ifilt_rest(NLAMZ) = ifilt
            LAMDIF_MIN = abs(LAMZ - FILTREST_LAMAVG(ifilt))
         endif

21    CONTINUE

c make sure that there is just one nearest filter.

      IF ( NLAMZ .GT. 1 ) THEN
        CFILT  = filtdef_string(ifiltdef:ifiltdef)
        CFILT1 = filtdef_string(ifilt_rest(1):ifilt_rest(1))
        CFILT2 = filtdef_string(ifilt_rest(2):ifilt_rest(2))

        print*,' ' 
        print*,'  LAMZ = ', LAMAVG_IN, '/',1+z,
     &       ' = ', LAMZ
        print*,'  NFILTDEF_REST=', NFILTDEF_REST
        print*,'  IFILTDEF_MAP_REST=', 
     &      (IFILTDEF_MAP_REST(i), i=1, NFILTDEF_REST )

        write(c1err,661) NLAMZ, IFILTDEF, CFILT(1:1), LAMZ
661     format('Found ',I2,' rest-filters for IFILTDEF=',
     &         I2,'(',A, '),  LAMZ=',F8.2  )

        write(c2err,662) 
     &      IFILT_REST(1), IFILT_REST(2), cfilt1, cfilt2
662     format('IFILT_NEAR = ', 2I3, 3x, '(',A, 2x, A, ')'  )

        CALL MADABORT (FNAM, C1ERR, C2ERR )
      ENDIF

      IF ( RANK_WANT .EQ. 1 ) THEN
         NEAREST_IFILT_REST = ifilt_rest(1)
         GOTO 900
      ENDIF

      IF ( LEGACY_MLCS2k2 ) GOTO 444

c --------------------------------------------
c check if we want 2nd closest filter
c Find filter with closest <LAM> +- RMS

      IF ( RANK_WANT .GE. 2 ) THEN

        ifilt2 = -9 
        LAMDIF_MIN = 999999.

        DO 22 i = 1, NFILTDEF_REST
         ifilt = IFILTDEF_MAP_REST(i)
         
          if ( IFILT .EQ. IFILT_BESS_BX ) GOTO 22   ! ignore BX filter
          if ( IFILT .EQ. ifilt_rest(1) ) GOTO 22

           DO i2 = 1, NFILTDEF_IGNORE_REST
             if ( ifilt .EQ. IFILTDEF_IGNORE_REST(i2) ) goto 22
           ENDDO


          DO 222 iedge = 1, 2   ! min, max edge of each filter 
             LAMDIF = abs(lamz - FILTREST_LAMRANGE(iedge,ifilt) )
             if ( LAMDIF .LT. LAMDIF_MIN ) then
                  LAMDIF_MIN = LAMDIF
                  ifilt2 = ifilt
             endif
222       CONTINUE

22      CONTINUE


         if ( RANK_WANT .EQ. 2 ) then
            NEAREST_IFILT_REST = ifilt2
            GOTO 900
         endif
      ENDIF

c --------------------------------------------
c check if we want 3rd closest filter
c Find filter with closest edge.

      IF ( RANK_WANT .EQ. 3 ) THEN

        ifilt3 = -9 
        LAMDIF_MIN = 999999.

        DO 33 i = 1, NFILTDEF_REST
          ifilt = IFILTDEF_MAP_REST(i)

          if ( IFILT .EQ. IFILT_BESS_BX ) GOTO 33   ! ignore BX filter
          if ( IFILT .EQ. ifilt_rest(1) ) GOTO 33
          if ( IFILT .EQ. ifilt2        ) GOTO 33

           DO i2 = 1, NFILTDEF_IGNORE_REST
             if ( ifilt .EQ. IFILTDEF_IGNORE_REST(i2) ) goto 33
           ENDDO


          DO 333 iedge = 1, 2   ! min, max edge of each filter 
             LAMDIF = abs(lamz - FILTREST_LAMRANGE(iedge,ifilt) )
             if ( LAMDIF .LT. LAMDIF_MIN ) then
                LAMDIF_MIN = LAMDIF
                ifilt3 = ifilt
             endif
333       CONTINUE

33      CONTINUE

        NEAREST_IFILT_REST = ifilt3
        GOTO 900

      ENDIF


c ------------------------------
c check special option to return 2nd closest filter
c according to MLCS. From Jha's e-mail.
c The rest-frame local colors From Jha are
c   U-B for U
c   B-V for B and V
c   V-R for R
c   R-I for I
c

444   CONTINUE
      IF ( LEGACY_MLCS2k2 .and. RANK_WANT .EQ. 2 ) THEN

         if ( ifilt_rest(1) .EQ. IFILT_BESS_U ) then
            NEAREST_IFILT_REST = IFILT_BESS_B
         else if ( ifilt_rest(1) .EQ. IFILT_BESS_B ) then
            NEAREST_IFILT_REST = IFILT_BESS_V
         else if ( ifilt_rest(1) .EQ. IFILT_BESS_V ) then
            NEAREST_IFILT_REST = IFILT_BESS_B
         else if ( ifilt_rest(1) .EQ. IFILT_BESS_R ) then
            NEAREST_IFILT_REST = IFILT_BESS_V
         else if ( ifilt_rest(1) .EQ. IFILT_BESS_I ) then
            NEAREST_IFILT_REST = IFILT_BESS_R
         endif

         GOTO 900
      ENDIF

c ------------------------------------------

900   CONTINUE

      if ( NEAREST_IFILT_REST .LE. 0 .and. ABORT_FLAG ) then
        CFILT  = filtdef_string(ifiltdef:ifiltdef)
        c1err = 'Could not find nearest filter for    '
        write(c2err,666) OPT_FRAME, ifiltdef, cfilt(1:1), rank_want, z
666     format('OPT_FRAME=',I2, 2x,'IFILTDEF=',I2,'(',A,')  RANK=',I1,
     &          2x, 'z=',G10.4 )
        CALL MADABORT ( FNAM, c1err, c2err)
      endif

      RETURN
      END



C =====================================================
+DECK,GET_MAGLC8.
      DOUBLE PRECISION FUNCTION GET_MAGLC8 ( 
     &     ifilt        ! (I) absolute filter index 
     &    ,T8_epoch     ! (I) rest frame epoch, days
     &    ,Z8           ! (I) redshift
     &    ,AVWARP8      ! (I) AV-warp parameter
     &      )

      IMPLICIT NONE

c input function args

      INTEGER IFILT    ! (I) filter index 

      REAL*8  
     &   T8_EPOCH    ! (I) rest frame T - Tmax, days
     &  ,Z8          ! (I)
     &  ,AVWARP8     ! (I)

c local args

      REAL*8 MWEBV8

c function
      DOUBLE PRECISION  GET_MAG8

C ------------------- BEGIN -----------------

      MWEBV8      = -9.0
      GET_MAGLC8 = GET_MAG8(ifilt,T8_EPOCH,Z8,AVWARP8,MWEBV8)

      RETURN
      END

C =====================================================
+DECK,GET_MWXT8.
      DOUBLE PRECISION FUNCTION GET_MWXT8 ( 
     &     ifilt        ! (I) absolute obs-frame filter index 
     &    ,Trest        ! (I) rest frame epoch, days
     &    ,z            ! (I) redshift
     &    ,AVWARP       ! (I) AV-warp parameter
     &    ,MWEBV        ! (I) E(B-V) for MW
     &    ,RV           ! (I) MW RV (added Sep 2013)
     &    ,OPT_COLORLAW ! (I) integer index for color law (Sep 2013)
     &      )

c Return Galactic extinction in magnitudes.
c Sep 2013: pass new arguments RV and OPT_COLORLAW;
c           make correction if either are different than
c           what was used to make the k-cor tables.

c -------------------
      IMPLICIT NONE

c input function args

      INTEGER IFILT    ! (I) filter index 

      REAL*8  Trest, z, AVwarp, MWEBV, RV  ! (I)
      INTEGER OPT_COLORLAW                 ! (I) 

c local args

+CDE,SNPAR.
+CDE,FILTCOM.
+CDE,KCORCOM.

      REAL*8  RVDIF,  RV0,  RV1, AV0, AV1, XT0, XT1, LAM
      INTEGER OPTDIF, OPT0, OPT1
      LOGICAL DOCOR

c function
      DOUBLE PRECISION  GET_MAG8, GALextinct

C ------------------- BEGIN -----------------

      GET_MWXT8 = GET_MAG8(ifilt,Trest,z,AVWARP,MWEBV)

      
c check for correction for different RV or color law
c Correction is computed at central wavelenth of filter;
c thus be careful of RV - RVMW_RDKCOR is large,
c or if the color law is very different.

      RVDIF  = RV - RVMW_RDKCOR
      OPTDIF = OPT_COLORLAW - OPT_MWCOLORLAW_RDKCOR

      DOCOR = abs(RVDIF) > 0.001 .or. OPTDIF .NE. 0

      IF ( DOCOR ) THEN
         RV0  = RVMW_RDKCOR
         RV1  = RV
         OPT0 = OPT_MWCOLORLAW_RDKCOR
         OPT1 = OPT_COLORLAW
         LAM  = FILTOBS_LAMAVG(ifilt)
         AV0   = mwebv * RV0 ;
         AV1   = mwebv * RV1 ;

         XT0   = GALextinct ( RV0, AV0, LAM, OPT0 ) !  repeat Kcor XT
         XT1   = GALextinct ( RV1, AV1, LAM, OPT1 ) !  requested XT

         GET_MWXT8 = GET_MWXT8 + (XT1-XT0)  ! correct with XT difference
      ENDIF

      RETURN
      END


C ======================================
+DECK,INIKCIND.
      SUBROUTINE INIT_KCOR_INDICES
c
c Created Jul 21, 2011 by R.Kessler
c Init index maps for KCOR-related tables:
c   KCOR, AVWARP, LCMAP and MWXT.
c These tables are multi-dimensional, but we use a 
c 1-d table allocation to save memory. This routine
c prepares index-mappings from the multi-dimensional 
c space to the 1-d space.


      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,KCORCOM.
+CDE,FILTCOM.
+CDE,SNLCINP.

      INTEGER KDIM, NFSQ 
      CHARACTER C1ERR*80, C2ERR*80, FNAM*18

C --------------- BEGIN --------------

      IF ( NKCOR_STORE .EQ. 0 ) RETURN

c load NBIN into array
      NBIN_KCOR(KDIM_T)      = NTBIN_KCOR
      NBIN_KCOR(KDIM_Z)      = NZBIN_KCOR
      NBIN_KCOR(KDIM_AV)     = NAVBIN_KCOR
      NBIN_KCOR(KDIM_ifiltr) = NFILTDEF_REST
      NBIN_KCOR(KDIM_ifilto) = NFILTDEF_SURVEY

c compute total number of kcor bins and check array bound
      NBINTOT_KCOR = 1
      DO KDIM = 1, NKDIM
         NBINTOT_KCOR =  NBINTOT_KCOR * NBIN_KCOR(KDIM)
      ENDDO

c get number of AVWARP bins
      NFSQ = NFILTDEF_REST**2
      NBINTOT_AVWARP = NTBIN_KCOR * MXCBIN_AVWARP * NFSQ
      NBIN_AVWARP(1) = NTBIN_KCOR
      NBIN_AVWARP(2) = MXCBIN_AVWARP
      NBIN_AVWARP(3) = NFILTDEF_REST
      NBIN_AVWARP(4) = NFILTDEF_REST     

c get number of LCMAG bins
      NBINTOT_LCMAG = 
     &   NTBIN_KCOR * NZBIN_KCOR * NAVBIN_KCOR * NFILTDEF_REST
      NBIN_LCMAG(1) = NTBIN_KCOR
      NBIN_LCMAG(2) = NZBIN_KCOR
      NBIN_LCMAG(3) = NAVBIN_KCOR
      NBIN_LCMAG(4) = NFILTDEF_REST

c get number of MWXT bins
      NBINTOT_MWXT = 
     &   NTBIN_KCOR * NZBIN_KCOR * NAVBIN_KCOR * NFILTDEF_SURVEY
      NBIN_MWXT(1) = NTBIN_KCOR
      NBIN_MWXT(2) = NZBIN_KCOR
      NBIN_MWXT(3) = NAVBIN_KCOR
      NBIN_MWXT(4) = NFILTDEF_SURVEY

c ----------------------------
c check array bounds

      write(c2err,6062) NBIN_KCOR
      FNAM = 'INIT_KCOR_INDICES'

      IF ( NBINTOT_KCOR .GT. MXTABLE1D_KCOR ) THEN
          write(c1err,6061) 
     &       'KCOR', NBINTOT_KCOR, 'KCOR', MXTABLE1D_KCOR
          CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

      IF ( NBINTOT_AVWARP .GT. MXTABLE1D_AVWARP ) THEN
          write(c1err,6061) 
     &       'AVWARP', NBINTOT_AVWARP, 'AVWARP', MXTABLE1D_AVWARP
          CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

      IF ( NBINTOT_LCMAG .GT. MXTABLE1D_LCMAG ) THEN
          write(c1err,6061) 
     &       'LCMAG', NBINTOT_LCMAG, 'LCMAG', MXTABLE1D_LCMAG
          CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

      IF ( NBINTOT_MWXT .GT. MXTABLE1D_MWXT ) THEN
          write(c1err,6061) 
     &       'MWXT', NBINTOT_MWXT, 'MWXT', MXTABLE1D_MWXT
          CALL MADABORT(FNAM, C1ERR, C2ERR)
      ENDIF

6061  format('NBINTOT_',A,'=',I8,' exceeds MXTABLE1D_',A,'=',I8)
6062  format('NBIN(T,Z,AV,filtr,filto)=', 5(I4,' , ') )

c --------------------------
c clear map IDs since RDKCOR can be called multiple times.

      CALL CLEAR_1DINDEX(IDMAP_KCOR) 
      CALL CLEAR_1DINDEX(IDMAP_AVWARP)
      CALL CLEAR_1DINDEX(IDMAP_LCMAG)
      CALL CLEAR_1DINDEX(IDMAP_MWXT)

c init multi-dimensional index maps      
      CALL INIT_1DINDEX(IDMAP_KCOR,   NKDIM, NBIN_KCOR)  ! in sntools.c
      CALL INIT_1DINDEX(IDMAP_AVWARP, N4DIM, NBIN_AVWARP)
      CALL INIT_1DINDEX(IDMAP_LCMAG,  N4DIM, NBIN_LCMAG)
      CALL INIT_1DINDEX(IDMAP_MWXT,   N4DIM, NBIN_MWXT)

      RETURN
      END

C =======================================
+DECK,FUPDINI.
      SUBROUTINE FILTER_UPDATE_INIT(IERR)
c
c If FILTER_UPDATE_PATH is defined, read FILTER.INFO
c file for instructions on updating the filters for
c each SN.
c
c Jun 15 2016:  CALL ENVreplace(FILTER_UPDATE_PATH)
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,SNFILECOM.
c +CDE,PARSECOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER IERR

c local var

      INTEGER 
     &   LEN_UPDPATH, LEN_FULLPATH, L1, LEN_ROOT
     &  ,iwd, NWD, IERROPEN, ifilt, LWD0, LWD1

      character 
     &   FILTINFO_FILE*(MXCHAR_FILENAME)
     &  ,NAME_forC*(MXCHAR_FILENAME)
     &  ,cwd*60, cwd_next*60, msg*100

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C --------------- BEGIN -------------

      IERR = 0

      OPT_FILTER_UPDATE    = 0
      DO ifilt=1, MXFILT_ALL
        DOFLAG_FILTER_UPDATE(ifilt) = 0
      ENDDO

      PREFIX_UPD_TRANSSN  = ' '     
      PREFIX_UPD_TRANSREF = ' '
      PREFIX_UPD_FILTDIR  = ' '
      SUFFIX_UPD_TRANSSN  = ' '
      SUFFIX_UPD_TRANSREF = ' ' 
      SUFFIX_UPD_FILTDIR  = ' '
      FILTINFO_UPD_SN     = .FALSE.
      FILTINFO_UPD_REF    = .FALSE.

      IF ( FILTER_UPDATE_PATH .EQ. ' ' ) RETURN

      CALL ENVreplace(FILTER_UPDATE_PATH)

      msg = 
     &   "FILTER_UPDATE_INIT: Prepare SN-dependent Filter response"
      CALL PRBANNER(msg(1:60))

c -------------------------------------------------------
c first try $SNDATA_ROOT/filters/[FILTER_UPDATE_PATH]/
c if not there, then try absolute path.

      LEN_UPDPATH  = INDEX(FILTER_UPDATE_PATH,' ' ) -  1
      LEN_ROOT     = INDEX(SNDATA_ROOT,' ') - 1

      FILTER_UPDATE_TOPDIR = SNDATA_ROOT(1:LEN_ROOT) 
     &    // '/filters/' // FILTER_UPDATE_PATH(1:LEN_UPDPATH)
      LEN_FULLPATH  = INDEX(FILTER_UPDATE_TOPDIR,' ') - 1


c check if/where FILTER.INFO exists ...
      FILTINFO_FILE = FILTER_UPDATE_TOPDIR(1:LEN_FULLPATH) 
     &                 // '/FILTER.INFO'
      OPEN(UNIT=LUNTMP, FILE = FILTINFO_FILE,
     &     IOSTAT = IERROPEN, STATUS='OLD')
      IF ( IERROPEN .EQ. 0 ) THEN
        CLOSE(UNIT = LUNTMP)
      ELSE
c try absolute path
        LEN_FULLPATH = LEN_UPDPATH
        FILTER_UPDATE_TOPDIR  = FILTER_UPDATE_PATH
        FILTINFO_FILE = FILTER_UPDATE_PATH(1:LEN_UPDPATH)
     &           // '/FILTER.INFO'
      ENDIF

      L1 = INDEX(FILTINFO_FILE,' ') - 1
      print*,' Update Filter Response for each SN from : '
      print*,' ', FILTINFO_FILE(1:L1)

      NAME_forC = FILTINFO_FILE(1:L1)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE,NAME_forC,L1)


c parse enough to know which type of FILTER.INFO file we have;
c set global  OPT_FILTER_UPDATE and call PARSE1_XXX or PARSE2_XXX
c to do the appropriate parsing.

      DO 10 iwd = 1, min(1000,NWD)

          CALL get_PARSE_WORD_fortran(iwd+0, cwd,      LWD0 )
          CALL get_PARSE_WORD_fortran(iwd+1, cwd_next, LWD1 )

          if ( cwd .EQ. ' ' ) goto 10

          if ( CWD .EQ. 'FILTER_SUBDIR:' ) THEN
             CALL PARSE1_FILTER_INFO(NWD)
             OPT_FILTER_UPDATE  = OPT_FILTUPD_EACHSN
             RETURN
          ENDIF

          if ( CWD .EQ. 'FILTER_PATH:' ) THEN
             CALL PARSE2_FILTER_INFO(NWD)
             OPT_FILTER_UPDATE  = OPT_FILTUPD_MAP
             RETURN
          ENDIF

10    CONTINUE


c if we get here then abort.

      c1err = 'Cannot parse FILTER.INFO file'
      c2err = FILTER_UPDATE_TOPDIR(1:LEN_FULLPATH)
      CALL MADABORT("FILTER_UPDATE_INIT", c1err, c2err)

      RETURN
      END


C =========================================
+DECK,GET_AVWARP8.
      DOUBLE PRECISION FUNCTION GET_AVWARP8 ( 
     &     epoch8               ! (I) rest epoch, days
     &    ,z8                   ! (I) redshift
     &    ,mag8_a,  mag8_b      ! (I) observed mags in above filters
     &    ,ifilt_a, ifilt_b     ! (I) filter indices
     &    ,ISTAT         ! (O) 0=> OK, -1 => lower bound, +1 => upper limit
     &      )

c  --------------------------------------
c Created Mar 14, 2006 by R.Kessler
c
c Return AVWARP parameter such that warped template gives
c observed color = mag8_a - mag8_b at "epoch".
c The templates have been warped with AV using CCM89 law,
c and then redshifted to observer frame.
c
c 
c Use GET_MAGLC8 to get interpolated magnitudes.
c
c May 13, 2006: re-do using binary search for AV_BEST
c                [much quicker and more accurate]
c 
c May 23, 2009 RSK: add ISTAT output arg to indicate when
c                   mni/max boundary is reached.
c
c Aug 14, 2009: add NERR_AVWARP  counter and abort after 100
c               => avoids infinite error loop
c
c Oct 12, 2009: use AVWARPTABLE if USE_AVWARPTABLE=T => much faster.
c
c Jul 21, 2011: switch from R4AVWARPTABLE(4 dimensions) to using
c               AVWARP_TABLE1D(IBIN)
c
c Dec 30, 2012: define AVRANGE_LOCAL to debug new FITS convention
c               where min,max are equivalent to HBOOK bin-centers.
c
c Aug 4 2019: IBINS starts at 0, not 1.
c
c ----------------------------------------- 

      IMPLICIT NONE

c function args
      REAL*8  z8, epoch8, mag8_a, mag8_b
      INTEGER IFILT_A, IFILT_B, ISTAT

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,KCORCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER MXITER_AV
      PARAMETER ( MXITER_AV = 20 )

c local var

      REAL*8  
     &   obs_color, av8
     &  ,lc_mag_a, lc_mag_b
     &  ,av_min,  lc_color_min, av_min_dump
     &  ,av_max,  lc_color_max, av_max_dump
     &  ,av_best, lc_color_best
     &  ,dif_color, dif_av
     &  ,dav_dcolor
     &  ,AV_LIST(MXITER_AV)
     &  ,AVDIF_LIST(MXITER_AV)
     &  ,DIF_COLOR_LIST(MXITER_AV)
     &  ,DAV_DCOLOR_LIST(MXITER_AV)
     &  ,AVRANGE_LOCAL(2)

      CHARACTER C1ERR*80, C2ERR*80

      REAL dif_color_converge / 1.0E-3 /
      
      INTEGER 
     &   iter, i

c  table-interp variables
      REAL*8
     &   DIF
     &  ,AV00, AV10,AV01, AV11,  AVC0, AVC1
     &  ,AV8_LOOKUP
     &  ,frac_T, frac_C

      INTEGER
     &   IT, IC
     &  ,i_a, i_b
     &  ,IBINS(4), IB(0:2,0:2), IBTMP
     &  ,iit, iic
 
      LOGICAL LDMP, LTMP

c function
      REAL*8   GET_MAGLC8
      INTEGER  GET_1DINDEX
      EXTERNAL GET_1DINDEX

C ------------------ BEGIN --------------------

c allow extra half-bin to be compatiable with previous versions.
      AVRANGE_LOCAL(1) = AVRANGE_KCOR(1) - AVbinsize_KCOR/2.0
      AVRANGE_LOCAL(2) = AVRANGE_KCOR(2) + AVbinsize_KCOR/2.0

      LDMP_AVWARP =
     &         abs(epoch8 + 3.92) .LT. 0.01
     &   .and. ifilt_a .EQ.  +IFILT_BESS_U
     &   .and. ifilt_b .EQ.  -IFILT_BESS_B  ! turn off with minus sign

  
      IF ( LDMP_AVWARP ) THEN
         CALL PRBANNER ( "GET_AVWARP8  DUMP " )
         print*,' xxx Epoch8, Z8 = ', epoch8, Z8
         print*,' xxx mag_a,b   = ', mag8_a, mag8_b
         print*,' xxx IFILT_a,b = ', IFILT_A, IFILT_B
         CALL FLUSH(6)
      ENDIF


      ISTAT = 0  ! init output arg.

      GET_AVWARP8 = 0.0  ! init funtion 

c return if either magnitude is too big
      if ( mag8_a .GT.  40.0 )  RETURN
      if ( mag8_b .GT.  40.0 )  RETURN
      if ( epoch8 .LT. -19.0 )  RETURN
      if ( epoch8 .GT. 200.0 )  RETURN  ! Aug 21, 2006

c get observed color
      obs_color = mag8_a - mag8_b

c check option to use lookup table.

      IF ( USE_AVWARPTABLE .and. Z8 .LE. 1.01*Zat10pc ) THEN

        DIF    = Epoch8 - DBLE(TRANGE_KCOR(1))
        IT     = INT( dif / DBLE(TBINSIZE_KCOR)) + 1  
        IF ( IT .LT. 1 ) IT = 1
        IF ( IT .GT. NTBIN_KCOR-1) IT = NTBIN_KCOR-1
        frac_T = (epoch8 - GRIDVAL_T(it)) /
     &           (GRIDVAL_T(it+1)-GRIDVAL_T(it))

        DIF   = obs_color - DBLE(GRIDVAL_C(1))
        IC    = INT( dif / DBLE(CBINSIZE_AVWARP)) + 1
        IF ( IC .LT. 1 ) IC = 1
        IF ( IC .GT. MXCBIN_AVWARP-1) IC = MXCBIN_AVWARP-1
        frac_C = (obs_color - GRIDVAL_C(ic)) /
     &           (GRIDVAL_C(ic+1)-GRIDVAL_C(ic))

c get sparse filter indices
        i_a = IFILTDEF_INVMAP_REST(IFILT_a)
        i_b = IFILTDEF_INVMAP_REST(IFILT_b)

c interpolate epoch for each color-bin

        IBINS(3) = i_a - 1
        IBINS(4) = i_b - 1
        DO iit = 0, 1
        DO iic = 0, 1
          IBINS(1) = it + iit - 1
          IBINS(2) = ic + iic - 1
          IBTMP    = GET_1DINDEX(IDMAP_AVWARP,N4DIM,IBINS)+1
          IB(iit,iic) = IBTMP

          if ( IBTMP < 1 .or. IBTMP > NBINTOT_AVWARP ) then
             CALL PRINT_PREABORT_BANNER("GET_AVWARP8"//char(0),40)
             print*,'   IBINS(it,ic,ia,ib) = ', IBINS
             print*,'   IDMAP_AVWARP = ', IDMAP_AVWARP
             print*,'   N4DIM        = ', N4DIM
             print*,'   z            = ', sngl(z8)
             print*,'   epoch        = ', sngl(epoch8)
             print*,'   mag(a,b)     = ', sngl(mag8_a), sngl(mag8_b)
             print*,'   ifilt(a,b)   = ', ifilt_a, ifilt_b

             write(c1err,641) IBTMP
 641         format('Invalid IBTMP=',I8)
             write(c2err,642) NBINTOT_AVWARP
 642         format('NBINTOT_AVWARP=',I8)
             CALL MADABORT( "GET_AVWARP8", c1err, c2err )     
          endif
        ENDDO
        ENDDO

        AV00  = DBLE( AVWARP_TABLE1D(IB(0,0)) )
        AV10  = DBLE( AVWARP_TABLE1D(IB(1,0)) )
        AV01  = DBLE( AVWARP_TABLE1D(IB(0,1)) )
        AV11  = DBLE( AVWARP_TABLE1D(IB(1,1)) )

        AVC0  = AV00 + (AV10-AV00)*frac_T 
        AVC1  = AV01 + (AV11-AV01)*frac_T 

c interpolate color bins
        AV8_LOOKUP = AVC0 + (AVC1-AVC0)*frac_C

        IF ( LDMP_AVWARP ) THEN
          print*,' ----------------------------------------------- '
          print*,'  NBINTOT  = ',NBINTOT_AVWARP
c          print*,'  i_a, i_b = ', i_a, i_b
c          print*,'  IBINS    = ', IBINS
          print*,'  IB       = ', IB
          print*,'  T=',epoch8,'  GRIDVAL_T=',
     &      GRIDVAL_T(IT),GRIDVAL_T(IT+1),'  frac=',frac_T
          print*,'  C=', obs_color,'  GRIDVAL_C=',
     &      GRIDVAL_C(Ic),GRIDVAL_C(IC+1),'  frac=',frac_C
          print*,'  AV00,AV10 = ', AV00, AV10
          print*,'  AV01,AV11 = ', AV01, AV11
          print*,'  AVC0,AVC1 = ', AVC0, AVC1,'   AV(LU)=',AV8_LOOKUP
          CALL FLUSH(6)
        ENDIF

        GET_AVWARP8 = AV8_LOOKUP

        IF ( LDMP_AVWARP ) CALL EXIT(EXIT_ERRCODE)  ! Feb 2013
        RETURN
      ENDIF

c ==============================================
c   if we get here, use brute force to evaluate AVWARP
c ==============================================

c -----------------------------------------------
c iterate search for AV;
c AV_MIN,MAX are defined to determine the slope.
c AV_BEST is current best estimate of AV.
c Note that AV_BEST starts out at zero.

      dif_color = 999.
      AV_BEST = 0.0
      AV_MIN  = GRIDVAL_AV(1)
      AV_MAX  = GRIDVAL_AV(NAVBIN_KCOR) 
      iter    = 0

      if ( LDMP_AVWARP ) THEN
         write(6,170) AV_MIN, AV_MAX
170      format(T10,'Initial AV_MIN,MAX = ',2F8.3 )
            CALL FLUSH(6)
      endif

c xxxxxxxxxxxxxx

      if ( abs(epoch8-0.0) < -2.0 .and. ifilt_a == 12 
     &    .and. ifilt_b==13 ) then
         print*,' xxx ----------------------- '
         print*,' xxx Epoch = ', Epoch8
         do i=1, 100
            av8 = -6.0 + dble(i)*0.10
            lc_mag_a = GET_MAGLC8 ( ifilt_a, epoch8, z8, av8 )
            lc_mag_b = GET_MAGLC8 ( ifilt_b, epoch8, z8, av8 )  
            write(6,666) av8, lc_mag_a, lc_mag_b
 666        format(T2,' xxx AV8=', F6.3, 3x, 'mag(a,b) = ', 2F10.3 )
            call flush(6)
         enddo
      endif
c xxxxxxxxxxxx



      DO 30 WHILE ( abs(dif_color) .GT. dif_color_converge ) 

         iter = iter + 1
c get color at av_best
         lc_mag_a = GET_MAGLC8 ( ifilt_a, epoch8, z8, av_best )
         lc_mag_b = GET_MAGLC8 ( ifilt_b, epoch8, z8, av_best )
         lc_color_best = lc_mag_a - lc_mag_b

         if ( LDMP_AVWARP ) then
            print*,' xxxxxxx BEST mag(a,b) = ',
     &           sngl(lc_mag_a), sngl(lc_mag_b)
         endif


c get color at av_min
         lc_mag_a = GET_MAGLC8 ( ifilt_a, epoch8, z8, av_min )
         lc_mag_b = GET_MAGLC8 ( ifilt_b, epoch8, z8, av_min )
         lc_color_min = lc_mag_a - lc_mag_b

c  get color at av_max
         lc_mag_a = GET_MAGLC8 ( ifilt_a, epoch8, z8, av_max )
         lc_mag_b = GET_MAGLC8 ( ifilt_b, epoch8, z8, av_max )
         lc_color_max = lc_mag_a - lc_mag_b

         av_min_dump = av_min
         av_max_dump = av_max

c get color-slope wrt AV
         dif_color  = lc_color_max - lc_color_min 
         dif_av     = av_max - av_min 

         if ( dif_color .NE. 0.0 ) then
           dav_dcolor = dif_av / dif_color
           dif_av     = (obs_color - lc_color_best) * dav_dcolor
         else
           dav_dcolor = 66.666  ! 1.0E8
           dif_av     = 0.0
         endif

         AV_BEST               = AV_BEST + dif_av
          
c also determine new AV_MIN,MAX for next iteration
         AV_MIN = AV_BEST - abs(dif_av) - dif_color_converge
         AV_MAX = AV_BEST + abs(dif_av) + dif_color_converge
      
         if ( AV_MIN < AVrange_LOCAL(1) ) then
             AV_min = AVrange_LOCAL(1)
         endif
         if ( AV_MAX > AVrange_LOCAL(2) ) then
             AV_max = AVrange_LOCAL(2)
         endif

c check color with new AV_BEST to see how close it is
c to OBS_COLOR

         lc_mag_a = GET_MAGLC8 ( ifilt_a, epoch8, z8, av_best )
         lc_mag_b = GET_MAGLC8 ( ifilt_b, epoch8, z8, av_best )
         lc_color_best = lc_mag_a      - lc_mag_b
         dif_color     = lc_color_best - obs_color

         AV_LIST(iter)         = AV_BEST
         AVDIF_LIST(iter)      = dif_av
         DIF_COLOR_LIST(iter)  = dif_color
         DAV_DCOLOR_LIST(iter) = dav_dcolor

c+SELF,IF=XXXX.
         if ( LDMP_AVWARP ) then
           write(6,33) 
     &          iter
     &        , lc_color_best, obs_color, dif_color
     &        , AV_BEST
33         format(T2,'iter ',I1,2x,' dColor = ',F7.4,' - ',F7.4,
     &          ' = ',G10.4, 3x,'AV=',F6.3 )
           print*,'   mag(a,b) = ', lc_mag_a, lc_mag_b
            CALL FLUSH(6)
         endif
c+SELF.

c ABORT if there are too many iterations

        if ( iter .GE. MXITER_AV .or. LDMP_AVWARP ) then
           print*,' '
           print*,' ----------------------------------------- '
           print*,'  GET_AVWARP ERROR: Niteration = ', iter
           print*,'     Epoch=', sngl(epoch8), '  Z=',sngl(Z8)
           print*,'     mag_a,b  = ', sngl(mag8_a), sngl(mag8_b)
           print*,'     filt_a,b = ', ifilt_a, ifilt_b,
     &              '   (',FILTDEF_STRING(ifilt_a:ifilt_a)
     &                    ,FILTDEF_STRING(ifilt_b:ifilt_b),' )'
           print*,' '

           do i = 1, iter
             write(6,180) i 
     &        ,AV_LIST(i), AVDIF_LIST(i), dif_color_list(i)
     &        ,DAV_DCOLOR_LIST(i)
180          format(T2,'AV(',I2,')=',F6.3,3x,'AVDIF=',F8.5,
     &              3x, 'difColor=',F8.5, 3x, 'dAV/dcolor=',F8.3 )

           enddo

           print*,'     AV_MIN,MAX = ', 
     &                     sngl(AV_MIN_DUMP), SNGL(AV_MAX_DUMP)
           print*,'     LC_COLOR_MIN,MAX = ',
     &                    sngl(lc_color_min), sngl(lc_color_max)
           print*,'     best_color =', sngl(lc_color_best)
           print*,'     obs_color  =', sngl(obs_color)
           print*,'     dif_color  = ', sngl(dif_color),' > ',
     &                     dif_color_converge
           print*,' '

            CALL FLUSH(6)

           if ( abs(dif_color) .LT. 0.02) GOTO 444

           if ( ABORT_ON_BADAVWARP ) then
             c1err = 'See above errors and '
             c2err = 'GET HELP.'
             CALL MADABORT( "GET_AVWARP8", c1err, c2err )
           endif

           NERR_AVWARP = NERR_AVWARP + 1
           if ( NERR_AVWARP .GT. 100 ) then
             print*,' '
             c1err = '100 AVWARP ERRORS => BASTA !!!'
             c2err = 'GET SOME HELP.' 
             CALL MADABORT( "GET_AVWARP8", c1err, c2err )
           endif
        endif

         if ( AV_BEST .GT. AVrange_LOCAL(2) ) goto 444
         if ( AV_BEST .LT. AVrange_LOCAL(1) ) goto 444

30    ENDDO   ! end of dif_color < bla loop

c --------------------------------------

444   CONTINUE

      AV8 = AV_BEST

c -------------------------------------
c avoid going past boundary.

      if ( AV8 .LT. AVRANGE_LOCAL(1) ) THEN
         GET_AVWARP8 = GRIDVAL_AV(1)
         ISTAT = -1
      else if ( AV8 .GT. AVRANGE_LOCAL(2) ) THEN
         GET_AVWARP8 = GRIDVAL_AV(NAVBIN_KCOR)
         ISTAT = +1
      else
         GET_AVWARP8 = AV8
      endif

c --------------

      if ( USE_AVWARPTABLE .and. obs_color .GT. 1.E9 ) then
         DIF = AV8_LOOKUP-GET_AVWARP8
         LTMP = abs(DIF) .GT. 0.005 .and. abs(GET_AVWARP8) .LT. 5.9  
         IF ( LTMP ) THEN
           write(6,680) 
     &          DIF
     &         ,filtdef_string(ifilt_a:ifilt_a)
     &         ,filtdef_string(ifilt_b:ifilt_b)
     &         ,obs_color, epoch8, GET_AVWARP8
          if ( LDMP ) print*,'       AV(EXACT)=', GET_AVWARP8
          CALL FLUSH(6)          
        ENDIF

680     format(T3,'AVdif(LU-EXACT)=',F7.4, 3x,
     &      'for ',A,'-',A,'=',F6.3,'   Tr=',F6.2, '  AVwarp=',F7.3 )
        
      endif


      RETURN
      END

C =========================================
+DECK,GET_KCOR8.
      DOUBLE PRECISION FUNCTION GET_KCOR8 ( 
     &    ifilt_rest   ! (I) filter index, rest frame
     &   ,ifilt_obs    ! (I) filter index, observer frame
     &   ,epoch8       ! (I) rest frame epoch since Max, days
     &   ,redshift8    ! (I) SN redshift
     &   ,av8          ! (I) AV-warp parameter
     &      )

C--------------------------
C Created by D.Cinabro Feb 1, 2006
C Interpolates the K-corrections array using CERNLIB-modified funciton 
c DFINT.  Note that if asked for rest and observer filter combination 
c that is not known, then it returns 0.0
C
C Mar 2, 2006  R.Kessler 
C    stop printing warnings after MXWARN warnings
C    per fit. Use redshift8 to determine when new
C    fit starts.
C
C Nov 6, 2006 RSK: use I2KCORTABLE / KCORPACK
C
C Dec 9, 2006 RSK: check Zrange_KCOR_LU instead of Zrange_KCOR;
C                  allows user to extend valid range and use
C                  extrapolations (i.e., for PHOTOZ fits)
C
C May 18, 2008 RSK: use sparse filter indices in KCORTABLE
C
C Aug 27, 2009 : check option INTERP_ZSMOOTH to smooth along Z.
C                Recommended for photoZ fits to avoid notches
C                in the chi2. To prepare for ZSMOOTH option,
C                change ordering from [Z,T,AV] -> [T,AV,Z]
C
C     ZSMOOTH principle is to interp for nominal Z-bins,
C     and with Z-bins shifted by 1; then take average.
C     This avoids kink at bin-center.
C
C Jan 18, 2010: comment out warnings for AV outside lookup range.
c Sep 09, 2010: replace +CDE,SNDATCOM. with specific keeps
c
c Sep 08, 2011: POLINT -> REAL*8 POLINT8
c
c Dec 29, 2012: use new EXIST_KCOR logical array to test that KCOR
c               table exists. Replaces HIDMAG that works only for
c               hbook tables; EXIST_KCOR works for HBOOK and FITS.
c
c Dec 30, 2012: 
c    use new min,max convention consistent with FITS format;
c    min,max correspond to HBOOK bin centers.
c    However, to avoid subtle changes w.r.t. previous versions,
c    allow half-bin extension on AV8 (AV-warp parameter);
c    See check on LIMIT.
c
c Aug 4 2019: IBKCOR stars at 0, not 1
C-----------------------
      IMPLICIT NONE

c function args

      integer 
     &   ifilt_rest  ! (I) filter index in rest frame
     &  ,ifilt_obs   ! (I) idem observer frame

      real*8
     &   epoch8       ! (I) t - t0 in days, rest frame
     &  ,redshift8
     &  ,av8  

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,KCORCOM.
+CDE,FILTCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.

c local args

      REAL*8 DFINT  ! CERNLIB's linear interp function

      INTEGER 
     &   NVAR
     &  ,IVAR_T, IVAR_AV, IVAR_Z
     &  ,NBZINT,  IBZCEN       ! # bins to interpolate and central bin
     &  ,NBTINT,  IBTCEN
     &  ,NBAVINT, IBAVCEN
     &  ,ADIM
     &  ,FDIM
     &  ,IFILTr, IFILTo

      PARAMETER ( 
     &   NVAR    = 3
     &  ,IVAR_T  = 1 
     &  ,IVAR_AV = 2
     &  ,IVAR_Z  = 3
c
     &  ,NBTINT  = 3,  IBTCEN=(NBTINT+1)/2
     &  ,NBAVINT = 3,  IBAVCEN=(NBAVINT+1)/2
     &  ,NBZINT  = 5,  IBZCEN=(NBZINT+1)/2
c
     &  ,ADIM  = NBZINT + NBTINT + NBAVINT
     &  ,FDIM  = NBZINT * NBTINT * NBAVINT
     &    )

      REAL*8 
     &   XIN(NVAR)
     &  ,A(ADIM)
     &  ,F(FDIM)
     &  ,FZ(FDIM/NBZINT,NBZINT)
     &  ,FZb(FDIM/NBZINT,NBZINT)
     &  ,DIF, xtmp
     &  ,TMPKCOR8
     &  ,TOFF, AVOFF, ZOFF
     &  ,TCEN, AVCEN, ZCEN
     &  ,LIMIT

      INTEGER 
     &   NLEN(NVAR)
     &  ,IZ, IAV, IEP
     &  ,NBIN, NBINZ
     &  ,ITCEN, IAVCEN, IZCEN, IZCENb
     &  ,MINBIN, MAXBIN
     &  ,KBIN, IBKCOR(NKDIM)

+SELF,IF=I2KCOR.
     &  INTEGER I2KCOR, I2KCORb
+SELF.

c POLINT args
c      REAL*4  Z4
c     &  ,KCOR4_Z(NBZINT), KCOR4b_Z(NBZINT)
c     &  ,ZLIST4(NBZINT),  ZLIST4b(NBZINT)
c     &  ,KCOR4, KCOR4b

      REAL*8
     &   Z8
     &  ,KCOR8_Z(NBZINT), KCOR8b_Z(NBZINT)
     &  ,ZLIST8(NBZINT),  ZLIST8b(NBZINT)
     &  ,KCOR8, KCOR8b

      LOGICAL  LTMP, ZSMOOTH

c stuff for warning messages

      INTEGER MXWARN
      PARAMETER ( MXWARN = 0 )   ! max warnings per fit

      INTEGER NWARN, IFILT_OBS_LAST
      LOGICAL LWARN, LTEST
      REAL*8 REDSHIFT8_LAST
  
      CHARACTER C1ERR*80, C2ERR*80

c functions
      INTEGER  GET_1DINDEX
      EXTERNAL GET_1DINDEX

C -------------- BEGIN ------------- 

c make sure that KCOR table exists for this filter-combo

      if ( .not. EXIST_KCOR(ifilt_rest,ifilt_obs) ) then
         print*,' '
         print*,' GET_KCOR8 FATAL ERROR: '

         write(6,66) filtdef_string(ifilt_rest:ifilt_rest)
     &              ,filtdef_string(ifilt_obs:ifilt_obs)

66       format(T10,'K_',A,A,' table does NOT exist !!! ')
         print*,'    IFILT_REST -> OBS : ', 
     &        IFILT_REST, ' -> ', IFILT_OBS
         print*,'    Redshift = ' , redshift8
         print*,'    Epoch    = ' , epoch8
         print*,'    Av       = ' , AV8

         c1err = "check Kcor table"
         c2err = " "
         CALL MADABORT( "GET_KCOR8", c1err, c2err )

      endif

      ZSMOOTH = ( INTERP_OPT .EQ. INTERP_ZSMOOTH ) 

c ----------------------------------------------
c check if warnings should be printed

      if ( REDSHIFT8_LAST .NE. REDSHIFT8 ) NWARN = 0

      LWARN = NWARN .LE. MXWARN

C Determine closest bin on the Kcor grid

      DIF   = Epoch8 - DBLE(TRANGE_KCOR(1))
      ITCEN = INT( (dif / DBLE(TBINSIZE_KCOR)) + 0.5 ) + 1

      DIF    = AV8 - DBLE(AVRANGE_KCOR(1))
      IAVCEN = INT( (dif / DBLE(AVBINSIZE_KCOR)) + 0.5 ) + 1

      DIF   = Redshift8 - DBLE(ZRANGE_KCOR(1))
      IZCEN = INT( (DIF / DBLE(ZBINSIZE_KCOR)) + 0.5 ) + 1

c get values at bin-centers
      
      TOFF  = TRANGE_KCOR(1) 
      AVOFF = AVRANGE_KCOR(1)
      ZOFF  = ZRANGE_KCOR(1)

      TCEN  = TOFF  + TBINSIZE_KCOR  * DBLE(ITCEN  - 1)
      AVCEN = AVOFF + AVBINSIZE_KCOR * DBLE(IAVCEN - 1)
      ZCEN  = ZOFF  + ZBINSIZE_KCOR  * DBLE(IZCEN  - 1)

c get shifted IZCEN-bin 

      IF ( ZSMOOTH ) THEN
         if ( ZCEN .LT. REDSHIFT8 ) then
           IZCENb = IZCEN + 1
         else
           IZCENb = IZCEN - 1
         endif
      ENDIF

C Check for edges

      MINBIN = IBTCEN
      MAXBIN = NTBIN_KCOR - (IBTCEN-1)
      IF (ITCEN.LT. MINBIN ) ITCEN = MINBIN
      IF (ITCEN.GT. MAXBIN ) ITCEN = MAXBIN

      MINBIN = IBAVCEN
      MAXBIN = NAVBIN_KCOR - (IBAVCEN-1)
      IF (IAVCEN .LT. MINBIN) IAVCEN = MINBIN
      IF (IAVCEN .GT. MAXBIN) IAVCEN = MAXBIN

      MINBIN = IBZCEN
      MAXBIN = NZBIN_KCOR - (IBZCEN-1)
      IF (IZCEN .LT. MINBIN) IZCEN = MINBIN
      IF (IZCEN .GT. MAXBIN) IZCEN = MAXBIN

      IF ( ZSMOOTH ) then
        IF ( IZCENb .LT. MINBIN ) IZCENb = MINBIN
        IF ( IZCENb .GT. MAXBIN ) IZCENb = MAXBIN
      ENDIF

C Fill DFINT inputs

      NLEN(IVAR_T)  = NBTINT
      NLEN(IVAR_AV) = NBAVINT
      NLEN(IVAR_Z)  = NBZINT

      NBIN = 0
      DO IEP = 1,NBTINT
        NBIN = NBIN + 1
        xtmp = float(ITCEN-IBTCEN+IEP-1)
        A(NBIN) = TOFF + xtmp*TBINSIZE_KCOR
      ENDDO
      DO IAV = 1,NBAVINT
        NBIN = NBIN + 1
        xtmp = float(IAVCEN-IBAVCEN+IAV-1)
        A(NBIN) = AVOFF + xtmp*AVBINSIZE_KCOR
      ENDDO
      DO IZ = 1,NBZINT
        NBIN = NBIN + 1
        xtmp = float(IZCEN-IBZCEN+IZ-1)
        A(NBIN) = ZOFF + xtmp*ZBINSIZE_KCOR
        ZLIST8(iz) = A(NBIN)  ! needed for ZSMOOTH option

        if ( ZSMOOTH ) then
          xtmp        = float(IZCENb-IBZCEN+IZ-1)
          ZLIST8b(iz) = ZOFF + xtmp*ZBINSIZE_KCOR
        endif
      ENDDO

C
C The actual interpolation
C
      XIN(IVAR_T)  = epoch8
      XIN(IVAR_AV) = av8
      XIN(IVAR_Z)  = redshift8
C
C check ranges for both red shift and epoch and edges of table
C
      LTEST = redshift8 .LT. ZRANGE_KCOR_LU(1) .or.
     &        redshift8 .GT. ZRANGE_KCOR_LU(2) .or.
     &        redshift8 .LT. 0.0

      IF ( LTEST ) THEN
        print*,' '
        print*,' GET_KCOR8 ERROR: '

        WRITE (6,'(T5, A, F6.4, A, F7.5, A, F7.5 )' ) 
     &     'z=', redshift8, '  is outside lookup range ',
     &                Zrange_Kcor_LU(1), ' - ', Zrange_Kcor_LU(2)


        IF ( ABORT_ON_BADZ ) THEN
          print*,' ***** ABORT ***** '
          CALL EXIT(EXIT_ERRCODE)
        ENDIF

      ENDIF


      LIMIT = TRANGE_KCOR(1)
      IF ( epoch8 .LT. LIMIT ) THEN
        XIN(IVAR_T) = LIMIT

        NWARN = NWARN + 1
c        if ( LWARN ) 
c     &     WRITE(6,601) Nwarn, ifilt_rest, ifilt_obs, Epoch8,
c     &            'Epoch', epoch8,  TRANGE_KCOR, LIMIT
      ENDIF


      LIMIT = TRANGE_KCOR(2)
      IF ( epoch8 .GT. LIMIT ) THEN
        XIN(IVAR_T) = LIMIT

        NWARN = NWARN + 1
c        if ( LWARN ) 
c     &     WRITE(6,601) NWARN, ifilt_rest, ifilt_obs, Epoch8,
c     &           'Epoch', epoch8, TRANGE_KCOR, LIMIT
      ENDIF


      LIMIT = AVRANGE_KCOR(1) - AVbinsize_KCOR/2.0 
      IF ( av8 .LT. LIMIT ) THEN
        XIN(IVAR_AV) = LIMIT

        NWARN = NWARN + 1
c        if ( LWARN ) 
c     &     WRITE(6,601) NWARN, ifilt_rest, ifilt_obs, Epoch8,
c     &           'AV', AV8,  AVRANGE_KCOR, LIMIT
      ENDIF

      LIMIT = AVRANGE_KCOR(2) + AVbinsize_KCOR/2.0 
      IF (av8 .GT. LIMIT ) THEN
        XIN(IVAR_AV) = LIMIT

        NWARN = NWARN + 1
c        if ( LWARN ) 
c     &     WRITE(6,601) NWARN, ifilt_rest, ifilt_obs, Epoch8,
c     &            'AV', AV8,  AVRANGE_KCOR, LIMIT
      ENDIF

+SELF,IF=XXXDEL.
601   format(T2,'GET_KCOR8 WARNING:', I4, 3x, 
     &       '[IFILT(rest,obs)=',I2,',',I2, 3x,'Trest=',F6.2,']'
     &   ,/, T4, A,1x,F8.3,' is outside lookup range ',
     &             F8.3,' to ',F8.3 
     &   ,/, T4, '==> using lookup at ', F8.3 , / )
+SELF.

c May 2008: construct SPARSE filter indices for KCOR table.
    
      ifilto = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
      ifiltr = IFILTDEF_INVMAP_REST(ifilt_rest) 

c check that sparse indices are valid

      LTMP = ( ifiltr .LE. 0 .or. ifiltr .GT. NFILTDEF_REST)
      if ( LTMP ) then
          write(c1err,690) ifiltr, ifilt_rest,
     &       filtdef_string(ifilt_rest:ifilt_rest)
690       format('Invalid ifiltr=',I3,' for ifilt_rest=',I3,' = ',A)
          CALL MADABORT("GET_KCOR8", c1err, "")
      endif

      LTMP = ( ifilto .LE. 0 .or. ifilto .GT. NFILTDEF_SURVEY)
      if ( LTMP ) then
          write(c1err,691) ifilto, ifilt_obs,
     &       filtdef_string(ifilt_obs:ifilt_obs)
691       format('Invalid ifilto=',I3,' for ifilt_obs=',I3,' = ',A)
          CALL MADABORT("GET_KCOR8", c1err, "")
      endif

C Load the table

      NBIN = 0
      IBKCOR(KDIM_ifiltr) = ifiltr - 1
      IBKCOR(KDIM_ifilto) = ifilto - 1

      DO IZ  = 1, NBZINT
         NBINZ  = 0
         IBKCOR(KDIM_Z)  = IZCEN-IBZCEN+IZ-1
      DO IAV = 1, NBAVINT
         IBKCOR(KDIM_AV) = IAVCEN-IBAVCEN+IAV-1
      DO IEP = 1, NBTINT
         IBKCOR(KDIM_T)  = ITCEN-IBTCEN+IEP-1

         KBIN = GET_1DINDEX(IDMAP_KCOR,NKDIM,IBKCOR)+1

         NBIN  = NBIN  + 1
         NBINZ = NBINZ + 1

+SELF,IF=I2KCOR.
         I2KCOR = I2KCORTABLE1D(KBIN)
         KCOR8  = DBLE(I2KCOR)/KCORPACK
+SELF,IF=R4KCOR.
         KCOR8  = DBLE(R4KCORTABLE1D(KBIN))
+SELF.
         F(NBIN)   = KCOR8

         if ( ZSMOOTH )then
             IBKCOR(KDIM_Z) = IZCENb-IBZCEN+IZ-1   ! <== note IZCENb
             KBIN = GET_1DINDEX(IDMAP_KCOR,NKDIM,IBKCOR)+1
             IBKCOR(KDIM_Z) = IZCEN-IBZCEN+IZ-1  ! reset with IZCEN
+SELF,IF=I2KCOR.
             I2KCORb = I2KCORTABLE1D(KBIN)
             KCOR8b  = DBLE(I2KCORb)/KCORPACK
+SELF,IF=R4KCOR.
             KCOR8b  = DBLE(R4KCORTABLE1D(KBIN))
+SELF.
             FZ(NBINZ,IZ)  = KCOR8
             FZb(NBINZ,IZ) = KCOR8b
         endif

      ENDDO
      ENDDO
      ENDDO

C ===========================================

      IF ( ZSMOOTH ) THEN

c get KCOR at nodes of redshift ...
        DO IZ = 1, NBZINT
          KCOR8_Z(iz)  = DFINT(NVAR-1, XIN, NLEN, A, FZ(1,iz) )
          KCOR8b_Z(iz) = DFINT(NVAR-1, XIN, NLEN, A, FZb(1,iz) )
        ENDDO

c now smoothly interpolate KCOR vs. redsfhit

        Z8 = SNGL(REDSHIFT8)
        CALL POLINT8 ( KCOR8_Z,  ZLIST8,  NBZINT, Z8, KCOR8 )
        CALL POLINT8 ( KCOR8b_Z, ZLIST8b, NBZINT, Z8, KCOR8b )
        GET_KCOR8 = .5 * (KCOR8+KCOR8b)
      ELSE
        TMPKCOR8  = DFINT(NVAR,XIN,NLEN,A,F)
        GET_KCOR8 = TMPKCOR8
      ENDIF

      REDSHIFT8_LAST = REDSHIFT8
      IFILT_OBS_LAST = IFILT_OBS

      RETURN
      END

C =========================================
+DECK,KCORERR8.
      DOUBLE PRECISION FUNCTION GET_KCORERR8 ( 
     &    OPT          ! (I) option
     &   ,ifilt_rest   ! (I) filter index, rest frame
     &   ,ifilt_obs    ! (I) filter index, observer frame
     &   ,epoch8       ! (I) rest frame epoch since Max, days
     &   ,redshift8    ! (I) SN redshift
     &   ,av8          ! (I) AV-warp parameter
     &      )

c ---------------------------------------
c Created Feb 14, 2007 by R.Kessler
c
c Return error on K-correction;
c to be used in fits.
c
c Oct 21, 2008: OPT=5 => multiply SJ's error by 5 (test only)
c
c Nov 04, 2009: new option OPT_KCORERR_SMOOTH 
c               with smooth function using half-Gaussian .
c               Note that original error function has kink
c               at 3500 A ... not good for MINUIT
c
c -------------------------------------

      IMPLICIT NONE

c function args

      integer 
     &   OPT
     &  ,ifilt_rest  ! (I) filter index (1-5 = ugriz) in rest frame
     &  ,ifilt_obs   ! (I) idem observer frame

      real*8
     &   epoch8       ! (I) t - t0 in days, rest frame
     &  ,redshift8
     &  ,av8  


c local var

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.

      REAL LAMZ, ZZ, ERR, SQERRSUM, ARG
      LOGICAL LERR_SJ

      REAL SQKCORERR_FLOOR

c define half-Gaussian parameters.
c Below 3280 A, the smoothed error is larger than the linear-kink error
      REAL ERRPAR_LAM0, ERRPAR_SIG, ERRPAR_MAX
      PARAMETER ( 
     &    ERRPAR_LAM0 = 3000.  ! Angstrom
     &   ,ERRPAR_SIG  = 200.   ! idem
     &   ,ERRPAR_MAX  = .35    ! max error at ERRPAR_LAM0
     
     &      )

C --------------- BEGIN ---------------

      GET_KCORERR8 = 0.0
      SQERRSUM     = 0.0

      ZZ   = 1.0 + redshift8
      LAMZ = FILTOBS_LAMAVG(ifilt_obs) / ZZ

      LERR_SJ = OPT .EQ. OPT_KCORERR_SJ 
     &  .or.    OPT .EQ. OPT_KCORERR_SJ5 

      SQKCORERR_FLOOR = 0.01 * 0.01

c Check SJ option:
c    if reff lt 3500 then addsig += 0.6d * ((3500d - reff)/1000d)
      IF ( LERR_SJ ) THEN
        SQERRSUM = SQKCORERR_FLOOR
        if ( LAMZ .LT. 3500.0 ) then
           ERR = 6.0E-4 * (3500.0 - LAMZ)  ! add error in UV
           if ( OPT .EQ. OPT_KCORERR_SJ5 ) then
              ERR = 5. * ERR
           endif

           SQERRSUM = SQERRSUM + ERR*ERR 
        endif

      ELSE IF  ( OPT .EQ. OPT_KCORERR_SMOOTH ) THEN

        if ( LAMZ .LT. ERRPAR_LAM0 ) then
           ERR = ERRPAR_MAX
        else
           arg = 0.5*((LAMZ - ERRPAR_LAM0)/ERRPAR_SIG)**2
           ERR = ERRPAR_MAX * EXP(-ARG)
        endif
        SQERRSUM = SQKCORERR_FLOOR + ERR*ERR 
      ENDIF

      
      GET_KCORERR8 = SQRT ( SQERRSUM )
  
      RETURN     
      END

C ==========================================
+DECK,KCORFUN8.
      DOUBLE PRECISION FUNCTION KCORFUN8 ( 
     &    ifilt_obs    ! (I) observer-filter index
     &   ,IFILT_REST   ! (I) indices of nearest rest-frame filters
     &   ,MAG_REST     ! (I) nearest, 2nd nearest, 3rd nearest mags
     &   ,LAMDIF       ! (I) restlam - lam(filter)
     &   ,Trest, Z     ! (I) rest-frame epoch in days
     &   ,AVWARP       ! (O) Avwarp params
     &        )

c Created Sep 8, 2009 by R.Kessler
c Evaluate AVWARP and KCOR. Note that K-cor takes
c wgted average of neighboring filters to avoid
c discontinuous function.
c
c MAG_REST(1) = mag of overlap rest-frame filter
c MAG_REST(2) = mag of 2nd nearest rest-frame filter for spectral warp
c MAG_REST(3) = mag of 3rd nearest
c
c IFILT_REST(1:3) = rest-frame filter indices.
c
c LAMDIF(2,3) are lambda-distances from central filter used for wgting.
c LAMDIF(1) is ignored
c
c If we are close to the center of IFILT_REST(1),
c then take wgted average of K-cor using both 
c neighbors to avoid discontinuity.
c
c Jun 16, 2010:  if MAG_REST(1) > 20 then set AVWARP = KCORFUN8=0
c Jun 26, 2010:  change to MAG_REST(1) > 15
c                
c Aug 26, 2010:  previously unused LAMDIF(1)  is now a flag to 
c                set AVWARP = 0 for Kcor (see NOAVWARP_FLAG)
c
c Dec 2010: don't allow absurb K-corrections from numerical 
c            artifacts. See KCOR_CRAZYVAL
c ---------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,KCORCOM.
+CDE,FILTCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.

      INTEGER IFILT_OBS, IFILT_REST(3)
      REAL*8  
     &   Trest, Z
     &  ,MAG_REST(3), LAMDIF(3), AVWARP(3)

c local args

      REAL*8 KCOR12, KCOR13, DDLAM, WSUM, W12, W13
      REAL*8 LAMDIF12, LAMDIF13
      INTEGER ISTAT

      REAL*8 DDLAM_MAX    ! max lam-dif to take Kcor wgt avg
      PARAMETER ( DDLAM_MAX = 200.0 )  ! Angstroms

      REAL*8 KCOR_CRAZYVAL
      PARAMETER ( KCOR_CRAZYVAL = 6.0 )
  
      LOGICAL NOAVWARP_FLAG

c functions
      REAL*8  GET_AVWARP8, GET_KCOR8, SMOOTH_STEPFUN8

c ------------ BEGIN ---------------

+SELF,IF=XXDBG.
      LDMP_KCORFUN =   
     &         abs(Trest-51.94) .LT. 0.01
     &   .and. abs(z-.8873)     .LT. 0.001
     &   .and. ifilt_obs     .EQ. IFILT_SDSS_g
     &   .and. ifilt_rest(1) .EQ. IFILT_BESS_U
+SELF.

c init output
      KCORFUN8  = -999.
      AVWARP(1) = -999.  ! this is just a dummy; never gets set
      AVWARP(2) = -999.
      AVWARP(3) = -999.

c check for sane arguments
      IF ( MAG_REST(1) .GT. 15.0 ) then  ! REALLY, REALLY DIM
         KCORFUN8  = 0.0
         AVWARP(1) = 0.0
         AVWARP(2) = 0.0
         AVWARP(3) = 0.0
        RETURN
      ENDIF

      NOAVWARP_FLAG = LAMDIF(1) .EQ. -7.0

c get AVwarp for two closest filters.

      AVWARP(2) = GET_AVWARP8(Trest, Zat10pc      ! (I)
     &             ,MAG_REST(1),   MAG_REST(2)    ! (I)
     &             ,IFILT_REST(1), IFILT_REST(2)  ! (I)
     &             ,istat )                       ! (O)
      if ( NOAVWARP_FLAG) AVWARP(2) = 0.0 

      KCOR12 = GET_KCOR8(ifilt_rest(1), ifilt_obs,    ! all inputs
     &                     Trest, Z, AVwarp(2))       ! all inputs

      KCORFUN8 = KCOR12


      IF ( LDMP_KCORFUN ) THEN
        print*,'  xxx ---------------------------------------- '
        print*,'  xxx KCORFUN DEBUG DUMP: '
        print*,'  xxx Trest=',Trest,'  Z=',Z,'  IFILT_OBS=',IFILT_OBS
        print*,'  xxx KCOR12     = ', KCOR12
        print*,'  xxx IFILT_REST = ', IFILT_REST
        print*,'  xxx MAG_REST   = ', MAG_REST
        print*,'  xxx AVwarp     = ', AVwarp
      ENDIF


      IF ( IFILT_REST(3) .LE. 0 ) GOTO 888

c check if 3rd filter is on other side of central filter
c Example 1: central filter = B, then U & V are valid 2nd and 3rd filters.
c Example 2: central filter = U, then B is valid 2nd filter, but V
c            is NOT a valid 3rd filter to use for K-corrections
c 
c In short, filter-lambda order must be 3-1-2  or  2-1-3.

      LAMDIF12 = FILTREST_LAMAVG(ifilt_rest(2))
     &         - FILTREST_LAMAVG(ifilt_rest(1))
      LAMDIF13 = FILTREST_LAMAVG(ifilt_rest(1))
     &         - FILTREST_LAMAVG(ifilt_rest(3))

      IF ( LAMDIF12/LAMDIF13 .LT. 0.0 ) GOTO 888

c check if both neighboring filters are pretty close to
c the central filter.

      DDLAM = LAMDIF(3) - LAMDIF(2) ! always postive
      W12   = SMOOTH_STEPFUN8(DDLAM, DDLAM_MAX )
      W13   = 1.0 - W12
      IF ( W13 .LT. 1.0E-9 ) GOTO 888

c if we get here, then take wgt avg of K-corrections

      AVWARP(3) = GET_AVWARP8(Trest, Zat10pc   
     &             ,MAG_REST(1),   MAG_REST(3)
     &             ,IFILT_REST(1), IFILT_REST(3)
     &             ,istat )
      if ( NOAVWARP_FLAG) AVWARP(3) = 0.0 

      KCOR13 = GET_KCOR8(ifilt_rest(1), ifilt_obs,  ! all inputs
     &                     Trest, Z, AVwarp(3) )     ! all inputs

      WSUM      = W12 + W13
      KCORFUN8  = (KCOR12*W12 + KCOR13*W13)/WSUM 


888   CONTINUE

c ------------------------------------------------
c Dec 2010: don't allow crazy K-correction values
      IF ( abs(KCORFUN8) .GT. KCOR_CRAZYVAL ) THEN
        KCORFUN8 = 0.0
      ENDIF

      RETURN
      END

C =====================================================
+DECK,GET_MAG8.
      DOUBLE PRECISION FUNCTION GET_MAG8 ( 
     &     ifilt        ! (I) absolute filter index 
     &    ,T8_epoch     ! (I) rest frame epoch, days
     &    ,Z8           ! (I) redshift
     &    ,AVWARP8      ! (I) AV-warp parameter for SN host-gal
     &    ,MWEBV8       ! (I) E(B-V) for MW
     &      )
c ---------------------------
c
c  - if MWEBV8 < 0, returns observer magnitude from LC template 
c    in desired filter, redshift, epoch, AV-warp
c    IFILT = rest-frame filter index.
c
c  - if MWEBV8 >=0, returns MilkyWay extinction in mags. 
c    IFILT = obs-frame filter index
c
c Use CERNLIB's FINT interpolation routine.
c
c To get un-warped spectra in rest frame, 
c pass Z8=0.0 and AV_WARP=0.0.
c
C Note that the distance modulus is NOT included
c in the magnitude when z > 0 ... so z > 0 should 
c be used only for color-differences.
c
c June 19, 2008: allow mags up to 50 (instead of 35)
c                to allow for HST.
c
c
c Aug 27, 2009: increase CRAZY mag limit from 50 to 60 to
c               allow for wierd Kasen models.
c
c Sep 9, 2010: replace +CDE,SNDATCOM.  with +CDE,KCORCOM. 
c
c Aug 4 2019: IBINS starts at 0, not 1
c --------------------------------
      IMPLICIT NONE

c frunction args

      INTEGER IFILT       ! (I) filter index 

      REAL*8  
     &   T8_EPOCH    ! (I) rest frame T - Tmax, days
     &  ,Z8          ! (I)
     &  ,AVWARP8     ! (I)
     &  ,MWEBV8      ! (I)


+CDE,SNPAR.
+CDE,FILTCOM.
+CDE,KCORCOM.

      INTEGER NDIM, NGRIDVAL, MXGRID
      INTEGER IDIMT, IDIMZ, IDIMAV

      PARAMETER ( 
     &   NDIM     = 3  ! # dimensions to interpolate (T,Z,AV)
     &  ,NGRIDVAL = 3  ! # values to store in each dimention
     &  ,MXGRID   = NGRIDVAL**NDIM   ! total GRID storage size
     &  ,IDIMT    = 1
     &  ,IDIMZ    = 2
     &  ,IDIMAV   = 3
     &     ) 

      REAL*8 
     &   GRID(MXGRID)
     &  ,MAGFUN(MXGRID)
     &  ,XCEN(NDIM)
     &  ,MAGOFF, MAG

      REAL*4 r4

      INTEGER 
     &    NVAL(NGRIDVAL),  itmp, Ngrid
     &   ,itbin,  itbin_start,  itbin_end
     &   ,izbin,  izbin_start,  izbin_end
     &   ,iavbin, iavbin_start, iavbin_end
     &   ,IFILTSP, IBINS(4), IBIN
      
      LOGICAL LT, LZ0, DOMAGLC, DOMWXT, LBAD

      CHARACTER C1ERR*80, C2ERR*80, CFILT1*1

c CERNLIB interplation function
      REAL*8 DFINT
      INTEGER FIRSTBIN_INTERP

c index  function
      INTEGER  GET_1DINDEX
      EXTERNAL GET_1DINDEX

C ------------ BEGIN ------------

      GET_MAG8 = +99.0  ! init output 

c check arguments are valid

      IF ( IFILT .LT. 1  .or. IFILT .GT. MXFILT_ALL )   RETURN

      IF ( Z8  .LT.  Zrange_KCOR(1) ) RETURN
      IF ( Z8  .GT.  Zrange_KCOR(2) ) RETURN

      IF ( T8_Epoch  .LT. Trange_KCOR(1) )   RETURN

c check if redshift is zero (rest-frame)

      LZ0 = Z8 .LT. Zat10pc * 1.01

c do NOT test beyong Trange_KCOR(2); if T8_epoch goes
c beyond Tmax, the DFINT function will just extrapolate.
c The fitter needs a smooth function so that late-time
c epochs do not bounce in/out of the max Trange.


c check if MAG or MWXT is evaluated

      IF ( MWEBV8 .LT. 0.0 ) THEN
         DOMAGLC = .TRUE.
         DOMWXT  = .FALSE.
         ifiltsp = IFILTDEF_INVMAP_REST(ifilt)  ! sparse filter index
      ELSE
         DOMAGLC = .FALSE.
         DOMWXT  = .TRUE.
         ifiltsp = IFILTDEF_INVMAP_SURVEY(ifilt) ! sparse filter index
      ENDIF

      if ( ifiltsp .LE. 0 ) then
         cfilt1 = filtdef_string(ifilt:ifilt)
         write(c1err,1661) ifiltsp, ifilt, cfilt1, MWEBV8
1661     format('undefined IFILTSP=',I3,' for  IFILT=',I2,
     &           '(', A, ') and MWEBV=',F5.2 )

         write(c2err,1662) DOMWXT
1662     format('DOMWXT=', L2)
         CALL MADABORT( "GET_MAG8", c1err, c2err )
      endif
c -----------------------------------------------------
c check smoothing option if T8_epoch is within defined range

      LT = T8_Epoch .LT. Trange_KCOR(2)

c ---------------------------------------------------------
c if we get here, use linear interpolation with DFINT function

      r4 = sngl(T8_epoch)
      itbin_start = 
     &   FIRSTBIN_INTERP(r4, Trange_KCOR, Tbinsize_KCOR)

      r4 = sngl(Z8)
      izbin_start = 
     &   FIRSTBIN_INTERP(r4, Zrange_KCOR, Zbinsize_KCOR)

      r4 = sngl(AVWARP8)
      iavbin_start = 
     &   FIRSTBIN_INTERP(r4, AVrange_KCOR, AVbinsize_KCOR)

c define binned grid and function values

      IBINS(1) = itbin_start-1
      IBINS(2) = izbin_start-1
      IBINS(3) = iavbin_start-1
      IBINS(4) = ifiltsp-1

      IF ( DOMAGLC ) THEN
        IBIN = GET_1DINDEX(IDMAP_LCMAG, N4DIM, IBINS)+1
        MAGOFF = LCMAG_TABLE1D(IBIN)
      ELSE
        IBIN   = GET_1DINDEX(IDMAP_MWXT, N4DIM, IBINS)+1
        MAGOFF = MWXT_TABLE1D(IBIN) 
      ENDIF

      XCEN(IDIMT)  = T8_epoch
      XCEN(IDIMZ)  = Z8
      XCEN(IDIMAV) = AVWARP8

      NVAL(IDIMT)     = NGRIDVAL
      NVAL(IDIMZ)     = NGRIDVAL
      NVAL(IDIMAV)    = NGRIDVAL

c collpase z-grid if z=0
      if ( LZ0 ) then 
        NVAL(IDIMZ)  = 1
      endif

      Ngrid = 0

      iavbin_end = iavbin_start + NVAL(IDIMAV) - 1
      izbin_end  = izbin_start  + NVAL(IDIMZ)  - 1
      itbin_end  = itbin_start  + NVAL(IDIMT)  - 1

      DO iavbin = iavbin_start, iavbin_end
      DO izbin  = izbin_start,  izbin_end
      DO itbin  = itbin_start,  itbin_end
 
         IBINS(1) = itbin  - 1
         IBINS(2) = izbin  - 1
         IBINS(3) = iavbin - 1
         IBINS(4) = ifiltsp - 1

         Ngrid = Ngrid + 1

         itmp = itbin - itbin_start + 1
         GRID(itmp)   = GRIDVAL_T(itbin)

         itmp = izbin - izbin_start + 1 + NVAL(IDIMT)
         GRID(itmp)   = GRIDVAL_Z(izbin)

         itmp = iavbin - iavbin_start + 1 + NVAL(IDIMT)+NVAL(IDIMZ)
         GRID(itmp)   = GRIDVAL_AV(iavbin)

         if ( DOMAGLC ) then
           IBIN = GET_1DINDEX(IDMAP_LCMAG, N4DIM, IBINS)+1
           MAG  = LCMAG_TABLE1D(IBIN)
         else
           IBIN   = GET_1DINDEX(IDMAP_MWXT, N4DIM, IBINS)+1
           MAG    = MWEBV8 * MWXT_TABLE1D(IBIN)
         endif

         LBAD =  (abs(MAG) .GT. 60.0 .and. T8_epoch > -18.0 )
     &      .or. (abs(MAG) .GT. 80.0 .and. T8_epoch < -18.0 )

         if ( LBAD .and. T8_epoch .LT. 1000. ) then
             print*,' '
             print*,' GET_MAG8 ERROR: crazy MAG = ', MAG
             print*,'   ifilt      = ', ifilt, ' => charfilt = ',
     &           filtdef_string(ifilt:ifilt)
             print*,'   Trest      = ', T8_epoch  
             print*,'   redshift   = ', Z8
             print*,'   AVwarp     = ', AVWARP8
             print*,'   MWEBV      = ', MWEBV8,'  DOMAGLC=', DOMAGLC
             print*,'   T,Z,AV bin numbers: ', itbin, izbin, iavbin
             print*,'   Check KCOR hid ', HIDMAG(iavbin,ifilt)

             c1err = "Crazy mag"
             c2err = ''
             CALL MADABORT( "GET_MAG8", c1err, c2err )

         endif

         MAGFUN(Ngrid) = MAG - MAGOFF

      ENDDO   ! end of ITBIN loop
      ENDDO   ! end of IZBIN loop
      ENDDO   ! end if IAVBIN loop

c ----------------------------------------------------------------- 
c                                            Grid    function
c                      Ndim          Ngrid   values  values
c ------------------------------------------------------------------
       MAG   = DFINT ( NDIM, XCEN,  NVAL,   GRID,   MAGFUN )

      GET_MAG8  = MAG + MAGOFF

      RETURN
      END       ! GET_MAG8

C ==========================================
+DECK,GET_SNXT8.
      DOUBLE PRECISION FUNCTION GET_SNXT8 ( opt, ifilt, T8, AV8, RV8 )
c
c Nov 17, 2006
c Returns extinction of SN in mags, and in the
c rest frame of the host galaxy.
c AV and RV are the extinction parameters of
c the host galaxy.
c
c
c Aug 8, 2009: allow RV down to -10 (instead of 0) to allow
c              analytic continutation when AV/RV is floated
c
c Aug 30, 2010: OPT_SNXT_CCM89 is now an exact calculation for any RV.
c               Interpolate XTHOST arrary on grid of 1/RV.
c               Previous version did exact calc, but only for the RV
c               value used to make the K-cor tables.
c               Now it works for any RV.
c ------------------------------
      IMPLICIT NONE

c function args

      INTEGER 
     &   OPT    ! (I) see OPT_SNXT_XXX parameters
     &  ,ifilt  ! (I) rest-frame filter (absolute index)

      REAL*8 
     &   T8    ! (I) rest-frame epoch, days
     &  ,AV8   ! (I) 
     &  ,RV8   ! (I)

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,KCORCOM.
+CDE,XTCOM.

c local var

      REAL*8 
     &   XTMAG8_GRID(2)
     &  ,XTMAG8
     &  ,DT8, DIFT8
     &  ,DX8, DXDT
     &  ,zeta8(2), a8, b8
     &  ,RVinv8, DRVinv8, RVfrac8

      INTEGER IT1, IT2, IRV, IRV1, IRV2, NBRV

C ----------------- BEGIN ------------

      GET_SNXT8 = 0.0

c check for crazy values

      IF ( abs(AV8) .GT. 100.0 ) RETURN
      IF ( RV8      .LT. -10.0 ) RETURN

c Convert epoch (days) into indices for interpolation 
c of extinction between nearest days.

        DT8    = DBLE(TBINSIZE_KCOR)
        DIFT8  = T8 - DBLE(TRANGE_KCOR(1))
        IT1    = INT( DIFT8/DT8) + 1

c make sure epoch index is on the grid.
        if ( IT1 .LT. 1          ) IT1 = 1
        if ( IT1 .GE. NTBIN_KCOR ) IT1 = NTBIN_KCOR - 1

c 2nd epoch index for interpolation
        IT2 = IT1 + 1       

c now get nearst RVinv indices for interpolation
        RVinv8 = 1./RV8
        NBRV   = NRVBIN_XTHOST
        IRV2   = NBRV
        DO  irv = NBRV, 1,  -1
          if ( RVinv8 .LT. RVINV_XTHOST(irv) ) IRV2 = IRV
        ENDDO
        IF ( IRV2 .LE. 1 ) IRV2 = 2
        IRV1 = IRV2 - 1
        DRVinv8 = RVINV_XTHOST(IRV2) - RVINV_XTHOST(IRV1)

c ---------------------------------------- 
      IF ( OPT .EQ. OPT_SNXT_CCM89 ) THEN

c use exact CCM89 law on template SNSED;
c interpolate in space of epoch and RV.

c first interpolate iver RVinv for each epoch bin
        DX8     = XTHOST(ifilt,IT1,irv2) - XTHOST(ifilt,IT1,irv1)
        RVfrac8 = ( RVinv8 - RVINV_XTHOST(IRV1) ) / DRVinv8
        XTMAG8_GRID(1)  = XTHOST(ifilt,IT1,irv1) + DX8 * RVfrac8

        DX8 = XTHOST(ifilt,IT2,irv2) - XTHOST(ifilt,IT2,irv1)
        RVfrac8 = ( RVinv8 - RVINV_XTHOST(IRV1) ) / DRVinv8
        XTMAG8_GRID(2)  = XTHOST(ifilt,IT2,irv1) + DX8 * RVfrac8

c now interpolate between epoch bins
        dX8     = XTMAG8_GRID(2) - XTMAG8_GRID(1)
        dXdT    = dX8 / dT8
        DIFT8   = T8 - GRIDVAL_T(it1)
        XTMAG8  = XTMAG8_GRID(1) + dXdT * DIFT8

c since XTHOST array is for AV=1, must multiply by AV,        
        XTMAG8 = AV8 * XTMAG8

      ELSE IF ( OPT .EQ. OPT_SNXT_SJPAR  ) THEN 

c Use Jha's parametrization.

        zeta8(1) = XTPAR_ZETA(ifilt,it1)
        zeta8(2) = XTPAR_ZETA(ifilt,it2)
        a8       = xtpar_alpha(ifilt)
        b8       = xtpar_beta(ifilt)
        XTMAG8_GRID(1)  = zeta8(1) * ( a8 + b8/RV8 ) * AV8
        XTMAG8_GRID(2)  = zeta8(2) * ( a8 + b8/RV8 ) * AV8

        dX8     = XTMAG8_GRID(2) - XTMAG8_GRID(1)
        dXdT    = dX8 / dT8
        DIFT8   = T8 - GRIDVAL_T(it1)
        XTMAG8  = XTMAG8_GRID(1) + dXdT * DIFT8
 
+SELF,IF=SNXTDBUG.
        LF  = IFILT .EQ. IFILT_BESS_V 
        LT  = T8 .EQ. 0.0
        LAV = abs(AV8-1.0) .LT. 0.01 
        if ( LF .and. LT .and. LAV ) then
           print*,' ------------------------------------------- '
           print*,' SNXT DUMP: TRANGE_KCOR = ', TRANGE_KCOR
           print*,' SNXT DUMP: AV=',AV8,'   RV=', RV8
           print*,' SNXT DUMP: alpha,beta=',a8, b8, 
     &              '  zeta=',zeta8
           print*,' SNXT DUMP: DIFT8=',DIFT8,'  IT1,IT2=',IT1,IT2
           print*,' SNXT DUMP: XTMAG_GRID = ', XTMAG8_GRID
           print*,' SNXT DUMP: dXdT       = ', DXDT
           print*,' SNXT DUMP: XTMAG      = ', XTMAG8
        endif
+SELF.

      ELSE
         print*,' '
         print*,' GET_SNXT8 ERROR: '
         print*,'   Invalid OPT=', OPT
         print*,'   ***** ABORT ***** '
         print*,' '
         CALL EXIT(EXIT_ERRCODE)
      ENDIF

      GET_SNXT8 = XTMAG8

      RETURN
      END

C ==========================================
+DECK,FILLAVWARP.
      SUBROUTINE FILL_AVWARPTABLE
c
c Created Oct 11, 2009 by R.Kessler
c 
c Fill R4AVWARPTABLE to be used by GET_AVWARP8 so that
c it runs much faster. Motivated by need to marginalize
c photoz fits with MLCS.
c
c Aug 4 2019: IBINS starts at zero, not one.
c --------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.


c local var

      INTEGER 
     &   ISQ
     &  ,IFILT1, IFILT1_REST
     &  ,IFILT2, IFILT2_REST
     &  ,IFILT3, IFILT3_REST
     &  ,it, ic
     &  ,inbr, IFILT_NBR, IFILT_NBR_REST
     &  ,ISTAT
     &  ,IBINS(4),  IBIN

      INTEGER*8 I8SIZE

      REAL 
     &   TABLESIZE, Trest
     &  ,CMIN, CMAX, CBIN, C
     &  ,Z, LAMDIF2, LAMDIF3, TMP

      REAL*8 mag8_a, mag8_b, T8, z8, AVWARP8

      CHARACTER cfilt1*1, cfilt2*1, cfilt3*1, cfilt_nbr*1

c functions
      REAL*8 GET_AVWARP8
      INTEGER NEAREST_IFILT_REST, GET_1DINDEX

      EXTERNAL GET_1DINDEX

C -------------- BEGIN --------------

      IF ( NFIT_ITERATION .LE. 0 .and. .NOT. LTEST_KCOR ) RETURN

      ISQ    =  MXFILT_REST *  MXFILT_REST
      I8SIZE = MXTBIN_KCOR * MXCBIN_AVWARP * ISQ
      TABLESIZE = 4.0E-6 * float(I8SIZE)  ! R4 size in MB

      print*,' ' 

      CMIN = -3.0
      CMAX = +3.0
      CBIN = (CMAX - CMIN)/float(MXCBIN_AVWARP)
      CBINSIZE_AVWARP = CBIN  ! store global variable

      z8 = Zat10pc
      Z  = SNGL(Z8)

      DO IBIN=1, MXTABLE1D_AVWARP
        AVWARP_TABLE1D(IBIN) = -9999.
      ENDDO

c --------------------

      DO 101 ifilt1 = 1, NFILTDEF_REST
    
        ifilt1_rest = IFILTDEF_MAP_REST(ifilt1)
 
        ifilt2_rest = 
     &    NEAREST_IFILT_REST(OPT_FILTREST,ifilt1_rest,2,Z,LAMDIF2)
        ifilt3_rest = 
     &    NEAREST_IFILT_REST(OPT_FILTREST,ifilt1_rest,3,Z,LAMDIF3)

        ifilt2      = IFILTDEF_INVMAP_REST(ifilt2_rest)
        ifilt3      = IFILTDEF_INVMAP_REST(ifilt3_rest)

        cfilt1 = filtdef_string(ifilt1_rest:ifilt1_rest)  
        cfilt2 = filtdef_string(ifilt2_rest:ifilt2_rest)  
        cfilt3 = filtdef_string(ifilt3_rest:ifilt3_rest)  

        LAMDIF2 = FILTREST_LAMAVG(ifilt2_rest) - 
     &            FILTREST_LAMAVG(ifilt1_rest)

        LAMDIF3 = FILTREST_LAMAVG(ifilt3_rest) - 
     &            FILTREST_LAMAVG(ifilt1_rest)
        
      DO 102 inbr = 2, 3
 
        if ( inbr .EQ. 2 ) then
           ifilt_nbr      = ifilt2
           ifilt_nbr_rest = ifilt2_rest
           cfilt_nbr      = cfilt2      
        else
           ifilt_nbr      = ifilt3
           ifilt_nbr_rest = ifilt3_rest
           cfilt_nbr      = cfilt3

c don't do ifilt3 if it's on the same side as ifilt2
c (because it's 2 filters away)

           if ( LAMDIF2/LAMDIF3 .GT. 0.0 ) goto 102
        endif

        IBINS(1) = 10-1
        IBINS(2) = 10-1
        IBINS(3) = ifilt_nbr-1
        IBINS(4) = ifilt1-1
        IBIN     = GET_1DINDEX(IDMAP_AVWARP,N4DIM,IBINS)+1
        TMP      = AVWARP_TABLE1D(IBIN)

        if ( TMP .GT. -9998. ) goto 102

        write(6,20) cfilt1, cfilt_nbr, cfilt_nbr, cfilt1
20      format(T5,'Fill AVWARPTABLE for Rest-frame colors ',
     &      A,'-',A ,' and ', A,'-',A  )

      DO 200 it  = 1, NTBIN_KCOR
         Trest = GRIDVAL_T(it)  ! rest-frame epoch
         T8    = DBLE(Trest)
      DO 300 ic = 1, MXCBIN_AVWARP

         C = CMIN + CBIN*float(ic)  ! color
         if ( it .EQ. 1 ) GRIDVAL_C(ic) = C

         mag8_a = C
         mag8_b = 0.0
         AVWARP8 = GET_AVWARP8(T8, Z8, mag8_a, mag8_b, 
     &        ifilt1_rest, ifilt_nbr_rest, ISTAT )

         IBINS(1) = it-1
         IBINS(2) = ic-1
         IBINS(3) = ifilt1-1
         IBINS(4) = ifilt_nbr-1
         IBIN     = GET_1DINDEX(IDMAP_AVWARP,N4DIM,IBINS)+1
         AVWARP_TABLE1D(IBIN) = SNGL(AVWARP8)

c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx DEBUG Dec 30 2012
         if ( ifilt1_rest    .eq. -11 .and. 
     &        ifilt_nbr_rest .EQ. -12 .and.
     &        abs(Trest + 4.0) < 1.0 ) then
c IBIN=59063
c          if ( LDMP_AVWARP ) then

            write(6,222) IBIN, Trest, c, AVWARP8
222         format('AVWARP: IBIN=',I7, 2x, 'Trest=',F6.2,2x,
     &            'c=',F6.3,2x,'AVwarp=',F8.4 )

            call flush(6)
         endif
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        
c now flip the color and filters

         mag8_a = 0.0
         mag8_b = C
         AVWARP8 = GET_AVWARP8(T8, Z8, mag8_a, mag8_b, 
     &        ifilt1_rest, ifilt_nbr_rest, ISTAT )

         IBINS(3) = ifilt_nbr-1
         IBINS(4) = ifilt1-1
         IBIN     = GET_1DINDEX(IDMAP_AVWARP,N4DIM,IBINS)+1
         AVWARP_TABLE1D(IBIN) = SNGL(AVWARP8)


300   CONTINUE
200   CONTINUE

102   CONTINUE
101   CONTINUE

      USE_AVWARPTABLE = .TRUE.

      RETURN
      END

C ======================================
+DECK,PRS1FUPD.
      SUBROUTINE PARSE1_FILTER_INFO(NWD)

c parse FILTER.INFO file that has a different filter set
c for each SN.

      IMPLICIT NONE

      INTEGER NWD ! (I) number of words in file
+CDE,SNPAR.
c +CDE,PARSECOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER IWD, istar, LEN

      character 
     &   FILTER_SUBDIR*(MXCHAR_PATH)
     &  ,cwd*(MXCHAR_FILEWORD)
     &  ,cwd_next*(MXCHAR_FILEWORD)
     &  ,copt*(MXCHAR_FILEWORD)
     &  ,c1err*80, c2err*80

      LOGICAL LDUMP 

C ----------- BEGIN ----------

      DO 10 iwd = 1, NWD-1

          CALL get_PARSE_WORD_fortran(iwd+0, cwd,      LEN)
          CALL get_PARSE_WORD_fortran(iwd+1, cwd_next, LEN)

          if ( cwd .EQ. ' ' ) goto 10

          if ( cwd .EQ. 'FILTER_SUBDIR:' ) then
            FILTER_SUBDIR = cwd_next
            istar = Index(FILTER_SUBDIR,'{SNID}')
            PREFIX_UPD_FILTDIR = FILTER_SUBDIR(1:istar-1)
            SUFFIX_UPD_FILTDIR = FILTER_SUBDIR(istar+6:99)
          endif

          if ( cwd .EQ. 'FILETRANS_SN:' ) then
            CALL SET_FILTINFO_UPD("SN", cwd_next)
          endif
          if ( cwd .EQ. 'FILETRANS_REF:' ) then
            CALL SET_FILTINFO_UPD("REF", cwd_next)
          endif

          if ( cwd(1:7) .EQ. 'OPTION:' ) then
             copt = cwd_next
             if ( copt(1:7) .EQ. 'DEFAULT' ) then

             else if ( copt(1:8) .EQ. 'SAMEFILT' ) then
               OPT_FILTER_UPDATE  = OPT_FILTUPD_SAMEFILT
             else
               C1ERR = 'Invalid FilterFile.INFO OPTION: ' // copt(1:20)
               C2ERR = 'Valid options: DEFAULT SAMEFILT '
               CALL MADABORT("FILTER_UPDATE_INIT", C1ERR, C2ERR )
             endif
          endif

10    CONTINUE

      LDUMP = .false.
      if ( LDUMP ) then
          print*, ' xxxxxx FILTER_SUBDIR= ', FILTER_SUBDIR(1:20)
          print*, ' xxxxxx   PREFIX_UPD_FILTDIR =',
     &                       PREFIX_UPD_FILTDIR(1:20) 
          print*, ' xxxxxx   SUFFIX_UPD_FILTDIR =',
     &                       SUFFIX_UPD_FILTDIR(1:20) 
      endif

      RETURN
      END

C ======================================
+DECK,PRS2FUPD.
      SUBROUTINE PARSE2_FILTER_INFO(NWD)

c Created July 16, 2011 by R.Kessler
c parse FILTER.INFO file that has a defined set of filters
c such as one set per SDSS-CCD column.
c IMAP is a sparse index 1-NMAP
c INDX is the absolute filter-path index in the FILTER.INFO file.
c
c Load MAP1_FILTER_UPDATE (subdir vs. index) and 
c MAP2_FILTER_UPDATE (index vs. CCID)
c
c ------------------------

      IMPLICIT NONE

+CDE,SNPAR.
c+CDE,PARSECOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER NWD  ! (I) number of words to check

      INTEGER 
     &   IWD, INDX, LEN
     &  ,IMAP1, IMAP1_STORE, NMAP1, NMAP2

      character
     &   cwd0*(MXCHAR_FILEWORD)
     &  ,cwd1*(MXCHAR_FILEWORD)
     &  ,cwd2*(MXCHAR_FILEWORD)
     &  ,ccid*(MXCHAR_CCID)
     &  ,c1err*80, c2err*80

C ---------------- BEGIN -------------

      NMAP1_FILTER_UPDATE = 0
      NMAP2_FILTER_UPDATE = 0

      NMAP1 = 0
      NMAP2 = 0

      DO 10 iwd = 1, NWD-2

          call get_PARSE_WORD_fortran(iwd+0, cwd0, LEN)
          call get_PARSE_WORD_fortran(iwd+1, cwd1, LEN)
          call get_PARSE_WORD_fortran(iwd+2, cwd2, LEN)

          if ( cwd0 .EQ. ' ' ) goto 10


          if ( cwd0 .EQ. 'FILTER_PATH:' ) then
             read(cwd1,*) INDX

             NMAP1 = NMAP1 + 1
             NMAP1_FILTER_UPDATE = NMAP1

             if ( NMAP1 .GT. MXMAP1_FILTER_UPDATE ) then
               write(c1err,1660) NMAP1, MXMAP1_FILTER_UPDATE
1660           format('NMAP=',I3,
     &           ' exceeds bound of MXMAP1_FILTER_UPDATE=',I3)
               c2err = 'Increase bound or reduce NMAP'
               CALL MADABORT('PARSE2_FILTER_INFO', C1ERR, C2ERR)
             endif
             MAP1_FILTER_UPDATE_INDX(NMAP1)    = INDX
             MAP1_FILTER_UPDATE_SUBDIR(NMAP1)  = CWD2
          endif

          if ( cwd0 .EQ. 'FILETRANS_SN:' ) then
            CALL SET_FILTINFO_UPD('SN', cwd1)
          endif
          if ( cwd0 .EQ. 'FILETRANS_REF:' ) then
            CALL SET_FILTINFO_UPD('REF', cwd1)
          endif



          if ( cwd0 .EQ. 'SN:' ) then
             CCID = cwd1(1:MXCHAR_CCID)
             read(cwd2,*) INDX

c translate INDX to sparse IMAP1
             IMAP1_STORE = -9
             DO imap1 = 1, NMAP1_FILTER_UPDATE
                if ( MAP1_FILTER_UPDATE_INDX(imap1) .EQ. INDX) then
                   imap1_store = imap1
                endif
             END DO

             if ( IMAP1_STORE .LE. 0 ) then
               write(c1err,670) INDX, CCID
               c2err = 'Check FILTER.INFO file.'
670            format('Undefined INDX=',I8,'   for  CID = ',A8)
               CALL MADABORT('PARSE2_FILTER_INFO', C1ERR, C2ERR)
             endif

c update 2nd map
             NMAP2 = NMAP2 + 1
             NMAP2_FILTER_UPDATE = NMAP2

             if ( NMAP2 .GT. MXSNLC_FILTUPD ) then
                write(c1err,661) MXSNLC_FILTUPD
661             format('MAP2 size exceeds bound of MXSNLC_FILTUPD=',I6)
                c2err = 'Check FILTER.INFO file.'
                CALL MADABORT("PARSE2_FILTER_INFO", C1ERR, C2ERR)
             endif
             
             MAP2_FILTER_UPDATE_CCID(NMAP2)    = CCID
             MAP2_FILTER_UPDATE_PTRMAP1(NMAP2) = IMAP1_STORE

          endif  !   'SN:' key


10    CONTINUE

c ---------------------------------------------------------

      write(6,60) NMAP1_FILTER_UPDATE
60    format(T4,'Found ',I2,' filter sets to use for updates.')

      write(6,61) NMAP2_FILTER_UPDATE
61    format(T4,'Filter update map stored for ',I6,' SNe.' )

      print*,' -------------------------------------------------- '

      RETURN
      END

C =================================
+DECK,SETFUPD.
      SUBROUTINE SET_FILTINFO_UPD(KEY,STRING)
c
c Created Jul 16, 2011
c
c Parse STRING for asterisk, and store PREFIX and SUFFIX
c before/after the asterisk. Used later to determine the
c name of the filter transmission  file where the  asterisk
c is replaced with the filter-character.
c
c Jul 5 2013: string-length fixes to avoid segfault in debug mode.
c             See use of LKEY and LSTR.
c
c ---------

      IMPLICIT  NONE

c input arguments
      CHARACTER KEY*(*)     ! (I) 'SN' or 'REF'
      CHARACTER STRING*(*)  ! (I) string to define filter filename
 
c local variables

+CDE,SNPAR.
c +CDE,PARSECOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
  
      INTEGER istar, LSTR, LKEY
      LOGICAL LDUMP 
C ------------ BEGIN -------------
 
      LSTR = INDEX(STRING,' ' ) - 1
      LKEY = INDEX(KEY//' ',   ' ' ) - 1

      istar = Index(STRING,'*')

      IF ( KEY(1:LKEY) .EQ. 'REF' ) THEN
          PREFIX_UPD_TRANSREF = STRING(1:istar-1)
          SUFFIX_UPD_TRANSREF = STRING(istar+1:LSTR)
          FILTINFO_UPD_REF = .TRUE. 

      ELSE IF ( KEY(1:LKEY) .EQ. 'SN' ) THEN
          PREFIX_UPD_TRANSSN = STRING(1:istar-1)
          SUFFIX_UPD_TRANSSN = STRING(istar+1:LSTR)
          FILTINFO_UPD_SN = .TRUE. 

      ELSE

      ENDIF

c print comment about filename syntax

      LDUMP = .TRUE.
      IF ( LDUMP ) THEN
         write(6,20) KEY, STRING(1:LSTR)
20       format(T4,'Filter-Trans filenames(', A, ') : ''',A, 
     &          '''  with * => filter' )
      ENDIF

      RETURN
      END
C =======================================
+DECK,FUPDDRIV.
      SUBROUTINE FILTER_UPDATE_DRIVER()
c
c Nov 8, 2010 R.Kessler
c Driver routine to udpate filter transmission for currenet SN.
c 
c May 2012: get filter-udpate directory outside the IFILT loop
c           by calling GET_FILTER_UDPATE_DIR(SNLC_CCID).
c
c
c Jan 17, 2013: skip filters with no obs; those with
c               ISNLC_NEPOCH_FILT(ifilt) .LE. 0 
c        
c Jan 31, 2013: print message that filter trans is updated
c
c --------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,FILTCOM.
+CDE,FILTUPDCM.

c local var

      INTEGER IFILT, IFILT_OBS, OPT
      LOGICAL LSAME, LUPD, ISBX
      CHARACTER C1ERR*80, C2err*80

c function
      LOGICAL ISBXFILT
C ------------- BEGIN ----------

      OPT = OPT_FILTER_UPDATE
      IF ( OPT .LE. 0 ) RETURN

      write(6,20) SNLC_CCID(1:ISNLC_LENCCID)
 20   format(T5,'***** UPDATE FILTER TRANSMISSION FOR CID = ', 
     &       A, ' ***** ')


      LUPD = ( OPT .EQ. OPT_FILTUPD_EACHSN ) .or.
     &       ( OPT .EQ. OPT_FILTUPD_MAP    )

c determine path with filter update; set global FILTER_UPDATE_DIR
c Make sure to do this outside the IFILT loop to avoid redundant
c loops through the maps.
      IF ( LUPD ) CALL GET_FILTER_UDPATE_DIR(SNLC_CCID)

c -----------------------------------------
c update filter transmissions based on option

      DO 10 IFILT = 1, NFILTDEF_SURVEY


        if ( ISNLC_NEPOCH_FILT(ifilt) .LE. 0 ) GOTO 10

        ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
        DOFLAG_FILTER_UPDATE(ifilt_obs) = OPT_FILTER_UPDATE ! July 2015

        ISBX      = ISBXFILT(ifilt_obs,'', 'OBS' )
   
        LSAME = (OPT .EQ. OPT_FILTUPD_SAMEFILT)  .or. ISBX


        if ( LSAME  ) then
           CALL FILTER_UPDATE_SAMEFILT(ifilt)
        else if ( LUPD ) then
           CALL FILTER_UPDATE_EACHSN(ifilt) 

        else
           write(c1err,60) OPT
60         format('Invalid  OPT_FILTER_UPDATE = ', I3 )
           c2err = 'Check OPT_FILTUPD_*  parameters in snana.car'
           CALL MADABORT("FILTER_UPDATE_DRIVER", C1ERR, C2ERR)
        endif

 10   CONTINUE
      

c ----------------------------------------------------
c  Finally, update ZP offsets for all filters.

      IF ( LUPD ) THEN
        CALL FILTER_UPDATE_ZPOFF(FILTER_UPDATE_DIR)
      ENDIF

c later add stuff for K-corrections ... 

      RETURN
      END

C ====================================
+DECK,FUPDZP.
      SUBROUTINE FILTER_UPDATE_ZPOFF(FDIR)

c Created July 2011
c Update MAGOBS_SHIFT_ZP_FILT(ifilt_obs) based on the
c zeropoint (AB) offsets in text-file $FDIR/ZPOFF.DAT .
c If this ZPOFF.DAT file does not exist, then just set 
c the offsets to the user offsets.
c
c -------------

      IMPLICIT NONE

c subroutine args
      CHARACTER FDIR*(*)  ! (I) directory with filters and ZPOFF.DAT

c local args

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
c+CDE,PARSECOM.

      INTEGER LDIR, IFILT, IFILT_OBS, ISTAT      
      REAL ZPOFF_UPD(MXFILT_ALL)

C --------------- BEGIN -------------

+SELF,IF=MARKDELETE.

c xxxxxxxxx mark delete Dec 7 2019 xxxxxxxxx
c check if ZPOFF.DAT file exists.
      LDIR = INDEX(FDIR,' ') - 1
      ZPOFF_FILE = FDIR(1:LDIR) // '/' // 'ZPOFF.DAT'
      OPEN(UNIT=LUNTMP, FILE=ZPOFF_FILE, STATUS='OLD', IOSTAT=istat)

      IF ( ISTAT .EQ. 0 ) THEN  
         CALL RD_ZPOFF(ZPOFF_FILE, ZPOFF_UPD)
      ELSE
         DO ifilt  = 1, NFILTDEF_SURVEY
            ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
            ZPOFF_UPD(ifilt_obs) = 0.0
         ENDDO
      ENDIF
c xxxxxxxxxxxx
+SELF.


       DO ifilt  = 1, NFILTDEF_SURVEY
          ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
          ZPOFF_UPD(ifilt_obs) = 0.0
       ENDDO

c update ZP-shift for each filter (i.e., add to user-shift)
      DO ifilt  = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         MAGOBS_SHIFT_ZP_FILT(ifilt_obs) = 
     &   MAGOBS_SHIFT_ZP_USER(ifilt_obs) + ZPOFF_UPD(ifilt_obs)
      ENDDO

      CALL DMP_ZPOFF

      RETURN
      END

C ================================================
+DECK,GTFUPDDIR.
      SUBROUTINE GET_FILTER_UDPATE_DIR(CCID)

c Created May 18, 2012
c Find and load global  FILTER_UPDATE_DIR for this CCID.
c Used for filter-update option.

      IMPLICIT NONE

      CHARACTER CCID*(*)  ! (I) SN name

c local var

+CDE,SNPAR.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER LPDIR, LSDIR, LPATH, LCC, LMAP, IMAP1, IMAP2
      CHARACTER MAPDIR*100
c functions
      INTEGER IMAP2_FUPDMATCH

C -------------------- BEGIN --------------

      LCC   = INDEX(CCID,' ') - 1
      LPDIR = INDEX(PREFIX_UPD_FILTDIR,' ') -1 
      LSDIR = INDEX(SUFFIX_UPD_FILTDIR,' ') -1 
      LPATH = INDEX(FILTER_UPDATE_TOPDIR,' ') - 1


      if ( OPT_FILTER_UPDATE .EQ. OPT_FILTUPD_EACHSN ) then
         FILTER_UPDATE_DIR = FILTER_UPDATE_TOPDIR(1:LPATH) // '/' 
     &        // PREFIX_UPD_FILTDIR(1:LPDIR)
     &        // CCID(1:LCC)
     &        // SUFFIX_UPD_FILTDIR(1:LSDIR)

      else if ( OPT_FILTER_UPDATE .EQ. OPT_FILTUPD_MAP ) then

c search 2nd map for CCID match to get IMAP1
         
         IMAP2   = IMAP2_FUPDMATCH(CCID) 
         IMAP1   = MAP2_FILTER_UPDATE_PTRMAP1(IMAP2)
         MAPDIR  = MAP1_FILTER_UPDATE_SUBDIR(IMAP1)
         LMAP    = INDEX(MAPDIR,' ') - 1
         FILTER_UPDATE_DIR = FILTER_UPDATE_TOPDIR(1:LPATH) // '/' 
     &             // MAPDIR(1:LMAP)   

      endif

      RETURN
      END

C ================================================
+DECK,FUPD1.
      SUBROUTINE FILTER_UPDATE_EACHSN(ifilt)

c Nov 8, 2010
c Read/update filter response for this sparse 'ifilt'
c Store in FILTOBS_TRANS_UPD array using same lambda 
c binning as in KCOR file. Updated lambda binning 
c can be different since it gets interpolated to the 
c original grid.
c
c Apr 3, 2011 RK
c  - replace LAMINTERP with INTERP_1DFUN
c
c Jul 16, 2011 RK
c   - move SAMEFILT option to FILTER_UPDATE_SAMEFILT
c     and rename this function from _READ to _EACHSN
c

      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
c +CDE,PARSECOM.

c subroutine args
      INTEGER IFILT     ! (I) sparse indices

c local var

      INTEGER 
     &   IFILT_OBS, L0, LCC, LL, LDIR, LTMPF, LCOM
     &  ,LPSN, LPREF, LSSN, LSREF, NLAM, ilam, NLAM_UPD
     &  ,istat, MXLAM, OPT_INTERP

      CHARACTER 
     &   FILTFILE_SN*(MXCHAR_FILENAME)   ! SN tranmission vs. lambda
     &  ,FILTFILE_REF*(MXCHAR_FILENAME)  ! idem for primary ref
     &  ,TMPFILE*(MXCHAR_FILENAME)
     &  ,CCID*(MXCHAR_CCID)
     &  ,cfilt*1
     &  ,c1err*80
     &  ,c2err*80
     &  ,comment*40 

      REAL*8
     &   LAM
     &  ,FLAM_UPD(MXLAMBIN_FILT)    ! temp lambda array
     &  ,FTRANS_UPD(MXLAMBIN_FILT)  ! temp filterTrans array
     &  ,Trans_upd, Trans_orig

      LOGICAL  LEXIST_SN, LEXIST_REF, UPDDUMP

c define utilities from sntools.c
      INTEGER  RD2COLUMNFILE 
      EXTERNAL RD2COLUMNFILE 
  
      REAL*8   INTERP_1DFUN
      EXTERNAL INTERP_1DFUN

C ---------------- BEGIN --------------

      UPDDUMP = .FALSE.  ! internal dump logical

      ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
      cfilt     = filtdef_string(ifilt_obs:ifilt_obs)   
      NLAM      = NLAMBIN_FILTOBS(ifilt_obs)
      LCC       = INDEX(SNLC_CCID, ' '     ) - 1 
      CCID      = SNLC_CCID(1:LCC)

      if (UPDDUMP) then
        print*,' '
        print*, 'XXXXXX ----------------------------------------- '
        print*, 'XXXXXX FILTER_UPDATE_EACHSN  DUMP start for ', 
     &       CCID(1:LCC),'-', cfilt
        call flush(6)
      end if 

      OPT_INTERP = 1   ! 1=linear;  2=quadratic

      comment = CCID(1:LCC) // '-filter-update' // char(0)
      LCOM    = INDEX(comment,' ') - 1


c     get string lengths for file name

      LPSN  = INDEX(PREFIX_UPD_TRANSSN,' ') -1 
      LSSN  = INDEX(SUFFIX_UPD_TRANSSN,' ') -1 

      LPREF = INDEX(PREFIX_UPD_TRANSREF,' ') -1 
      LSREF = INDEX(SUFFIX_UPD_TRANSREF,' ') -1 

      L0    = INDEX(FILTER_UPDATE_PATH, ' ' ) - 1
      LDIR = INDEX(FILTER_UPDATE_DIR,' ') - 1

c constuct full filename of SN and REF-transmission files.

      TMPFILE = PREFIX_UPD_TRANSSN(1:LPSN)   
     &           // cfilt // SUFFIX_UPD_TRANSSN(1:LSSN)
      LTMPF = INDEX(TMPFILE,' ') - 1
      FILTFILE_SN = FILTER_UPDATE_DIR(1:LDIR)  
     &                 // '/' // TMPFILE(1:LTMPF) 

      TMPFILE = PREFIX_UPD_TRANSREF(1:LPREF)   
     &          // cfilt // SUFFIX_UPD_TRANSREF(1:LSREF)
      LTMPF = INDEX(TMPFILE,' ') - 1
      FILTFILE_REF = FILTER_UPDATE_DIR(1:LDIR)  
     &          // '/' // TMPFILE(1:LTMPF) 


      if (UPDDUMP) then

        print*, '++++ UPDATING FILTER ' 
     &          ,'IFILT = ', ifilt_obs,' '
     &         , cfilt(1:1), ' with NLAM '
     &         , NLAM , ' for SN ', CCID
        call flush(6)
       end if


c Use IOSTAT option to figure out which of the files
c FILTFILE_REF  and FILTFILE_SN exist

c     check if FILTFILE_REF exists?


      istat=1
      LL = INDEX(FILTFILE_REF,' ') - 1
      TMPFILE =FILTFILE_REF(1:LL)
      OPEN(UNIT=LUNTMP, FILE=TMPFILE, STATUS='OLD',
     &       IOSTAT=istat)
      CLOSE( UNIT = LUNTMP)      

      if (istat .EQ. 0) then

       LEXIST_REF = .true.

       MXLAM   = MXLAMBIN_FILT
       TMPFILE = FILTFILE_REF(1:LL) // char(0)
       istat   = rd2columnFile (TMPFILE, MXLAM, NLAM_UPD 
     &          ,FLAM_UPD, FTRANS_UPD, LL)  ! (out)

      else 
        LEXIST_REF = .false.
      endif 

      if (UPDDUMP) then 
        print*, '  LEXIST_REF = ', LEXIST_REF,' for ', CCID
        call flush(6)
      end if


c    now interpolate to the original grid
c    for files which exist


      if (LEXIST_REF) then      

      DO 20 ilam = 1, NLAM
            LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS) 
            Trans_orig = FILTOBS_TRANS(ilam,IFILT_OBS) ! for debug only
            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) = 0.0

            if ( LAM .LT. FLAM_UPD(1)        ) GOTO 20
            if ( LAM .GT. FLAM_UPD(NLAM_UPD) ) GOTO 20
 
            Trans_upd = interp_1dfun(OPT_INTERP, LAM, 
     &                  NLAM_UPD, FLAM_UPD, FTRANS_UPD, comment, LCOM)

            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) = Trans_upd  

20    CONTINUE  ! ILAM loop over original lambda binning
        if (UPDDUMP) then
          print*, "REF interp done"
          call flush(6)
        end if 
      end if 


c     FILTFILE_SN exists?

      istat=1
      LL = INDEX(FILTFILE_SN,' ') - 1
      TMPFILE =FILTFILE_SN(1:LL)
      OPEN(UNIT=LUNTMP, FILE=TMPFILE, STATUS='OLD',
     &  IOSTAT=istat)
     
      if (istat.EQ.0) then
       LEXIST_SN = .true.
c     readsnfile
      MXLAM   = MXLAMBIN_FILT
      TMPFILE = FILTFILE_SN(1:LL) // char(0)
      istat   = rd2columnFile (TMPFILE, MXLAM, NLAM_UPD 
     &          ,FLAM_UPD, FTRANS_UPD,LL)  ! (out)

      else 
       LEXIST_SN = .false.
      endif 
      CLOSE( UNIT = LUNTMP)        

c   INTERPOLATE to get FILTOBS_TRANSSN_UPD

      if (LEXIST_SN) then
cc      print*, ' Interpolate SN file', NLAM 
      DO 70 ilam = 1, NLAM
            LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS) 
            Trans_orig = FILTOBS_TRANS(ilam,IFILT_OBS) ! for debug only
            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) = 0.0

            if ( LAM .LT. FLAM_UPD(1)        ) GOTO 70
            if ( LAM .GT. FLAM_UPD(NLAM_UPD) ) GOTO 70
 
            Trans_upd = interp_1DFUN(OPT_INTERP, LAM, 
     &             NLAM_UPD, FLAM_UPD, FTRANS_UPD, comment, LCOM )

            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) = Trans_upd  

70    CONTINUE  ! ILAM loop over original lambda binning
        if (UPDDUMP) then
          print*, 'SN Interp done for', NLAM, CCID
          call flush(6)
        end if
      end if 


c    If neither file exists, abort program


      if (.NOT.( LEXIST_REF .OR. LEXIST_SN) ) then        
        c1err = 'Could not update filter-trans for CID = ' 
     &       // CCID(1:LCC) // '-' // cfilt
        c2err = 'FILTDIR=' // FILTER_UPDATE_DIR(1:LDIR)
        CALL MADABORT('FILTER_UPDATE_EACHSN', c1err, c2err )
      endif

c     IF either SN or REF file does not exist, copy the other 
c     file for the transmission functions


c     SN File does not exist. IF REF file exists, SN trans= Ref Trans
c                             IF REF file does not exist, SN trans undef
c                             but should have been aborted above

      if (.NOT.(LEXIST_SN)) then 
      DO 170 ilam = 1, NLAM
            LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS) 
            FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) 
     &       = FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) 

            if ( LAM .LT. FLAM_UPD(1)        ) GOTO 170
            if ( LAM .GT. FLAM_UPD(NLAM_UPD) ) GOTO 170

170    CONTINUE  ! ILAM loop over original lambda binning
      end if


c     REF File does not exist. IF SN file exists, Ref trans= SN Trans
c                             IF SN file does not exist, Ref trans undef
c                             but should have been aborted above
      if (.NOT. (LEXIST_REF)) then
      DO 270 ilam = 1, NLAM
            LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS) 
            FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) 
     &       = FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) 

            if ( LAM .LT. FLAM_UPD(1)        ) GOTO 270
            if ( LAM .GT. FLAM_UPD(NLAM_UPD) ) GOTO 270

270    CONTINUE  ! ILAM loop over original lambda binning
      end if

c -----------------------------
      if(UPDDUMP) then 
        print*, '%%%% ', NLAM
        if (mod(NLAM,2).EQ.0) then
           ilam = NLAM/2
        else
         ilam = (NLAM+1)/2
        end if
        LAM  = FILTOBS_LAMBDA(ilam,IFILT_OBS)
        print*, 'xxxxx',LAM 
     &        , FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS)
     &        , FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS)
     &        , FILTOBS_TRANS (ilam, IFILT_OBS) 
 

        print*, 'xxxx SN =' , CCID
        print*, 'xxxx LEXIST_REF =', LEXIST_REF
        print*, 'xxxx LEXIST_SN =', LEXIST_SN
        print*, 'xxxx FILE_REF =', FILTFILE_REF
        print*, 'xxxx FILE_SN =', FILTFILE_SN

        print*, 'XXXXXX FILTER_UPDATE_EACHSN  DUMP end for ', CCID
        call flush(6)
      endif


      RETURN
      END

C =======================================
+DECK,IMAP2FUPD.
      INTEGER FUNCTION IMAP2_FUPDMATCH(CCID)

c Created May 19, 2012
c Search array IMAP2_FILTER_UPDATE_CCID(imap2)
c to find CCID match; return IMAP2 = index of array.
c Used to match CCID to sparse index associated
c with the filter-subdir.

      IMPLICIT NONE
      CHARACTER CCID*(*)  ! (I) SN name to match

c local  var

+CDE,SNPAR.
+CDE,FILTCOM.
+CDE,FILTUPDCM.

      INTEGER IMAP2, L0, L1
      CHARACTER CCID_TMP*(MXCHAR_CCID), C1ERR*72, C2ERR*72

C ---------------- BEGIN ------------------

      IMAP2_FUPDMATCH = -9
      L0 = INDEX(CCID,' ') - 1

      DO 100 IMAP2 = 1, NMAP2_FILTER_UPDATE

         CCID_TMP  = MAP2_FILTER_UPDATE_CCID(IMAP2)
         L1 = INDEX(CCID_TMP // ' ',' ') - 1

         IF ( L0 .NE. L1 ) GOTO 100
         IF ( CCID(1:L0) .NE. CCID_TMP(1:L1) ) GOTO 100

c if we get here then return
         IMAP2_FUPDMATCH = IMAP2
         RETURN

100   CONTINUE


c if we get here then abort.
      write(c1err,61) CCID(1:8)
61    format('Could not find MAP2_FILTER_UPDATE match for CID=',A)
      c2err = 'Check FILTER.INFO file.'
      CALL MADABORT('IMAP2_FUPDMATCH', c1err, c2err )


      RETURN
      END

C ================================================
+DECK,FUPD3.
      SUBROUTINE FILTER_UPDATE_SAMEFILT(ifilt)
      IMPLICIT NONE
+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNLCCOM. 
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,FILTUPDCM.
c +CDE,PARSECOM.

      INTEGER ifilt  ! (I) sparse SN & filter index

c local variables

      INTEGER ilam, NLAM, ifilt_obs

C ------------ BEGIN -------------

      ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
      NLAM      = NLAMBIN_FILTOBS(ifilt_obs)

      DO 100 ilam = 1, NLAM

          FILTOBS_TRANSSN_UPD(ilam,IFILT_OBS) = 
     &    FILTOBS_TRANS(ilam,IFILT_OBS) 

          FILTOBS_TRANSREF_UPD(ilam,IFILT_OBS) = 
     &    FILTOBS_TRANS(ilam,IFILT_OBS) 
100   CONTINUE

      RETURN
      END

C =============================
+DECK,GET_FILTMAP.
      INTEGER FUNCTION GET_FILTMAP( COPT, FILTMAP )
c
c Created Oct 2007
c C-callable routine to return map of INDICES or ABOFF.
c Returns NFILTDEF_SURVEY as argument.
c Note that NFILTDEF_SURVEY is the total number of filters
c defined for the telescope system.
c
c Apr 25 2013: replace COPT*12 with COPT*(*)
c 
c July 5 2016: COPT='SPECTROGRAPH' -> return list of SYN_FILTER
c

      IMPLICIT NONE
+CDE,SNPAR.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,KCORCOM.

c function args

      CHARACTER COPT*(*)         ! (I) 'ABOFF' or 'INDEX'
      REAL FILTMAP(MXFILT_ALL)   ! (O) index map or ABOFF

c local variables
      INTEGER ifilt, ifilt_obs

c ---------------- BEGIN ---------------


       GET_FILTMAP = 0
c init output to -9

       DO ifilt = 1, NFILTDEF_SURVEY
           FILTMAP(ifilt) = -9
       ENDDO
      
c check for sparse filter-index map

      IF ( COPT(1:5) .EQ. 'INDEX' ) THEN
         DO ifilt = 1, NFILTDEF_SURVEY
             FILTMAP(ifilt) = float ( IFILTDEF_MAP_SURVEY(ifilt))
         ENDDO
         GET_FILTMAP = NFILTDEF_SURVEY
         RETURN
      ENDIF

c check for AB offsets
      IF ( COPT(1:5) .EQ. 'ABOFF' ) THEN
         DO ifilt      = 1, NFILTDEF_SURVEY
             ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
             FILTMAP(ifilt) = MAGOBS_SHIFT_ZP_FILT(ifilt_obs)
         ENDDO         
         GET_FILTMAP = NFILTDEF_SURVEY
         RETURN
      ENDIF

c check for spectrograph (Jul 2016)
      IF ( COPT(1:12) .EQ. 'SPECTROGRAPH' ) THEN
         DO ifilt = 1, NFILTDEF_SPECTROGRAPH
           FILTMAP(ifilt) = float ( IFILTDEF_SPECTROGRAPH(ifilt) )
         ENDDO
         GET_FILTMAP = NFILTDEF_SPECTROGRAPH         
         RETURN
      ENDIF

      RETURN
      END
C ===========================
+DECK,GET_FILTLAM.
      SUBROUTINE GET_FILTLAM (OPT_FRAME, ifilt, 
     &               lamavg, lamrms, lammin, lammax )
c
c Return filter info; this is for C code to get info
c from fortran commmon block.
c 
c July 2016: add arguments lammin, lammax

      IMPLICIT NONE

      INTEGER IFILT        ! (I) absolute filter index
      INTEGER OPT_FRAME    ! (I) 1=rest, 2=obs

      REAL LAMAVG, LAMRMS  ! (O) info to return
      REAL LAMMIN, LAMMAX  ! (O) added July 2016

+CDE,SNPAR.
+CDE,FILTCOM.

      IF ( OPT_FRAME .EQ. OPT_FILTOBS ) THEN
        LAMAVG = FILTOBS_LAMAVG(ifilt)
        LAMRMS = FILTOBS_LAMRMS(ifilt)
        LAMMIN = FILTOBS_LAMRANGE(1,ifilt)
        LAMMAX = FILTOBS_LAMRANGE(2,ifilt)
      ELSE
        LAMAVG = FILTREST_LAMAVG(ifilt)
        LAMRMS = FILTREST_LAMRMS(ifilt)
        LAMMIN = FILTREST_LAMRANGE(1,ifilt)
        LAMMAX = FILTREST_LAMRANGE(2,ifilt)
      ENDIF

      RETURN
      END

C ======================================================
+DECK,LDFILTTRANS.
      SUBROUTINE LOAD_FILTTRANS(OPT, ifiltdef, NLAM, flam, ftrans)

c Nov 2010: load filter trans & lambda bins  into global array.
c           Use OBS or REST arrays based on input OPT argument.
c
c Dec 31, 2010: ilam_max++ and ilam_min--  to include one
c               zero-trans bin on each side of the trans function
c               may be needed for interpolation at the min/max region.
c
c Nov 15, 2011: compute and store MEAN and RMS so that we can get
c               rid of the ill-defined 'FUNCTION HSTATI' in CERNLIB.
c
c July 2016: also store min & max lambda
c
c Jan 16 2017: check NLAM_LOAD against array bound BEFORE ilam loop.

c -----------------------

      IMPLICIT NONE

      INTEGER   
     &   OPT       ! (I) OPT_FILTOBS or OPT_FILTREST
     &  ,IFILTDEF  ! (I) absolute filter index
     &  ,NLAM      ! (I) Number of lambda bins

      REAL 
     &   FLAM(NLAM)     ! (I) lambda array
     &  ,FTRANS(NLAM)   ! (I) filter trans per lambda bin

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,FILTCOM.

      INTEGER ilam, ilam_min, ilam_max, jj, NLAM_LOAD
      REAL trans, LAM, LAMMIN, LAMMAX
      REAL*8  SUM8(0:2), TRANS8, LAM8, SQERR8, MN8, RMS8
      character frame*4, cfilt*28, c1err*80, c2err*80, FNAM*16
C -------------------- BEGIN --------------

      FNAM = 'LOAD_FILTTRANS'

c get min/max lambda index to allow for zero-transmission bins

      ilam_min =  99999
      ilam_max = -99999
      do ilam = 1, NLAM
        trans = FTRANS(ilam) 

        if ( trans .GT. 0.0 ) ilam_max = ilam

        if ( trans .GT. 0.0 .and. ilam_min .EQ. 99999 ) then
            ilam_min = ilam
        endif
      enddo

c include zero-trans bin on each side of trans function
 
      if ( ilam_min .GT. 1 ) then
         ilam_min = ilam_min - 1
      endif
      if ( ilam_max .LT. NLAM ) then
         ilam_max = ilam_max + 1 
      endif

      SUM8(0) = 0.0
      SUM8(1) = 0.0
      SUM8(2) = 0.0

      LAMMIN = FLAM(ilam_min)
      LAMMAX = FLAM(ilam_max)

c --------------------------------------------------
c check expected number of bins to load, and abort if exceeds bound
      NLAM_LOAD = ilam_max - ilam_min + 1
      IF ( NLAM_LOAD > MXLAMBIN_FILT ) THEN

        if ( OPT .EQ. OPT_FILTOBS ) then
           frame = 'OBS'
           cfilt = FILTOBS_NAME(ifiltdef)
        else
           frame = 'REST'
           cfilt = FILTREST_NAME(ifiltdef)
        endif
      
        CALL PRINT_PREABORT_BANNER(FNAM(1:16)//char(0),40)
        print*,'   IFILTDEF, OPT   = ', IFILTDEF, OPT
        print*,'   NLAM, NLAM_LOAD = ', NLAM, NLAM_LOAD
        print*,'   ilam_min, ilam_max = ', ilam_min, ilam_max

        write(c1err,61) NLAM_LOAD, frame, cfilt
61      format('NLAM_LOAD = ',I5,' > bound for ',
     &       A,'-frame ', A )

        write(c2err,62) MXLAMBIN_FILT
62      format('Check bound in snana.car: MXLAMBIN_FILT = ',I5)

        CALL MADABORT(FNAM, c1err, c2err)
      ENDIF


c ---------------- START LAMBDA LOOP ----------------

      jj = 0
      do ilam = ilam_min, ilam_max 
        lam   = FLAM(ilam)
        trans = FTRANS(ilam) 
        jj    = jj + 1

c keep track of sums for MEAN and RMS
         TRANS8    = DBLE(trans)
         LAM8      = DBLE(lam)
         SUM8(0)   = SUM8(0) + TRANS8
         SUM8(1)   = SUM8(1) + TRANS8 * LAM8
         SUM8(2)   = SUM8(2) + TRANS8 * LAM8 * LAM8

        if ( OPT .EQ. OPT_FILTOBS ) then
          NLAMBIN_FILTOBS(ifiltdef)   = 
     &    NLAMBIN_FILTOBS(ifiltdef) + 1

          FILTOBS_LAMBDA(jj,ifiltdef) = LAM

          FILTOBS_TRANS(jj,ifiltdef)  = TRANS

          FILTOBS_TRANSMAX(ifiltdef)  = 
     &          MAX(TRANS, FILTOBS_TRANSMAX(ifiltdef))
        else

          NLAMBIN_FILTREST(ifiltdef)   = 
     &    NLAMBIN_FILTREST(ifiltdef) + 1

          FILTREST_LAMBDA(jj,ifiltdef) = LAM

          FILTREST_TRANS(jj,ifiltdef)  = TRANS

          FILTREST_TRANSMAX(ifiltdef)  = 
     &          MAX(TRANS, FILTREST_TRANSMAX(ifiltdef))

        endif

      enddo

c -----------------------------------------
c compute wavelength MEAN and RMS 

      MN8    = SUM8(1)/SUM8(0)
      SQERR8 = SUM8(2)/SUM8(0) - MN8**2
      RMS8   = SQRT(SQERR8)

      if ( OPT .EQ. OPT_FILTOBS ) then
         FILTOBS_LAMAVG(ifiltdef)  = sngl(MN8)
         FILTOBS_LAMRMS(ifiltdef)  = sngl(RMS8)
         FILTOBS_LAMRANGE(1,ifiltdef)  = LAMMIN  ! July 2016
         FILTOBS_LAMRANGE(2,ifiltdef)  = LAMMAX  ! July 2016
      else
         FILTREST_LAMAVG(ifiltdef)  = sngl(MN8)
         FILTREST_LAMRMS(ifiltdef)  = sngl(RMS8)
      endif

c ----------------------

      RETURN
      END  ! end LOAD_FILTTRANS


C ======================================================
+DECK,SHIFT_FILTTRANS.
      SUBROUTINE SHIFT_FILTTRANS(IFILT_OBS, LAMSHIFT, NLBIN, ARRAY_LAM, 
     &                            ARRAY_TRANS) 

C Created Jun 20 2017
C Redefine ARRAY_TRANS corresponding to LAMSHIFT (Angstroms)
C Note that input ARRAY_TRANS is changed, but ARRAY_LAM is not.
C
      IMPLICIT NONE

c subroutine args
      INTEGER IFILT_OBS ! (I) filter index, for comments only
      REAL LAMSHIFT     ! (I) lambda shift
      INTEGER NLBIN     ! (I) number of lambda bins 
      REAL  ARRAY_LAM(NLBIN)    ! (I) lambda array
      REAL  ARRAY_TRANS(NLBIN)  ! (I,O) trans array -> modified

c local args

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,FILTCOM.

      INTEGER ILAM
      CHARACTER FNAM*16, CFILT*2

      REAL*8   DTRANS, DLAM, DLAMMIN, DLAMMAX
      REAL*8   DTEMP_LAMLIST(NLBIN), DTEMP_TRANSLIST(NLBIN)
      REAL*8   INTERP_1DFUN
      EXTERNAL INTERP_1DFUN

C ------------ BEGIN -------------

      IF ( abs(LAMSHIFT) < 0.001 ) RETURN

      cfilt     = FILTDEF_STRING(ifilt_obs:ifilt_obs)
      write(6,20) cfilt, LAMSHIFT
20    format(T14,'Shift ', A1,'-band by ', F5.1,' Angstroms' )
      CALL FLUSH(6)

      FNAM = 'SHIFT_FILTTRANS'

c store trans in double-precision arrays for interpolation
      DO ILAM = 1, NLBIN
        DTEMP_LAMLIST(ILAM)   = DBLE( ARRAY_LAM(ILAM) )
        DTEMP_TRANSLIST(ILAM) = DBLE( ARRAY_TRANS(ILAM) )
      ENDDO
      DLAMMIN = DTEMP_LAMLIST(1)
      DLAMMAX = DTEMP_LAMLIST(NLBIN)

c loop over each bin and transfer lam-shifted trans
      DO 200 ILAM = 1, NLBIN
        DLAM = DTEMP_LAMLIST(ILAM) - DBLE(LAMSHIFT)

        IF ( DLAM < DLAMMIN .OR. DLAM > DLAMMAX ) THEN
          DTRANS = 0.0 
        ELSE
          DTRANS = interp_1dfun(1, DLAM, NLBIN,
     &                  DTEMP_LAMLIST, DTEMP_TRANSLIST,
     &                  FNAM//char(0), 16)
        ENDIF

        ARRAY_TRANS(ILAM) = SNGL(DTRANS)
200   CONTINUE

      RETURN
      END    ! end SHIFT_FILTTRANS


C ======================================================
+DECK,GET_FILTTRANS.
      SUBROUTINE GET_FILTTRANS ( MASKFRAME, ifilt, cfiltname, magPrim, 
     &                           NLAM, lam, transSN, transREF  )
c
c Created Dec 4, 2007 by R.Kessler
c C-function interface to return filter-transmission for 
c absolute filter index "IFILT".
c
c MASKFRAME = 1 (OPT_FILTREST)
c    -> check REST filters only, abort if not found
c MASKFRAME = 2 (OPT_FILTOBS) 
c    -> check OBS filters only; abort if not found
c MASKFRAME = 3 
c    -> check OBS and REST filters; if both OBS and REST exist,
c       return OBS transmission.
c
c
c May 4, 2009: also return primary mag.
c
c Nov 9, 2010: return updated filterTrans (FILTOBS_TRANS_UPD)
c              if OPT_FILTER_UPDATE > 0
c
c Mar 09, 2011: retutn 2 sets of transmissions: SN and REF.
c
c Jul 20, 2011: ABORT if filter is not recognized.
c
c Feb 12, 2012: use LFILTDEF_OBS to check if filter exists.
c
c Jan 23, 2014: add new MASKFRAME arg to select OBS and/or REST frame
c
c Apr 2, 2014: new &SNLCINP variable SNRMAX_FILTERS = 'gri' -->
c              use these filters for SNRMAX cuts.
c
c ---------------------------------------------------------

      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,FILTCOM.
+CDE,FILTUPDCM.


c subroutine args.

      INTEGER MASKFRAME         ! (I) (MASK&1)=>obs, (MASK&2)=>rest
      INTEGER IFILT             ! (I) absolute filter index

      CHARACTER cfiltname*(*)    ! (O) full name of filter
      INTEGER NLAM               ! (O) Number of lambda bins
      REAL*8  
     &   MAGPRIM                  ! (O) primary mag of reference
     &  ,LAM(MXLAMBIN_FILT)       ! (O) array of lambdas
     &  ,TRANSSN(MXLAMBIN_FILT)   ! (O) array of transmissions
     &  ,TRANSREF(MXLAMBIN_FILT)  ! (O) array of transmissions

      LOGICAL 
     &   LDBUG
     &  ,LOBS_CHECK, LREST_CHECK
     &  ,LOBS_FOUND, LREST_FOUND, LOK

c local variables.

      INTEGER i, LL
      character cfilt*2, C1err*80, C2ERR*80, CFILTNAME_TMP*60

c ---------------- BEGIN -------------

      LDBUG = (IFILT .EQ. -99)
     
      LOBS_CHECK  = BTEST( MASKFRAME, OPT_FILTOBS  - 1 )
      LREST_CHECK = BTEST( MASKFRAME, OPT_FILTREST - 1 )

      LOBS_FOUND  = LFILTDEF_OBS(ifilt)
      LREST_FOUND = LFILTDEF_REST(ifilt)

      LOK = (LOBS_CHECK  .and. LOBS_FOUND) .or.
     &      (LREST_CHECK .and. LREST_FOUND)

c pass back  full name of filter
      
      IF ( .not. LOK ) THEN
         cfilt     = FILTDEF_STRING(ifilt:ifilt)
         write(C1ERR,601) CFILT, IFILT
         write(C2ERR,602) MASKFRAME
601      format('Unknown filter-trans for FILTER = ',A, 2x,'IFILT=',I3)
602      format('MASKFRAME = ',I4 )
         CALL MADABORT('GET_FILTTRANS', C1ERR, C2ERR )
      ENDIF

c -----------------
c  if we get here, then we have found a filter.
c  Make sure that a FOUND OBS filter has priority.

      IF ( LOBS_FOUND ) THEN
         CFILTNAME_TMP = FILTOBS_NAME(ifilt)
         MAGPRIM       = DBLE ( FILTOBS_MAG_PRIMARY(ifilt) )
         NLAM          = NLAMBIN_FILTOBS(ifilt) 
      ELSE
         CFILTNAME_TMP = FILTREST_NAME(ifilt)
         MAGPRIM       = DBLE ( FILTREST_MAG_PRIMARY(ifilt) )
         NLAM          = NLAMBIN_FILTREST(ifilt) 
      ENDIF

c prepare C-string return argument.
      LL = INDEX ( CFILTNAME_TMP, ' ') - 1
      cfiltname = CFILTNAME_TMP(1:LL) // char(0)

      DO 200 i = 1, NLAM

        IF ( LOBS_FOUND ) THEN
          LAM(i)      = FILTOBS_LAMBDA(i,ifilt)  ! obs-frame
          TRANSSN(i)  = FILTOBS_TRANS(i,ifilt)   
          TRANSREF(i) = FILTOBS_TRANS(i,ifilt)   
        ELSE
          LAM(i)      = FILTREST_LAMBDA(i,ifilt)  ! rest-frame
          TRANSSN(i)  = FILTREST_TRANS(i,ifilt)   
          TRANSREF(i) = FILTREST_TRANS(i,ifilt)   
        ENDIF

c --- check special option for filter-update for each SN
        
        IF ( DOFLAG_FILTER_UPDATE(ifilt) > 0 ) THEN
           TRANSSN(i)  = FILTOBS_TRANSSN_UPD(i,ifilt)
           TRANSREF(i) = FILTOBS_TRANSREF_UPD(i,ifilt)
        ENDIF

 200  CONTINUE  ! end lambda loop

      RETURN
      END


C ===========================
+DECK,GET_PRIMARY.
      SUBROUTINE GET_PRIMARY ( NAME,  NLAM, lam, flux  )
c
c Created May 4, 2009 by R.Kessler
c Return NAME of primary ref and its 
c spectrum in flux per Angstrom.
c 
c Jan 1 2013: primary flux is now per A, so no longer divide by DLAM.
c Sep 1 2016: NAME*20 -> NAME*(*) to match sim string length
c                [bug found by Rachel on NSERC/Edison]
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,FILTCOM.

c subroutine args.
 
      CHARACTER name*(*)    ! (O) full name of primary
      INTEGER NLAM          ! (O) Number of lambda bins
      REAL*8  
     &   LAM(MXLAMBIN_FILT)    ! (O) array of lambdas
     &  ,FLUX(MXLAMBIN_FILT)   ! (O) flux array

c local variables.

      INTEGER i, LL

c ---------------- BEGIN -------------
      
      LL     = INDEX ( PRIMARY_NAME, ' ') - 1
      NAME   = PRIMARY_NAME(1:LL) // char(0)
      NLAM   = NLAMBIN_PRIMARY

c each histogram flux-bin is integrated over DLAM,
c so divide by DLAM to get flux per A.

      DO i = 1, NLAM
        LAM(i)   = PRIMARY_LAM(i)
        FLUX(i)  = PRIMARY_FLUX(i)
      ENDDO

      RETURN
      END


C ======================================
+DECK,FILTBTEST.
      LOGICAL FUNCTION FILTBTEST(MSK8,ibit)
c Mar 29, 2011
C Return true if 1 <= IBIT < 90 is set in MSK8.
c Note that LSB=1 (not 0)
c

      INTEGER   IBIT    ! (I) bit to set 
      INTEGER*8 MSK8(2) ! (I/O) 8-byte mask to set

      INTEGER IBIT2
      INTEGER MXBIT
      PARAMETER ( MXBIT =  60 )

      LOGICAL LTMP
C ------------ BEGIN ------------

      if ( IBIT .LE. MXBIT ) then
        LTMP = BTEST(MSK8(1),IBIT-1)
      else if ( IBIT .LT. 2*MXBIT ) then
        IBIT2  = IBIT-MXBIT
        LTMP   = BTEST(MSK8(2),IBIT2-1)
      endif
      FILTBTEST = LTMP
      RETURN
      END

C ======================================
+DECK,FILTBSET.
      SUBROUTINE FILTBSET(MSK8,ibit)
c Mar 29, 2011
C set bit IBIT(1 to 2*MXBIT) for long int MSK8.
c Note that the input argument is also the output
c with IBIT set.

      INTEGER   IBIT    ! (I) bit to set 
      INTEGER*8 MSK8(2) ! (I/O) 8-byte mask to set

      INTEGER IBIT2
      INTEGER MXBIT
      PARAMETER ( MXBIT =  60 )

C ------------ BEGIN ------------

      if ( IBIT .LE. MXBIT ) then
        MSK8(1) = IBSET(MSK8(1),IBIT-1)
      else if ( IBIT .LT. 2*MXBIT ) then
        IBIT2   = IBIT-MXBIT
        MSK8(2) = IBSET(MSK8(2),IBIT2-1)
      endif

      RETURN
      END


C ==========================================
+DECK,CHECK_MAGSHIFTS.
      SUBROUTINE RDKCOR_CHECK_MAGSHIFTS

C Nov 13, 2010
C Check that user-defined mag-shifts correspond to 
c defined filters. Check both OBS and REST frame.
c
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IFILT
      REAL MAGTMP
      LOGICAL LFILTOBS, LFILTREST, LSHIFT
      CHARACTER CFILT*4, C1ERR*80, C2ERR*80, FNAM*24

C ------------- BEGIN ------------

      FNAM = 'RDKCOR_CHECK_MAGSHIFTS'

      DO 660 IFILT = 1, MXFILT_ALL

        LFILTOBS  = ( IFILTDEF_INVMAP_SURVEY(ifilt) .GT. 0   )
        LFILTREST = ( IFILTDEF_INVMAP_REST(ifilt)   .GT. 0   )

c ----------------------
c obs-frame mag shift
        MAGTMP  = MAGOBS_SHIFT_PRIMARY_FILT(ifilt)
        LSHIFT  = ( MAGTMP   .NE. 0.0 )
        CFILT   = filtdef_string(ifilt:ifilt)           
        if ( LSHIFT .and. .NOT. LFILTOBS ) then
           write(c1err,661) 'OBS', cfilt(1:1), MAGTMP
           c2err = 'for an undefined OBS-frame filter.'
           CALL MADABORT(FNAM, c1err, c2err)
        endif 

c rest-frame mag shift
        MAGTMP  = MAGREST_SHIFT_PRIMARY_FILT(ifilt)
        LSHIFT  = ( MAGTMP   .NE. 0.0 )
        CFILT   = filtdef_string(ifilt:ifilt)           
        if ( LSHIFT .and. .NOT. LFILTREST ) then
           write(c1err,661) 'REST', cfilt(1:1), MAGTMP
           c2err = 'for an undefined REST-frame filter.'
           CALL MADABORT(FNAM, c1err, c2err)
        endif 

c ----------------------
c obs-frame ZP shift
        MAGTMP  = MAGOBS_SHIFT_ZP_FILT(ifilt)
        LSHIFT  = ( MAGTMP   .NE. 0.0 )
        CFILT   = filtdef_string(ifilt:ifilt)           
        if ( LSHIFT .and. .NOT. LFILTOBS ) then
           write(c1err,662) 'OBS', cfilt(1:1), MAGTMP
           c2err = 'for an undefined OBS-frame filter.'
           CALL MADABORT(FNAM, c1err, c2err)
        endif 

c rest-frame ZP shift
        MAGTMP  = MAGREST_SHIFT_ZP_FILT(ifilt)
        LSHIFT  = ( MAGTMP   .NE. 0.0 )
        CFILT   = filtdef_string(ifilt:ifilt)           
        if ( LSHIFT .and. .NOT. LFILTREST ) then
           write(c1err,662) 'REST', cfilt(1:1), MAGTMP
           c2err = 'for an undefined REST-frame filter.'
           CALL MADABORT(FNAM, c1err, c2err)
        endif 

660   CONTINUE

661   format('MAG', A, '_SHIFT_PRIMARY(',A,') = ', F7.4)
662   format('MAG', A, '_SHIFT_ZP(',A,') = ', F7.4)

      RETURN
      END
C ==========================================
+DECK,RDZPOFF,IF=MARKDELETE.
      SUBROUTINE RD_ZPOFF(ZPOFF_FILE, ZPOFF_VALUES )
c
c xxxxxxx mark this subroutine for delete Dec 7 2019 xxxxxxxxxxxx
c
c Created July 17, 2011 by R.Kessler
c Read ZPOFF_FILE and return ZPOFF_VALUES(ifilt_obs)
c Format of ZPOFF_FILE assumed to be 
c   [filt1] [ZPOFF1]  [filt2] [ZPOFF2] etc ...
c -------------

      IMPLICIT NONE

+CDE,SNPAR.
c+CDE,PARSECOM.

c subroutine args
      CHARACTER ZPOFF_FILE*(*)            ! (I) read this file
      REAL      ZPOFF_VALUES(MXFILT_ALL)  ! (O) ZPOFF vs. ifilt_obs

c local var

      REAL       ZPOFF
      INTEGER    iwd, NWD, LEN, LWD0, LWD1, ifilt_obs
      CHARACTER  cfilt*(MXCHAR_FILEWORD), cval*(MXCHAR_FILEWORD)
      CHARACTER  NAME_forC*(MXCHAR_FILENAME)
c functions
      INTEGER FILTINDX

      INTEGER  STORE_PARSE_WORDS
      EXTERNAL STORE_PARSE_WORDS

C ----------------- BEGIN ---------------

      LEN = INDEX(ZPOFF_FILE,' ')-1
      NAME_forC = ZPOFF_FILE(1:LEN)//char(0)
      NWD = STORE_PARSE_WORDS(MSKOPT_PARSE_WORDS_FILE,NAME_forC,LEN)

      DO 100 iwd = 1, NWD, 2

         CALL get_PARSE_WORD_fortran(iwd+0, cfilt, LWD0 )
         CALL get_PARSE_WORD_fortran(iwd+1, cval,  LWD1 )

         ifilt_obs =  FILTINDX(cfilt)
         read(cval,*) ZPOFF

         ZPOFF_VALUES(ifilt_obs) = ZPOFF
100   CONTINUE

      RETURN
      END
c xxxxxxxxxxx end mark xxxxxxxxxxxx
+SELF.


C ==========================================
+DECK,DMP_ZPOFF.
      SUBROUTINE DMP_ZPOFF

c --------------------------
c Created Jul 17, 2011
c Dump zeropoint offsets to screen.
c
c Feb 2016: dump only obs-filters in kcor file; ingore un-defined filters.
c
c -------------------------
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,CTRLCOM.
+CDE,SNCUTS.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,KCORCOM.

      REAL      ZPOFF_TOT
      INTEGER   ifilt_obs, jlen, ifilt_tmp
      character CFILT*2

C ------------------ BEGIN ------------

      print*,' '

+SELF,IF=MARKDELETE.
c xxxxxxx mark delete Dec 7 2019 xxxxxxxxxxxxx
      IF ( ZPOFF_FILE(1:4) .EQ. 'NULL' ) then
         write(6,20) 'KCOR file'
      ELSE
        jlen = INDEX(ZPOFF_FILE,' ') - 1
        write(6,21) ZPOFF_FILE(1:jlen)
      ENDIF
+SELF.

         write(6,20) 'KCOR file'  ! Dec 7 2019 (pull out of IF block)

20    format(T5,'Zeropoint offsets (ZPOFF) from : ', A)
21    format(T5,'Zeropoint offsets (ZPOFF) from : ' /, T8, A)

      DO 200 ifilt_tmp = 1, NFILTOBS_RDKCOR
        ifilt_obs = IFILTOBS_RDKCOR(ifilt_tmp)     

          if ( ifilt_obs .EQ. IFILT_BESS_BX ) goto 200

          cfilt     = filtdef_string(ifilt_obs:ifilt_obs)

          ZPOFF_TOT = MAGOBS_SHIFT_ZP_FILT(ifilt_obs) 
          write(6,801) cfilt(1:1), ZPOFF_TOT
801       format(T10,'Will apply net MAGOBS_SHIFT_ZP(',A,') = ', F7.4 )

200   CONTINUE

      CALL FLUSH(6)

      RETURN
      END  ! end of DMP_ZPOFF

C =======================
+PATCH,*SPLINE.
C =======================


cc +PATCH,*2DEX.

+KEEP,DA2DEX.

C Data for surface smoother
C 5/02/2011 : INMAX=6 -> 8

      INTEGER IND,NMAX,NCMAX,INMAX
      PARAMETER (NMAX=4000, NCMAX=NMAX*100,INMAX=8)  ! save memory

cc      PARAMETER (NMAX=10000,NCMAX=NMAX*100,INMAX=20)  ! original

      INTEGER NX(INMAX),NY(INMAX),KX(INMAX),KY(INMAX)
      INTEGER NND,JND(INMAX)
      REAL*8 TX(NMAX,INMAX),TY(NMAX,INMAX), C(NCMAX,INMAX)
      REAL*8 WRK1(NCMAX,INMAX)
      COMMON /DA2DEX/ TX,NX,TY,NY,C,WRK1,KX,KY,NND,JND

+DECK,IN2DEX.
      SUBROUTINE IN2DEX(IND,M,XX,YY,ZZ,XXM,YYM,SS,IER)
C-------------------------------
C Interface to 2d surface extrapolator.  This initializes the 2D 
C extrapolator by interfacing to the surface fitter and storing 
C the results. D. Cinabro May, 2006
C
C Usage:
C  IND (I) = Index of surface, INMAX allowed
C  M   (I) = number of data points (nx*ny)
C  XX  (I) = First Dimension inputs, double precision
C  YY  (I) = Second Dimension inputs, double precision
C  ZZ  (I) = Output of F(XX,YY) to be smoothed, double precision
C  XXM (I) = Range of X extrapolation min and max, double precision
C  YYM (I) = Range of Y extrapolation min and max, double precision
C  S   (I) = Smoothing parameter, double precision optimal value should be
C            bounded by (m-sqrt(2*m),m+sqrt(2m)).  See surfit documentation
C            for more advice.  Smaller means less smoothing.
C  IER (o) = Error flag.  <=0 is good, >0 is bad.  See surfit for meaning.
C
C Based on the DIERCKX package of Fortran subroutines for calculating 
C smoothing splines for various kinds of data and geometries, 
C with automatic knot selection.  This library is also called 
C FITPACK, but is independent of the FITPACK library by Alan Cline.
C
C Reference:
C Paul Dierckx, Curve and Surface Fitting with Splines, 
C Oxford University Press, 1993
C
C Developer
C Paul Dierckx, Department of Computer Science, K.U. Leuven, 
C Celestijnenlaan 200 A,
C B-3001, Heverlee, Belgium Paul.Dierckx@cs.kuleuven.ac.be
C---------------------------------------------------------------
C
      IMPLICIT NONE
C
C User inputs
C
      INTEGER IOPT,M,IER
      REAL*8 XX(M),YY(M),ZZ(M),XXM(2),YYM(2),SS
C
C Surfit inputs
C
      INTEGER I, NXEST,NYEST
      REAL*8 X(M),Y(M),Z(M),W(M),XB,XE,YB,YE,S,EPS
C
C Surfit outputs in common block needed for function
C
+CDE,DA2DEX.
+CDE,SNPAR.
+CDE,CTRLCOM.
C
      LOGICAL FIRST, USEY
      DATA FIRST/.TRUE./
      INTEGER IN
C
C Working arrays
C
      INTEGER IWRK(NMAX),LWRK1,LWRK2,KWRK
      REAL*8 FP,WRK2(NCMAX)
C
C--------------------------
C
      IF (FIRST) THEN
        FIRST = .FALSE.
        NND = 0
      ENDIF
C
      IN = 0
      IF (NND.GT.0) THEN
        DO 50 I = 1,NND
          IF (IND.EQ.JND(I)) THEN
            IN = I
          ENDIF
  50    CONTINUE
      ENDIF     
      IF (IN.EQ.0) THEN
        NND = NND + 1
        JND(NND) = IND
        IN = NND
      ENDIF
  51  CONTINUE
      IF (IN.GT.INMAX) THEN
        print*,' '
        print*,' IN2DEX Warning: IND =',IND
        print*,' Too many functions defined.  Increase INMAX '
        print*,' ***** ABORT ***** '
        CALL EXIT(EXIT_ERRCODE)
      ENDIF

C Tell the fitter to not use a user supplied set of knots
      IOPT = 1
      USEY = .FALSE.
      DO 100 I = 1,M
        X(I) = XX(I)
        Y(I) = YY(I)
        Z(I) = ZZ(I)
C All points wieghted equally
        W(I) = 1.0
        if ( Y(I) .NE. Y(1) ) USEY = .TRUE.
 100  CONTINUE
      XB = XXM(1)
      XE = XXM(2)
      YB = YYM(1)
      YE = YYM(2)
C Use cublic splines.  Cannot be larger than 5.
      KX(IN) = 3
 
      IF ( USEY ) then
         KY(IN) = 3
      ELSE
         KY(IN) = 1
      ENDIF

      S = SS
C Maximum Number of knots.  Value here is advice from surfit plus 10
      NXEST = KX(IN) + 1 + NINT(SQRT(REAL(M)/2.0))  + 10
      NYEST = KY(IN) + 1 + NINT(SQRT(REAL(M)/2.0))  + 10
C Nearness of fit parameter, 1/10000 should be more than adequate
      EPS = 0.0001
      LWRK1 = NCMAX
      LWRK2 = NCMAX
      KWRK = NMAX
C Zero out the working array to avoid hysterisis
      DO 101 I = 1,NCMAX
        WRK1(I,IN) = 0.0
 101  CONTINUE
C
C Call the fitter
C
      CALL SURFIT(IOPT,M,X,Y,Z,W,XB,XE,YB,YE,KX(IN),KY(IN),
     &  S,NXEST,NYEST,NMAX,EPS,NX(IN),TX(1,IN),NY(IN),TY(1,IN),
     &  C(1,IN),FP,WRK1(1,IN),LWRK1,WRK2,LWRK2,IWRK,KWRK,IER)
C
      RETURN
      END

+DECK,GE2DEDX.
      DOUBLE PRECISION FUNCTION GE2DEX(IND,XX1,YY1,IER)
C----------------------------------------------------
C GE2DEX gets the result of the smoothing initialized by IN2DEX
C
C GE2DEX(XX1,YY1,IER)
C  IND  (I) = Index of function, INMAX allowed
C  XX1  (I) = First Dimension input, double precision
C  YY1  (I) = Second Dimension inputs, double precision
C  IER  (o) = Error flag.  =0 is good, =10 is bad.  See bispev for meaning.
C---------------------------------------------------------
      IMPLICIT NONE
      REAL*8 XX1(1),YY1(1)
      INTEGER IER
      REAL*8 X1(1),Y1(1),Z1(1)
C
C Stuff from the fit
C
+CDE,DA2DEX.
+CDE,SNPAR.
+CDE,CTRLCOM.
C
C Working arrays
C
      INTEGER IWRK(NMAX),LWRK1,KWRK,IX,IY,IN,I
C---------------------------------------------------------
C Get the right index
      IN = 0
      DO 50 I = 1,NND
        IF (IND.EQ.JND(I)) THEN
          IN = I
        ENDIF
  50  CONTINUE
      IF (IN.EQ.0) THEN
        print*,' '
        print*,' GE2DEX Warning: IND =',IND
        print*,' Unrecognized function index? '
        print*,' ***** ABORT ***** '
        CALL EXIT(EXIT_ERRCODE)
      ENDIF

C Evaluate the spline at XX1, YY1

      X1(1) = XX1(1)
      Y1(1) = YY1(1)
      LWRK1 = NCMAX
      KWRK = NMAX
      IX = 1
      IY = 1
      CALL BISPEV(TX(1,IN),NX(IN),TY(1,IN),NY(IN),C(1,IN),
     &  KX(IN),KY(IN),X1,IX,Y1,IY,Z1,WRK1(1,IN),LWRK1,IWRK,KWRK,IER)
      GE2DEX = Z1(1)
C
      RETURN
      END
C =============================
+DECK,UTILEX.
      subroutine surfit(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,
     *  nmax,eps,nx,tx,ny,ty,c,fp,wrk1,lwrk1,wrk2,lwrk2,iwrk,kwrk,ier)
c given the set of data points (x(i),y(i),z(i)) and the set of positive
c numbers w(i),i=1,...,m, subroutine surfit determines a smooth bivar-
c iate spline approximation s(x,y) of degrees kx and ky on the rect-
c angle xb <= x <= xe, yb <= y <= ye.
c if iopt = -1 surfit calculates the weighted least-squares spline
c according to a given set of knots.
c if iopt >= 0 the total numbers nx and ny of these knots and their
c position tx(j),j=1,...,nx and ty(j),j=1,...,ny are chosen automatic-
c ally by the routine. the smoothness of s(x,y) is then achieved by
c minimalizing the discontinuity jumps in the derivatives of s(x,y)
c across the boundaries of the subpanels (tx(i),tx(i+1))*(ty(j),ty(j+1).
c the amounth of smoothness is determined by the condition that f(p) =
c sum ((w(i)*(z(i)-s(x(i),y(i))))**2) be <= s, with s a given non-neg-
c ative constant, called the smoothing factor.
c the fit is given in the b-spline representation (b-spline coefficients
c c((ny-ky-1)*(i-1)+j),i=1,...,nx-kx-1;j=1,...,ny-ky-1) and can be eval-
c uated by means of subroutine bispev.
c
c calling sequence:
c     call surfit(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,
c    *  nmax,eps,nx,tx,ny,ty,c,fp,wrk1,lwrk1,wrk2,lwrk2,iwrk,kwrk,ier)
c
c parameters:
c  iopt  : integer flag. on entry iopt must specify whether a weighted
c          least-squares spline (iopt=-1) or a smoothing spline (iopt=0
c          or 1) must be determined.
c          if iopt=0 the routine will start with an initial set of knots
c          tx(i)=xb,tx(i+kx+1)=xe,i=1,...,kx+1;ty(i)=yb,ty(i+ky+1)=ye,i=
c          1,...,ky+1. if iopt=1 the routine will continue with the set
c          of knots found at the last call of the routine.
c          attention: a call with iopt=1 must always be immediately pre-
c                     ceded by another call with iopt=1 or iopt=0.
c          unchanged on exit.
c  m     : integer. on entry m must specify the number of data points.
c          m >= (kx+1)*(ky+1). unchanged on exit.
c  x     : real array of dimension at least (m).
c  y     : real array of dimension at least (m).
c  z     : real array of dimension at least (m).
c          before entry, x(i),y(i),z(i) must be set to the co-ordinates
c          of the i-th data point, for i=1,...,m. the order of the data
c          points is immaterial. unchanged on exit.
c  w     : real array of dimension at least (m). before entry, w(i) must
c          be set to the i-th value in the set of weights. the w(i) must
c          be strictly positive. unchanged on exit.
c  xb,xe : real values. on entry xb,xe,yb and ye must specify the bound-
c  yb,ye   aries of the rectangular approximation domain.
c          xb<=x(i)<=xe,yb<=y(i)<=ye,i=1,...,m. unchanged on exit.
c  kx,ky : integer values. on entry kx and ky must specify the degrees
c          of the spline. 1<=kx,ky<=5. it is recommended to use bicubic
c          (kx=ky=3) splines. unchanged on exit.
c  s     : real. on entry (in case iopt>=0) s must specify the smoothing
c          factor. s >=0. unchanged on exit.
c          for advice on the choice of s see further comments
c  nxest : integer. unchanged on exit.
c  nyest : integer. unchanged on exit.
c          on entry, nxest and nyest must specify an upper bound for the
c          number of knots required in the x- and y-directions respect.
c          these numbers will also determine the storage space needed by
c          the routine. nxest >= 2*(kx+1), nyest >= 2*(ky+1).
c          in most practical situation nxest = kx+1+sqrt(m/2), nyest =
c          ky+1+sqrt(m/2) will be sufficient. see also further comments.
c  nmax  : integer. on entry nmax must specify the actual dimension of
c          the arrays tx and ty. nmax >= nxest, nmax >=nyest.
c          unchanged on exit.
c  eps   : real.
c          on entry, eps must specify a threshold for determining the
c          effective rank of an over-determined linear system of equat-
c          ions. 0 < eps < 1.  if the number of decimal digits in the
c          computer representation of a real number is q, then 10**(-q)
c          is a suitable value for eps in most practical applications.
c          unchanged on exit.
c  nx    : integer.
c          unless ier=10 (in case iopt >=0), nx will contain the total
c          number of knots with respect to the x-variable, of the spline
c          approximation returned. if the computation mode iopt=1 is
c          used, the value of nx should be left unchanged between sub-
c          sequent calls.
c          in case iopt=-1, the value of nx should be specified on entry
c  tx    : real array of dimension nmax.
c          on succesful exit, this array will contain the knots of the
c          spline with respect to the x-variable, i.e. the position of
c          the interior knots tx(kx+2),...,tx(nx-kx-1) as well as the
c          position of the additional knots tx(1)=...=tx(kx+1)=xb and
c          tx(nx-kx)=...=tx(nx)=xe needed for the b-spline representat.
c          if the computation mode iopt=1 is used, the values of tx(1),
c          ...,tx(nx) should be left unchanged between subsequent calls.
c          if the computation mode iopt=-1 is used, the values tx(kx+2),
c          ...tx(nx-kx-1) must be supplied by the user, before entry.
c          see also the restrictions (ier=10).
c  ny    : integer.
c          unless ier=10 (in case iopt >=0), ny will contain the total
c          number of knots with respect to the y-variable, of the spline
c          approximation returned. if the computation mode iopt=1 is
c          used, the value of ny should be left unchanged between sub-
c          sequent calls.
c          in case iopt=-1, the value of ny should be specified on entry
c  ty    : real array of dimension nmax.
c          on succesful exit, this array will contain the knots of the
c          spline with respect to the y-variable, i.e. the position of
c          the interior knots ty(ky+2),...,ty(ny-ky-1) as well as the
c          position of the additional knots ty(1)=...=ty(ky+1)=yb and
c          ty(ny-ky)=...=ty(ny)=ye needed for the b-spline representat.
c          if the computation mode iopt=1 is used, the values of ty(1),
c          ...,ty(ny) should be left unchanged between subsequent calls.
c          if the computation mode iopt=-1 is used, the values ty(ky+2),
c          ...ty(ny-ky-1) must be supplied by the user, before entry.
c          see also the restrictions (ier=10).
c  c     : real array of dimension at least (nxest-kx-1)*(nyest-ky-1).
c          on succesful exit, c contains the coefficients of the spline
c          approximation s(x,y)
c  fp    : real. unless ier=10, fp contains the weighted sum of
c          squared residuals of the spline approximation returned.
c  wrk1  : real array of dimension (lwrk1). used as workspace.
c          if the computation mode iopt=1 is used the value of wrk1(1)
c          should be left unchanged between subsequent calls.
c          on exit wrk1(2),wrk1(3),...,wrk1(1+(nx-kx-1)*(ny-ky-1)) will
c          contain the values d(i)/max(d(i)),i=1,...,(nx-kx-1)*(ny-ky-1)
c          with d(i) the i-th diagonal element of the reduced triangular
c          matrix for calculating the b-spline coefficients. it includes
c          those elements whose square is less than eps,which are treat-
c          ed as 0 in the case of presumed rank deficiency (ier<-2).
c  lwrk1 : integer. on entry lwrk1 must specify the actual dimension of
c          the array wrk1 as declared in the calling (sub)program.
c          lwrk1 must not be too small. let
c            u = nxest-kx-1, v = nyest-ky-1, km = max(kx,ky)+1,
c            ne = max(nxest,nyest), bx = kx*v+ky+1, by = ky*u+kx+1,
c            if(bx.le.by) b1 = bx, b2 = b1+v-ky
c            if(bx.gt.by) b1 = by, b2 = b1+u-kx  then
c          lwrk1 >= u*v*(2+b1+b2)+2*(u+v+km*(m+ne)+ne-kx-ky)+b2+1
c  wrk2  : real array of dimension (lwrk2). used as workspace, but
c          only in the case a rank deficient system is encountered.
c  lwrk2 : integer. on entry lwrk2 must specify the actual dimension of
c          the array wrk2 as declared in the calling (sub)program.
c          lwrk2 > 0 . a save upper boundfor lwrk2 = u*v*(b2+1)+b2
c          where u,v and b2 are as above. if there are enough data
c          points, scattered uniformly over the approximation domain
c          and if the smoothing factor s is not too small, there is a
c          good chance that this extra workspace is not needed. a lot
c          of memory might therefore be saved by setting lwrk2=1.
c          (see also ier > 10)
c  iwrk  : integer array of dimension (kwrk). used as workspace.
c  kwrk  : integer. on entry kwrk must specify the actual dimension of
c          the array iwrk as declared in the calling (sub)program.
c          kwrk >= m+(nxest-2*kx-1)*(nyest-2*ky-1).
c  ier   : integer. unless the routine detects an error, ier contains a
c          non-positive value on exit, i.e.
c   ier=0  : normal return. the spline returned has a residual sum of
c            squares fp such that abs(fp-s)/s <= tol with tol a relat-
c            ive tolerance set to 0.001 by the program.
c   ier=-1 : normal return. the spline returned is an interpolating
c            spline (fp=0).
c   ier=-2 : normal return. the spline returned is the weighted least-
c            squares polynomial of degrees kx and ky. in this extreme
c            case fp gives the upper bound for the smoothing factor s.
c   ier<-2 : warning. the coefficients of the spline returned have been
c            computed as the minimal norm least-squares solution of a
c            (numerically) rank deficient system. (-ier) gives the rank.
c            especially if the rank deficiency which can be computed as
c            (nx-kx-1)*(ny-ky-1)+ier, is large the results may be inac-
c            curate. they could also seriously depend on the value of
c            eps.
c   ier=1  : error. the required storage space exceeds the available
c            storage space, as specified by the parameters nxest and
c            nyest.
c            probably causes : nxest or nyest too small. if these param-
c            eters are already large, it may also indicate that s is
c            too small
c            the approximation returned is the weighted least-squares
c            spline according to the current set of knots.
c            the parameter fp gives the corresponding weighted sum of
c            squared residuals (fp>s).
c   ier=2  : error. a theoretically impossible result was found during
c            the iteration proces for finding a smoothing spline with
c            fp = s. probably causes : s too small or badly chosen eps.
c            there is an approximation returned but the corresponding
c            weighted sum of squared residuals does not satisfy the
c            condition abs(fp-s)/s < tol.
c   ier=3  : error. the maximal number of iterations maxit (set to 20
c            by the program) allowed for finding a smoothing spline
c            with fp=s has been reached. probably causes : s too small
c            there is an approximation returned but the corresponding
c            weighted sum of squared residuals does not satisfy the
c            condition abs(fp-s)/s < tol.
c   ier=4  : error. no more knots can be added because the number of
c            b-spline coefficients (nx-kx-1)*(ny-ky-1) already exceeds
c            the number of data points m.
c            probably causes : either s or m too small.
c            the approximation returned is the weighted least-squares
c            spline according to the current set of knots.
c            the parameter fp gives the corresponding weighted sum of
c            squared residuals (fp>s).
c   ier=5  : error. no more knots can be added because the additional
c            knot would (quasi) coincide with an old one.
c            probably causes : s too small or too large a weight to an
c            inaccurate data point.
c            the approximation returned is the weighted least-squares
c            spline according to the current set of knots.
c            the parameter fp gives the corresponding weighted sum of
c            squared residuals (fp>s).
c   ier=10 : error. on entry, the input data are controlled on validity
c            the following restrictions must be satisfied.
c            -1<=iopt<=1, 1<=kx,ky<=5, m>=(kx+1)*(ky+1), nxest>=2*kx+2,
c            nyest>=2*ky+2, 0<eps<1, nmax>=nxest, nmax>=nyest,
c            xb<=x(i)<=xe, yb<=y(i)<=ye, w(i)>0, i=1,...,m
c            lwrk1 >= u*v*(2+b1+b2)+2*(u+v+km*(m+ne)+ne-kx-ky)+b2+1
c            kwrk >= m+(nxest-2*kx-1)*(nyest-2*ky-1)
c            if iopt=-1: 2*kx+2<=nx<=nxest
c                        xb<tx(kx+2)<tx(kx+3)<...<tx(nx-kx-1)<xe
c                        2*ky+2<=ny<=nyest
c                        yb<ty(ky+2)<ty(ky+3)<...<ty(ny-ky-1)<ye
c            if iopt>=0: s>=0
c            if one of these conditions is found to be violated,control
c            is immediately repassed to the calling program. in that
c            case there is no approximation returned.
c   ier>10 : error. lwrk2 is too small, i.e. there is not enough work-
c            space for computing the minimal least-squares solution of
c            a rank deficient system of linear equations. ier gives the
c            requested value for lwrk2. there is no approximation re-
c            turned but, having saved the information contained in nx,
c            ny,tx,ty,wrk1, and having adjusted the value of lwrk2 and
c            the dimension of the array wrk2 accordingly, the user can
c            continue at the point the program was left, by calling
c            surfit with iopt=1.
c
c further comments:
c  by means of the parameter s, the user can control the tradeoff
c   between closeness of fit and smoothness of fit of the approximation.
c   if s is too large, the spline will be too smooth and signal will be
c   lost ; if s is too small the spline will pick up too much noise. in
c   the extreme cases the program will return an interpolating spline if
c   s=0 and the weighted least-squares polynomial (degrees kx,ky)if s is
c   very large. between these extremes, a properly chosen s will result
c   in a good compromise between closeness of fit and smoothness of fit.
c   to decide whether an approximation, corresponding to a certain s is
c   satisfactory the user is highly recommended to inspect the fits
c   graphically.
c   recommended values for s depend on the weights w(i). if these are
c   taken as 1/d(i) with d(i) an estimate of the standard deviation of
c   z(i), a good s-value should be found in the range (m-sqrt(2*m),m+
c   sqrt(2*m)). if nothing is known about the statistical error in z(i)
c   each w(i) can be set equal to one and s determined by trial and
c   error, taking account of the comments above. the best is then to
c   start with a very large value of s ( to determine the least-squares
c   polynomial and the corresponding upper bound fp0 for s) and then to
c   progressively decrease the value of s ( say by a factor 10 in the
c   beginning, i.e. s=fp0/10, fp0/100,...and more carefully as the
c   approximation shows more detail) to obtain closer fits.
c   to choose s very small is strongly discouraged. this considerably
c   increases computation time and memory requirements. it may also
c   cause rank-deficiency (ier<-2) and endager numerical stability.
c   to economize the search for a good s-value the program provides with
c   different modes of computation. at the first call of the routine, or
c   whenever he wants to restart with the initial set of knots the user
c   must set iopt=0.
c   if iopt=1 the program will continue with the set of knots found at
c   the last call of the routine. this will save a lot of computation
c   time if surfit is called repeatedly for different values of s.
c   the number of knots of the spline returned and their location will
c   depend on the value of s and on the complexity of the shape of the
c   function underlying the data. if the computation mode iopt=1
c   is used, the knots returned may also depend on the s-values at
c   previous calls (if these were smaller). therefore, if after a number
c   of trials with different s-values and iopt=1, the user can finally
c   accept a fit as satisfactory, it may be worthwhile for him to call
c   surfit once more with the selected value for s but now with iopt=0.
c   indeed, surfit may then return an approximation of the same quality
c   of fit but with fewer knots and therefore better if data reduction
c   is also an important objective for the user.
c   the number of knots may also depend on the upper bounds nxest and
c   nyest. indeed, if at a certain stage in surfit the number of knots
c   in one direction (say nx) has reached the value of its upper bound
c   (nxest), then from that moment on all subsequent knots are added
c   in the other (y) direction. this may indicate that the value of
c   nxest is too small. on the other hand, it gives the user the option
c   of limiting the number of knots the routine locates in any direction
c   for example, by setting nxest=2*kx+2 (the lowest allowable value for
c   nxest), the user can indicate that he wants an approximation which
c   is a simple polynomial of degree kx in the variable x.
c
c  other subroutines required:
c    fpback,fpbspl,fpsurf,fpdisc,fpgivs,fprank,fprati,fprota,fporde
c
c  references:
c   dierckx p. : an algorithm for surface fitting with spline functions
c                ima j. numer. anal. 1 (1981) 267-283.
c   dierckx p. : an algorithm for surface fitting with spline functions
c                report tw50, dept. computer science,k.u.leuven, 1980.
c   dierckx p. : curve and surface fitting with splines, monographs on
c                numerical analysis, oxford university press, 1993.
c
c  author:
c    p.dierckx
c    dept. computer science, k.u. leuven
c    celestijnenlaan 200a, b-3001 heverlee, belgium.
c    e-mail : Paul.Dierckx@cs.kuleuven.ac.be
c
c  creation date : may 1979
c  latest update : march 1987
c
c  ..

      IMPLICIT NONE

c  ..scalar arguments..
      real*8 xb,xe,yb,ye,s,eps,fp
      integer iopt,m,kx,ky,nxest,nyest,nmax,nx,ny,lwrk1,lwrk2,kwrk,ier
c  ..array arguments..
      real*8 x(m),y(m),z(m),w(m),tx(nmax),ty(nmax),
     * c((nxest-kx-1)*(nyest-ky-1)),wrk1(lwrk1),wrk2(lwrk2)
      integer iwrk(kwrk)
c  ..local scalars..
      real*8 tol
      integer i,ib1,ib3,jb1,ki,kmax,km1,km2,kn,kwest,kx1,ky1,la,lbx,
     * lby,lco,lf,lff,lfp,lh,lq,lsx,lsy,lwest,maxit,ncest,nest,nek,
     * nminx,nminy,nmx,nmy,nreg,nrint,nxk,nyk
c  ..function references..
      integer max0
c  ..subroutine references..
c    fpsurf
c  ..

c  we set up the parameters tol and maxit.
      maxit = 20
      tol = 0.1e-02
c  before starting computations a data check is made. if the input data
c  are invalid,control is immediately repassed to the calling program.
      ier = 10
      if(eps.le.0. .or. eps.ge.1.) go to 70
      if(kx.le.0 .or. kx.gt.5) go to 70
      kx1 = kx+1
      if(ky.le.0 .or. ky.gt.5) go to 70
      ky1 = ky+1
      kmax = max0(kx,ky)
      km1 = kmax+1
      km2 = km1+1
      if(iopt.lt.(-1) .or. iopt.gt.1) go to 70
      if(m.lt.(kx1*ky1)) go to 70
      nminx = 2*kx1
      if(nxest.lt.nminx .or. nxest.gt.nmax) go to 70
      nminy = 2*ky1
      if(nyest.lt.nminy .or. nyest.gt.nmax) go to 70
      nest = max0(nxest,nyest)
      nxk = nxest-kx1
      nyk = nyest-ky1
      ncest = nxk*nyk
      nmx = nxest-nminx+1
      nmy = nyest-nminy+1
      nrint = nmx+nmy
      nreg = nmx*nmy
      ib1 = kx*nyk+ky1
      jb1 = ky*nxk+kx1
      ib3 = kx1*nyk+1
      if(ib1.le.jb1) go to 10
      ib1 = jb1
      ib3 = ky1*nxk+1
  10  lwest = ncest*(2+ib1+ib3)+2*(nrint+nest*km2+m*km1)+ib3
      kwest = m+nreg
      if(lwrk1.lt.lwest .or. kwrk.lt.kwest) go to 70
      if(xb.ge.xe .or. yb.ge.ye) go to 70
      do 20 i=1,m
        if(w(i).le.0.) go to 70
        if(x(i).lt.xb .or. x(i).gt.xe) go to 70
        if(y(i).lt.yb .or. y(i).gt.ye) go to 70
  20  continue
      if(iopt.ge.0) go to 50
      if(nx.lt.nminx .or. nx.gt.nxest) go to 70
      nxk = nx-kx1
      tx(kx1) = xb
      tx(nxk+1) = xe
      do 30 i=kx1,nxk
        if(tx(i+1).le.tx(i)) go to 70
  30  continue
      if(ny.lt.nminy .or. ny.gt.nyest) go to 70
      nyk = ny-ky1
      ty(ky1) = yb
      ty(nyk+1) = ye
      do 40 i=ky1,nyk
        if(ty(i+1).le.ty(i)) go to 70
  40  continue
      go to 60
  50  if(s.lt.0.) go to 70
  60  ier = 0
c  we partition the working space and determine the spline approximation
      kn = 1
      ki = kn+m
      lq = 2
      la = lq+ncest*ib3
      lf = la+ncest*ib1
      lff = lf+ncest
      lfp = lff+ncest
      lco = lfp+nrint
      lh = lco+nrint
      lbx = lh+ib3
      nek = nest*km2
      lby = lbx+nek
      lsx = lby+nek
      lsy = lsx+m*km1
      call fpsurf(iopt,m,x,y,z,w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,
     * eps,tol,maxit,nest,km1,km2,ib1,ib3,ncest,nrint,nreg,nx,tx,
     * ny,ty,c,fp,wrk1(1),wrk1(lfp),wrk1(lco),wrk1(lf),wrk1(lff),
     * wrk1(la),wrk1(lq),wrk1(lbx),wrk1(lby),wrk1(lsx),wrk1(lsy),
     * wrk1(lh),iwrk(ki),iwrk(kn),wrk2,lwrk2,ier)
  70  return
      end

      subroutine fpback(a,z,n,k,c,nest)
      IMPLICIT NONE

c  subroutine fpback calculates the solution of the system of
c  equations a*c = z with a a n x n upper triangular matrix
c  of bandwidth k.
c  ..
c  ..scalar arguments..
      integer n,k,nest
c  ..array arguments..
      real*8 a(nest,k),z(n),c(n)
c  ..local scalars..
      real*8 store
      integer i,i1,j,k1,l,m
c  ..
      k1 = k-1
      c(n) = z(n)/a(n,1)
      i = n-1
      if(i.eq.0) go to 30
      do 20 j=2,n
        store = z(i)
        i1 = k1
        if(j.le.k1) i1 = j-1
        m = i
        do 10 l=1,i1
          m = m+1
          store = store-c(m)*a(i,l+1)
  10    continue
        c(i) = store/a(i,1)
        i = i-1
  20  continue
  30  return
      end

      subroutine fpbspl(t,n,k,x,l,h)
      IMPLICIT NONE
c  subroutine fpbspl evaluates the (k+1) non-zero b-splines of
c  degree k at t(l) <= x < t(l+1) using the stable recurrence
c  relation of de boor and cox.
c  ..
c  ..scalar arguments..
      real*8 x
      integer n,k,l
c  ..array arguments..
      real*8 t(n),h(6)
c  ..local scalars..
      real*8 f,one
      integer i,j,li,lj
c  ..local arrays..
      real*8 hh(5)
c  ..
      one = 0.1e+01
      h(1) = one
      do 20 j=1,k
        do 10 i=1,j
          hh(i) = h(i)
  10    continue
        h(1) = 0.
        do 20 i=1,j
          li = l+i
          lj = li-j
          f = hh(i)/(t(li)-t(lj))
          h(i) = h(i)+f*(t(li)-x)
          h(i+1) = f*(x-t(lj))
  20  continue
      return
      end

      subroutine fpsurf(iopt,m,x,y,z,w,xb,xe,yb,ye,kxx,kyy,s,nxest,
     * nyest,eta,tol,maxit,nmax,km1,km2,ib1,ib3,nc,intest,nrest,
     * nx0,tx,ny0,ty,c,fp,fp0,fpint,coord,f,ff,a,q,bx,by,spx,spy,h,
     * index,nummer,wrk,lwrk,ier)
      IMPLICIT NONE

c  ..
c  ..scalar arguments..
      real*8 xb,xe,yb,ye,s,eta,tol,fp,fp0
      integer iopt,m,kxx,kyy,nxest,nyest,maxit,nmax,km1,km2,ib1,ib3,
     * nc,intest,nrest,nx0,ny0,lwrk,ier
c  ..array arguments..
      real*8 x(m),y(m),z(m),w(m),tx(nmax),ty(nmax),c(nc),fpint(intest),
     * coord(intest),f(nc),ff(nc),a(nc,ib1),q(nc,ib3),bx(nmax,km2),
     * by(nmax,km2),spx(m,km1),spy(m,km1),h(ib3),wrk(lwrk)
      integer index(nrest),nummer(m)
c  ..local scalars..
      real*8 acc,arg,cos,dmax,fac1,fac2,fpmax,fpms,f1,f2,f3,hxi,p,pinv,
     * piv,p1,p2,p3,sigma,sin,sq,store,wi,x0,x1,y0,y1,zi,eps,
     * rn,one,con1,con9,con4,half,ten
      integer i,iband,iband1,iband3,iband4,ibb,ichang,ich1,ich3,ii,
     * in,irot,iter,i1,i2,i3,j,jrot,jxy,j1,kx,kx1,kx2,ky,ky1,ky2,l,
     * la,lf,lh,lwest,lx,ly,l1,l2,n,ncof,nk1x,nk1y,nminx,nminy,nreg,
     * nrint,num,num1,nx,nxe,nxx,ny,nye,nyy,n1,rank
c  ..local arrays..
      real*8 hx(6),hy(6)
cc      real*8 dif  ! for computed goto
c  ..function references..
      real*8 abs,fprati,sqrt
      integer min0
c  ..subroutine references..
c    fpback,fpbspl,fpgivs,fpdisc,fporde,fprank,fprota
c  ..
c  set constants
      one = 0.1e+01
      con1 = 0.1e0
      con9 = 0.9e0
      con4 = 0.4e-01
      half = 0.5e0
      ten = 0.1e+02
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c part 1: determination of the number of knots and their position.     c
c ****************************************************************     c
c given a set of knots we compute the least-squares spline sinf(x,y),  c
c and the corresponding weighted sum of squared residuals fp=f(p=inf). c
c if iopt=-1  sinf(x,y) is the requested approximation.                c
c if iopt=0 or iopt=1 we check whether we can accept the knots:        c
c   if fp <=s we will continue with the current set of knots.          c
c   if fp > s we will increase the number of knots and compute the     c
c      corresponding least-squares spline until finally  fp<=s.        c
c the initial choice of knots depends on the value of s and iopt.      c
c   if iopt=0 we first compute the least-squares polynomial of degree  c
c     kx in x and ky in y; nx=nminx=2*kx+2 and ny=nminy=2*ky+2.        c
c     fp0=f(0) denotes the corresponding weighted sum of squared       c
c     residuals                                                        c
c   if iopt=1 we start with the knots found at the last call of the    c
c     routine, except for the case that s>=fp0; then we can compute    c
c     the least-squares polynomial directly.                           c
c eventually the independent variables x and y (and the corresponding  c
c parameters) will be switched if this can reduce the bandwidth of the c
c system to be solved.                                                 c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  ichang denotes whether(1) or not(-1) the directions have been inter-
c  changed.
      ichang = -1
      x0 = xb
      x1 = xe
      y0 = yb
      y1 = ye
      kx = kxx
      ky = kyy
      kx1 = kx+1
      ky1 = ky+1
      nxe = nxest
      nye = nyest
      eps = sqrt(eta)
      if(iopt.lt.0) go to 20
c  calculation of acc, the absolute tolerance for the root of f(p)=s.
      acc = tol*s
      if(iopt.eq.0) go to 10
      if(fp0.gt.s) go to 20
c  initialization for the least-squares polynomial.
  10  nminx = 2*kx1
      nminy = 2*ky1
      nx = nminx
      ny = nminy
      ier = -2
      go to 30
  20  nx = nx0
      ny = ny0
c  main loop for the different sets of knots. m is a save upper bound
c  for the number of trials.
  30  do 420 iter=1,m
c  find the position of the additional knots which are needed for the
c  b-spline representation of s(x,y).
        l = nx
        do 40 i=1,kx1
          tx(i) = x0
          tx(l) = x1
          l = l-1
  40    continue
        l = ny
        do 50 i=1,ky1
          ty(i) = y0
          ty(l) = y1
          l = l-1
  50    continue
c  find nrint, the total number of knot intervals and nreg, the number
c  of panels in which the approximation domain is subdivided by the
c  intersection of knots.
        nxx = nx-2*kx1+1
        nyy = ny-2*ky1+1
        nrint = nxx+nyy
        nreg = nxx*nyy
c  find the bandwidth of the observation matrix a.
c  if necessary, interchange the variables x and y, in order to obtain
c  a minimal bandwidth.
        iband1 = kx*(ny-ky1)+ky
        l = ky*(nx-kx1)+kx
        if(iband1.le.l) go to 130
        iband1 = l
        ichang = -ichang
        do 60 i=1,m
          store = x(i)
          x(i) = y(i)
          y(i) = store
  60    continue
        store = x0
        x0 = y0
        y0 = store
        store = x1
        x1 = y1
        y1 = store
        n = min0(nx,ny)
        do 70 i=1,n
          store = tx(i)
          tx(i) = ty(i)
          ty(i) = store
  70    continue
        n1 = n+1

ccc        if(nx-ny) 80,120,100  ! obsolete
        if( (nx-ny) .LT. 0 ) goto  80
        if( (nx-ny) .EQ. 0 ) goto 120
        if( (nx-ny) .GT. 0 ) goto 100

  80    do 90 i=n1,ny
          tx(i) = ty(i)
  90    continue
        go to 120
 100    do 110 i=n1,nx
          ty(i) = tx(i)
 110    continue
 120    l = nx
        nx = ny
        ny = l
        l = nxe
        nxe = nye
        nye = l
        l = nxx
        nxx = nyy
        nyy = l
        l = kx
        kx = ky
        ky = l
        kx1 = kx+1
        ky1 = ky+1
 130    iband = iband1+1
c  arrange the data points according to the panel they belong to.
        call fporde(x,y,m,kx,ky,tx,nx,ty,ny,nummer,index,nreg)
c  find ncof, the number of b-spline coefficients.
        nk1x = nx-kx1
        nk1y = ny-ky1
        ncof = nk1x*nk1y
c  initialize the observation matrix a.
        do 140 i=1,ncof
          f(i) = 0.
          do 140 j=1,iband
            a(i,j) = 0.
 140    continue
c  initialize the sum of squared residuals.
        fp = 0.
c  fetch the data points in the new order. main loop for the
c  different panels.
        do 250 num=1,nreg
c  fix certain constants for the current panel; jrot records the column
c  number of the first non-zero element in a row of the observation
c  matrix according to a data point of the panel.
          num1 = num-1
          lx = num1/nyy
          l1 = lx+kx1
          ly = num1-lx*nyy
          l2 = ly+ky1
          jrot = lx*nk1y+ly
c  test whether there are still data points in the panel.
          in = index(num)
 150      if(in.eq.0) go to 250
c  fetch a new data point.
          wi = w(in)
          zi = z(in)*wi
c  evaluate for the x-direction, the (kx+1) non-zero b-splines at x(in).
          call fpbspl(tx,nx,kx,x(in),l1,hx)
c  evaluate for the y-direction, the (ky+1) non-zero b-splines at y(in).
          call fpbspl(ty,ny,ky,y(in),l2,hy)
c  store the value of these b-splines in spx and spy respectively.
          do 160 i=1,kx1
            spx(in,i) = hx(i)
 160      continue
          do 170 i=1,ky1
            spy(in,i) = hy(i)
 170      continue
c  initialize the new row of observation matrix.
          do 180 i=1,iband
            h(i) = 0.
 180      continue
c  calculate the non-zero elements of the new row by making the cross
c  products of the non-zero b-splines in x- and y-direction.
          i1 = 0
          do 200 i=1,kx1
            hxi = hx(i)
            j1 = i1
            do 190 j=1,ky1
              j1 = j1+1
              h(j1) = hxi*hy(j)*wi
 190        continue
            i1 = i1+nk1y
 200      continue
c  rotate the row into triangle by givens transformations .
          irot = jrot
          do 220 i=1,iband
            irot = irot+1
            piv = h(i)
            if(piv.eq.0.) go to 220
c  calculate the parameters of the givens transformation.
            call fpgivs(piv,a(irot,1),cos,sin)
c  apply that transformation to the right hand side.
            call fprota(cos,sin,zi,f(irot))
            if(i.eq.iband) go to 230
c  apply that transformation to the left hand side.
            i2 = 1
            i3 = i+1
            do 210 j=i3,iband
              i2 = i2+1
              call fprota(cos,sin,h(j),a(irot,i2))
 210        continue
 220      continue
c  add the contribution of the row to the sum of squares of residual
c  right hand sides.
 230      fp = fp+zi**2
c  find the number of the next data point in the panel.
 240      in = nummer(in)
          go to 150
 250    continue
c  find dmax, the maximum value for the diagonal elements in the reduced
c  triangle.
        dmax = 0.
        do 260 i=1,ncof
          if(a(i,1).le.dmax) go to 260
          dmax = a(i,1)
 260    continue
c  check whether the observation matrix is rank deficient.
        sigma = eps*dmax
        do 270 i=1,ncof
          if(a(i,1).le.sigma) go to 280
 270    continue
c  backward substitution in case of full rank.
        call fpback(a,f,ncof,iband,c,nc)
        rank = ncof
        do 275 i=1,ncof
          q(i,1) = a(i,1)/dmax
 275    continue
        go to 300
c  in case of rank deficiency, find the minimum norm solution.
c  check whether there is sufficient working space
 280    lwest = ncof*iband+ncof+iband
        if(lwrk.lt.lwest) go to 780
        do 290 i=1,ncof
          ff(i) = f(i)
          do 290 j=1,iband
            q(i,j) = a(i,j)
 290    continue
        lf =1
        lh = lf+ncof
        la = lh+iband
        call fprank(q,ff,ncof,iband,nc,sigma,c,sq,rank,wrk(la),
     *    wrk(lf),wrk(lh))
        do 295 i=1,ncof
          q(i,1) = q(i,1)/dmax
 295    continue
c  add to the sum of squared residuals, the contribution of reducing
c  the rank.
        fp = fp+sq
 300    if(ier.eq.(-2)) fp0 = fp
c  test whether the least-squares spline is an acceptable solution.
        if(iopt.lt.0) go to 820
        fpms = fp-s
        if(abs(fpms).le.acc) then
ccc           if(fp) 815,815,820  ! obsolete
           if ( fp .LT. 0 ) GOTO 815
           if ( fp .EQ. 0 ) GOTO 815
           if ( fp .GT. 0 ) GOTO 820
        endif
c  test whether we can accept the choice of knots.
        if(fpms.lt.0.) go to 430
c  test whether we cannot further increase the number of knots.
        if(ncof.gt.m) go to 790
        ier = 0
c  search where to add a new knot.
c  find for each interval the sum of squared residuals fpint for the
c  data points having the coordinate belonging to that knot interval.
c  calculate also coord which is the same sum, weighted by the position
c  of the data points considered.
 310    do 320 i=1,nrint
          fpint(i) = 0.
          coord(i) = 0.
 320    continue
        do 360 num=1,nreg
          num1 = num-1
          lx = num1/nyy
          l1 = lx+1
          ly = num1-lx*nyy
          l2 = ly+1+nxx
          jrot = lx*nk1y+ly
          in = index(num)
 330      if(in.eq.0) go to 360
          store = 0.
          i1 = jrot
          do 350 i=1,kx1
            hxi = spx(in,i)
            j1 = i1
            do 340 j=1,ky1
              j1 = j1+1
              store = store+hxi*spy(in,j)*c(j1)
 340        continue
            i1 = i1+nk1y
 350      continue
          store = (w(in)*(z(in)-store))**2
          fpint(l1) = fpint(l1)+store
          coord(l1) = coord(l1)+store*x(in)
          fpint(l2) = fpint(l2)+store
          coord(l2) = coord(l2)+store*y(in)
          in = nummer(in)
          go to 330
 360    continue
c  find the interval for which fpint is maximal on the condition that
c  there still can be added a knot.
 370    l = 0
        fpmax = 0.
        l1 = 1
        l2 = nrint
        if(nx.eq.nxe) l1 = nxx+1
        if(ny.eq.nye) l2 = nxx
        if(l1.gt.l2) go to 810
        do 380 i=l1,l2
          if(fpmax.ge.fpint(i)) go to 380
          l = i
          fpmax = fpint(i)
 380    continue
c  test whether we cannot further increase the number of knots.
        if(l.eq.0) go to 785
c  calculate the position of the new knot.
        arg = coord(l)/fpint(l)
c  test in what direction the new knot is going to be added.
        if(l.gt.nxx) go to 400
c  addition in the x-direction.
        jxy = l+kx1
        fpint(l) = 0.
        fac1 = tx(jxy)-arg
        fac2 = arg-tx(jxy-1)
        if(fac1.gt.(ten*fac2) .or. fac2.gt.(ten*fac1)) go to 370
        j = nx
        do 390 i=jxy,nx
          tx(j+1) = tx(j)
          j = j-1
 390    continue
        tx(jxy) = arg
        nx = nx+1
        go to 420
c  addition in the y-direction.
 400    jxy = l+ky1-nxx
        fpint(l) = 0.
        fac1 = ty(jxy)-arg
        fac2 = arg-ty(jxy-1)
        if(fac1.gt.(ten*fac2) .or. fac2.gt.(ten*fac1)) go to 370
        j = ny
        do 410 i=jxy,ny
          ty(j+1) = ty(j)
          j = j-1
 410    continue
        ty(jxy) = arg
        ny = ny+1
c  restart the computations with the new set of knots.
 420  continue
c  test whether the least-squares polynomial is a solution of our
c  approximation problem.
 430  if(ier.eq.(-2)) go to 830
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c part 2: determination of the smoothing spline sp(x,y)                c
c *****************************************************                c
c we have determined the number of knots and their position. we now    c
c compute the b-spline coefficients of the smoothing spline sp(x,y).   c
c the observation matrix a is extended by the rows of a matrix,        c
c expressing that sp(x,y) must be a polynomial of degree kx in x and   c
c ky in y. the corresponding weights of these additional rows are set  c
c to 1./p.  iteratively we than have to determine the value of p       c
c such that f(p)=sum((w(i)*(z(i)-sp(x(i),y(i))))**2) be = s.           c
c we already know that the least-squares polynomial corresponds to     c
c p=0  and that the least-squares spline corresponds to p=infinity.    c
c the iteration process which is proposed here makes use of rational   c
c interpolation. since f(p) is a convex and strictly decreasing        c
c function of p, it can be approximated by a rational function r(p)=   c
c (u*p+v)/(p+w). three values of p(p1,p2,p3) with corresponding values c
c of f(p) (f1=f(p1)-s,f2=f(p2)-s,f3=f(p3)-s) are used to calculate the c
c new value of p such that r(p)=s. convergence is guaranteed by taking c
c f1 > 0 and f3 < 0.                                                   c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      kx2 = kx1+1
c  test whether there are interior knots in the x-direction.
      if(nk1x.eq.kx1) go to 440
c  evaluate the discotinuity jumps of the kx-th order derivative of
c  the b-splines at the knots tx(l),l=kx+2,...,nx-kx-1.
      call fpdisc(tx,nx,kx2,bx,nmax)
 440  ky2 = ky1 + 1
c  test whether there are interior knots in the y-direction.
      if(nk1y.eq.ky1) go to 450
c  evaluate the discontinuity jumps of the ky-th order derivative of
c  the b-splines at the knots ty(l),l=ky+2,...,ny-ky-1.
      call fpdisc(ty,ny,ky2,by,nmax)
c  initial value for p.
 450  p1 = 0.
      f1 = fp0-s
      p3 = -one
      f3 = fpms
      p = 0.
      do 460 i=1,ncof
        p = p+a(i,1)
 460  continue
      rn = ncof
      p = rn/p
c  find the bandwidth of the extended observation matrix.
      iband3 = kx1*nk1y
      iband4 = iband3 +1
      ich1 = 0
      ich3 = 0
c  iteration process to find the root of f(p)=s.
      do 770 iter=1,maxit
        pinv = one/p
c  store the triangularized observation matrix into q.
        do 480 i=1,ncof
          ff(i) = f(i)
          do 470 j=1,iband
            q(i,j) = a(i,j)
 470      continue
          ibb = iband+1
          do 480 j=ibb,iband4
            q(i,j) = 0.
 480    continue
        if(nk1y.eq.ky1) go to 560
c  extend the observation matrix with the rows of a matrix, expressing
c  that for x=cst. sp(x,y) must be a polynomial in y of degree ky.
        do 550 i=ky2,nk1y
          ii = i-ky1
          do 550 j=1,nk1x
c  initialize the new row.
            do 490 l=1,iband
              h(l) = 0.
 490        continue
c  fill in the non-zero elements of the row. jrot records the column
c  number of the first non-zero element in the row.
            do 500 l=1,ky2
              h(l) = by(ii,l)*pinv
 500        continue
            zi = 0.
            jrot = (j-1)*nk1y+ii
c  rotate the new row into triangle by givens transformations without
c  square roots.
            do 540 irot=jrot,ncof
              piv = h(1)
              i2 = min0(iband1,ncof-irot)
              if(piv.eq.0.) then
ccc                 if(i2) 550,550,520 ! obsolete
                 if ( i2 .LT. 0 ) goto 550
                 if ( i2 .EQ. 0 ) goto 550
                 if ( i2 .GT. 0 ) goto 520
              endif
c  calculate the parameters of the givens transformation.
              call fpgivs(piv,q(irot,1),cos,sin)
c  apply that givens transformation to the right hand side.
              call fprota(cos,sin,zi,ff(irot))
              if(i2.eq.0) go to 550
c  apply that givens transformation to the left hand side.
              do 510 l=1,i2
                l1 = l+1
                call fprota(cos,sin,h(l1),q(irot,l1))
 510          continue
 520          do 530 l=1,i2
                h(l) = h(l+1)
 530          continue
              h(i2+1) = 0.
 540        continue
 550    continue
 560    if(nk1x.eq.kx1) go to 640
c  extend the observation matrix with the rows of a matrix expressing
c  that for y=cst. sp(x,y) must be a polynomial in x of degree kx.
        do 630 i=kx2,nk1x
          ii = i-kx1
          do 630 j=1,nk1y
c  initialize the new row
            do 570 l=1,iband4
              h(l) = 0.
 570        continue
c  fill in the non-zero elements of the row. jrot records the column
c  number of the first non-zero element in the row.
            j1 = 1
            do 580 l=1,kx2
              h(j1) = bx(ii,l)*pinv
              j1 = j1+nk1y
 580        continue
            zi = 0.
            jrot = (i-kx2)*nk1y+j
c  rotate the new row into triangle by givens transformations .
            do 620 irot=jrot,ncof
              piv = h(1)
              i2 = min0(iband3,ncof-irot)
              if(piv.eq.0.) then
cccc              if(i2) 630,630,600 ! obsolete
                if ( i2 .LT. 0 ) goto 630
                if ( i2 .EQ. 0 ) goto 630
                if ( i2 .GT. 0 ) goto 600
              endif
c  calculate the parameters of the givens transformation.
              call fpgivs(piv,q(irot,1),cos,sin)
c  apply that givens transformation to the right hand side.
              call fprota(cos,sin,zi,ff(irot))
              if(i2.eq.0) go to 630
c  apply that givens transformation to the left hand side.
              do 590 l=1,i2
                l1 = l+1
                call fprota(cos,sin,h(l1),q(irot,l1))
 590          continue
 600          do 610 l=1,i2
                h(l) = h(l+1)
 610          continue
              h(i2+1) = 0.
 620        continue
 630    continue
c  find dmax, the maximum value for the diagonal elements in the
c  reduced triangle.
 640    dmax = 0.
        do 650 i=1,ncof
          if(q(i,1).le.dmax) go to 650
          dmax = q(i,1)
 650    continue
c  check whether the matrix is rank deficient.
        sigma = eps*dmax
        do 660 i=1,ncof
          if(q(i,1).le.sigma) go to 670
 660    continue
c  backward substitution in case of full rank.
        call fpback(q,ff,ncof,iband4,c,nc)
        rank = ncof
        go to 675
c  in case of rank deficiency, find the minimum norm solution.
 670    lwest = ncof*iband4+ncof+iband4
        if(lwrk.lt.lwest) go to 780
        lf = 1
        lh = lf+ncof
        la = lh+iband4
        call fprank(q,ff,ncof,iband4,nc,sigma,c,sq,rank,wrk(la),
     *   wrk(lf),wrk(lh))
 675    do 680 i=1,ncof
          q(i,1) = q(i,1)/dmax
 680    continue
c  compute f(p).
        fp = 0.
        do 720 num = 1,nreg
          num1 = num-1
          lx = num1/nyy
          ly = num1-lx*nyy
          jrot = lx*nk1y+ly
          in = index(num)
 690      if(in.eq.0) go to 720
          store = 0.
          i1 = jrot
          do 710 i=1,kx1
            hxi = spx(in,i)
            j1 = i1
            do 700 j=1,ky1
              j1 = j1+1
              store = store+hxi*spy(in,j)*c(j1)
 700        continue
            i1 = i1+nk1y
 710      continue
          fp = fp+(w(in)*(z(in)-store))**2
          in = nummer(in)
          go to 690
 720    continue
c  test whether the approximation sp(x,y) is an acceptable solution.
        fpms = fp-s
        if(abs(fpms).le.acc) go to 820
c  test whether the maximum allowable number of iterations has been
c  reached.
        if(iter.eq.maxit) go to 795
c  carry out one more step of the iteration process.
        p2 = p
        f2 = fpms
        if(ich3.ne.0) go to 740
        if((f2-f3).gt.acc) go to 730
c  our initial choice of p is too large.
        p3 = p2
        f3 = f2
        p = p*con4
        if(p.le.p1) p = p1*con9 + p2*con1
        go to 770
 730    if(f2.lt.0.) ich3 = 1
 740    if(ich1.ne.0) go to 760
        if((f1-f2).gt.acc) go to 750
c  our initial choice of p is too small
        p1 = p2
        f1 = f2
        p = p/con4
        if(p3.lt.0.) go to 770
        if(p.ge.p3) p = p2*con1 + p3*con9
        go to 770
 750    if(f2.gt.0.) ich1 = 1
c  test whether the iteration process proceeds as theoretically
c  expected.
 760    if(f2.ge.f1 .or. f2.le.f3) go to 800
c  find the new value of p.
        p = fprati(p1,f1,p2,f2,p3,f3)
 770  continue
c  error codes and messages.
 780  ier = lwest
      go to 830
 785  ier = 5
      go to 830
 790  ier = 4
      go to 830
 795  ier = 3
      go to 830
 800  ier = 2
      go to 830
 810  ier = 1
      go to 830
 815  ier = -1
      fp = 0.
 820  if(ncof.ne.rank) ier = -rank
c  test whether x and y are in the original order.
 830  if(ichang.lt.0) go to 930
c  if not, interchange x and y once more.
      l1 = 1
      do 840 i=1,nk1x
        l2 = i
        do 840 j=1,nk1y
          f(l2) = c(l1)
          l1 = l1+1
          l2 = l2+nk1x
 840  continue
      do 850 i=1,ncof
        c(i) = f(i)
 850  continue
      do 860 i=1,m
        store = x(i)
        x(i) = y(i)
        y(i) = store
 860  continue
      n = min0(nx,ny)
      do 870 i=1,n
        store = tx(i)
        tx(i) = ty(i)
        ty(i) = store
 870  continue
      n1 = n+1
ccc      if(nx-ny) 880,920,900  ! obsolete
      if( (nx-ny) .LT. 0 ) GOTO 880
      if( (nx-ny) .EQ. 0 ) GOTO 920
      if( (nx-ny) .GT. 0 ) GOTO 900

 880  do 890 i=n1,ny
        tx(i) = ty(i)
 890  continue
      go to 920
 900  do 910 i=n1,nx
        ty(i) = tx(i)
 910  continue
 920  l = nx
      nx = ny
      ny = l
 930  if(iopt.lt.0) go to 940
      nx0 = nx
      ny0 = ny
 940  return
      end

      subroutine fpdisc(t,n,k2,b,nest)
      IMPLICIT NONE
c  subroutine fpdisc calculates the discontinuity jumps of the kth
c  derivative of the b-splines of degree k at the knots t(k+2)..t(n-k-1)
c  ..scalar arguments..
      integer n,k2,nest
c  ..array arguments..
      real*8 t(n),b(nest,k2)
c  ..local scalars..
      real*8 an,fac,prod
      integer i,ik,j,jk,k,k1,l,lj,lk,lmk,lp,nk1,nrint
c  ..local array..
      real*8 h(12)
c  ..
      k1 = k2-1
      k = k1-1
      nk1 = n-k1
      nrint = nk1-k
      an = nrint
      fac = an/(t(nk1+1)-t(k1))
      do 40 l=k2,nk1
        lmk = l-k1
        do 10 j=1,k1
          ik = j+k1
          lj = l+j
          lk = lj-k2
          h(j) = t(l)-t(lk)
          h(ik) = t(l)-t(lj)
  10    continue
        lp = lmk
        do 30 j=1,k2
          jk = j
          prod = h(j)
          do 20 i=1,k
            jk = jk+1
            prod = prod*h(jk)*fac
  20      continue
          lk = lp+k1
          b(lmk,j) = (t(lk)-t(lp))/prod
          lp = lp+1
  30    continue
  40  continue
      return
      end

      subroutine fpgivs(piv,ww,cos,sin)
      IMPLICIT NONE
c  subroutine fpgivs calculates the parameters of a givens
c  transformation .
c  ..
c  ..scalar arguments..
      real*8 piv,ww,cos,sin
c  ..local scalars..
      real*8 dd,one,store
c  ..function references..
      real*8 abs,sqrt
c  ..
      one = 0.1e+01
      store = abs(piv)
      if(store.ge.ww) dd = store*sqrt(one+(ww/piv)**2)
      if(store.lt.ww) dd = ww*sqrt(one+(piv/ww)**2)
      cos = ww/dd
      sin = piv/dd
      ww = dd
      return
      end

      subroutine fprank(a,f,n,m,na,tol,c,sq,rank,aa,ff,h)
      IMPLICIT NONE
c  subroutine fprank finds the minimum norm solution of a least-
c  squares problem in case of rank deficiency.
c
c  input parameters:
c    a : array, which contains the non-zero elements of the observation
c        matrix after triangularization by givens transformations.
c    f : array, which contains the transformed right hand side.
c    n : integer,wich contains the dimension of a.
c    m : integer, which denotes the bandwidth of a.
c  tol : real value, giving a threshold to determine the rank of a.
c
c  output parameters:
c    c : array, which contains the minimum norm solution.
c   sq : real value, giving the contribution of reducing the rank
c        to the sum of squared residuals.
c rank : integer, which contains the rank of matrix a.
c
c  ..scalar arguments..
      integer n,m,na,rank
      real*8 tol,sq
c  ..array arguments..
      real*8 a(na,m),f(n),c(n),aa(n,m),ff(n),h(m)
c  ..local scalars..
      integer i,ii,ij,i1,i2,j,jj,j1,j2,j3,k,kk,m1,nl
      real*8 cos,fac,piv,sin,yi
      double precision store,stor1,stor2,stor3
c  ..function references..
      integer min0
c  ..subroutine references..
c    fpgivs,fprota
c  ..
      m1 = m-1
c  the rank deficiency nl is considered to be the number of sufficient
c  small diagonal elements of a.
      nl = 0
      sq = 0.
      do 90 i=1,n
        if(a(i,1).gt.tol) go to 90
c  if a sufficient small diagonal element is found, we put it to
c  zero. the remainder of the row corresponding to that zero diagonal
c  element is then rotated into triangle by givens rotations .
c  the rank deficiency is increased by one.
        nl = nl+1
        if(i.eq.n) go to 90
        yi = f(i)
        do 10 j=1,m1
          h(j) = a(i,j+1)
  10    continue
        h(m) = 0.
        i1 = i+1
        do 60 ii=i1,n
          i2 = min0(n-ii,m1)
          piv = h(1)
          if(piv.eq.0.) go to 30
          call fpgivs(piv,a(ii,1),cos,sin)
          call fprota(cos,sin,yi,f(ii))
          if(i2.eq.0) go to 70
          do 20 j=1,i2
            j1 = j+1
            call fprota(cos,sin,h(j1),a(ii,j1))
            h(j) = h(j1)
  20      continue
          go to 50
  30      if(i2.eq.0) go to 70
          do 40 j=1,i2
            h(j) = h(j+1)
  40      continue
  50      h(i2+1) = 0.
  60    continue
c  add to the sum of squared residuals the contribution of deleting
c  the row with small diagonal element.
  70    sq = sq+yi**2
  90  continue
c  rank denotes the rank of a.
      rank = n-nl
c  let b denote the (rank*n) upper trapezoidal matrix which can be
c  obtained from the (n*n) upper triangular matrix a by deleting
c  the rows and interchanging the columns corresponding to a zero
c  diagonal element. if this matrix is factorized using givens
c  transformations as  b = (r) (u)  where
c    r is a (rank*rank) upper triangular matrix,
c    u is a (rank*n) orthonormal matrix
c  then the minimal least-squares solution c is given by c = b' v,
c  where v is the solution of the system  (r) (r)' v = g  and
c  g denotes the vector obtained from the old right hand side f, by
c  removing the elements corresponding to a zero diagonal element of a.
c  initialization.
      do 100 i=1,rank
        do 100 j=1,m
          aa(i,j) = 0.
 100  continue
c  form in aa the upper triangular matrix obtained from a by
c  removing rows and columns with zero diagonal elements. form in ff
c  the new right hand side by removing the elements of the old right
c  hand side corresponding to a deleted row.
      ii = 0
      do 120 i=1,n
        if(a(i,1).le.tol) go to 120
        ii = ii+1
        ff(ii) = f(i)
        aa(ii,1) = a(i,1)
        jj = ii
        kk = 1
        j = i
        j1 = min0(j-1,m1)
        if(j1.eq.0) go to 120
        do 110 k=1,j1
          j = j-1
          if(a(j,1).le.tol) go to 110
          kk = kk+1
          jj = jj-1
          aa(jj,kk) = a(j,k+1)
 110    continue
 120  continue
c  form successively in h the columns of a with a zero diagonal element.
      ii = 0
      do 200 i=1,n
        ii = ii+1
        if(a(i,1).gt.tol) go to 200
        ii = ii-1
        if(ii.eq.0) go to 200
        jj = 1
        j = i
        j1 = min0(j-1,m1)
        do 130 k=1,j1
          j = j-1
          if(a(j,1).le.tol) go to 130
          h(jj) = a(j,k+1)
          jj = jj+1
 130    continue
        do 140 kk=jj,m
          h(kk) = 0.
 140    continue
c  rotate this column into aa by givens transformations.
        jj = ii
        do 190 i1=1,ii
          j1 = min0(jj-1,m1)
          piv = h(1)
          if(piv.ne.0.) go to 160
          if(j1.eq.0) go to 200
          do 150 j2=1,j1
            j3 = j2+1
            h(j2) = h(j3)
 150      continue
          go to 180
 160      call fpgivs(piv,aa(jj,1),cos,sin)
          if(j1.eq.0) go to 200
          kk = jj
          do 170 j2=1,j1
            j3 = j2+1
            kk = kk-1
            call fprota(cos,sin,h(j3),aa(kk,j3))
            h(j2) = h(j3)
 170      continue
 180      jj = jj-1
          h(j3) = 0.
 190    continue
 200  continue
c  solve the system (aa) (f1) = ff
      ff(rank) = ff(rank)/aa(rank,1)
      i = rank-1
      if(i.eq.0) go to 230
      do 220 j=2,rank
        store = ff(i)
        i1 = min0(j-1,m1)
        k = i
        do 210 ii=1,i1
          k = k+1
          stor1 = ff(k)
          stor2 = aa(i,ii+1)
          store = store-stor1*stor2
 210    continue
        stor1 = aa(i,1)
        ff(i) = store/stor1
        i = i-1
 220  continue
c  solve the system  (aa)' (f2) = f1
 230  ff(1) = ff(1)/aa(1,1)
      if(rank.eq.1) go to 260
      do 250 j=2,rank
        store = ff(j)
        i1 = min0(j-1,m1)
        k = j
        do 240 ii=1,i1
          k = k-1
          stor1 = ff(k)
          stor2 = aa(k,ii+1)
          store = store-stor1*stor2
 240    continue
        stor1 = aa(j,1)
        ff(j) = store/stor1
 250  continue
c  premultiply f2 by the transpoze of a.
 260  k = 0
      do 280 i=1,n
        store = 0.
        if(a(i,1).gt.tol) k = k+1
        j1 = min0(i,m)
        kk = k
        ij = i+1
        do 270 j=1,j1
          ij = ij-1
          if(a(ij,1).le.tol) go to 270
          stor1 = a(ij,j)
          stor2 = ff(kk)
          store = store+stor1*stor2
          kk = kk-1
 270    continue
        c(i) = store
 280  continue
c  add to the sum of squared residuals the contribution of putting
c  to zero the small diagonal elements of matrix (a).
      stor3 = 0.
      do 310 i=1,n
        if(a(i,1).gt.tol) go to 310
        store = f(i)
        i1 = min0(n-i,m1)
        if(i1.eq.0) go to 300
        do 290 j=1,i1
          ij = i+j
          stor1 = c(ij)
          stor2 = a(i,j+1)
          store = store-stor1*stor2
 290    continue
 300    fac = a(i,1)*c(i)
        stor1 = a(i,1)
        stor2 = c(i)
        stor1 = stor1*stor2
        stor3 = stor3+stor1*(stor1-store-store)
 310  continue
      fac = stor3
      sq = sq+fac
      return
      end

      real*8 function fprati(p1,f1,p2,f2,p3,f3)
c  given three points (p1,f1),(p2,f2) and (p3,f3), function fprati
c  gives the value of p such that the rational interpolating function
c  of the form r(p) = (u*p+v)/(p+w) equals zero at p.
c  ..
c  ..scalar arguments..
      real*8 p1,f1,p2,f2,p3,f3
c  ..local scalars..
      real*8 h1,h2,h3,p
c  ..
      if(p3.gt.0.) go to 10
c  value of p in case p3 = infinity.
      p = (p1*(f1-f3)*f2-p2*(f2-f3)*f1)/((f1-f2)*f3)
      go to 20
c  value of p in case p3 ^= infinity.
  10  h1 = f1*(f2-f3)
      h2 = f2*(f3-f1)
      h3 = f3*(f1-f2)
      p = -(p1*p2*h3+p2*p3*h1+p3*p1*h2)/(p1*h1+p2*h2+p3*h3)
c  adjust the value of p1,f1,p3 and f3 such that f1 > 0 and f3 < 0.
  20  if(f2.lt.0.) go to 30
      p1 = p2
      f1 = f2
      go to 40
  30  p3 = p2
      f3 = f2
  40  fprati = p
      return
      end

      subroutine fprota(cos,sin,a,b)
      IMPLICIT NONE
c  subroutine fprota applies a givens rotation to a and b.
c  ..
c  ..scalar arguments..
      real*8 cos,sin,a,b
c ..local scalars..
      real*8 stor1,stor2
c  ..
      stor1 = a
      stor2 = b
      b = cos*stor2+sin*stor1
      a = cos*stor1-sin*stor2
      return
      end

      subroutine fporde(x,y,m,kx,ky,tx,nx,ty,ny,nummer,index,nreg)
      IMPLICIT NONE
c  subroutine fporde sorts the data points (x(i),y(i)),i=1,2,...,m
c  according to the panel tx(l)<=x<tx(l+1),ty(k)<=y<ty(k+1), they belong
c  to. for each panel a stack is constructed  containing the numbers
c  of data points lying inside; index(j),j=1,2,...,nreg points to the
c  first data point in the jth panel while nummer(i),i=1,2,...,m gives
c  the number of the next data point in the panel.
c  ..
c  ..scalar arguments..
      integer m,kx,ky,nx,ny,nreg
c  ..array arguments..
      real*8 x(m),y(m),tx(nx),ty(ny)
      integer nummer(m),index(nreg)
c  ..local scalars..
      real*8 xi,yi
      integer i,im,k,kx1,ky1,k1,l,l1,nk1x,nk1y,num,nyy
c  ..
      kx1 = kx+1
      ky1 = ky+1
      nk1x = nx-kx1
      nk1y = ny-ky1
      nyy = nk1y-ky
      do 10 i=1,nreg
        index(i) = 0
  10  continue
      do 60 im=1,m
        xi = x(im)
        yi = y(im)
        l = kx1
        l1 = l+1
  20    if(xi.lt.tx(l1) .or. l.eq.nk1x) go to 30
        l = l1
        l1 = l+1
        go to 20
  30    k = ky1
        k1 = k+1
  40    if(yi.lt.ty(k1) .or. k.eq.nk1y) go to 50
        k = k1
        k1 = k+1
        go to 40
  50    num = (l-kx1)*nyy+k-ky
        nummer(im) = index(num)
        index(num) = im
  60  continue
      return
      end

      subroutine bispev(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wrk,lwrk,
     * iwrk,kwrk,ier)
      IMPLICIT NONE
c  subroutine bispev evaluates on a grid (x(i),y(j)),i=1,...,mx; j=1,...
c  ,my a bivariate spline s(x,y) of degrees kx and ky, given in the
c  b-spline representation.
c
c  calling sequence:
c     call bispev(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wrk,lwrk,
c    * iwrk,kwrk,ier)
c
c  input parameters:
c   tx    : real array, length nx, which contains the position of the
c           knots in the x-direction.
c   nx    : integer, giving the total number of knots in the x-direction
c   ty    : real array, length ny, which contains the position of the
c           knots in the y-direction.
c   ny    : integer, giving the total number of knots in the y-direction
c   c     : real array, length (nx-kx-1)*(ny-ky-1), which contains the
c           b-spline coefficients.
c   kx,ky : integer values, giving the degrees of the spline.
c   x     : real array of dimension (mx).
c           before entry x(i) must be set to the x co-ordinate of the
c           i-th grid point along the x-axis.
c           tx(kx+1)<=x(i-1)<=x(i)<=tx(nx-kx), i=2,...,mx.
c   mx    : on entry mx must specify the number of grid points along
c           the x-axis. mx >=1.
c   y     : real array of dimension (my).
c           before entry y(j) must be set to the y co-ordinate of the
c           j-th grid point along the y-axis.
c           ty(ky+1)<=y(j-1)<=y(j)<=ty(ny-ky), j=2,...,my.
c   my    : on entry my must specify the number of grid points along
c           the y-axis. my >=1.
c   wrk   : real array of dimension lwrk. used as workspace.
c   lwrk  : integer, specifying the dimension of wrk.
c           lwrk >= mx*(kx+1)+my*(ky+1)
c   iwrk  : integer array of dimension kwrk. used as workspace.
c   kwrk  : integer, specifying the dimension of iwrk. kwrk >= mx+my.
c
c  output parameters:
c   z     : real array of dimension (mx*my).
c           on succesful exit z(my*(i-1)+j) contains the value of s(x,y)
c           at the point (x(i),y(j)),i=1,...,mx;j=1,...,my.
c   ier   : integer error flag
c    ier=0 : normal return
c    ier=10: invalid input data (see restrictions)
c
c  restrictions:
c   mx >=1, my >=1, lwrk>=mx*(kx+1)+my*(ky+1), kwrk>=mx+my
c   tx(kx+1) <= x(i-1) <= x(i) <= tx(nx-kx), i=2,...,mx
c   ty(ky+1) <= y(j-1) <= y(j) <= ty(ny-ky), j=2,...,my
c
c  other subroutines required:
c    fpbisp,fpbspl
c
c  references :
c    de boor c : on calculating with b-splines, j. approximation theory
c                6 (1972) 50-62.
c    cox m.g.  : the numerical evaluation of b-splines, j. inst. maths
c                applics 10 (1972) 134-149.
c    dierckx p. : curve and surface fitting with splines, monographs on
c                 numerical analysis, oxford university press, 1993.
c
c  author :
c    p.dierckx
c    dept. computer science, k.u.leuven
c    celestijnenlaan 200a, b-3001 heverlee, belgium.
c    e-mail : Paul.Dierckx@cs.kuleuven.ac.be
c
c  latest update : march 1987
c
c  ..scalar arguments..
      integer nx,ny,kx,ky,mx,my,lwrk,kwrk,ier
c  ..array arguments..
      integer iwrk(kwrk)
      real*8 tx(nx),ty(ny),c((nx-kx-1)*(ny-ky-1)),x(mx),y(my),z(mx*my),
     * wrk(lwrk)
c  ..local scalars..
      integer i,iw,lwest
c  ..
c  before starting computations a data check is made. if the input data
c  are invalid control is immediately repassed to the calling program.
      ier = 10
      lwest = (kx+1)*mx+(ky+1)*my
      if(lwrk.lt.lwest) go to 100
      if(kwrk.lt.(mx+my)) go to 100
ccc      if(mx-1) 100,30,10  ! obsolete
      if ( (mx-1) .LT. 0 ) GOTO  100
      if ( (mx-1) .EQ. 0 ) GOTO  30
      if ( (mx-1) .GT. 0 ) GOTO  10

  10  do 20 i=2,mx
        if(x(i).lt.x(i-1)) go to 100
  20  continue

  30  continue  
ccc if(my-1) 100,60,40  ! obsolete
      if ( (my-1) .LT. 0 ) goto 100
      if ( (my-1) .EQ. 0 ) goto 60
      if ( (my-1) .GT. 0 ) goto 40


  40  do 50 i=2,my
        if(y(i).lt.y(i-1)) go to 100
  50  continue
  60  ier = 0
      iw = mx*(kx+1)+1
      call fpbisp(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wrk(1),wrk(iw),
     * iwrk(1),iwrk(mx+1))
 100  return
      end

      subroutine fpbisp(tx,nx,ty,ny,c,kx,ky,x,mx,y,my,z,wx,wy,lx,ly)
      IMPLICIT NONE
c  ..scalar arguments..
      integer nx,ny,kx,ky,mx,my
c  ..array arguments..
      integer lx(mx),ly(my)
      real*8 tx(nx),ty(ny),c((nx-kx-1)*(ny-ky-1)),x(mx),y(my),z(mx*my),
     * wx(mx,kx+1),wy(my,ky+1)
c  ..local scalars..
      integer kx1,ky1,l,l1,l2,m,nkx1,nky1,i,j,i1,j1
      real*8 arg,sp,tb,te
c  ..local arrays..
      real*8 h(6)
c  ..subroutine references..
c    fpbspl
c  ..
      kx1 = kx+1
      nkx1 = nx-kx1
      tb = tx(kx1)
      te = tx(nkx1+1)
      l = kx1
      l1 = l+1
      do 40 i=1,mx
        arg = x(i)
        if(arg.lt.tb) arg = tb
        if(arg.gt.te) arg = te
  10    if(arg.lt.tx(l1) .or. l.eq.nkx1) go to 20
        l = l1
        l1 = l+1
        go to 10
  20    call fpbspl(tx,nx,kx,arg,l,h)
        lx(i) = l-kx1
        do 30 j=1,kx1
          wx(i,j) = h(j)
  30    continue
  40  continue
      ky1 = ky+1
      nky1 = ny-ky1
      tb = ty(ky1)
      te = ty(nky1+1)
      l = ky1
      l1 = l+1
      do 80 i=1,my
        arg = y(i)
        if(arg.lt.tb) arg = tb
        if(arg.gt.te) arg = te
  50    if(arg.lt.ty(l1) .or. l.eq.nky1) go to 60
        l = l1
        l1 = l+1
        go to 50
  60    call fpbspl(ty,ny,ky,arg,l,h)
        ly(i) = l-ky1
        do 70 j=1,ky1
          wy(i,j) = h(j)
  70    continue
  80  continue
      m = 0
      do 130 i=1,mx
        l = lx(i)*nky1
        do 90 i1=1,kx1
          h(i1) = wx(i,i1)
  90    continue
        do 120 j=1,my
          l1 = l+ly(j)
          sp = 0.
          do 110 i1=1,kx1
            l2 = l1
            do 100 j1=1,ky1
              l2 = l2+1
              sp = sp+c(l2)*h(i1)*wy(j,j1)
 100        continue
            l1 = l1+nky1
 110      continue
          m = m+1
          z(m) = sp
 120    continue
 130  continue
      return
      end


C ==============================
+PATCH,*FITPKMJD.

C utility to fit for the peak-MJD.
C ==============================


C ================================================
+DECK,SELECTEP_TREST.
      SUBROUTINE SELECT_EPOCHS_CUTWIN_TREST()

c Created Jun 23 2019
c
c Called if OPT_SETPKMJD>0 so that Trest cuts are applied here
c to select smaller set of epochs. Note that if OPT_SETPKMJD>0,
c TREST cuts CANNOT be applied in the read-stage.
c This function greatly reduces loop sizes for fitting, and helps 
c prevent array bound overflows if fit-epoch arrays are smaller 
c than the total array storage.

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PKMJDCOM.

      REAL*8  MJD8, MJD8_LAST
      INTEGER NMJD_STORE_NEW, NMJD_STORE_ORIG, NEWMJD
      INTEGER EPMIN, EPMAX, ep_orig, ep_new, IMJD
      REAL MJD, TOBS, TREST, z1, z
      LOGICAL LPASS
      CHARACTER FNAM*28

c ------------------- BEGIN -------------------

      FNAM = 'SELECT_EPOCHS_CUTWIN_TREST'
      NMJD_STORE_NEW  = 0
      NMJD_STORE_ORIG = ISNLC_NEWMJD_STORE
      EP_NEW          = 0 
      MJD8_LAST       = -9.0


      z    = SNLC_REDSHIFT
      if ( z > 0.0 ) then
         z1 = 1.0  + z
      else
         z1 = 1.0  ! in case Z = -9 is undefined; Trest -> Tobs
      endif


      DO 101 NEWMJD = 1, ISNLC_NEWMJD_STORE
         EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
         EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)

         MJD8  = SNLC8_MJD(EPMIN) 
         MJD   = SNGL(MJD8)
         TOBS  = MJD - SNLC_SEARCH_PEAKMJD
         TREST = TOBS/z1
         LPASS = TREST >= CUTWIN_TREST(1) .and. 
     &           TREST <= CUTWIN_TREST(2)

          IF ( LPASS ) THEN
            NMJD_STORE_NEW = NMJD_STORE_NEW + 1
            IMJD = NMJD_STORE_NEW
            ISNLC_NFILT_NEWMJD(IMJD) = ISNLC_NFILT_NEWMJD(NEWMJD)
          ENDIF

          if ( .NOT. LPASS ) goto 101

        DO 102 EP_ORIG = EPMIN, EPMAX

         EP_NEW = EP_NEW + 1

         MJD8  = SNLC8_MJD(EP_ORIG)
         if ( MJD8 > MJD8_LAST ) then
            if ( EP_ORIG == EPMIN ) then
              ISNLC_EPOCH_RANGE_NEWMJD(1,IMJD) = EP_NEW
            endif
              ISNLC_EPOCH_RANGE_NEWMJD(2,IMJD) = EP_NEW
         endif
         MJD8_LAST = MJD8          

         if ( EP_NEW > EP_ORIG ) then
            CALL PRINT_PREABORT_BANNER(FNAM//char(0),40)
            print*,'    EPMIN, EPMAX = ', EPMIN, EPMAX
            print*,'    NEWMJD(ORIG,NEW) = ', NEWMJD, IMJD
            write(c1err,61) EP_NEW, EP_ORIG
61          format('Invalid EP_NEW=',I4, ' > EP_ORIG=',I4)
            c2err = 'Something is messed up.'
            CALL MADABORT(FNAM, c1err, c2err)
         endif

         CALL MOVE_SNLC_ARRAYS(EP_NEW,EP_ORIG)

102     CONTINUE
101     CONTINUE

      ISNLC_NEWMJD_STORE = NMJD_STORE_NEW

      RETURN
      END    ! end SELECT_EPOCHS_CUTWIN_TREST


C ====================================
+DECK,SET_PEAKMJD.
      SUBROUTINE SET_PEAKMJD()

c Created Oct 24, 2009 by R.Kessler
c
c Analyze and/or fit light curve to estimate peak-MJD. 
c Fill SNLC_SEARCH_PEAKMJD to be used as the initial 
c Tpeak-estimate in the light curve fit.
c
c This routine will not work properly for low SNR light curves.
c The minimum SNR on a light curve must be at least 4.
c
c Namelist variable OPT_SETPKMJD determines options;
c see OPTBIT_SETPKMJD_XXX options in global declaration.
c
c           HISTORY
c
c May 10 2016: remove PSF>2 epochs to get fluxMax (avoid crazy fluxes)
c              See new parameter PSFMAX_forFLUXMAX
c
c May 17, 2019: implement new options OPTBIT_SETPKMJD_[TRIGGER,MAXFLUX2]
c May 20, 2019: return if less then 2 epochs.
c -------------------------------------------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,SNANAFIT.
+CDE,PKMJDCOM.

      INTEGER 
     &   EPMAX, EP
     &  ,EP_atFLUXMAX(0:MXFILT_ALL), EPTEST_atFLUXMAX(0:MXFILT_ALL)
     &  ,IFILT_OBS, ifilt, ifilt_snrmin 
     &  ,IFILT_OBS2, IFILT_OUTLIER, IFILT_REJECT
     &  ,NPKMJD, LUN, VBOSE

      REAL 
     &   PKMJDSUM, PKMJDAVG, PKMJDDIF, PKMJDDIF_MAX
     &  ,PKMJD, DIF, WGTSUM, WGT
     &  ,FLUX, FLUXERR, SNR, SNRMIN
     &  ,FLUXMAX(0:MXFILT_ALL)
     &  ,MJDatFLUXMAX(0:MXFILT_ALL)
     &  ,SNRatFLUXMAX(0:MXFILT_ALL)
         
      REAL*8  
     &   MJD8, F8, PKMJD8, PKMJD8ERR, PKFLUX8, PKFLUX8ERR
     &  ,PARLIST(3), FITWIN_MJD8(2)

      LOGICAL 
     &    LSET, LDMP, LDMP_USER, NOABORT, LABORT
     &   ,USEFILT(MXFILT_ALL)
     &   ,USE_MJDatFLUXMAX, USE_MJDatFLUXMAX2, USE_MJDatTRIGGER
     &   ,FIRST_INIT, DOFIT, NOFIT

      CHARACTER cfilt*8, FNAM*12, METHOD*24, CCID*(MXCHAR_CCID)

c define hard-wired cut-parameters
      REAL   
     &   MJDMIN_LC
     &  ,PKMJD_OUTLIER
     &  ,MAX_SNRMIN_REJECT

      PARAMETER ( 
     &   MJDMIN_LC           = 40000. ! min MJD to consider for light curve
     &  ,PKMJD_OUTLIER       = 30.0   ! reject PKMJD off by this much 
     &  ,MAX_SNRMIN_REJECT   = 2.0    ! max SNRMIN to reject filter
     &     )
      
c function
      EXTERNAL init_obs_atFLUXMAX, get_obs_atFLUXMAX

C ---------------- BEGIN ----------------

      if ( OPT_SETPKMJD <= 0 ) RETURN
      FNAM = 'SET_PEAKMJD'
      CCID = SNLC_CCID

      if ( ISNLC_NEWMJD_STORE < 2 ) RETURN

c July 12 2013: check option to use MJD at max flux (no fitting)
      USE_MJDatFLUXMAX  = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_FLUXMAX)
      USE_MJDatFLUXMAX2 = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_FLUXMAX2)
      USE_MJDatTRIGGER  = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_TRIGGER)
      DOFIT = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_ANYFUN) .or. ! Bazin09
     &        BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_POLYCOR)
      NOFIT = (.NOT. DOFIT)

      if ( USE_MJDatTRIGGER .and. PHOTFLAG_TRIGGER == 0 ) then
        c1err = 'Must set PHOTFLAG_TRIGGER in &SNLCINP'
        c2err = 'to set PEAKMJD = MJD_TRIGGER'
        CALL MADABORT(FNAM, c1err, c2err)
      endif

c bail if the user CUTWIN_PEAKMJD does not contain  any observations:
      IF ( SNLC8_MJDMIN .GT. CUTWIN_PEAKMJD(2) ) RETURN
      IF ( SNLC8_MJDMAX .LT. CUTWIN_PEAKMJD(1) ) RETURN

c first-time init: 
c  + print comments to stdout
c  + open separate log file to dump MNFIT stuff for each SN
      FIRST_INIT = (NFIT_PKMJD==0) 

      IF  ( FIRST_INIT ) THEN  ! init
         LSET = .FALSE.
         print*,' ' 
         if ( USE_MJDatFLUXMAX ) then
            write(6,80) 'MJD at max flux' ; LSET=.TRUE.
            METHOD = '(FLuxMax)'
         else if ( USE_MJDatFLUXMAX2 ) then
            write(6,80) 
     &         'MJD at max flux in dense clump of SNR-detections.'
            LSET=.TRUE.
            METHOD = '(FmaxClump)'
         else if ( USE_MJDatTRIGGER ) then
            write(6,80) 'MJD_TRIGGER' ; LSET=.TRUE.
            METHOD = '(MJD_trigger)'
         endif

         if( DOFIT ) then
            write(6,80) 'Bazin fit' ; LSET=.TRUE.
            METHOD = '(FluxMax+BazinFit)'
            if (USE_MJDatFLUXMAX2) METHOD = '(FmaxClump+BazinFit)'
         endif
 80      format(' SET_PEAKMJD method: ', A)
         print*,' ' 
         call flush(6)

         if ( .not. LSET ) then
            write(6,80) 'UNKNOWN'
            write(c1err,86) OPT_SETPKMJD
 86         format('Unknown OPT_SETPKMJD=',I5,' in &SNLCINP.')
            c2err = 'See manual for OPT_SETPKMJD'
            CALL MADABORT(FNAM, c1err,c2err ) 
         endif

         VBOSE = 0
         PARLIST(1) = MJDWIN_SETPKMJD    ! user MJDWIN from &SNLCINP
         PARLIST(2) = SNRCUT_SETPKMJD    ! user SNRCUT from &SNLCINP
         PARLIST(3) = SNRMIN_forFLUXMAX  ! backup SNRCUT if above always fails
         call init_obs_atFLUXMAX(OPT_SETPKMJD, PARLIST, VBOSE)

c open outfile to dump MINUIT stdout
         if ( DOFIT ) then
            LUN = LUNPKMJD
            OPEN(UNIT=LUN,FILE=MNFIT_PKMJD_LOGFILE,status='UNKNOWN')
         endif

c open INTERP-OUT file if set
+SELF,IF=SNANA.
         IF ( SNMJD_OUT_FILE .NE. ' ' ) THEN
            LUN = LUNINTERP
            OPEN(UNIT=LUN,FILE=SNMJD_OUT_FILE,status='UNKNOWN')
            write(LUNINTERP,46) 
 46         format('VARNAMES:',2x,'CID', 4x,'FILT', 5x,'MJD',
     &           10x,'FLUX      FLUXERR')
         ENDIF
+SELF.

      ENDIF  ! end of FIRST_INIT
    
      NFIT_PKMJD = NFIT_PKMJD  + 1

      global_banner = 
     &   'SET_PEAKMJD: Find Estimate of PEAK-MJD for CID='  // 
     &   CCID
cc      CALL PRBANNER ( global_banner )

      IF ( NFILTDEF_SURVEY .GT. MXFILT_OBS ) THEN
        write(c1err,1661) NFILTDEF_SURVEY
        write(c2err,1662) MXFILT_OBS
1661    format('There are ', I3,' obs-filters,')
1662    format('but SET_PEAKMJD works for up to ',I2,' filters.')
        CALL MADABORT(FNAM, c1err, c2err)        
      ENDIF

c initialize

      DO 480 IFILT_OBS = 0, MXFILT_ALL
         EP_atFLUXMAX(IFILT_OBS)  = -9
         FLUXMAX(IFILT_OBS)       =  0.0
         MJDatFLUXMAX(IFILT_OBS)  = -9.0 
         SNRatFLUXMAX(IFILT_OBS)  = -9.0 
         
         IF ( IFILT_OBS .EQ. 0 ) goto 480

         PKMJD_FIT(IFILT_OBS)     =  0.0
         PKMJD_ERR(IFILT_OBS)     = -9.0
         PKFLUX_FIT(IFILT_OBS)    = -9.0
         PKFLUX_ERR(IFILT_OBS)    = -9.0
         
         USEFILT(ifilt_obs) = .FALSE.
 480  CONTINUE


      PKMJD_ERRMIN = 1.0E9
      PKMJD_ERRWGT = 0.0

      PKFLUX_ERRMIN = 1.0E9
      PKFLUX_ERRWGT = 0.0

c find epoch with max flux for each filter using C-function
       
       CALL get_obs_atFLUXMAX(
     &      CCID(1:ISNLC_LENCCID)//char(0),
     &      ISNLC_NEWMJD_STORE,
     &      SNLC_FLUXCAL, SNLC_FLUXCAL_ERRTOT,   
     &      SNLC8_MJD, ISNLC_IFILT_OBS,
     &      EP_atFLUXMAX(0),            ! <== returned array vs. IFILTOBS
     &      MXCHAR_CCID )

c use EP at max flux to set FLUXMAX, MJD at max, SNR at max.
      DO 40 ifilt = 0, NFILTDEF_SURVEY
         if ( ifilt == 0 ) then
            ifilt_obs = 0
         else
            ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         endif
         EP = EP_atFLUXMAX(ifilt_obs)+1 ! from C code

         if ( EP < 0 ) then
           SNRatFLUXMAX(ifilt_obs) = 0.01
           MJDatFLUXMAX(ifilt_obs) = 0.01
           goto 40
         endif

         FLUX      = SNLC_FLUXCAL(EP)
         FLUXERR   = SNLC_FLUXCAL_ERRTOT(EP)

         FLUXMAX(ifilt_obs)      = FLUX
         MJDatFLUXMAX(ifilt_obs) = SNLC8_MJD(ep)
         if ( FLUXERR > 0.0 ) then
            SNRatFLUXMAX(ifilt_obs) = FLUX/FLUXERR
         else
            SNRatFLUXMAX(ifilt_obs) = 0.0
         endif
40     CONTINUE

c -------------------------------------
c check option to use MJD at max-flux or at TRIGGER
      IF ( NOFIT ) THEN
         IF ( USE_MJDatFLUXMAX .or. USE_MJDatFLUXMAX2) THEN
            PKMJD  = MJDatFLUXMAX(0) 
         ELSE IF ( USE_MJDatTRIGGER ) THEN
            PKMJD  = SNLC8_MJD_TRIGGER
         ELSE
            C1err = 'Invalid NOFIT option.'
            c2err = 'Expecting MJD-at-maxFlux or MJD-at-Trigger'
            CALL MADABORT(FNAM, c1err, c2err)  
         ENDIF

         SNLC_SEARCH_PEAKMJD    = PKMJD
         write(6,50) CCID(1:ISNLC_LENCCID), PKMJD, METHOD
         RETURN
      ENDIF


c --------- Below do some kind of Bazin fit -----------

c --------------
c Find valid filter with smallest SNR at epoch with max-FLux,
c and that has SNR below MAX_SNRMIN_REJECT.
c If all filters have SNR > MAX_SNRMIN_REJECT then use all filters;
c otherwise toss the one with smallest SNR at FLUXMAX.

      SNRMIN = 999999999.
      IFILT_SNRMIN = -9
      DO ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         SNR = SNRatFLUXMAX(ifilt_obs)

         if (    SNR .LT. SNRMIN 
     &     .and. SNR .LT. MAX_SNRMIN_REJECT
     &     .and. SNR .GT. 0.0  ) then

            SNRMIN = SNR
            ifilt_snrmin = ifilt_obs  ! filter to reject
         endif
      ENDDO

c -----------------------------------------
c Now fit each filter to general function using MINUIT.
c Take weighted PKMJD-average so that badly measured
c PKMJD don't have much effect

      NPKMJD   = 0
      PKMJDSUM = 0.0
      WGTSUM   = 0.0
      PKMJDDIF_MAX = 0.0
      FITWIN_MJD8(1) = MJDatFLUXMAX(0) + CUTWIN_TOBS(1)
      FITWIN_MJD8(2) = MJDatFLUXMAX(0) + CUTWIN_TOBS(2)

      DO 200 ifilt = 1, NFILTDEF_SURVEY
         ifilt_obs = IFILTDEF_MAP_SURVEY(ifilt)
         MJD8      = DBLE( MJDatFLUXMAX(ifilt_obs) )
         F8        = DBLE ( FLUXMAX(IFILT_OBS) ) 

         if ( MJD8      .LT. MJDMIN_LC    ) GOTO 200
         if ( ifilt_obs .EQ. ifilt_snrmin ) GOTO 200

         USEFILT(ifilt_obs) = .TRUE.
          
         CALL MNFIT_PKMJD(IFILT_OBS, FITWIN_MJD8, F8, MJD8,   ! inputs
     &              PKMJD8, PKMJD8ERR, PKFLUX8, PKFLUX8ERR)   ! return args

c store result for each filter.

           PKFLUX_FIT(ifilt_obs) = SNGL(PKFLUX8)
           PKFLUX_ERR(ifilt_obs) = SNGL(PKFLUX8ERR)

           PKMJD_FIT(ifilt_obs) = SNGL(PKMJD8)
           PKMJD_ERR(ifilt_obs) = SNGL(PKMJD8ERR)
           NPKMJD = NPKMJD + 1

c check option to interpolate flux
+SELF,IF=SNANA.
           CALL SNMJD_INTERP_ANYLC(ifilt_obs)
+SELF.

200   CONTINUE

      IF ( NPKMJD .EQ. 0 ) then

         NOABORT = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_NOABORT)
     &        .or. (OPT_REFORMAT_FITS > 0)
     &        .or. (.not. ABORT_ON_NOPKMJD)  ! 7.29.2014

         LABORT  = (.NOT. NOABORT)

         IF ( LABORT ) then         
            C1err = 'NMJD=0 => no estimate of PKMJD !!!'
            c2err = 'Check SN ' // CCID
            CALL MADABORT(FNAM, c1err, c2err)  
         ELSE
            write(6,240) CCID
 240        format(T8,'Could not estimate PKMJD for CID=',A)
            call flush(6)
            PKMJD = -1.
            GOTO 800
         ENDIF
      ENDIF

c convert sum of 1/err^2 into wgted error.
      IF  ( PKMJD_ERRWGT .GT. 0.0 ) THEN
         PKMJD_ERRWGT  = SQRT(1.0/PKMJD_ERRWGT)
      ENDIF
      IF ( PKFLUX_ERRWGT .GT. 0.0 ) THEN
         PKFLUX_ERRWGT = SQRT(1.0/PKFLUX_ERRWGT)
      ENDIF

c if there are more than 2 filters, check for
c crazy outlier.

      IFILT_REJECT    = -9
      IFILT_OUTLIER   = -9

      IF ( NPKMJD .GE. 3 ) THEN
      DO 252 ifilt_obs2 = 1, MXFILT_ALL  ! ignore this filter in average
         if ( .not. USEFILT(ifilt_obs2) ) goto 252
         PKMJDSUM = 0.0
         WGTSUM = 0.0

      DO 250 ifilt_obs  = 1, MXFILT_ALL
         if ( .not. USEFILT(ifilt_obs) ) goto 250
         if ( ifilt_obs2 .NE. ifilt_obs ) then
           PKMJDSUM = PKMJDSUM + (PKMJD_FIT(ifilt_obs)-MJDOFF)
           WGTSUM   = WGTSUM + 1.0
         endif
250   CONTINUE

c test average against filter that was excluded

         PKMJDAVG = (PKMJDSUM/WGTSUM + MJDOFF)
         PKMJDDIF = abs(PKMJDAVG - PKMJD_FIT(ifilt_obs2))

         if ( PKMJDDIF .GT. PKMJDDIF_MAX ) then
            PKMJDDIF_MAX  = PKMJDDIF
            IFILT_OUTLIER = ifilt_obs2            
         endif

252   CONTINUE

         if ( PKMJDDIF_MAX .GT. PKMJD_OUTLIER ) then
           USEFILT(ifilt_outlier) = .FALSE.
           IFILT_REJECT = IFILT_OUTLIER

c            print*,' xxx REJECT FILT=',IFILT_OUTLIER, 
c     &       '  for CID=',CCID,'  PKMJDDIF=', PKMJDDIF_MAX
         endif

      ENDIF

c ---------------------------------------
c Finally, take PKMJD-wgted average of remaining filters.

      PKMJDSUM = 0.0
      WGTSUM   = 0.0
      NPKMJD   = 0

      DO 300 ifilt_obs = 1, MXFILT_ALL
         if ( .not. USEFILT(ifilt_obs) ) goto 300
      
           PKMJD8    = PKMJD_FIT(ifilt_obs)
           PKMJD8ERR = PKMJD_ERR(ifilt_obs)

           WGT    = (1.0/PKMJD8ERR) ! * 10.0/MAX(PKMJDDIF,10.0)

           PKMJDDIF = SNGL(PKMJD8 - MJDOFF)
       
           PKMJDSUM = PKMJDSUM + WGT*PKMJDDIF
           WGTSUM = WGTSUM + WGT
           NPKMJD = NPKMJD + 1

300   CONTINUE

      PKMJDAVG = PKMJDSUM/WGTSUM + MJDOFF
      PKMJD    = PKMJDAVG

      write(6,50) CCID(1:ISNLC_LENCCID), PKMJD,METHOD
50    format(T8,'SET_PEAKMJD(',A,') --> ', F9.3, 3x, A )

c -----------------------------------------------

      LDMP_USER =  BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_DUMP)
      LDMP      = LDMP_USER

      IF ( LDMP ) THEN
        print*,'  --------------------------------------------- '
        print*,'  BEGIN DUMP of SET_PEAKMJD for SN ', CCID
        print*,'  '
        print*,'                  MJDat    SNRat      PKMJD  PKMJD  '
        print*,'  filt  FLUXMAX   FLUXMAX  FLUXMAX    fit    err    '
        print*,'  --------------------------------------------------'

        DO 660 ifilt_obs = 1, MXFILT_ALL
           if ( .not. USEFILT(ifilt_obs) ) goto 660
           cfilt =  filtdef_string(ifilt_obs:ifilt_obs) 
           write(6,661) cfilt
     &       , FLUXMAX(ifilt_obs)
     &       , MJDatFLUXMAX(ifilt_obs)
     &       , SNRatFLUXMAX(ifilt_obs)
     &       , PKMJD_FIT(ifilt_obs)
     &       , PKMJD_ERR(ifilt_obs)
661        format( T5,A, T7,F10.1, F11.2, F6.1, F11.2, F7.2 )

660      CONTINUE
         print*, ' '

        if ( ifilt_snrmin .GT. 0 ) then
          cfilt =  filtdef_string(ifilt_snrmin:ifilt_snrmin) 
        else
          cfilt = 'none'
        endif
        print*,'    Filter with min SNR at max: ', cfilt

        if ( ifilt_reject .GT. 0 ) then
          cfilt =  filtdef_string(ifilt_reject:ifilt_reject) 
        else
          cfilt = 'none'
        endif
        print*,'    PKMJD-outlier filter rejected : ', cfilt

        print*,'    PEAKMJD(CALC,SEARCH)  = ', 
     &            PKMJD, SNLC_SEARCH_PEAKMJD

        print*,'    CALC-SEARCH PKMJD DIF = ', DIF
        print*,'  END DUMP of SET_PEAKMJD for SN ', CCID
        print*,'  --------------------------------------------- '
      ENDIF
     
c -----------------------------------------    
800   CONTINUE

      SNLC_SNANAFIT_PEAKMJD = PKMJD
      SNLC_SEARCH_PEAKMJD   = PKMJD

      RETURN
      END  ! end SET_PEAKMJD


C =========================================
+DECK,MNFIT_PKMJD.
      SUBROUTINE MNFIT_PKMJD(ifilt_obs, FITWIN_MJD,
     &        FLUXatMAX, MJDatMAX, PKMJD,PKMJDERR, PKFLUX, PKFLUXERR )

c -----------------------------------------------
c Created Oct 29, 2009 by R.Kessler
c Fit FCNANYLC (any LC function) to estimate PKMJD.
c
c METHOD:
c First get  approx PEAKMJD = filter-average of MJDs at max flux.
c Then grid-minimize Eq. 1 of  Bazin et al., (SNLC CC rate)
c from astro-ph 0904.1066. 
c
c               exp[ -(t-t0)/Tfall ]
c  f(t) = A * --------------------------  +  B
c              1 + exp[ -(t-t0)/Trise ]
c
c where t0, Trise, Tfall, A, & B=0 are the five
c fit-parameters for each filter. We only care about
c getting an approximate function, so we don't care
c about errors.
c
c Note that the exponent in their denomintor is missing a 
c minus sign (with Trise > 0). The t0 parameter is not really 
c the time at peak; after the fit has converged, the true Tpeak  
c is found by setting the derivative=0.
c
c Jun 6, 2010: for POLYCOR option, do BTEST on OPT_SETPKMJD
c
c Oct 26, 2010: remove "SET PRint" command so that we get
c               correlation matrix printed to screen.
c
c Dec 9, 2011: keep track of min-error and  wgted error for 
c              T0 and F0err/F0.
c
c May 28 2019: add FITWIN_MJD argument to restrict range of epochs fit.
c
c ----------------------------

      IMPLICIT NONE

c function args

      INTEGER IFILT_OBS   ! (I) SN index and obs filter to fit

      REAL*8
     &   FITWIN_MJD(2) ! (I) MJD window to fit observations
     &  ,MJDatMAX      ! (I) MJD at epoch with max flux
     &  ,FLUXatMAX     ! (I) flux at MJD with max flux
     &  ,PKMJD      ! (O) MJD at peak of function
     &  ,PKMJDERR   ! (O) approx error on PKMJD (used for wgted avg)
     &  ,PKFLUX     ! (O) peak flux from fit
     &  ,PKFLUXERR  ! (O) error on above

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PKMJDCOM.

c MINUIT stuff

      INTEGER IERR, IPAR, IVARBL

      INTEGER 
     &   IUNIN, IUOUT, IUWRI
     &  ,NFIXPAR, IFILT
     
      EXTERNAL FCNANYLC, ANYLCFUN
      DOUBLE  PRECISION  ANYLCFUN

      LOGICAL USE_ANYFUN, USE_POLYCOR 

      REAL*8 
     &   MNARG
     &  ,FIXLIST(NPAR_ANYLC)
     &  ,INIBND(2,NPAR_ANYLC)
     &  ,INISTP(NPAR_ANYLC)
     &  ,INIVAL(NPAR_ANYLC)
     &  ,TMPVAL(10), TMPERR(10), BND1, BND2
     &  ,T0, TRISE, TFALL, ARG, T0ERR
     &  ,INIVAL_TMP, COV
     &  ,ERRTMP

c functions
      REAL*8 COVPKFLUXFUN

C ---------------- BEGIN -------------

      USE_ANYFUN  = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_ANYFUN)
      USE_POLYCOR = BTEST(OPT_SETPKMJD,OPTBIT_SETPKMJD_POLYCOR)

      IUNIN = 5
      IUOUT = LUNPKMJD   ! write to file instead of STDOUT=6 
      IUWRI = 7

      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 

c ---------------------------------
c write header to log file so we know what CID and filter

      write(LUNPKMJD,20) 
     &   SNLC_CCID
     &  ,filtdef_string(ifilt_obs:ifilt_obs) 
20    format(/, T2, 60('#'), 
     &       /, T10,'MNFIT_PKMJD for CID=',A8,' FILTER=',A,
     &       /, T2, 60('#'), / )

c ------------------------

+SELF,IF=MINUIT.
      CALL MNINIT(IUNIN,IUOUT,IUWRI)  ! init MINUIT

      MNARG = dble(0.0) 
      CALL MNEXCM(FCNANYLC, 'SET NOWarnings', MNARG,0,IERR, ANYLCFUN)

      MNARG = DBLE(MINUIT_PRINT_LEVEL)
      CALL MNEXCM(FCNANYLC, 'SET PRI', MNARG, 1, IERR, ANYLCFUN )
+SELF.


c init each parameter
      INIBND(1,IPAR_ISN) = 0
      INIBND(2,IPAR_ISN) = 9999999.
      INIVAL(IPAR_ISN)   = DBLE(SNLC_CID) 
      INISTP(IPAR_ISN)   = 0.0       ! fixed parameter

      INIBND(1,IPAR_FILT) = 0
      INIBND(2,IPAR_FILT) = 100
      INIVAL(IPAR_FILT)   = DBLE(IFILT_OBS)
      INISTP(IPAR_FILT)   = 0.0     ! fixed parameter

      INIBND(1,IPAR_MJDMIN) = 0
      INIBND(2,IPAR_MJDMIN) = 150000
      INIVAL(IPAR_MJDMIN)   = FITWIN_MJD(1)
      INISTP(IPAR_MJDMIN)   = 0.0     ! fixed parameter

      INIBND(1,IPAR_MJDMAX) = 0
      INIBND(2,IPAR_MJDMAX) = 150000
      INIVAL(IPAR_MJDMAX)   = FITWIN_MJD(2)
      INISTP(IPAR_MJDMAX)   = 0.0     ! fixed parameter

      INIBND(1,IPAR_T0) = MJDatMAX - 50.0
      INIBND(2,IPAR_T0) = MJDatMAX + 50.0
      INIVAL(IPAR_T0)   = MJDatMAX
      INISTP(IPAR_T0)   = 2.0

      INIBND(1,IPAR_TRISE) =  1.0
      INIBND(2,IPAR_TRISE) =  40.
      INIVAL(IPAR_TRISE)   =  5.0
      INISTP(IPAR_TRISE)   =  2.0

      INIBND(1,IPAR_TFALL) = 1.0
      INIBND(2,IPAR_TFALL) = 100.0
      INIVAL(IPAR_TFALL)   = 10.0
      INISTP(IPAR_TFALL)   = 2.0

      INIBND(1,IPAR_A0) = FLUXatMAX * 0.2
      INIBND(2,IPAR_A0) = FLUXatMAX * 5.0
      INIVAL(IPAR_A0)   = FLUXatMAX * 1.2
      INISTP(IPAR_A0)   = FLUXatMAX * 0.1

      IF ( USE_POLYCOR ) THEN
         INIVAL_TMP = 0.1
      ELSE
         INIVAL_TMP = 0.0
      ENDIF

      INIBND(1,IPAR_A1)   = -20.0
      INIBND(2,IPAR_A1)   =  20.0
      INIVAL(IPAR_A1)     =   0.0
      INISTP(IPAR_A1)     = INIVAL_TMP

      INIBND(1,IPAR_A2)   = -20.0
      INIBND(2,IPAR_A2)   =  20.0
      INIVAL(IPAR_A2)     =   0.0
      INISTP(IPAR_A2)     = INIVAL_TMP
c      PKPARNAME(IPAR_A2)  =  'A2'


      CHI2_FITPKMJD(IFILT) = -9.0
      NDOF_FITPKMJD(IFILT) = -9

      NFIXPAR = 0
      DO IPAR = 1, NPAR_ANYLC

+SELF,IF=MINUIT.
         CALL MNPARM(IPAR,    PKPARNAME(IPAR)
     &       ,INIVAL(IPAR),   INISTP(IPAR)
     &       ,INIBND(1,IPAR), INIBND(2,IPAR)
     &       ,IERR   ) 
+SELF.

         IF ( IERR .NE. 0 ) THEN
            WRITE (6,'(A,A10,A)') '  ERROR initializing ', 
     &            PKPARNAME(ipar), '  with MNPARM '
            RETURN
         ENDIF

c keep track of fixed parameters
        if ( INISTP(IPAR) .EQ. 0.0 ) then
           NFIXPAR =  NFIXPAR + 1
           FIXLIST(NFIXPAR) = DBLE ( IPAR )
        endif

      ENDDO  ! end of IPAR loop

      CALL FLUSH(6)

+SELF,IF=MINUIT.
      CALL MNEXCM(FCNANYLC, 'FIX', FIXLIST, NFIXPAR, IERR, ANYLCFUN )

      MNARG = dble(30000.0)  ! MAXCALLS
      CALL MNEXCM(FCNANYLC, 'MINIMIZE', MNARG, 0, IERR, ANYLCFUN )
+SELF.

      DO IPAR = 1,  NPAR_ANYLC

+SELF,IF=MINUIT.
        CALL MNPOUT(  IPAR, PKPARNAME(IPAR)
     &              , TMPVAL(IPAR), TMPERR(IPAR)
     &              , BND1, BND2, IVARBL )
+SELF.

        SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar) = TMPVAL(IPAR)
        SNLC_SNANAFIT_PEAKMJD_FITERR(ifilt,ipar) = TMPERR(IPAR)

      ENDDO

+SELF,IF=MINUIT.
      CALL MNEXCM ( FCNANYLC, 'EXIT',  ZERO8, 0, IERR, ANYLCFUN )
**      PRINT *,'  MNFIT_PKMJD: EXIT returns IERR = ', IERR
+SELF.

c compute PKMJD from setting 1st deriviate = 0
      Tfall = TMPVAL(IPAR_TFALL)
      Trise = TMPVAL(IPAR_TRISE)
      T0    = TMPVAL(IPAR_T0)
      T0ERR = TMPERR(IPAR_T0)

      arg = (Tfall - Trise)/Trise
      if ( ARG .GT. 0.1 ) then 
         PKMJD = T0 + Trise * DLOG(ARG)
         PKMJDERR = MIN(T0ERR,4.0)  ! max error is 4 days
      else
         PKMJD = MJDatMAX
         PKMJDERR = 4.0
      endif


      if ( OPT_REFORMAT_SALT2 .GT. 0 ) then
         PKMJDERR = T0ERR
      endif

c get error on peak flux from fit


+SELF,IF=MINUIT.
      CALL MNEMAT(FITERRMAT_PKMJD(1,1,ifilt_obs),NPAR_ANYLC)
+SELF.
      COV = COVPKFLUXFUN(ifilt_obs,PKMJD,PKMJD)

      PKFLUX    = ANYLCFUN(PKMJD,TMPVAL)
      PKFLUXERR = SQRT(COV)

c Dec 9, 2011
c keep track of min error and wgted error
      ERRTMP  = T0ERR
      IF ( ERRTMP .LT. PKMJD_ERRMIN .and. ERRTMP .GT. 0.0 ) THEN
         PKMJD_ERRMIN = ERRTMP
         PKMJD_ERRWGT = PKMJD_ERRWGT + 1.0/(ERRTMP*ERRTMP)
      ENDIF

      ERRTMP  = PKFLUXERR/PKFLUX
      IF ( ERRTMP .LT. PKFLUX_ERRMIN .and. 
     &     ERRTMP .GT. 0.0   .and.
     &     ERRTMP .NE. 1.0 ) THEN
        PKFLUX_ERRMIN = ERRTMP  
        PKFLUX_ERRWGT = PKFLUX_ERRWGT + 1.0/(ERRTMP*ERRTMP)
      ENDIF

      RETURN
      END

C =========================================
+DECK,FCNANYLC.
      SUBROUTINE FCNANYLC(NVAR,GRAD,CHI2,XVAL,IFLAG, ANYLCFUN )
c
c Created Oct 25, 2009
c MINUIT-callable function to return data-model CHI2
c using the "ANY LC" model from Bazin et al.
c See comments at top of MNFIT_PKMJD.
c
c May 28, 2019: Use MJDMIN/MJDMAX to restrict epoch range.
c
c --------------------------------------------
      IMPLICIT NONE

      INTEGER NVAR, IFLAG
      REAL*8 
     &   XVAL(*)  ! (I) T0, Trise, Tfall, A, B
     &  ,GRAD(*)
     &  ,CHI2
     &  ,ANYLCFUN

      EXTERNAL ANYLCFUN
  
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,PKMJDCOM.  Oct 2014

c local var

      INTEGER 
     &   ISN, IFILT_OBS, IFILT, IMJD
     &  ,NEWMJD, EPMIN, EPMAX, EP, NDOF

      REAL*8
     &   MJDMIN, MJDMAX, FLUX, FLUXERR, MJD, SQDIF, SQERR, SNR 
     &  ,MODEL_FLUX, MODEL_FLUXERR

      REAL*8 MODEL_MAGERR
      PARAMETER ( MODEL_MAGERR = 0.05 )

c function
      LOGICAL CHECK_EPOCH_IGNORE

C --------------- BEGIN -------------

      ISN         = INT ( XVAL(1) + 0.0001 )
      IFILT_OBS   = INT ( XVAL(2) + 0.0001 )
      MJDMIN      = XVAL(3)
      MJDMAX      = XVAL(4)

      CHI2 = 0.0
      NDOF = 0 

      DO 200 NEWMJD = 1, ISNLC_NEWMJD_STORE
 
        EPMIN = ISNLC_EPOCH_RANGE_NEWMJD(1,NEWMJD)
        EPMAX = ISNLC_EPOCH_RANGE_NEWMJD(2,NEWMJD)
        MJD   = SNLC8_MJD(EPMIN)

        if ( MJD < MJDMIN ) goto 200
        if ( MJD > MJDMAX ) goto 200

        MODEL_FLUX    = ANYLCFUN(MJD,XVAL)
        MODEL_FLUXERR = MODEL_FLUX * MODEL_MAGERR

        DO 201 EP = EPMIN, EPMAX

cc xxx no longer needed  if ( CHECK_EPOCH_IGNORE(0,ep) ) GOTO 201  ! May 2016
            if ( IFILT_OBS .NE. ISNLC_IFILT_OBS(ep) ) GOTO 201

            FLUX      = SNLC_FLUXCAL(ep)
            FLUXERR   = SNLC_FLUXCAL_ERRTOT(ep)

c SNR requirement makes things worse ??
            SNR = FLUX/FLUXERR
            
            SQDIF = (FLUX - MODEL_FLUX)**2
            SQERR = FLUXERR*FLUXERR + MODEL_FLUXERR*MODEL_FLUXERR
            CHI2  = CHI2 + SQDIF/SQERR
            NDOF = NDOF + 1

201     CONTINUE   ! ep
200   CONTINUE  ! end of NEWMJD

c --------------------------------------
c load chi2 and NDOF in global array

      IF (IFLAG == FCNFLAG_LAST ) THEN
        IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
        CHI2_FITPKMJD(IFILT) = CHI2
        NDOF_FITPKMJD(IFILT) = NDOF
      ENDIF

      RETURN
      END

C ======================================
+DECK,ANYLCFUN.
      DOUBLE PRECISION FUNCTION ANYLCFUN(MJD,XVAL)
c
c Created Dec 5, 2009 by R.Kessler
c Any light curve function based on Bazin et al,, 2009 (SNLS CC rate)
c
c May 28 2019: replace hard-code XVAL-indices with IPAR_XXX
c ------------
      IMPLICIT NONE

+CDE,SNPAR.
+CDE,PKMJDCOM. 

c function args

      REAL*8 MJD, XVAL(*)

c local args

      REAL*8 
     &   T0, TRISE, TFALL, A0, A1, A2
     &  ,ARG1, ARG2, DUM1, DUM2, TDIF, POLYCOR
     &  ,MODEL_FLUX

C ---------- BEGIN ---------

      T0    = XVAL(IPAR_T0)
      TRISE = XVAL(IPAR_TRISE)
      TFALL = XVAL(IPAR_TFALL)
      A0    = XVAL(IPAR_A0)
      A1    = XVAL(IPAR_A1)
      A2    = XVAL(IPAR_A2)
 
      TDIF  = MJD - T0

c numerator
      ARG1  = TDIF / Tfall
      DUM1  = EXP(-ARG1)

c denominator
      ARG2  = TDIF / Trise
      DUM2  = 1.0 + EXP(-ARG2)

c polynominal correction
      POLYCOR = A0 * ( 1.0 + A1*TDIF + A2*TDIF*TDIF )

c final flux

      MODEL_FLUX = POLYCOR * (DUM1/DUM2)

c Aug 31 2019: protect against crazy values.
      if ( MODEL_FLUX > +1.0E20 ) MODEL_FLUX =  1.0E20
      if ( MODEL_FLUX < -1.0E20 ) MODEL_FLUX = -1.0E20

      ANYLCFUN = MODEL_FLUX

      RETURN
      END

C =====================================
+DECK,COVPKFLUX.
      REAL*8 FUNCTION COVPKFLUXFUN(ifilt_obs, MJD1, MJD2)

c
c Created April 12, 2010 by R.Kessler
c
c Similar to COVARFLUX in snlc_fit.car, but this is
c for the PKMJD fit to estimate error on peak flux.
c Since the user-function calls are different than
c in snlc_fit.car, we must have a separate COV function
c here to evaluate errors.
c
c Using full fitpar covariance, FITERRMAT(ipar1,ipar2)
c  ( see eq. 32.24 in PDG statistics section)
c
c                           dF1   dF2
c U12       = \sum_{k,l}  ------ ------ * FITERRMAT_PKMJD(k,l)
c                         dPAR_k dPAR_l
c
c  where PAR_k = fit-parameter with index 'k'.
c  and F1,F2 are fluxes at days with index 1,2.
c
c If T1 = T2,  then U12 = square of model
c uncertainty at this epoch.
c
c
c
c Jan 9, 2012: fix bug : use IFILT in SNLC_SNANAFIT_PEAKMJD_FITPAR
c -------------------------------

      IMPLICIT NONE

c subroutine args:

      INTEGER
     &   IFILT_OBS  ! (I) ifilt_obs 
  
      REAL*8  MJD1, MJD2  ! (I) MJDs to get covariance
  
c local var

+CDE,SNDATCOM.  from snana.car
+CDE,SNANAFIT.  from snana.car
+CDE,SNLCINP.
+CDE,FILTCOM. 
+CDE,PKMJDCOM.

      INTEGER 
     &   ipar, ipar_k, ipar_l, isp_k, isp_l, IFILT

      REAL*8 
     &   XVAL(NPAR_ANYLC), XERR(NPAR_ANYLC)
     &  ,FLUX1, FLUX2
     &  ,FTMP1, FTMP2
     &  ,SAVEVAL_k, SAVEVAL_l
     &  ,ERRPAR_k,  ERRPAR_l
     &  ,dF1dVAL_k, dF2dVAL_l, FF
     &  ,V_kl, U12

c functions
      REAL*8  ANYLCFUN

C -------------- BEGIN -------------

      COVPKFLUXFUN = 0.0
      U12 = 0.0   ! init output

c get reference fluxes to computer deriviates below.

      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
      DO ipar = 1, NPAR_ANYLC
        XVAL(ipar) = SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar)
        XERR(ipar) = SNLC_SNANAFIT_PEAKMJD_FITERR(ifilt,ipar)
      ENDDO
      Flux1   =  ANYLCFUN ( MJD1, XVAL )
      Flux2   =  ANYLCFUN ( MJD2, XVAL )

      isp_k = 0
      DO 301 ipar_k = 1, NPAR_ANYLC
         IF ( XERR(ipar_k) .LE. 0.0 ) goto 301
         isp_k = isp_k + 1  ! for COV matrix

      isp_l = 0
      DO 302 ipar_l = 1, NPAR_ANYLC
         IF ( XERR(ipar_l) .LE. 0.0 ) goto 302
         isp_l = isp_l + 1 ! for COV matrix

         SAVEVAL_k = XVAL(ipar_k) 
         SAVEVAL_l = XVAL(ipar_l)  

         ERRPAR_k  = XERR(ipar_k)
         ERRPAR_l  = XERR(ipar_l) 

c change fitpar values by +1 sigma and re-evaluate Flux.

         XVAL(ipar_k) = XVAL(ipar_k) + ERRPAR_k
         Ftmp1  = ANYLCFUN ( MJD1, XVAL )
         XVAL(ipar_k) = SAVEVAL_k

c repeat for 2nd fitpar ...
         XVAL(ipar_l) = XVAL(ipar_l) + ERRPAR_l
         Ftmp2   = ANYLCFUN ( MJD2, XVAL )
         XVAL(ipar_l) = SAVEVAL_l

c make sure that errors are non-zero before dividing.

         c2err = ' '
         if ( ERRPAR_k .EQ. 0.0 ) then
           write(c1err,662) PARNAME_STORE(ipar_k)
           CALL MADABORT("COVPKFLUXFUN", c1err, c2err )
         endif
         if ( ERRPAR_l .EQ. 0.0 ) then
           write(c1err,662) PARNAME_STORE(ipar_l)
           CALL MADABORT("COVPKFLUXFUN", c1err, c2err )
         endif
662      format('Cannot compute FLUXERR with ERR(',A,') = 0' )

c evaluate partial deriviates for flux
         dF1dVAL_k = (Ftmp1 - Flux1) / ERRPAR_k
         dF2dVAL_l = (Ftmp2 - Flux2) / ERRPAR_l

         FF   = dF1dVAL_k * dF2dVAL_l 
         V_kl = FITERRMAT_PKMJD(isp_k,isp_l,ifilt_obs)
         U12 = U12 + FF * V_kl

c         print*,'  xxxx V_(',ipar_k,ipar_l, ') = ', V_kl,
c     &      '   RHO=', V_kl/(ERRPAR_k*ERRPAR_l)

302   CONTINUE
301   CONTINUE

      COVPKFLUXFUN = U12

      RETURN
      END

C ============================
+DECK,INTERPANYLC.
      SUBROUTINE SNMJD_INTERP_ANYLC(ifilt_obs)
c
c
c Jan 9, 2012: write output to LUNINTERP if SNMJD_OUT_FILE is defined.
c
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.
+CDE,INTERPCM.

      INTEGER ifilt_obs   ! (I) absolute filter index

c local args

      INTEGER  NMJD, imjd,  LENCCID, ipar, IFILT, LUN

      REAL*8  
     &   FLUX, FLUXERR, MJD, COV, MJDLIST(MXINTERP)
     &  ,XVAL(NPAR_ANYLC)
     &  ,XERR(NPAR_ANYLC)

      CHARACTER cfilt*1, ccid*(MXCHAR_CCID)
 
      LOGICAL ADDFLAG  ! dummy arg

c functions
      REAL*8 COVPKFLUXFUN, ANYLCFUN

C ---------------- BEGIN --------------

      IF ( N_INTERP_MJDLIST .LE. 0 ) RETURN

      CCID = SNLC_CCID
      LENCCID = INDEX(CCID,' ') - 1

c get NMJD and MJDLIST; 
      CALL GET_INTERP_MJDLIST(CCID, NMJD, MJDLIST, ADDFLAG)

      IF ( NMJD .EQ. 0 ) RETURN

      IFILT     = IFILTDEF_INVMAP_SURVEY(ifilt_obs) 
      cfilt     = filtdef_string(ifilt_obs:ifilt_obs)

      IF ( SNMJD_OUT_FILE .EQ. ' ' ) THEN
         LUN = -1
      ELSE
         LUN = LUNINTERP
      ENDIF

      DO 200 imjd = 1, NMJD

        MJD  = MJDLIST(imjd)

c IF MJD=0, then replace with PEAKMJD (Aug 20, 2012)
        IF ( MJD .LT. 1.0  ) THEN
            MJD = SNLC_SEARCH_PEAKMJD
        ENDIF

        DO ipar = 1, NPAR_ANYLC
          XVAL(ipar) = SNLC_SNANAFIT_PEAKMJD_FITPAR(ifilt,ipar)
          XERR(ipar) = SNLC_SNANAFIT_PEAKMJD_FITERR(ifilt,ipar)
        ENDDO

        COV     = COVPKFLUXFUN(ifilt_obs,MJD,MJD)
        FLUX    = ANYLCFUN(MJD,XVAL)
        FLUXERR = SQRT(COV)
       
        write(6,60) SNLC_CCID(1:LENCCID), 
     &       cfilt, MJD, FLUX, FLUXERR
60      format(T4,'INTERP-FLUX(CID=',A, '-', A,
     &         ' MJD=', F9.3, ')= ', G10.4, ' +- ', G10.4 )

        IF ( LUN .GT. 0 ) THEN
           write(LUN,70) SNLC_CCID(1:12), 
     &       cfilt, MJD, FLUX, FLUXERR
70         format('INTERP:',2x, A, 2x,A, 3x, F9.3, 2x, G12.4, G12.4)
        ENDIF

200   CONTINUE

      RETURN 
      END  ! end of SNMJD_INTERP_ANYLC

C ======================

C =======================
+PATCH,*TESTFUNS.
C =======================

+DECK,TEST_GET_SNFITSIO_INFO.
      SUBROUTINE TEST_GET_SNFITSIO_INFO()

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.

c Aug 2018
c  Test new C function GET_SNFITSIO_INFO to return 
c  current FITS file being read.

      CHARACTER VERSION*80, FILENAME_PHOT*80, FILENAME_HEAD*80
      INTEGER IFILE

C ----------- BEGIN ------------------

      if ( OPT_DEBUG == 0 ) RETURN
 
      CALL GET_SNFITSIO_INFO(VERSION,FILENAME_HEAD,FILENAME_PHOT,IFILE,
     &      80,80,80 )

      print*,' xxx =================================== '
      print*,' xxx TEST_GET_SNFITSIO_INFO for CID = ', SNLC_CCID
      print*,' xxx VERSION       = ', VERSION(1:60)
      print*,' xxx FILENAME_HEAD = ', FILENAME_HEAD(1:60)
      print*,' xxx FILENAME_PHOT = ', FILENAME_PHOT(1:60)
      print*,' xxx IFILE         = ', IFILE
      CALL FLUSH(6)

      RETURN
      END

+DECK,TESTFBIT.
      SUBROUTINE TEST_FILTBIT
      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      integer ibit
      INTEGER*8  MSK8(2)
      LOGICAL LTMP, FILTBTEST
C ----------- BEGIN -----------

      ibit = 2
      CALL FILTBSET(MSK8,ibit)
      ibit = 61
      CALL FILTBSET(MSK8,ibit)

      print*,'  MSK8=', MSK8

      LTMP = FILTBTEST(MSK8,2)
      print*,'  FILTBTEST(2) = ', LTMP
      LTMP = FILTBTEST(MSK8,3)
      print*,'  FILTBTEST(3) = ', LTMP

      LTMP = FILTBTEST(MSK8,61)
      print*,'  FILTBTEST(61) = ', LTMP
      LTMP = FILTBTEST(MSK8,62)
      print*,'  FILTBTEST(62) = ', LTMP

      CALL EXIT(EXIT_ERRCODE)
      RETURN
      END

C ======================
+DECK,TEST_MAG.
      SUBROUTINE TEST_MAG
      IMPLICIT NONE
c ------------------
c
c Jan 31, 2008: illustrate extinction calculation
c               for unwarped vs. warped SED (for cosmo paper)
c
c -----------------

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER 
     &   IFILT_OBS
     &  ,IFILT_REST1, IFILT_REST2
     &  ,I, ISTAT

      REAL*8  
     &    Z8, Z0, T8, AV8, AVWARP8, MWEBV8
     &   ,MAG8, MWXT8
     &   ,MAG8_REST1, MAG8_REST2
     &   ,AV8TMP(2)
     &   ,XMAG8_REST1, XMAG8_REST2

c function

      REAL*8  GET_MAGLC8, GET_AVWARP8
      INTEGER FILTINDX

C --------------- BEGIN --------------

      CALL prbanner ( " TEST_MAG " )

c for illustration in cosmology paper,
c commpute AV for unwarped and warped SED.

      T8          = DBLE(0.0)
      Z8          = DBLE(0.2)
      Z0          = Zat10pc
      IFILT_OBS   = FILTINDX('r ')  ! => K_Vr and V-B to warp
      IFILT_REST1 = FILTINDX('V ')
      IFILT_REST2 = FILTINDX('B ')

c xxxxxxxxxxxxxxxx
c 6/08/2009 : set values that cause 'nan' for non1a in v8_13
     
       T8 = 7.7
       mag8_rest1 = -15.58
       mag8_rest2 = -13.61
       ifilt_rest1 = 30
       ifilt_rest2 = 29

       LDMP_AVWARP = .TRUE.

       AVWARP8 = GET_AVWARP8(T8, Z0, mag8_rest1, mag8_rest2, 
     &                      ifilt_rest1, ifilt_rest2, ISTAT )

      print*,' xxxxx AVwarp8 = ', AVwarp8
      CALL EXIT(EXIT_ERRCODE)
c xxxxxxxxxxxxxxxx

c compute unextincted V-B volor
      AV8         =  0.0 
      MAG8_REST1  = GET_MAGLC8(ifilt_rest1, T8, Z0, AV8 )
      MAG8_REST2  = GET_MAGLC8(ifilt_rest2, T8, Z0, AV8 )
      MAG8_REST1  = MAG8_REST1 - MAG8_REST2
            
      AV8         = 1.0  ! test with 1 mag extinction

      print*,' '
      print*,'      rest                                 ' 
      print*,'      color        AVwarp        XV  '
      print*,' ---------------------------------------------------'

      DO I = -10, 10
        MAG8_REST2 = DBLE(I)/10.0 ! SN B mag before extinction

        AVWARP8 = GET_AVWARP8(T8, Z0, mag8_rest1, mag8_rest2, 
     &                      ifilt_rest1, ifilt_rest2, ISTAT )

        AV8TMP(1) = AVWARP8
        AV8TMP(2) = AVWARP8 + AV8

        XMAG8_REST1  = GET_MAGLC8(ifilt_rest1, T8, Z0, AV8TMP(1) )
        XMAG8_REST2  = GET_MAGLC8(ifilt_rest1, T8, Z0, AV8TMP(2) )

        write(6,23) 
     &      MAG8_REST2 - MAG8_REST1    ! unextincted color
     &     ,AVWARP8                    ! AV warp parameter
     &     ,XMAG8_REST2 - XMAG8_REST1  ! extincted R

23       format(T2,3F12.4)

      ENDDO

      print*,' '
      print*,'  TEST COMPLETE: STOP PROGRAM '
      CALL EXIT(EXIT_ERRCODE)

      RETURN
      END

C ================================
+DECK,TEST_KCOR.
      SUBROUTINE TEST_KCOR
c
c Nov 1, 2006
c Plot Kcor and AVwarp on a grid of Color vs. epoch
c in order to compare with Jha's K-corrections.
c Hard-wire Z8 and IFILT_x variables for each test-case.
c
c Also check extinction calc for each filter.
c
c Aug 27, 2009; look for Kcor-kink as Trest varies
c
c ------------------------

      IMPLICIT NONE

+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,FILTCOM.

      INTEGER IERR

      INTEGER iz, it, ic, iav
      INTEGER 
     &   ifiltr, ifilto
     &  ,ifilt_rest, ifilt_obs, istat

      REAL*8 Z8, Z0, T8, C8, AVWARP8, MAG8_a, MAG8_b, KCOR8
      REAL*8 T8obs, KCOR8_LAST, DKDZ8,  DZ8, Z8ref
      REAL*8 XT8(2)

c function
      REAL*8 GET_KCOR8, GET_AVWARP8, GET_MAGLC8, GET_SNXT8
      INTEGER FILTINDX

C ------------ BEGIN --------------  

      CALL PRBANNER("TEST_KCOR")

cc      if ( NFIT_ITERATION .LE. 0 ) RETURN

      ifilt_rest = FILTINDX('B ')
      ifilt_obs  = FILTINDX('i ')
  
      AVWARP8    = 0.5924
      Z8ref      = 0.59653
      T8obs      = 34.0144 * ( 1. + Z8ref )
      DZ8        = 0.0004

c loop over T8

      DO iz = -5, 5
         Z8 = Z8ref + DZ8 * DBLE(iz)

         T8 = T8obs/(1+Z8)
         KCOR8 = GET_KCOR8(ifilt_rest, ifilt_obs, T8, Z8, AVWARP8 )

         DKDZ8 = (KCOR8-KCOR8_LAST) / DZ8

         write(6,20) 
     &     filtdef_string(ifilt_rest:ifilt_rest)
     &    ,filtdef_string(ifilt_obs:ifilt_obs)
     &    ,Z8,T8, AVWARP8, KCOR8, DKDZ8

20       format(T5,'K_',A,A, '(Z=',F7.5,' Tr=',F7.4,
     &        ' AVwarp=',F6.3,') =',G12.5, 2x,'dK/dz=',F7.3)

         KCOR8_LAST = KCOR8
      ENDDO

      print*,' '
      print*,' ================================================ '
      print*,' '

      RETURN
      END

 
C =========================================
+DECK,TESTFUN1.
      DOUBLE PRECISION FUNCTION TESTFUN1(X)
      REAL*8 X
      TESTFUN1 = DSIN(0.5*X)
      RETURN
      END
+DECK,TESTFUN2.
      DOUBLE PRECISION FUNCTION TESTFUN2(X,Y)
      REAL*8 X,Y
      TESTFUN2 = DSIN(0.5*X) * Y
      RETURN
      END

C =======================

+PATCH,*FITUTIL.

C =======================

+KEEP,NOTES.

 General fit-related utilites to use with any fitter.
 Includes marginalization and histograms.

C ==============================================
+DECK,MNFIT_DRIVER.
      SUBROUTINE MNFIT_DRIVER ( 
     &   CID         ! (I) cand id
     &  ,NFITPAR     ! (I) number of fit parameters
     &  ,INIVAL      ! (I) initial parmater values
     &  ,INISTP      ! (I) initial step sizes (0=> fixed parameter)
     &  ,INIBND      ! (I) parameter bounds (0,0 => no bound)
     &  ,PARNAME     ! (I) list of parmater names     
     &  ,USE_MINOS   ! (I) T=> use minos
     &  ,PRINT_LEVEL ! (I) integer print level (-1=none)
     &  ,FITVAL       ! (O) final fit values
     &  ,FITERR_PLUS  ! (O) final fit errors, positive
     &  ,FITERR_MINUS ! (O) final fit errors, negative
     &  ,FITCHI2      ! (O) min chi2
     &  ,NFIXPAR      ! (O) number of fixed parameters
     &  ,ERRTYPE      ! (O) error types (MINOS vs. PARABOLIC)
     &  ,MNSTAT_COV   ! (O) status of cov matrix (see minuit manual)
     &  ,IERR         ! (O) 0=>OK
     &      )
c
c Created 2 Feb 28, 2006 by D.Cinabro and R.Kessler
c 
c Interface for minuit fitting
C
c This is a SNANA routine ... not a MINUIT routine
C
C Note that the non-integer/characater inputs are Double Precision!!!!
C For more information on using MINUIT, type minuit in Google and follor 
c the URL with cern in it.
c
c
c Aug 31,  2009: Add USE_MINOS argument.
c
c May 21, 2012: set print level using SNLCINP namelist MINUIT_PRINT_LEVEL
c
c Jan 03 2016: pass new output arg MNSTAT_COV
c
c -------------------------------------------------

      IMPLICIT NONE

c arguments

      INTEGER CID, NFITPAR, NFIXPAR, PRINT_LEVEL 

      LOGICAL USE_MINOS  ! (I) 

      DOUBLE PRECISION 
     &   INIVAL(NFITPAR)
     &  ,INISTP(NFITPAR)
     &  ,INIBND(2,NFITPAR)      ! (I) fit bounds (zero=> no bound)
     &  ,FITVAL(NFITPAR)        ! (O) final fit values
     &  ,FITERR_PLUS(NFITPAR)   ! (O) final fit errors
     &  ,FITERR_MINUS(NFITPAR)  ! (O) final fit errors
     &  ,FITCHI2                ! (O) min chi2 value

      CHARACTER PARNAME(NFITPAR)*20  ! (MXCHAR_PARNAME)

      INTEGER ERRTYPE(NFITPAR), MNSTAT_COV
      INTEGER IERR

c local var

+CDE,SNPAR.
+CDE,SNCONTCM.

      EXTERNAL FCNSNLC, USRFUN
      DOUBLE PRECISION  USRFUN

      INTEGER 
     &   IPAR, IVARBL, i, IFLAG, NARG
     &  ,NPARI, NPARX, ISTAT

      DOUBLE PRECISION 
     &   FIXLIST(NFITPAR)
     &  ,BND1, BND2
     &  ,STRATEGY, PARG
     &  ,MAXCALLS
     &  ,GRAD(NFITPAR)
     &  ,CHI2
     &  ,ARGLIST(20)
     &  ,EPLUS, EMINUS, EPARAB, GLOBCC
     &  ,FEDM, ERRDEF
     &  ,ERRSYM      ! local SYMMMETRIC fiterr

      LOGICAL LFIX

C Unit numbers for input and output

      INTEGER IUNIN,IUOUT,IUWRI
      DATA IUNIN/5/
      DATA IUOUT/6/
      DATA IUWRI/7/

C
C -------------------- BEGIN -------------------------

      IERR = 0
      NFIXPAR = 0
      FITCHI2 = 0.0
C  
C Initialize MINUIT, input unit, output unit, save unit
C

+SELF,IF=MINUIT.
      CALL MNINIT(IUNIN,IUOUT,IUWRI)

      PARG = DBLE(PRINT_LEVEL)
      CALL MNEXCM(FCNSNLC, 'SET PRI', PARG, 1, IERR, USRFUN )
+SELF.

C Define parameters in MINUIT

      DO IPAR = 1, NFITPAR

+SELF,IF=MINUIT.
         CALL MNPARM(IPAR, PARNAME(IPAR)
     &       ,INIVAL(IPAR), INISTP(IPAR)
     &       ,INIBND(1,IPAR)   ! lo-bound
     &       ,INIBND(2,IPAR)   ! hi-bound
     &       ,IERR   ) 
+SELF.
         IF ( IERR .NE. 0 ) THEN
            WRITE (6,'(A,A10,A)') '  ERROR initializing ', 
     &            PARNAME(ipar), '  with MNPARM '
            RETURN
         ENDIF

c init fit params
         FITVAL(ipar)       = 0.0
         FITERR_PLUS(ipar)  = 0.0
         FITERR_MINUS(ipar) = 0.0
         ERRTYPE(ipar)      = 0

C Set list of fixed parameters with step size = 0

         IF ( INISTP(IPAR) .EQ. 0.0 ) THEN
            NFIXPAR = NFIXPAR + 1
            FIXLIST(NFIXPAR) = DFLOAT(IPAR)
         ENDIF

      ENDDO

      CALL FLUSH(6)

c --------------------------------------------
c fix param if its step size is zero

      IF ( NFIXPAR .GT. 0 ) THEN

+SELF,IF=MINUIT.
         CALL MNEXCM(FCNSNLC,'FIX',FIXLIST, NFIXPAR,IERR,USRFUN)
+SELF.
         IF ( IERR .NE. 0 ) THEN
            WRITE (6,'(A)') '  ERROR fixing parameters'
            RETURN
         ENDIF
      ENDIF

c call FCN function with init flag: IFLAG=2
      IFLAG = 2
+SELF,IF=MINUIT.
      CALL FCNSNLC ( NFITPAR, GRAD, chi2, FITVAL, IFLAG, USRFUN )
+SELF.

C Set Strategy 2 for more accurate derivative calculation

      NARG = 1
      STRATEGY = DBLE(2.0)   ! 1=default,  2 => better results 
      print*,'  Set MINUIT STRATEGY = ', int(STRATEGY)

+SELF,IF=MINUIT.
      CALL MNEXCM(FCNSNLC,'SET STR', STRATEGY, NARG, IERR, USRFUN )
+SELF.
      MAXCALLS = dble(30000.0)

C Actually do the fit

      PRINT *,' '
      PRINT *,' ------------------------------------------------ '
 
+SELF,IF=MINUIT.
      IF ( USE_MINOS ) THEN
        PRINT *,' '
        PRINT *,'   MNFIT_DRIVER: fit with MINOS '
          CALL MNEXCM(FCNSNLC, 'MINOS', MAXCALLS, NARG, IERR, USRFUN)
        PRINT *,'  MNFIT_DRIVER: MINOS returns IERR = ', IERR
      ELSE

cc      PRINT *,'   MNFIT_DRIVER: begin fit with MIGRAD '
cc      CALL MNEXCM(FCNSNLC, 'MIGRAD', MAXCALLS, NARG, IERR, USRFUN)

        PRINT *,'   MNFIT_DRIVER: begin fit with MINIMIZE '
        CALL MNEXCM(FCNSNLC, 'MINIMIZE', MAXCALLS, 0, IERR, USRFUN)
        PRINT *,'  MNFIT_DRIVER: MIGRAD returns IERR = ', IERR
      ENDIF
+SELF.

      PRINT *,' ------------------------------------------------ '

c -------------------------------------------
c get the fit result
  
      PRINT *,' ' 
      PRINT *,'   MNFIT_DRIVER: extract fit parameters with MNPOUT' 
      CALL FLUSH(6)

      DO 44 IPAR = 1, NFITPAR

        LFIX = ( INISTP(ipar) .EQ. 0.0 ) 

+SELF,IF=MINUIT.
        CALL MNPOUT(  IPAR, PARNAME(IPAR)
     &              , FITVAL(IPAR), ERRSYM
     &              , BND1,BND2, IVARBL )

        CALL MNERRS( IPAR, EPLUS, EMINUS, EPARAB, GLOBCC )
+SELF.

c xxxxxxxxxxxxxxxxxxxxxxxx
c        print*, IPAR, ': ERR(EPARAB)=', sngl(EPARAB)
c     &            ,'  ERR(+-) = ', sngl(EPLUS), sngl(EMINUS)
c xxxxxxxxxxxxxxxxxxxxxxxxxxxxx

c take average of +- errors (note that EMINUS is negative)
c If MINOS errors are zero, then use parabolic error above.

        if ( EPLUS .GT. 0.0 .and. EMINUS .LT. 0.0 ) THEN
           FITERR_PLUS(IPAR)   = EPLUS
           FITERR_MINUS(IPAR)  = EMINUS
           ERRTYPE(ipar)       = ERRTYPE_MINOS
        else
           FITERR_PLUS(IPAR)   = +ERRSYM
           FITERR_MINUS(IPAR)  = -ERRSYM
           ERRTYPE(ipar)       = ERRTYPE_PARAB
        endif

44    CONTINUE  ! end of loop over IPAR


+SELF,IF=MINUIT.
c -------------------------------------------------------
c get chi2 and status; fill FITCHI2 return arg
c From Minuit manual, here are the ISTAT values from MNSTAT:
c
c ISTAT  meaning
c  0    Not calculated at all
c  1    Diagonal approximation only, not accurate
c  2    Full matrix, but forced positive-definite
c  3    Full accurate covariance matrix 
c          (After MIGRAD, this is the indication of normal convergence.)

      CALL MNSTAT(FITCHI2, FEDM, ERRDEF, NPARI, NPARX, ISTAT)
      MNSTAT_COV = ISTAT  ! 3=OK
+SELF.

c ----------------------------------
c Prepare contours

      DO i = 1, NPLOT_CONT
  
+SELF,IF=MINUIT.
         CALL MNCONT ( FCNSNLC
     &       , IPAR_CONT(1,i)  ! (I) 1st parameter for contour
     &       , IPAR_CONT(2,i)  ! (I) 2nd param
     &       , NPT_CONT(i)     ! (I) number of contour points
     &       , VCONT8(1,1,i)   ! (O) par1 contour array
     &       , VCONT8(1,2,i)   ! (O) par2 contour array
     &       , NPT_FOUND(i)    ! (O) 
     &       , USRFUN )
+SELF.

      ENDDO

c Stop fit and make LAST call to function

+SELF,IF=MINUIT.
      CALL MNEXCM(FCNSNLC, 'EXIT',  dble(0.0), 0, IERR, USRFUN )
+SELF.
      PRINT *,'  MNFIT_DRIVER: EXIT returns IERR = ', IERR
      CALL FLUSH(6)

c ---------------------------------
      RETURN
      END

C ===========================
+DECK,MNFIT_STOREPAR.
      SUBROUTINE MNFIT_STOREPAR(iter,IERR)
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNLCINP.
+CDE,SNANAFIT.

c
c Nov 17, 2011: replace CERNLIB's PROB with snana's PROB_CHI2NDOF
c Jan 04, 2016: protect sqrt(negative SQERR8)
c May 05, 2018: init FITERRMAT=0 instead of -9. Allows USESIM_xxx=T
c May 23, 2018: set LCFRACERRDIF_STORE(ipar)
c
c subroutine args

      INTEGER 
     &   iter   ! (I) iterationn
     &  ,IERR   ! (O) error flag; 0=> OK

c local variables

      INTEGER ipar, NDOF, ipar1, ipar2, i
      INTEGER J, JPAR(MXFITPAR), J1, J2, etmp
      REAL EPLUS, EMINUS, PCHI2
      LOGICAL LBADERR, FLOATBOTH
      
      REAL*8  
     &   CHI8, GRAD8(MXFITPAR)
     &  ,EMAT8, ERR8(2), SQERR8(2), ERR_FINAL, ERR_LAST, ERR_AVG

c function

      REAL*8   PROB_CHI2NDOF
      REAL*8   USRFUN
      EXTERNAL USRFUN

C -------------- BEGIN ------------------

      IERR = 0   ! set output flag to OK
    
c store chi2

      FITCHI2_STORE(1)     = FITCHI2_MIN ! total chi2

c get prior-chi2 using special flag

+SELF,IF=MINUIT.
      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, FITVAL(1,iter),
     &       FCNFLAG_PRIOR_ONLY, USRFUN)
+SELF.

c determine effective Ndof for prior.

      if ( CHI8 .GT. 0.01 ) then
        NDOF_PRIOR = 1
      endif

      FITCHI2_STORE(3) = CHI8  ! prior chi2
      FITCHI2_STORE(2) = 
     &     FITCHI2_STORE(1) - FITCHI2_STORE(3)  ! total - prior

c store chi2 from ln(sigma) terms
+SELF,IF=MINUIT.
      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, FITVAL(1,iter),
     &       FCNFLAG_SIGMA_ONLY, USRFUN)
+SELF.
      FITCHI2_STORE(4) = CHI8

c store number of degrees of freedom

      NDOF          = NEPOCH_FIT(0) - (NFITPAR_MN - NFIXPAR)
      NDOF_STORE(1) = NDOF + NDOF_PRIOR  ! full chi2
      NDOF_STORE(2) = NDOF               ! chi2 excluding prior
      NDOF_STORE(3) = NDOF_PRIOR         ! prior chi2 only
      NDOF_STORE(4) = 1                  ! ln(sigma)

c Convert fitchi2 into fitprobs.

      DO i     = 1, 4
        NDOF   = NDOF_STORE(i)
        CHI8   = DBLE(FITCHI2_STORE(i))

        if ( NDOF .GT. 0 .and. CHI8 .GT. 0.0 ) THEN
           PCHI2  = SNGL( PROB_CHI2NDOF(CHI8,NDOF) )
        ELSE
           PCHI2  = 1.0
        ENDIF

        FITPROBCHI2_STORE(i) = PCHI2      
        LCCHI2_STORE(i)      = FITCHI2_STORE(i)
        LCPROBCHI2_STORE(i)  = FITPROBCHI2_STORE(i)
      ENDDO


c now store fit parameters.

      DO 444 ipar = 1, NFITPAR_MN

         FLOATPAR(ipar) = ( INISTP(ipar) .NE. 0.0 )

c if there are no floated params, then set errors
c to user-initialized values: FITERR(ipar)

         if ( NFIXPAR .EQ. NFITPAR_MN  ) then
           FITERR_PLUS(ipar,iter)   = FITERR(ipar,iter)
           FITERR_MINUS(ipar,iter)  = FITERR(ipar,iter)
         endif

         EPLUS  = FITERR_PLUS(ipar,iter) 
         EMINUS = ABS ( FITERR_MINUS(ipar,iter) )

c if fit error is way too small, set error to INISTP 
c and set error type to BAD

         LBADERR = Eplus  .LT. ERRMAX_BAD(ipar)
     &     .and.   Eminus .LT. ERRMAX_BAD(ipar)

c 9/22/2007: allow tiny errors when the exposure time is large.
         IF ( SIM_EXPOSURE_TIME(1) .GT. 10.0 ) then
            LBADERR = .FALSE.
         endif

c set bad-error flag of fit-value has not moved from initial value.
         LBADERR = LBADERR .or. 
     &            ( INIVAL(ipar) .EQ. FITVAL(ipar,iter) )

         if ( FLOATPAR(ipar) .and. LBADERR ) then
            FITERR_PLUS(ipar,iter)  = +INISTP(ipar)
            FITERR_MINUS(ipar,iter) = -INISTP(ipar)
            EPLUS              = FITERR_PLUS(ipar,iter) 
            EMINUS             = ABS ( FITERR_MINUS(ipar,iter) )
            ERRTYPE(ipar)      = ERRTYPE_BAD
         endif

         FITERR_RATIO(ipar,iter)   = EPLUS / EMINUS
         FITERR(ipar,iter)         = 0.5 * ( EPLUS + EMINUS )

         FITVAL_STORE(ipar)    = FITVAL(ipar,iter)
         FITERR_STORE(ipar)    = FITERR(ipar,iter)
         INIVAL_STORE(ipar)    = INIVAL(ipar)
         ERRTYPE_STORE(ipar)   = ERRTYPE(ipar)
      
c store FITVCAL in 'LC' array (might get over-written later by PDFVAL

         LCVAL_STORE(ipar) = FITVAL_STORE(ipar)
         LCERR_STORE(ipar) = MIN(99.9,FITERR_STORE(ipar))

c print results for floated parameters only

         if ( FLOATPAR(ipar)
     &     .or. NFIXPAR .EQ. NFITPAR_MN 
     &     .or .IPAR    .EQ. 1             ! IPAR_ITER - Nov 2014
     &           ) then
            CALL PR_FITPAR(SNLC_CCID, iter, ipar, 'fit' )
         endif

c do stuff on last iteration
         IF ( iter .EQ. NFIT_ITERATION .and. FLOATPAR(ipar) ) then
            etmp = ERRTYPE(ipar)
            NERRTYPE(etmp) = NERRTYPE(etmp) + 1

            if ( iter > 1 ) then
              ERR_FINAL = FITERR(ipar,iter)
              ERR_LAST  = FITERR(ipar,iter-1)
              ERR_AVG   = 0.5*(ERR_FINAL+ERR_LAST)
              if ( ERR_AVG > 1.0E-12 ) then
                LCFRACERRDIF_STORE(ipar) = (ERR_FINAL-ERR_LAST)/ERR_AVG
              endif
            endif
         ENDIF

444   CONTINUE   ! end loop over IPAR



c ----------------------
c 9/29/2007: get error matrix

+SELF,IF=MINUIT.
      IF ( LREPEAT_MINOS ) MNSTAT_COV = MNSTAT_COV + 10
      CALL MNEMAT(FITERRMAT_SPARSE,MXFITPAR)
+SELF.

c compute correlation matrix from error matrix

      J = 0
      DO ipar = 1, NFITPAR_MN
        if ( FLOATPAR(ipar) ) then
           j = j + 1
           JPAR(ipar) = j
        endif
      ENDDO

      DO ipar1 = 1, NFITPAR_MN
      DO ipar2 = 1, NFITPAR_MN

         FITERRMAT(ipar1,ipar2) = 0.0
         FITCORMAT(ipar1,ipar2) = 0.0
 
         FLOATBOTH = ( FLOATPAR(ipar1) .and. FLOATPAR(ipar2) )
         if ( FLOATBOTH ) then
           J1 = JPAR(ipar1)
           J2 = JPAR(ipar2)
           EMAT8     = FITERRMAT_SPARSE(J1,J2)
           SQERR8(1) = FITERRMAT_SPARSE(J1,J1)
           SQERR8(2) = FITERRMAT_SPARSE(J2,J2)

           IF  ( SQERR8(1) > 0.0 .and. SQERR8(2) > 0.0 ) then
             ERR8(1) = sqrt ( SQERR8(1) )
             ERR8(2) = sqrt ( SQERR8(2) )
             FITCORMAT(ipar1,ipar2) = EMAT8/(ERR8(1) * ERR8(2) )
             FITERRMAT(ipar1,ipar2) = EMAT8
           else
+SELF,IF=XXXDBUG.
             print*,' xxx ==================================== '
             print*,' xxx CID = ', SNLC_CCID
             print*,' xxx ipar1,ipar2 = ', ipar1, ipar2
             print*,' xxx SQERR = ', SQERR8
             call flush(6)
+SELF.
           endif

         endif
      ENDDO
      ENDDO

      RETURN
      END   ! end MNFIT_STOREPAR

C ======================================
+DECK,ERRTYPE_STR.
      FUNCTION ERRTYPE_STR(ERRTYPE)
      IMPLICIT NONE

      INTEGER ERRTYPE  ! (I) error type

      CHARACTER ERRTYPE_STR*1

+CDE,SNPAR.

C --------------- BEGIN -------------

      if ( ERRTYPE .EQ. ERRTYPE_MINOS ) then
        ERRTYPE_STR = 'M'
      else if ( ERRTYPE .EQ. ERRTYPE_PARAB ) then
        ERRTYPE_STR = 'P'
      else if ( ERRTYPE .EQ. ERRTYPE_MARG ) then
        ERRTYPE_STR = 'm'
      else if ( ERRTYPE .EQ. ERRTYPE_BAD ) then
        ERRTYPE_STR = '?'
      else if ( ERRTYPE .EQ. 0 ) then
        ERRTYPE_STR = ' '
      else
        ERRTYPE_STR = '?'
      endif

      RETURN
      END

C =======================================
+DECK,PR_FITPAR.
      SUBROUTINE PR_FITPAR(CCID, iter, ipar, type )
c
c standard print-line for fit-result or pdf-result.
c
c type = 'fit' : uses current FITVAL and FITERR
c type = 'pdf' : uses current PDFVAL and PDFERR
c
c Note that ITER is used only for 'fit' option
c
c Jun 2013: return if we are no longer in VERBOSE mode and iter < NFIT_ITER
c            (to reduce output for BIG jobs)
c
      IMPLICIT NONE

c subroutine args

      INTEGER  ITER, IPAR  ! (I) SN cand id and IPAR to print
      CHARACTER 
     &    CCID*(*)   ! (I) char string cand id
     &   ,type*(*)   ! (I) 'fit' or 'pdf' type of result

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER LL
      REAL*8  VAL, ERR
      LOGICAL LQUIET
      CHARACTER STRING_VAL*12

c function
      CHARACTER ERRTYPE_STR*1

C --------------- BEGIN -------------

      LQUIET = ( N_SNLC_FIT >  NFIT_VERBOSE )
      IF ( LQUIET .and. ITER < NFIT_ITERATION ) RETURN
      
      IF ( type .EQ. 'fit' ) then
        VAL = FITVAL(ipar,iter)
        ERR = FITERR(ipar,iter)
      ELSE IF ( type .EQ. 'pdf' ) then
        VAL = PDFVAL(ipar)
        ERR = PDFERR(ipar)
      ELSE

      ENDIF

c write par value into string using format
      WRITE(STRING_VAL,211) VAL
211   FORMAT(G11.5)
      IF ( VAL > 1.0E4 ) THEN  ! this is PEAKMJD
        WRITE(STRING_VAL,212) VAL
212     FORMAT(F11.3)
      ENDIF

      LL = INDEX(CCID,' ') - 1
      IF ( LL .LE. 0 ) LL = MXCHAR_CCID
      WRITE (6,430)  CCID(1:LL), type, IPAR
     &    , PARNAME_STORE(IPAR), STRING_VAL, ERR
     &    , ERRTYPE_STR ( ERRTYPE(IPAR) )

 430    FORMAT (T8,'CID ',A,2x, A,'par(', I2, '):',A14,' = ', 
     &                 A11,' +/- ', G10.4, '(',A,')' )

      CALL FLUSH(6)

      RETURN
      END    ! end of PR_FITPAR

C ==============================
+DECK,BOOK_CONTOUR.
      SUBROUTINE BOOK_CONTOUR ( h1,h2, Npt, IPAR1, IPAR2 )
c
c Store information about this contour.
c The contour is made with MNCONT after 
c the fit has finished.
c
c The contour results are booked in h1,h2 
c when the user calls PLOT_CONTOUR.
c
c ----------------------------------

      IMPLICIT NONE

      INTEGER 
     &    h1,h2   ! (I) hbook ids for storage (in PLOT_CONTOUR)
     &   ,NPT     ! (I) Number of points for contour
     &   ,IPAR1   ! (I) 1st param index 
     &   ,IPAR2   ! (I) 1st param index 

c local var

+CDE,SNPAR.
+CDE,SNCONTCM.
+CDE,SNANAFIT.

      INTEGER N, L1, L2

C ------------- BEGIN -------------

      NPLOT_CONT = NPLOT_CONT + 1
      N = NPLOT_CONT

      NPT_CONT(N)   = NPT
      HID_CONT(1,N) = h1
      HID_CONT(2,N) = h2

      IPAR_CONT(1,N) = ipar1
      IPAR_CONT(2,N) = ipar2

      L1 = INDEX ( PARNAME_STORE(ipar1), ' ') -1 
      L2 = INDEX ( PARNAME_STORE(ipar2), ' ') -1 

      write(6,20) PARNAME_STORE(ipar1)(1:L1), 
     &            PARNAME_STORE(ipar2)(1:L2), NPT

20    format(T5,'BOOK_CONTOUR for ',A,' vs. ', A,
     &    ' with ',I3,' points. ' )

      RETURN
      END


C ======================================
+DECK,PDF_INIT.
      SUBROUTINE PDF_INIT()
c
c Created Nov 24, 2009 by R.Kessler
c
c Init PDFXXX arrays before marginalizing or before running
c the MCMC option.  The main issue here is to make sure that
c fixed parameters (like ITER) get transfered to 
c the PDFVAL array.
c
c ---------------------------
      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

c local var
      INTEGER IPAR, IPAR2

C --------------- BEGIN -----------------

      DO 40 ipar = 1, NFITPAR_MN
         PDFVAL(ipar) = FITVAL(ipar,NFIT_ITERATION)

c reset PDF-marginalized values for floated parameters
         IF ( FLOATPAR(ipar) ) then
            PDFERR(ipar)  = -9.0 
            PDFVAL(ipar)  = -9.0 
         ENDIF

c zero the covariance matrix

         DO ipar2 = 1, NFITPAR_MN
           PDFERRMAT(ipar,ipar2) = 0.0
           PDFCORMAT(ipar,ipar2) = 0.0
         ENDDO
40    CONTINUE

      RETURN
      END
C ======================================
+DECK,PDF_STORE.
      SUBROUTINE PDF_STORE()
c
c Created Nov 11, 2009 by R.Kessler
c 
c Utility to store marginalized/MCMC PDF values,
c and re-compute chi2 and fit-probs.
c [Code moved from end of MARG_DRIVER]
c
c Nov 17, 2011: replace CERNLIB's PROB() with PROB_CHI2NDOF
c
c -----------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

c local var

      INTEGER IPAR, NDOF, i

      DOUBLE PRECISION
     &    GRAD8(MXFITPAR)
     &   ,CHI8, USRFUN
 
      REAL  PCHI2
      EXTERNAL USRFUN 

c function
      REAL*8 PROB_CHI2NDOF

C ----------------- BEGIN -----------

c print/store results

      DO 30 ipar = 1, NFITPAR_MN

         PDFVAL_STORE(ipar)   = PDFVAL(ipar)
         PDFERR_STORE(ipar)   = PDFERR(ipar)
         PDFPROB2_STORE(ipar) = PDFPROB2(ipar)

c over-write LCVAL[ERR] array with pdf-avarges

         LCVAL_STORE(ipar) = PDFVAL_STORE(ipar)
         LCERR_STORE(ipar) = MIN(99.9,PDFERR_STORE(ipar))

         if ( .NOT. FLOATPAR(ipar)  ) goto 30

         CALL PR_FITPAR( SNLC_CCID, 0, ipar, 'pdf' )
         CALL FLUSH(6)

30    CONTINUE

c ----------------------------------------------------
c re-compute chi2, prior-chi2 and prob with marginalized values.

c start with PRIOR-only chi2.
      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, PDFVAL,
     &       FCNFLAG_PRIOR_ONLY, USRFUN)
      LCCHI2_STORE(3) = CHI8

c now get contribution from ln(sigma)-terms

      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, PDFVAL,
     &       FCNFLAG_SIGMA_ONLY, USRFUN)
      LCCHI2_STORE(4) = CHI8

c Now get full chi2 ...

      CALL FCNSNLC(NFITPAR_MN, GRAD8, CHI8, PDFVAL,
     &      FCNFLAG_LAST, USRFUN)
      LCCHI2_STORE(1) = CHI8

c data-only chi2 if full-prior chi2.
      LCCHI2_STORE(2) = CHI8 - LCCHI2_STORE(3)

c compute fit-probs.

      DO i     = 1, 4
        chi8   = LCCHI2_STORE(i)
        NDOF   = NDOF_STORE(i)

        if ( NDOF .GT. 0 .and. CHI8 .GT. 0.0 ) then
           PCHI2  = SNGL( PROB_CHI2NDOF(CHI8,NDOF) )
        else
           PCHI2 = 1.0
        endif

        LCPROBCHI2_STORE(i) = PCHI2
      ENDDO

      CALL FLUSH(6)

      RETURN
      END

 
C =============================================
+DECK,RDMCMCNML.   
      SUBROUTINE RDMCMCNML(IERR)   
      IMPLICIT NONE   
c   
c Created Nov 11, 2009 by R.Kessler   
c Read optional &MCMCINP namelist.   
c If &MCMCINP is not in the namelist file,   
c just exit quietly. If MCMCNML is there,   
c read it and print a few comments   
c     
c --------------------------   
   
+CDE,SNDATCOM.   
+CDE,SNLCINP.   
+CDE,MCMCCOM.   
+CDE,MCMCTUP.
   
      INTEGER IERR   ! 0=>OK,  else error   
   
c local ars   
   
      integer LL, iocheck, ISEED

      EXTERNAL RANDOMINIT
   
C -------------- BEGIN -----------   
      IERR = 0   
   
c ----------------------------------------   
c set namelist defaults   
  
      NMCMC_EVAL      = 10000   
      IMCMC_FLAG      = -1   
      NMCMC_CHAINS    = 1   
      NMCMC_BURN      = 1000  
      MCMC_NSIG_STEP  = 0.5   
      CHOPT_MCMC      = ''   
      LMCMC           = .FALSE.   
      LTUP_MCMC       = .FALSE.         
      IMCMC_STORE     = 1   
      NSIG_MCMC_START = 3.0  
  
c misc. init
      NCALL_MCMCTUP = 0
c --------------------------------   
   
      LL = INDEX(nmlfile,' ' ) - 1   
   
      OPEN (   
     &    UNIT   = LUNNML   
     &   ,file   = nmlfile   
     &   ,status = 'OLD'   
     &   ,ERR    = 900    
     &       )   
   
c try reading MCMCINP; if not there, just return quietly.   
c Danger here is that a namelist bug is not distinguished   
c from a missing namelist.   
   
      READ ( LUNNML, NML = MCMCINP, ERR = 900, IOSTAT = iocheck )         
      CLOSE ( UNIT = LUNNML ) 

      if ( iocheck .NE. 0 ) return   
   
      CALL PRBANNER ( " FOUND and READ MCMCINP NAMELIST. " )   
   
         
      WRITE ( 6 , NML = MCMCINP )   
         
c check for namelist over-rides from command line.   
   
      CALL MCMCINP_OVERRIDE(IERR)   
        IF ( IERR .NE. 0 ) RETURN   
   

      IF ( LMCMC ) THEN
        ISEED = 12345
        CALL randominit(ISEED)  ! init randoms via C interface
      ENDIF

C #################################################   
   
         GOTO 999   
   
C #################################################   
   
900   CONTINUE   
      C1err = 'Could not read  &MCMCINP namelist '   
      C2err = 'Check ' // nmlfile   
      CALL  MADABORT("RDMCMCNML", C1ERR, C2ERR)   
    
999   CONTINUE
      RETURN   
      END  ! end of RDMCMCNML   


C =============================================
+DECK,MCMC_DRIVER.   
      SUBROUTINE MCMC_DRIVER(HOFF_MARG
     &     , NMCMC_CHAINS   
     &     , NMCMC_EVAL   
     &     , NMCMC_BURN   
     &     , LTUP_MCMC   
     &     , IMCMC_STORE   
     &     , MCMC_NSIG_STEP   
     &     , NSIG_MCMC_START   
     &     )   
c   
c Created Nov 2009 by B. Dilday; 
c installed in snana Nov 2009 by R.Kessler   
c Markov Chain Monte Carlo driver   
c   
c   
c Oct 1 2012 RK replace HBOOK1 and HFILL with LCPLOT utility
c
c Feb 10, 2012 RK - comment out call to MCMCTUP until it replaces
c                   CERNLIB calls with SNTABLE_xxx functions
c  
c -------------------------------------   
   
      IMPLICIT NONE   
+CDE,SNDATCOM.    
+CDE,SNANAFIT.
+CDE,SNLCINP.   
+CDE,FILTCOM.   
+CDE,MCMCTUP.  
 
c declare subroutine args   
   
      INTEGER HOFF_MARG    ! (I) hbook offset   
      INTEGER NMCMC_CHAINS ! (I) number of chains to run (per SN)   
      INTEGER NMCMC_EVAL   ! (I) number of evaluations (per chain, per SN)   
      INTEGER NMCMC_BURN   ! (I) size of burn in   
      LOGICAL LTUP_MCMC    ! (I) store mcmc in a ntuple?   
      INTEGER IMCMC_STORE  ! (I) if ltup_mcmc set, store only every IMCMC_STORE values   
      REAL MCMC_NSIG_STEP  ! (I)
      REAL NSIG_MCMC_START ! (I) perturb MCMC starting point from minuit max-likelihood value   
    
c local variables   
      INTEGER iv   
     &     ,cid  
     &     ,idum   
     &     ,imcmc   
     &     ,IFLAG   
     &     ,NVAR   
     &     ,IPAR   
     &     ,JPAR  
     &     ,oset   
     &     ,ichain   
     &     ,jmcmc   
     &     ,NMCMC_TOT   
     &     ,NMCMC_TOT_EVALS   
     &     ,IERR   
     &     ,nvtot  
     &     ,hid  
     &     ,nbin  
     &     ,LL  
  
      CHARACTER sdir*20  
     &     , subdirname*40  
     &     , topdir*20  
     &     ,chis*80  
  
      LOGICAL LDMP / .FALSE. /   
       
      REAL  XNTUP(MXNTVAR) 
     &     ,MCMC_STORE(MXFITPAR, MAX_NMCMC_TOT) 
       
      REAL pchi2 , dum4, wgt
     &     ,xmin(MXFITPAR), xmax(MXFITPAR)  
       
      REAL*8 CHI2    
     &     , XVAL(MXFITPAR)     ! fit parameters    
     &     , SVAL(MXFITPAR)     ! fit parameter errors   
     &     , MVAL(MXFITPAR)     ! fit parameters     
     &     , GRAD8(MXFITPAR)   
c     &     ,PDFSUM_GRID(MXGRID,MXFITPAR) ! PDF vs. par to plot 1-d pdf   
     &     ,MCMC_DENOM8   
     &     ,CUR_DENOM8  
     &     ,SQERR  
  
      REAL*8 
     &      MCMC_SUM(MXFITPAR)   
     &     ,MCMC_SUM2(MXFITPAR, MXFITPAR)   
     &     ,MCMC_MEAN(MXFITPAR)  
     &     ,MCMC_SIGMA(MXFITPAR)  
  
c functions   
      REAL*8 PROB   
      DOUBLE PRECISION USRFUN, GAUSSRAN 
   
      INTEGER  MCMCFUN   
      EXTERNAL USRFUN   
   
C ------------------- BEGIN ---------------------   
   
      print*, ' '   
      print*,'  MCMC_DRIVER called for CID=', SNLC_CCID
      CALL FLUSH(6)   
   
      NMCMC_TOT = NMCMC_EVAL*NMCMC_CHAINS   
      NMCMC_TOT_EVALS = NMCMC_TOT*N_SNLC   

c init PDFVAL = FITVAL so that fixed params get transfered.
      CALL PDF_INIT()
   
c there seems to be a limit for number of values that can be    
c stored in an ntuple; abort right away if LTUP is set,    
c and NMCMC_TOT_EVALS is larger than this   
c the limit may be system dependent??  
 
      IF ( NMCMC_TOT_EVALS/IMCMC_STORE .GT. MAX_NMCMC_TOT .AND.  
     &     LTUP_MCMC ) THEN   
         c1err = "NMCMC_TOT_EVALS is too big!"   
         write(c2err,660) NMCMC_TOT, MAX_NMCMC_TOT    
660      format('NMCMC_TOT=',I10,' exceed limit of ', I8 )   
         CALL MADABORT( "MCMC_DRIVER", c1err, c2err )   
      ENDIF   
  
c book ntuple here  
  
      IF ( LTUP_MCMC ) THEN  
cc         CALL MCMCTUP(0, MCMCNTUPN)  
      ENDIF  
  
c compute denominator for computing mean, sigma and do a    
c sanity check on length of burn-in   
   
      if ( NMCMC_BURN .GE. NMCMC_EVAL ) THEN   
         c1err = "NMCMC_BURN cannot be greater than NMCMC_EVAL!"   
         c2err = " "   
         CALL MADABORT( "MCMC_DRIVER", c1err, c2err )   
      ELSE   
         MCMC_DENOM8 = DBLE((NMCMC_EVAL-NMCMC_BURN)*NMCMC_CHAINS)   
         wgt = 1.0/MCMC_DENOM8  
      ENDIF   
   
      iflag = FCNFLAG_USER   
c      iflag = 4   
      nvar = NFITPAR_MN    
   
      IF ( LDMP ) THEN   
        print*,'nmcmc= ', nmcmc_eval   
        print*,'nvar= ', nvar   
      ENDIF   
   
      inival(1) = 1   
      inival(9) = 0.05   
   
      DO 51 ipar = 1, nvar   
         xval(ipar) = FITVAL_STORE(ipar)    
         sval(ipar) = FITERR_STORE(ipar)   
         mval(ipar) = xval(ipar)   
c         xval(ipar) = xval(ipar) 
c     &     + sval(ipar)*NSIG_MCMC_START*GAUSSRAN()    
 51   CONTINUE   
   
      call fcnsnlc(nvar, grad8, chi2, xval, iflag, usrfun)   
   
      IF ( LDMP ) THEN   
        print*,'fcnsnlc= ', chi2   
        print*,'iflag= ',iflag   
c      idum = testy(nvar, grad8, chi2, xval, sval, iflag, usrfun)   
        print*,'idum fortran= ', idum   
      ENDIF   
   
c     initialize sumations to 0   
c     initialize xmin and xmax 
      DO ipar = 1, nvar   
         xmin(ipar) =  9E9 
         xmax(ipar) = -9E9 
         MCMC_SUM(ipar) = 0.0   
         DO jpar = 1, nvar              
            MCMC_SUM2(ipar, jpar) = 0.0   
         ENDDO   
      ENDDO  
  
      CUR_DENOM8 = 0.0  
   
c loop over number of chains   
      do ichain = 1, NMCMC_CHAINS   
         oset = (ichain-1)*nmcmc_eval   
   
c     choose a new starting point   
         DO 52 ipar = 1, nvar   
   
            if ( .not. FLOATPAR(ipar) ) goto 52   
            xval(ipar) = FITVAL_STORE(ipar)    
            sval(ipar) = FITERR_STORE(ipar)   
            xval(ipar) = xval(ipar) + 
     &         sval(ipar)*NSIG_MCMC_START*GAUSSRAN(1)
c     initialize the chi**2 for passing to snfit_mcmc_   
            call fcnsnlc(nvar, grad8, chi2, xval, iflag, usrfun)    
 52      CONTINUE   
   
c     loop over number of evaluations per chain   
         do jmcmc = 1, nmcmc_eval   
            imcmc = oset + jmcmc   
   
               idum = mcmcfun(nvar, chi2,    
     &              mval, xval, sval, iflag   
     &              , usrfun   
     &              )   
  
       IF ( LDMP ) THEN   
c       IF ( LDMP .or. .not. LDMP ) THEN   
          DO jpar = 1, nvar  
             print*,'ipar= ', jpar, ' val= ', xval(jpar)                 
             CALL FLUSH(6)  
          ENDDO  
       ENDIF  
c     now values have been returned   
c     if we are not still in burn-in phase, then add to the mean and sigma sumations, fill pdf histograms...   
               IF ( jmcmc .GT. NMCMC_BURN ) THEN   
                  CUR_DENOM8 = CUR_DENOM8 + 1  
                  DO ipar = 1, nvar   
                     IF ( FLOATPAR(ipar) ) THEN  
                         
                        dum4 = sngl(xval(ipar)-mval(ipar))  
                         
                        IF ( dum4 .GT. xmax(ipar) ) THEN 
                           xmax(ipar) = dum4 
                        ENDIF 
                         
                        IF ( dum4 .LT. xmin(ipar) ) THEN 
                           xmin(ipar) = dum4 
                        ENDIF 
 
c     fill after fit is done, so that we know the min, max  
c     hid = HOFF_MARG + ipar  
c     CALL HFILL(hid, dum4, 0.0, wgt)  
                         
                        MCMC_STORE(ipar, int(CUR_DENOM8)) = xval(ipar) 
  
                        MCMC_SUM(ipar)  = MCMC_SUM(ipar)  + xval(ipar)   
                          
                        DO jpar = 1, nvar  
                           IF ( FLOATPAR(jpar) ) THEN  
                              MCMC_SUM2(ipar, jpar) =   
     &                             MCMC_SUM2(ipar, jpar)   
     &                             + xval(ipar)*xval(jpar)   
                                
                           ENDIF ! jpar is floated  
                        ENDDO   ! jpar  
                     ENDIF      ! ipar is floated  
                  ENDDO         ! ipar  
               ENDIF            ! jmcmc<nburn  
                 
c     check if we should fill the ntuple  
               if ( LTUP_MCMC .AND. mod(imcmc, IMCMC_STORE)==0) THEN   
c     need to fill the ntuple value array before calling MCMCTUP  
                  iv = 0  
                  DO ipar = 1, mxfitpar  
                     if ( FLOATPAR(ipar) ) THEN  
                        iv = iv + 1  
                        mcmctupvals(iv) = xval(ipar)  
                     ENDIF           
                  ENDDO  
c     we need the chi2 value  
                  iv = iv + 1  
                  mcmctupvals(iv) = chi2  
           
c     number of degrees of freedom  
                  iv = iv + 1  
                  mcmctupvals(iv) = NDOF_STORE(2)  
  
c     mcmc index           
                  iv = iv + 1  
                  mcmctupvals(iv) = float(imcmc)  
           
c     was the new point accepted?   
                  iv = iv + 1  
                  mcmctupvals(iv) = float(idum)  
  
c     done  
                    
cc                  IF ( LTUP_MCMC ) CALL MCMCTUP(1, MCMCNTUPN)  
               ENDIF  
                 
               if ( mod(imcmc, 2000) .EQ. 0 ) then   
                  print*, '     imcmc= ', imcmc, ' / ', nmcmc_tot   
                  call flush(6)   
               endif   
            enddo               ! loop over evaluations   
         enddo                  ! loop over chains   
   
c     now compute mean, sigma, fill marg arrays, etc...   
         IERR = 0   
   
c     mean of distribution for each floated par  
         DO ipar = 1, nvar   
            if ( FLOATPAR(ipar) ) THEN  
               MCMC_MEAN(ipar) = MCMC_SUM(ipar)/MCMC_DENOM8    
               PDFVAL(ipar) = MCMC_MEAN(ipar)  
            ENDIF  
         ENDDO  
           
c     elements of covariance matrix  
         DO ipar = 1, nvar   
         if ( FLOATPAR(ipar) ) THEN  
            DO jpar = 1, nvar   
               if ( FLOATPAR(jpar) ) THEN  
                  SQERR = MCMC_SUM2(ipar,jpar)/MCMC_DENOM8   
     &                 -MCMC_MEAN(ipar)*MCMC_MEAN(jpar)   
                  PDFERRMAT(ipar, jpar) = sngl(SQERR)  
               ENDIF   
            ENDDO  
         ENDIF  
      ENDDO  
        
c     check that diagonal elements are >0  
      DO ipar = 1, nvar  
         SQERR = PDFERRMAT(ipar, ipar)  
         IF ( SQERR .GE. 0.0 ) THEN   
            MCMC_SIGMA(ipar) = SQRT(SQERR)             
            PDFERR(ipar) = MCMC_SIGMA(ipar)  
         ELSE   
            write(c1err,666) PARNAME_STORE(IPAR), SQERR, SNLC_CCID
 666        format('SQERR(', A, ') = ', G12.4,'  for CID=',A )   
            IERR = -1   
            MCMC_SIGMA(ipar) = -SQRT(ABS(SQERR))   
         ENDIF   
      ENDDO  
  
      DO ipar = 1, nvar   
         if ( FLOATPAR(ipar) ) THEN  
            DO jpar = 1, nvar   
               if ( FLOATPAR(jpar) ) THEN  
                  SQERR = MCMC_SUM2(ipar,jpar)/MCMC_DENOM8   
     &                 -MCMC_MEAN(ipar)*MCMC_MEAN(jpar)   
                  PDFERRMAT(ipar, jpar) = SQERR  
                  PDFCORMAT(ipar, jpar) = PDFERRMAT(ipar, jpar)/  
     &                 (PDFERR(ipar)*PDFERR(jpar))  
               ENDIF   
            ENDDO  
         ENDIF  
      ENDDO  
  
c     --------------------------- 
c     book 1d pdfs here  
      nbin = 41  
      IF ( HOFF_MARG .GT. 0 ) THEN  
         DO ipar = 1, nvar   
            if ( FLOATPAR(ipar) ) THEN   
               hid = HOFF_MARG + ipar  
               LL = index ( PARNAME_STORE(ipar), ' ' ) - 1  
               write(chis,21)    
     &              PARNAME_STORE(IPAR)(1:LL)  
     &              , PARNAME_STORE(IPAR)(1:LL)  
     &              , SNLC_CCID
                
 21            format(' margin. PDF(',A,'-',A,'?fit!) for CID=',A6)  
            ENDIF  
         ENDDO  
      ENDIF  
              
c     store results and print to screen   
      CALL PDF_STORE()
        
      IF ( IERR .LT. 0 ) THEN   
         c2err = 'Check MCMC error calc.'   
         CALL MADABORT( "MCMC_DRIVER", c1err, c2err )   
      ENDIF   
   
      RETURN   
      END   
C =============================================
+DECK,MCMCFUN.   
      INTEGER FUNCTION MCMCFUN(nvar, chi2,    
     &     mval, xval, sval, iflag, usrfun)   
         
c Created Nov 2009 by B.Dilday   
c   
c   
c
c This function constitutes one step of the MCMC algorithm.
c The current parameters and the associated chi**2 value are 
c passed in 'xval' and 'chi2'.  A new set of parameters is 
c generated from a proposal distribution,  and accepted
c with probability equal to the the ratio of the probabilities  
c associated with each chi**2 value.  The proposal distribution 
c is a gaussian with a diagonal covariance  matrix and with a 
c step size in each dimension proportional to the estimated 
c error (e.g., from minuit minimization) on the parameter 
c (passed in 'sval'). the proportionality constant is given 
c by the global variable 'MCMC_NSIG_STEP'. The proposal
c distribution is independent of the current values of the 
c parameters.  If the proposed point is accepted, then the 
c values are returned in 'xval' and the function returns 1
c (0 otherwise).
c Possible improvements:
c - use a non-diagonal covariance matrix
c 
c
c Jan 2013 RK - replace CERNLIB random generator with 
c               sntools random generators: snran1 & gaussran().
c               WARNING - not tested !!!
c -----------------------------   
         
      IMPLICIT NONE   
   
+CDE,SNDATCOM.    
+CDE,SNANAFIT.
+CDE,SNLCINP.   
+CDE,FILTCOM.   
+CDE,MCMCCOM.   
         
c declare function args   
   
      INTEGER nvar ! (I) number of variables   
      REAL*8 CHI2  ! (I/O) chi**2 value   
      REAL*8 XVAL(MXFITPAR) ! (I/O) parameter values   
      REAL*8 SVAL(MXFITPAR) ! (I) parameter errors   
      REAL*8 MVAL(MXFITPAR) ! (I) parameter starting value   
      INTEGER IFLAG         ! (I) input option   
      DOUBLE PRECISION USRFUN ! (I) optional user function   
   
c misc. args   
   
      EXTERNAL USRFUN   
   
      REAL*8 GRAD8(MXFITPAR)   
   
      INTEGER IMNFLAG   
     &     , ipar, itest, ilist
   
      REAL*8 XVAL_SV(MXFITPAR)   
     &     , delchi2, sig   
     &     , c1, c2, gval    
     &     , rtest, rtest2   
     &     , nsig8, prob8   
   
c randon generators in sntools.c (RK - Jan 2013)
      REAL*8  FLATRAN1, GAUSSRAN

C ===========================================   
C ------------------- BEGIN -----------------   
C ===========================================   
      IMNFLAG = 90   
      nsig8 = MCMC_NSIG_STEP   
   
      c1 = chi2   
   
      DO ipar = 1, NVAR   
         XVAL_SV(ipar) = XVAL(ipar)   
      ENDDO   
   
      ILIST = 1
      DO ipar = 1, NVAR   
         sig = SVAL(ipar)   
c         IF ( sig .GT. 1E-9 ) THEN   
c heres a better way to see if the variable is floated...   
         IF ( FLOATPAR(ipar) ) THEN   
            gval = GAUSSRAN(ILIST)   
            XVAL(ipar) = XVAL(ipar) + gval*sig*nsig8   
         ENDIF   
      ENDDO   
   
      CALL FCNSNLC(nvar, grad8, chi2, xval, imnflag, usrfun)   
      c2 = chi2   
      delchi2 = c2-c1   
      prob8 = DEXP(-0.5*delchi2)   

      rtest = FlatRan1();   ! RK - Jan 2013
      rtest2 = -2.0*DLOG(rtest)   
   
      itest = 0   
      IF ( rtest2 .GT. delchi2 ) THEN   
         itest = 1   
      ENDIF   
   
      IF ( itest .GT. 0 ) THEN   
         chi2 = c2   
         c1 = c2   
      ELSE   
         DO ipar = 1, NVAR   
            XVAL(ipar) = XVAL_SV(ipar)   
         ENDDO   
         chi2 = c1   
      ENDIF   
   
      MCMCFUN = itest   
      RETURN    
      END   

C =======================================
+DECK,MARG_DRIVER.
      SUBROUTINE MARG_DRIVER( HOFF_MARG, OPT, 
     &           MAX_INTEGPDF, NGRID_FINAL, NSIGMA)
c
c Created Aug 3, 2006 by R.Kessler
c
c Utility to compute pdf-averaged quantity for each fitpar.
c
c Call this routine AFTER fit is done ...
c this routine uses current FITVAL and FITERR,
c and fills PDFVAL(ipar) and PDFERR(ipar).
c
c Histograms book/filled:
c   HOFF:         PDF value for each FCNPDF function call
c   HOFF + ipar : 1-dim PDF distribution for each fitted ipar
c
c
c  May 5, 2007: fix dumb bug. Need to init PDVAL(ipar) = FITVAL(ipar)
c               before integration to make sure that fixed parameters
c               are set in PDFVAL
c
c Oct 16, 2009: call INTEGPDF twice. First time set NGRID=7 to get
c               better estimate of errors. Second time set
c               NGRID = NGRID_FINAL. Change should run faster 
c               if there are fewer iterations needed with NGRID_FINAL.
c
c Nov 24, 2009: call PDF_INIT() to init PDFXXX arrays
c
c -------------------------------------------

      IMPLICIT NONE

c input args

      INTEGER 
     &    HOFF_MARG      ! (I) fill plots with hbook offset = HOFF
     &   ,OPT            ! (I) options
     &   ,MAX_INTEGPDF   ! (I) max number of iterations
     &   ,NGRID_FINAL    ! (I) # bins for each integrated dimension

      REAL  NSIGMA     ! (I) integrate +_ NSIGMA for exact pdf.

c -------------
c local var

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER 
     &   ipar, ipar2
     &  ,JTIME1, JTIME2, JDIFTIME
     &  ,NEVAL        ! number of function evaluations
     &  ,LL, NDOF
     &  ,i, IERR
     &  ,NGRID, HOFF, NHDIM, HID_PDF, NBPDF

      character chis*80, copt*6

      REAL*8 XMIN, XMAX, TMP
      LOGICAL LSYMERR

c functions
      CHARACTER ERRTYPE_STR*1
      REAL*8  PROB

c FCN args

      DOUBLE PRECISION
     &    GRAD8(MXFITPAR)
     &   ,CHI8
     &   ,USRFUN
 
      EXTERNAL USRFUN

c ------------------ BEGIN ------------

c require at least a few bins ...

      if ( NGRID_FINAL .LE. 0 ) RETURN

c set chi2 value for FCN function to quit

      IF ( PDFMIN .GT. 0.0 .and. 
     &        OPT .EQ. OPT_INTEGPDF_QUITCHI2 ) THEN
        FITCHI2_QUIT = -2.0*DLOG(PDFMIN) + FITCHI2_MIN
      ELSE
        FITCHI2_QUIT = 1.0E20
      ENDIF

      COPT = 'GRID'   ! only option so far

c -----------------

      write(6,19) SNLC_CCID, NSIGMA, copt
19    format(/,T5,'MARG_DRIVER(CID ',A6,'): ', 
     &      'compute P.D.F(+- ',F3.1,' sigma)', 2x, 'method=',A)

      IF ( FITCHI2_QUIT .LT. 1.0E19 ) then
        print*,'   CPU-saver ON  => FCNSNLC quits when CHI2 > ', 
     &         FITCHI2_QUIT
      ELSE
        print*,'   CPU-saver OFF => FCNSNLC always computes full CHI2.'
      ENDIF

      CALL FLUSH(6)

      USEPDF_MARG  = .TRUE.
      ISTAGE_SNANA = ISTAGE_TEST

c --------------------------------------
c book plots

c start with monitor plot for FCNPDF value for each function call

      IF ( HOFF_MARG .GT. 0 ) THEN
         HID_PDF = HOFF_MARG ; NHDIM   = 1  
         NBPDF = 202 ;  XMIN  = -20.1 ; XMAX  =  +0.1
         CHIS  = 'log10(PDF) for integration' // char(0)
         CALL SNHIST_INIT(NHDIM, HID_PDF, CHIS,
     &              NBPDF, XMIN, XMAX, LEN(CHIS) )
      ENDIF

c init PDFVAL = FITVAL so that fixed parameters get transfered.

      CALL PDF_INIT()

c ---------------------
c get exact pdf by integrating over other fit-parameters

      JTIME1 = TIME()

c First marginalize with just 7 grid-points per variable.

      OPT   = 1   ! 1st round estimate 
      NGRID = 7
      HOFF  = 0   ! skip histograms
      CALL INTEGPDF( OPT, HOFF, 
     &        MAX_INTEGPDF, NGRID, DBLE(NSIGMA), NEVAL, IERR )

c final marginalization; use previous PDF for grid size estimate

      OPT   = 2       
      NGRID = NGRID_FINAL
      HOFF  = HOFF_MARG
      CALL INTEGPDF( OPT, HOFF, 
     &        MAX_INTEGPDF, NGRID, DBLE(NSIGMA), NEVAL, IERR )

c compute integration time.

      JTIME2   = TIME()
      JDIFTIME = JTIME2 - JTIME1

      LL = INDEX(SNLC_CCID,' ') - 1
      write(6,80) NEVAL, JDIFTIME, SNLC_CCID(1:LL)
80    format(T5,'MARG_DRIVER: Finished ',I7,' function calls in ', 
     &         I4,' seconds  (SN ', A,')'   )
      print*,' '

c keep track of integration times.

      NCALL_INTEGPDF     = NCALL_INTEGPDF + 1
      TIME_INTEGPDF      = JDIFTIME
      TIMESUM_INTEGPDF   = TIMESUM_INTEGPDF + JDIFTIME
      tmp                = DBLE(TIMESUM_INTEGPDF)/DBLE(NCALL_INTEGPDF)
      TIMEAVG_INTEGPDF   = INT(TMP+0.5)

      if ( mod(NCALL_INTEGPDF,5) .EQ. 0 ) then
         print*,' '
         print*,'   (AVERAGE INTEGPDF TIME: ', 
     &              TIMEAVG_INTEGPDF,'  seconds)'
         print*,' '
      endif

c call utility to store PDF results
      CALL PDF_STORE()

      RETURN
      END   ! end of MARG_DRIVER


C =======================================
+DECK,INTEGPDF.
      SUBROUTINE INTEGPDF(OPT, HOFF,
     &           MAX_INTEGPDF, NGRID, NSIGMA, NEVAL, IERR )
c ---------------------
c  Retruns p.d.f(DLMAG) integratged over other parameters;
c  integration is from +-NSIGMA * FITERR over each
c  dimension with non-zero INISTP.
c
c  The calling routine must set FITVAL(IPAR_DLMAG) = DLMAG,
c  and also set INISTP(IPAR_DLMAG) = 0.0 so that FCNPDF
c  knows to ignore the DLMAG-dimension in the integration.
c
c  OPT=1 => first estimate with small NGRID
c  OPT=2 => final estimate with final NGRID
c
c
c histograms are booked / filled for
c
c  HOFF          : function value for each call
c  HOFF + ipar   : pdf for each floated "ipar"
c
c
c  Feb 24, 2007: major upgrade to iterate if problem
c                is detected. See LREDO logic.
c
c                PDFERR(ipar) is now the RMS of the pdf distribution.
c
c Apr 28, 2007: 
c  on 2nd iteration when prob at edge is too high, make more robust 
c  estimate of integration region. Previously, integ-region was extended
c  by three times the shift in PDFVAL. Now, a Gaussian profile is
c  assumed, and an effective SIGMA is computed based on prob(at edge)
c  and current PDFVAL(ipar).  The integration limmit is then
c  changed to PDFVAL + NSIGMA*SIGMA
c  This improvement should help when MINUIT returns an error that 
c  is way too small, but is still not flagged by BADERR.
c
c May 3, 2007: accept MAX_INTEGPDF as argument
c
c Aug 20, 2008: change MXPAR from 8 to 10
c               (to accomodate IPAR_LUMIPAR2 in STRETCH2 model)
c
c Oct 16, 2009: 
c      use OPT=1,2 to determine which NGRID-iteration
c      Compute covariance & correlations: PDFCORMAT(ipar1,ipar2)
c
c      Fill PDRPROB2(ipar)
c
c Jan 4, 2010: add IERR argument. For PDF=0 error, abort only
c              if OPT=2. This gives both NGRID values a chance
c              to  succeed.
c
c Oct 01, 2012: use LCPLOT utility instead of HBOOK1 and HPAK
c
c Feb 06, 2013: replace LCPLOT util with SNHIST
c
c Jun 10 2013: protect ABORT when LPDFZERO=T using user namelist 
c              ABORT_ON_MARGPDF0
c
c -------------------------------------------------

      IMPLICIT NONE

c function aarguments

      INTEGER 
     &   OPT      ! (I) option 
     &  ,MAX_INTEGPDF  ! (I) max # times to integrate
     &  ,NGRID    ! (I) # grid-bins for each dimension
     &  ,HOFF     ! (I) hbook offset
     &  ,NEVAL    ! (O) number of function calls.
     &  ,IERR     ! (O) 0=>OK
     
      REAL*8  NSIGMA   ! (I) integrate +- NSIGMA in each dimension

c local args

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER MXPAR, MXGRID

      PARAMETER (  
     &    MXPAR   = 10   ! max number of fit paramters/dimensions
     &   ,MXGRID  = 30
     &     )

      INTEGER 
     &   IPAR, IPAR2
     &  ,NBINTOT
     &  ,IBIN
     &  ,IBIN_OFF
     &  ,IGRID
     &  ,NDIM, IDIM, IDIM2
     &  ,IPAR_DIM(MXPAR)  ! IPAR for each dimension to integrate
     &  ,IBIN_DIM(MXPAR)  ! local grid-bin for each dimension
     &  ,NN, i
     &  ,NPASS
     &  ,HID, NHDIM, LL, NUM
     &  ,ITER
     &  ,NPDF, IBIN_PLOT

      REAL*8
     &   PARVAL_MIN(MXPAR)
     &  ,PARVAL_MAX(MXPAR)
     &  ,PARVAL_BINSIZE(MXPAR)
     &  ,PARDIF_MIN(MXPAR)
     &  ,PARDIF_MAX(MXPAR)
     &  ,PARVAL(MXPAR)
     &  ,PARVAL_GRID(MXGRID,MXPAR)
     &  ,TMP, TMPVAL
     &  ,DVOL
     &  ,X8(MXPAR)
     &  ,PDF, XPDF, WGT
     &  ,PDFWSUMCOR(0:MXPAR,0:MXPAR)   ! wgted sum for correlations
     &  ,PDFSUMCOR
     &  ,PDFWSUM(0:MXPAR)          ! wgted sum for each ipar
     &  ,PDFSUM                    ! PDF sum for each ipar
     &  ,PDFSUM_GRID(MXGRID,MXPAR)  ! PDF vs. par to plot 1-d pdf
     &  ,PDFMAX(MXPAR)             ! max over grid for each ipar
     &  ,TMP_RANGE(2,MXPAR)
     &  ,PDF1D(MXGRID,MXPAR)
     &  ,SUM0, SUM1, SUM2, XN, XTMP
     &  ,SQERR, E12, E1xE2, PDFTMP
     &  ,PDF_NBR1, PDF_NBR2
     &  ,XMIN, XMAX


      LOGICAL 
     &   LTMP
     &  ,LPDFZERO
     &  ,LREDO
     &  ,LREDO_ALL
     &  ,LDMP_DEBUG

      CHARACTER chis*80, choice*12

c function

      REAL*8   FCNPDF
      EXTERNAL FCNPDF

c ----------------- BEGIN ------------

      NEVAL    = 0  ! init output arg
      IERR     = 0

      NPASS    = 0

      ITER = NFIT_ITERATION

      DO ipar = 1, NFITPAR_MN
         PARVAL_MIN(ipar) = 0.0
         PARVAL_MAX(ipar) = 0.0
         PARDIF_MIN(ipar) = 0.0
         PARDIF_MAX(ipar) = 0.0
      ENDDO
 
      LDMP_DEBUG = .FALSE.

      NHDIM    = 1  ! 1D histo

C =====================================
2     CONTINUE
      NPASS = NPASS + 1

c init some useful things.

      DVOL      = 1.0
      NBINTOT   = 1
      NDIM      = 0  ! number of dimensions to integrate PDF
      PDFSUM    = 0.0
      PDFSUMCOR = 0.0
      LREDO_ALL = .FALSE.

C set up integration limits for each parameter

      DO 30 ipar = 1, NFITPAR_MN

         PDFWSUM(ipar) =  0.0
         PDFMAX(ipar)  =  0.0

         do ipar2 = 1, NFITPAR_MN
            PDFWSUMCOR(ipar,ipar2) = 0.0
         enddo

         do igrid = 1, NGRID
            PDFSUM_GRID(igrid,ipar) = 0.0
         enddo

         if ( .not. FLOATPAR(ipar)  ) goto 30 ! skip fixed params

         NBINTOT = NBINTOT * NGRID

c keep track of which parameters to integrate
c (i.e., to ignore fixed parameters)

         NDIM = NDIM + 1
         IPAR_DIM(NDIM) = IPAR
         TMP_RANGE(1,ipar) = PARVAL_MIN(ipar)
         TMP_RANGE(2,ipar) = PARVAL_MAX(ipar)

         CALL INTEGRANGE(IPAR,NGRID,NSIGMA,PDF1D(1,ipar),  ! inputs
     &          LREDO, TMP_RANGE(1,ipar) ) ! outputs are LREDO & RANGE(1:2)

c set global REDO flag if any parameter-range is adjusted.
  
         LREDO_ALL = LREDO_ALL .OR. LREDO

30    CONTINUE  ! end of IPAR loop

c --------------------------------------------
c check if integration should proceed.
c Allow no more than three tries ... give "BEWARE" warning
c after 3 tries.

      IF ( NPASS .GT. 1 ) THEN

        IF ( LREDO_ALL ) THEN
           LL = INDEX(SNLC_CCID,' ') - 1

           if ( NPASS .LE. MAX_INTEGPDF ) then
              print*,'  ==> Integrate ',SNLC_CCID(1:LL), 
     &            ' again with NGRID=', NGRID
              CALL FLUSH(6)
           else if ( OPT .EQ. 1 ) then 
              goto 800

           else if ( OPT .EQ. 2 ) then  ! warn on final NGRID only

              print*,'  ==> Store ',SNLC_CCID(1:LL), 
     &          ' result, but BEWARE !!!'
              CALL FLUSH(6)
c              print*,'  ==> Cannot converge for ',SNLC_CCID(1:LL)
c              IERR = -9  ! Dec 16, 2011

              GOTO 800  ! skip integration
           endif

        ELSE
           GOTO 800  ! skip integration
        ENDIF
      ENDIF

        CALL FLUSH(6)

c ----
c if we get here, then adjust integration range

      DO 31 ipar = 1, NFITPAR_MN

        if ( .not. FLOATPAR(ipar)  ) goto 31 ! skip fixed params

        PARVAL_MIN(ipar) = TMP_RANGE(1,ipar)
        PARVAL_MAX(ipar) = TMP_RANGE(2,ipar)

        TMP = FITVAL(ipar,ITER)
        PARDIF_MIN(ipar) = PARVAL_MIN(ipar) - TMP
        PARDIF_MAX(ipar) = PARVAL_MAX(ipar) - TMP

        TMP = PARVAL_MAX(ipar) - PARVAL_MIN(ipar) 
        PARVAL_BINSIZE(ipar) = TMP / float(NGRID)

c compute volume element (used in brute-force method)

        DVOL = DVOL *  PARVAL_BINSIZE(ipar)

31    CONTINUE


c Now do the integration 

      LPDFZERO = .TRUE.

      DO 770 IBIN = 1, NBINTOT

c determine local grid-bin for each dimension to integrate;
c the load local PARVAL with value at each grid-point.

         ibin_off = 0
         do idim  = 1, NDIM
            NN    = NGRID**(NDIM-idim)
            ibin_dim(idim) = (ibin - 1 - ibin_off)/NN + 1
            ibin_off       = ibin_off + (ibin_dim(idim) - 1) * NN

            ipar     = ipar_dim(idim)  ! fetch fit par index
            igrid    = ibin_dim(idim)
            TMP      = float( igrid ) - 0.5
 
            XTMP     = PARVAL_MIN(ipar) 
     &               + PARVAL_BINSIZE(ipar) * TMP 

            PARVAL(ipar)            = XTMP
            PARVAL_GRID(igrid,ipar) = XTMP

         enddo  ! end loop of NDIM

c get X8 array that contains only parameters to integrate
c (fixed parameters are weeded out from PARVAL)

         CALL FITVAL_FLOAT(PARVAL, NDIM, X8) ! returns NDIM and X8

         PDF   = FCNPDF(NDIM,X8)   ! evaluate normalized PDF

         NEVAL = NEVAL + 1         ! increment # function calls

         IF ( PDF .EQ. 0.0 ) goto 771

         LPDFZERO = .FALSE.

         PDFSUM   = PDFSUM + PDF  ! increment total integral

         do idim  = 1, NDIM
            ipar  = ipar_dim(idim)  ! fetch fit par index

            PDFWSUM(ipar) = PDFWSUM(ipar) + PDF * PARVAL(ipar)

            do idim2 = 1, NDIM
               ipar2 = ipar_dim(idim2) 
               PDFWSUMCOR(ipar,ipar2) = PDFWSUMCOR(ipar,ipar2) 
     &                + PDF * PARVAL(ipar) * PARVAL(ipar2)
            enddo

c sum pdf separately for each grid point and for each IPAR
c so that 1-dim PDF can be plotted for each IPAR.

            igrid = ibin_dim(idim)
            PDFSUM_GRID(igrid,ipar) = 
     &      PDFSUM_GRID(igrid,ipar) + PDF 

            if ( PDFSUM_GRID(igrid,ipar) .GT. PDFMAX(ipar) ) then
              PDFMAX(ipar) = PDFSUM_GRID(igrid,ipar)
            endif
         enddo  ! end of idim loop

          if ( PDF > 0.0 .and. HOFF > 0 ) then
            xpdf   = DLOG10(PDF)
            xpdf   = max ( -19.999, xpdf )
            wgt    = 1.0
            CALL SNHIST_FILL(NHDIM, HOFF, XPDF, WGT ) 
          endif

771       continue
          if ( MOD(IBIN,10000)  .EQ. 0 ) then
             print*,'      Processing grid-bin ', 
     &           ibin,'/', NBINTOT
             CALL FLUSH(6)
          endif

770   CONTINUE

      IF ( LPDFZERO ) THEN
        print*,' '
        print*,'  WARNING: INTEGPDF ERROR for CID=', SNLC_CCID
        print*,'  pdf function is zero everywhere with NGRID=',NGRID
        print*,' '
        IERR = -9

        IF ( OPT .EQ. 2 .and. ABORT_ON_MARGPDF0 ) THEN
          print*,' ***** ABORT ***** '
          CALL EXIT(EXIT_ERRCODE)
        ELSE
          RETURN
        ENDIF

      ENDIF

c ---------------------------------------
c fill histograms and PDFVAL_STORE array

      DO idim  = 1, NDIM
         ipar  = ipar_dim(idim)  ! fetch fit par index

         PDFVAL(ipar) = PDFWSUM(ipar) / PDFSUM 

         DO igrid = 1, NGRID
            PDF = PDFSUM_GRID(igrid,ipar) / PDFMAX(ipar)

            if ( PDF .LT. 1.0E-30 ) THEN
              PDF1D(igrid,ipar) = 1.0E-20  ! avoid hbook bit problems
            else
              PDF1D(igrid,ipar) = PDF
            endif

         ENDDO  ! end of igrid loop
  
      ENDDO  ! end of IDIM loop   
  
c determine PDF error (RMS) without using hbook so 
c that we can pass HOFF=0 and skip histograms

      DO idim  = 1, NDIM
         ipar  = ipar_dim(idim)  ! fetch fit par index
         SUM0 = 0.0
         SUM1 = 0.0
         SUM2 = 0.0
         NPDF = 0
         PDFPROB2(ipar) = 0.0

      DO igrid = 1, NGRID

         XTMP   = PARVAL_GRID(igrid,ipar)
         PDFTMP = PDF1D(igrid,ipar)
         if ( PDFTMP .GT. 1.0E-6 ) NPDF = NPDF + 1

         SUM0   = SUM0 + PDFTMP
         SUM1   = SUM1 + PDFTMP * XTMP
         SUM2   = SUM2 + PDFTMP * XTMP * XTMP

         PDF_NBR1 = 0.0
         PDF_NBR2 = 0.0
         if ( igrid .GT. 1     )  PDF_NBR1 = PDF1D(igrid-1,ipar)
         if ( igrid .LT. NGRID )  PDF_NBR2 = PDF1D(igrid+1,ipar)

c check for 2nd local maximum
         if (    PDFTMP .LT. .99 
     &     .and. PDFTMP .GT. PDF_NBR1
     &     .and. PDFTMP .GT. PDF_NBR2 ) then
            PDFPROB2(ipar) = PDFTMP
         endif
      ENDDO  ! igrid

        SQERR = SUM2/SUM0 - (SUM1/SUM0)**2

        if ( SQERR .LT. -0.00001 ) THEN ! allow for numerical rounding
                print*,' '
                print*,' SUM[0,1,2] = ', SUM0, SUM1, SUM2
                print*,' (SUM2/SUM0)     = ', SUM2/SUM0
                print*,' (SUM1/SUM0)**2  = ', (SUM1/SUM0)**2
                print*,' SQERR           = ', SQERR
                print*,' NPASS=',NPASS,'  OPT=',OPT
                c1err = ' SWERR < 0 for ' // PARNAME_STORE(ipar)
                CALL MADABORT("INTEGPDF", c1err, "  ")
         endif

c to compute error from RMS, require more than 1 PDF bin to be non-zero 
c (to avoid pathologies from PDFERR -> 0)

         if ( SQERR .GT. 0.0 .and. NPDF .GT. 1 ) then
            PDFERR(ipar) = SQRT( SQERR )         
         else
            PDFERR(ipar) = FITERR(ipar,iter)  ! PDF err = fit err for now
         endif

         ERRTYPE(ipar) = ERRTYPE_MARG 
      ENDDO  ! idim


C -------------------------------------------------
C evaluate covariances

      DO 400 idim  = 1, NDIM
         ipar      = ipar_dim(idim) 
      DO 400 idim2 = 1, NDIM
         ipar2     = ipar_dim(idim2) 

         E12   = PDFWSUMCOR(ipar,ipar2)/PDFSUM 
         E1xE2 = PDFVAL(ipar)*PDFVAL(ipar2)
         PDFERRMAT(ipar,ipar2) = E12 - E1xE2

         SQERR = PDFERR(ipar)*PDFERR(ipar2)
         PDFCORMAT(ipar,ipar2) = PDFERRMAT(ipar,ipar2)/SQERR

+SELF,IF=XXXDBG.
         if ( ipar2 .GT. ipar .and. OPT .EQ. 2) then
            write(6,466) 
     &      PARNAME_STORE(ipar), PARNAME_STORE(ipar2)
     &     ,FITCORMAT(ipar,ipar2)
     &     ,PDFCORMAT(ipar,ipar2)
     &     ,NPASS, NGRID

466         format(T5,'xxx RHO(',A6,',', A6,')= ', F6.3, ' ', F6.3,
     &         ' at NPASS=',I1,'  NGRID=',I2 )
         endif
+SELF.

400   CONTINUE


c ------------------------
       IF ( LDMP_DEBUG ) THEN

          print*,' xxx ====================================== '
          PRINT*,' xxx NPASS = ', NPASS

         DO idim  = 1, NDIM
            ipar  = ipar_dim(idim) 
          
            print*,' - - - - - - - - - - - - - - - - - '
            write(6,665) PARNAME_STORE(ipar),
     &      PDFVAL(ipar), PDFERR(ipar), PDFPROB2(ipar)

            write(6,666) PARNAME_STORE(ipar),
     &      PARVAL_MIN(ipar), PARVAL_MAX(ipar)

            write(6,667) 'PARVAL', 
     &           ( PARVAL_GRID(igrid,ipar), igrid=1,11)
            write(6,667) 'PDFVAL', 
     &           ( PDF1D(igrid,ipar), igrid=1,11)

665        format(T3, 'xxx ',A6, 2x, 'PDFVAL = ',
     &          G10.3,' +- ', G10.3, 3x, 'PROB2=',F5.3 )
666        format(T3, 'xxx ',A6, 2x, 'PARDIF(MIN,MAX)=',2F9.3)

667        format(T3,'xxx ',A, '=', 11F7.3 )
           CALL FLUSH(6)
         ENDDO
       ENDIF
c ------------------------

c  ------------------------------------------------------
c always go back to start to check if we have converged

           goto 2

c ==================================================
c Check option to plot PDF for each floated parameter

800   CONTINUE
      CALL FLUSH(6)

      IF ( HOFF .LE. 0 ) RETURN

      DO idim  = 1, NDIM
         ipar  = ipar_dim(idim)  ! fetch fit par index
         hid   = HOFF + ipar
 
         LL = index ( PARNAME_STORE(ipar), ' ' ) - 1
         write(chis,21)  
     &          PARNAME_STORE(IPAR)(1:LL)
     &        , PARNAME_STORE(IPAR)(1:LL)
     &        , SNLC_CCID(1:ISNLC_LENCCID), char(0)

21       format(' margin. PDF( ',A,'-',A,'(fit) ) for CID=',A, A)


         TMPVAL  = FITVAL(ipar,NFIT_ITERATION)
         xmin    = PARVAL_MIN(ipar) - TMPVAL 
         xmax    = PARVAL_MAX(ipar) - TMPVAL

         CALL SNHIST_INIT(NHDIM, HID, CHIS//char(0), 
     &           NGRID, XMIN, XMAX, LEN(chis) )

         DO igrid = 1, NGRID
           TMP   = DBLE(igrid)-0.5
           XTMP  = XMIN + PARVAL_BINSIZE(ipar) * TMP
           CALL SNHIST_FILL( NHDIM, HID, XTMP, PDF1D(igrid,ipar) )
         ENDDO

      ENDDO

      RETURN
      END   ! end of INTEGPDF


C =======================================
+DECK,INTEGRANGE.
      SUBROUTINE INTEGRANGE(IPAR,NGRID,NSIGMA,PDFLAST,
     &      LREDO,RANGE)

c
c Created Apr 30, 2007 by R.Kessler
c
c Determine integration range for IPAR parameter based on
c 1-dim PDF values from previous integration.
c
c On first pass, RANGE(1)=RANGE(2)=0 and integration range
c is just based on NSIGMA * FITERR from MINUIT.
c
c Oct 23, 2007: TMP_PROB -> min (0.98, GRIDPROB)
c               to avoid dividing by ln(near 1)
c
c Dec 3, 2007:  min(0.98,GRIDPROB) -> min(0.95,GRIDPROB) 
c               so that integ-range is not opened so much
c               (short-term fix for photoZ fit to 14888)
c
c Oct 17, 2009: define PDFLAST_MAX = .95 with mutiple PDF bins,
c               or =.5 with just one PDF bin. Avoids severe bin-
c               extensions when there is just one non-zero PDF bin.
c
c               Makes sure that RANGE(1:2) is withing INIBND
c
c Dec 16, 2011: 
c    - write more info on PDFPROBLEM at endge of 1 dim PDF.
c    - for PHOTOZ, skip upper INIBND check on RANGE(2)
c
c -----------------------------------

      IMPLICIT NONE

c subroutine args

      INTEGER
     &   IPAR   ! (I) parameter to determine integration range
     &  ,NGRID  ! (I) number of grid points to integrate
     
      REAL*8
     &   NSIGMA          ! (I) 
     &  ,PDFLAST(NGRID)  ! (I) 1-dim PDF at grid points of last integration
     &  ,RANGE(2)        ! (I,O) integration limits: old -> new

      LOGICAL LREDO      ! (I) flag to redo integration

c local args

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      LOGICAL   
     &   LSYMERR
     &  ,LTMP
     &  ,LPDFMAX
     &  ,BADEDGE(2)
     &  ,LFIRST 
     &  ,USE_PDFERR

      INTEGER 
     &   NREDO
     &  ,N1D_TOT           ! total number of 1D bins = NGRID
     &  ,N1D_PROB0         ! number of 1D bins with negligible prob
     &  ,NPDF_GOOD
     &  ,igrid
     &  ,igrid_min
     &  ,igrid_max
     &  ,L1, L2, i
     &  ,ITER

      REAL*8
     &   XNSIG, XNGRID, xgrid
     &  ,RANGE_OLD(2)
     &  ,RANGE_NEW(2)
     &  ,BINSIZE_OLD
     &  ,BINSIZE_NEW
     &  ,TMP_PLUS
     &  ,TMP_MINUS
     &  ,TMP_SIG
     &  ,TMP_PROB
     &  ,TMP_EDGE
     &  ,TMP_PDF
     &  ,TMP_VAL
     &  ,SHIFT, BND
     &  ,PDFMAX_atEDGE
     &  ,PDFLAST_MAX
     
      CHARACTER PDFPROBLEM(40)*48

C -------------- BEGIN -------------

      ITER = NFIT_ITERATION

c init a bunch of stuff.

      XNSIG         = NSIGMA
      XNGRID        = FLOAT(NGRID)

      LFIRST = (RANGE(1) .EQ. 0.0 .and. RANGE(2) .EQ. 0.0)

c store old integration range since it gets over-written later.
      RANGE_OLD(1) = RANGE(1)
      RANGE_OLD(2) = RANGE(2)
      BINSIZE_OLD  = (RANGE_OLD(2)-RANGE_OLD(1))/XNGRID

      NREDO        = 0
      LREDO        = .FALSE.  ! output arg !!
      TMP_PLUS     = 0.0
      TMP_MINUS    = 0.0

      IF ( LFIRST ) THEN  

         USE_PDFERR = PDFERR(ipar) .GT. 0.0
         LSYMERR = abs(FITERR_RATIO(ipar,ITER)-1.0) .LT. 0.20 

         IF ( USE_PDFERR ) THEN  ! PDF error gives better estimate
           TMP_PLUS    =  XNSIG * PDFERR(ipar)
           TMP_MINUS   = -XNSIG * PDFERR(ipar)  ! neg number
         ELSE IF ( LSYMERR ) THEN
           TMP_PLUS    =  XNSIG * FITERR(ipar,ITER)
           TMP_MINUS   = -XNSIG * FITERR(ipar,ITER)  ! neg number
         ELSE
           TMP_PLUS    =  XNSIG * FITERR_PLUS(ipar,ITER)
           TMP_MINUS   =  XNSIG * FITERR_MINUS(ipar,ITER)  ! neg number
         ENDIF

         RANGE(1) = FITVAL(ipar,ITER) + TMP_MINUS
         RANGE(2) = FITVAL(ipar,ITER) + TMP_PLUS

         LREDO = .TRUE.
         RETURN

      ENDIF

c ---------------------------------------------------
c loop over grid points and find bin with first,last 
c non-negligible PDF value.
c Also count NPDF_GOOD = number of bins with PDF > PDFMIN

      N1D_TOT    = 0 
      N1D_PROB0  = 0
      LPDFMAX    = .FALSE.
      igrid_min  = 1
      igrid_max  = NGRID

      DO 100 igrid = 1, NGRID

         TMP_PDF = PDFLAST(igrid)
         if ( TMP_PDF .GT. 0.90 ) LPDFMAX = .TRUE.

         N1D_TOT = N1D_TOT + 1

         if ( TMP_PDF .GT. PDFMIN_GOOD ) then
             NPDF_GOOD = NPDF_GOOD + 1
         else
             N1D_PROB0 = N1D_PROB0 + 1

             if ( LPDFMAX .and. IGRID_MAX .EQ. NGRID ) then
                igrid_max = igrid  ! first negligible pdf past max
             endif

             if ( .not. LPDFMAX ) then
                igrid_min = igrid  ! last negligible pdf before max
             endif
         endif

100   CONTINUE  ! end of igrid loop

      IF ( NPDF_GOOD .GT. 1 ) THEN
          PDFLAST_MAX = 0.95
      ELSE
          PDFLAST_MAX = 0.80  ! Guass approx is bad with just one bin
      ENDIF


c -----------------------------------------------------------
c if PDF at edge is too big, then compute adjustment to extend edge.
c Adjustent is based on assumption of Gaussian profile.

      SHIFT      = PDFVAL(ipar) - FITVAL(ipar,ITER)
      BADEDGE(1) = .FALSE.
      BADEDGE(2) = .FALSE.
      PDFMAX_atEDGE = MAX ( PDFLAST(1), PDFLAST(NGRID) )

      LTMP = PDFLAST(1) .GT. PDFMAX_EDGE
      IF ( LTMP  ) THEN
         BADEDGE(1) = .TRUE.
         TMP_PROB   = min ( PDFLAST(1), PDFLAST_MAX )
         TMP_EDGE   = RANGE_OLD(1) - PDFVAL(ipar) ! distance to min edge
         TMP_SIG    = TMP_EDGE / SQRT ( -2.0 * DLOG(TMP_PROB) )
         TMP_MINUS  = XNSIG * TMP_SIG - TMP_EDGE

c avoid making integration window smaller
         if ( TMP_MINUS .GT. 0.0 ) then
              TMP_MINUS = -abs(3.*SHIFT)
         endif
      ENDIF



      LTMP = PDFLAST(NGRID) .GT. PDFMAX_EDGE
      IF ( LTMP ) THEN
          BADEDGE(2) = .TRUE.
          TMP_PROB   = min ( PDFLAST(NGRID), PDFLAST_MAX )
          TMP_EDGE   = RANGE_OLD(2) - PDFVAL(ipar) ! distance to edge
          TMP_SIG    = TMP_EDGE / SQRT ( -2.0 * DLOG(TMP_PROB) )
          TMP_PLUS   = XNSIG * TMP_SIG - TMP_EDGE

c avoid making integration window smaller
          if ( TMP_PLUS .LT. 0.0 ) then
               TMP_PLUS = +abs(3.*SHIFT)
          endif
      ENDIF

c ----------------------------
c update new integration range to account for 
c extended range(s).

      RANGE_NEW(1) = RANGE_OLD(1) + TMP_MINUS
      RANGE_NEW(2) = RANGE_OLD(2) + TMP_PLUS
      BINSIZE_NEW  = (RANGE_NEW(2)-RANGE_NEW(1))/XNGRID

c -------------------------------------
c check for bins that have ~0 prob, and reduce integration
c range to eliminate these 0-prob bins.

      if ( igrid_min .GT. 1 ) then
         xgrid        = float(igrid_min) - 0.5
         TMP_VAL      = RANGE_OLD(1) + BINSIZE_OLD * xgrid
         RANGE_NEW(1) = TMP_VAL - BINSIZE_NEW/2.0
      endif

      if ( igrid_max .LT. NGRID ) then
         xgrid        = float(igrid_max) - 0.5
         TMP_VAL      = RANGE_OLD(1) + BINSIZE_OLD * xgrid
         RANGE_NEW(2) = TMP_VAL + BINSIZE_NEW/2.0
      endif

c store NEW integration range in output subroutine arg.

      RANGE(1) = RANGE_NEW(1)
      RANGE(2) = RANGE_NEW(2)

c ---------------------------------------------------
c check of there is any reason that integration needs to be redone.
c  - Prob(edge) is too high
c  - Only 1 bin in 1D PDF
c  - Too many Zero-prob bins'
c 
c  Set LREDO flag = T if there is a problem.

      IF ( BADEDGE(1)  ) then
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),441) PDFLAST(1), 'lo'
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),1441) RANGE_OLD, RANGE_NEW
      ENDIF
      IF ( BADEDGE(2)  ) then
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),441) PDFLAST(NGRID), 'hi'
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),1441) RANGE_OLD, RANGE_NEW
      ENDIF

441        format('PROB=',F6.4, ' at ',A,' edge of 1 dim PDF')
1441       format('RANGE=(', F6.2, ',', F6.2, ')' , ' -> ',
     &                  '(', F6.2, ',', F6.2, ')'   )  ! Dec 2011

      IF ( NPDF_GOOD .LT. 3  ) then
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),442) 
442        format('<= 2 non-zero PDF bins.' )
      ENDIF

      IF ( N1D_PROB0 .GT. 3 ) THEN
           NREDO = NREDO + 1
           write(pdfproblem(NREDO),443) N1D_PROB0, N1D_TOT
443        format('PROB=0 for ', I3, '/' , I3, 2x,
     &           'PDF bins' )
      ENDIF

c ----------------------------------------------
c print list of PDF-problems to STDOUT

      IF ( NREDO .GT. 0 ) THEN

         LREDO = .TRUE.

         L1 = index ( PARNAME_STORE(ipar), ' ' ) - 1
         L2 = index ( SNLC_CCID, ' ' ) - 1

         do i = 1, NREDO
            write(6,449) 
     &          PARNAME_STORE(ipar)(1:L1)
     &        , SNLC_CCID(1:L2)
     &        , PDFPROBLEM(i)
449         format(T8,A,'-PDF PROBLEM(',A,') : ', A)
         enddo

      ENDIF

c don't allow range to go outside of official INIBND range.

      BND = INIBND(1,IPAR)
      IF (RANGE(1) .LT. BND ) RANGE(1) = BND

c special exception for PHOTOZ
      IF ( PARNAME_STORE(IPAR)(1:6) .NE. 'PHOTOZ' ) THEN
        BND = INIBND(2,IPAR)
        IF (RANGE(2) .GT. BND ) RANGE(2) = BND
      ENDIF

      RETURN
      END

C =======================================
+DECK,FCNPDF.
      DOUBLE PRECISION FUNCTION FCNPDF(NDIM,X)
c
c  Retruns exp[ - (chi2 - chi2min) / 2 ]
c
c  where CHI2 is returned from a call to FCNSNLC.
c  This function is designed to accept only the
c  floated parameters so that it can be used by
c  more generic integration routines that don't
c  know about fixed parameters.
c
c Example: fit-params 1,2 are fixed and 3-6 float.
c          Then pass NDIM=4 and X(4) = array of floated parameters.
c
c -----------------------
      IMPLICIT NONE

c function input

      INTEGER NDIM     ! (I) number of dimensions
      REAL*8  X(NDIM)  ! (I) args for chi2-function

c local args

+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

      INTEGER 
     &   ipar_all
     &  ,ipar_float
     &  ,ipar

c FCNSNLC args

      INTEGER IFLAG

      DOUBLE PRECISION
     &    GRAD(MXFITPAR)
     &   ,FITVAL_LOC(MXFITPAR)
     &   ,CHI2, DELCHI2
     &   ,USRFUN
 
      EXTERNAL USRFUN

C ---------- BEGIN -----------------

      FCNPDF  = 0.0
      IFLAG   = FCNFLAG_FAST

c restore input parameters X to local FITVAL array;
c note that fixed parameters are loaded from FITVAL_STORE array.

      ipar_float = 0

      DO ipar_all = 1, NFITPAR_MN

        if ( FLOATPAR(ipar_all)  ) then  ! is a floated param
           ipar_float = ipar_float + 1
           FITVAL_LOC(ipar_all) = X(ipar_float)
        else
           FITVAL_LOC(ipar_all) = FITVAL(ipar_all,NFIT_ITERATION) 
        endif

      ENDDO

c      write(6,20) (FITVAL_LOC(ipar), ipar=1, 6)

      CALL FCNSNLC(NFITPAR_MN,GRAD,CHI2,FITVAL_LOC,IFLAG,USRFUN)

c set FCNPDF only if FCN function did not have its
c chi2 got too big.

      if ( chi2 .LE. FITCHI2_QUIT ) then
         DELCHI2 = chi2 - FITCHI2_MIN
         FCNPDF  = dexp(-DELCHI2/2.0)
      endif

      RETURN
      END  ! end of FCNPDF


C ==============================================
+DECK,FITVAL_FLOAT.
      SUBROUTINE FITVAL_FLOAT(FITVAL_LOC,NDIM,X)
c
c FITVAL is the array of NFITPAR_MN parameters.
c Returns NDIM = number of floated parmaters,
c and X(NDIM) = array of floated paramters.
c i.e, the fixed paramters are ignored.
c
c -----------------------------------

      IMPLICIT NONE
+CDE,SNDATCOM.
+CDE,SNANAFIT.
+CDE,SNLCINP.

c declare function args

      REAL*8  FITVAL_LOC(*)     ! (I) fit parameters
      INTEGER NDIM              ! (O) number of floated params
      REAL*8  X(*)              ! (O) array of floated params

c local args
      INTEGER ipar
C --------------- BEGIN -------------

      NDIM = 0
      DO ipar = 1, NFITPAR_MN
        if ( FLOATPAR(ipar) ) then
           NDIM    = NDIM + 1
           X(NDIM) = FITVAL_LOC(ipar)
        endif
      ENDDO

      RETURN
      END

